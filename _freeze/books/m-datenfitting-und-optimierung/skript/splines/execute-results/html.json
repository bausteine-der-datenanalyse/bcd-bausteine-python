{
  "hash": "4f237b949e1186983985c08870aca2ab",
  "result": {
    "engine": "jupyter",
    "markdown": "# Splines\n\n\n\nPolynominterpolation versucht eine globale Modellfunktion zu finden. Jedoch eignen sich Polynome mit hohen Graden im Allgemeinen nicht für eine Interpolation vieler Punkte. Einen anderen Ansatz verfolgen Splines (auch: Polynomzug), welche mehrere, niedrige Polynome zur Interpolation vieler Punkte verwenden. Die Polynome haben typischerweise Grade zwischen eins und drei.\n\n## Definition\n\nFür $n+1$ Messpunkte $(x_i, y_i)$ kann eine Splinefunktion $s_k$, hier ein Polynomspline, wie folgt definiert werden:\n\n* Vorausgesetzt ist, dass die Messpunkte sortiert sind, d. h. $x_0 < x_1 < \\cdots < x_n$.\n* Für jedes $i = 0\\dots n − 1$ ist $s_k$ ein Polynom vom Grad $k$ auf dem Intervall $\\left[x_i , x_{i+1}\\right]$\n* $s_k$ ist auf $\\left[x_0 , x_n \\right]$ $(k − 1)$-mal stetig differenzierbar\n\nBeispiele:\n\n* $k = 1$: Polygonzug\n* $k = 3$: kubische Polynomsplines (B-Splines)\n\n## Kubische Splines\n\nDie in der Praxis häufig eingesetzten kubischen Polynomsplines $s_3$ ($k = 3$) haben folgende Eigenschaften:\n\n* $s_3|\\left[x_i,x_{i+1}\\right] = \\beta_0 +\\beta_1 x + \\beta_2 x^2 + \\beta_3 x^3$\n* $s_3$ ist zweimal stetig differenzierbar auf $\\left[x_0,x_n\\right]$, also insbesondere an den Stützpunkten $x_i$ der Messpunkte.\n\nDie Koeffizienten $\\beta_i$ werden wie folgt bestimmt:\n\n* Aus den $n + 1$ Messpunkten ergeben sich $n$ Intervalle, d. h. mit jeweils vier Koeffizienten sind es insgesamt $4n$ Koeffizienten.\n* Exakte Darstellung der Messpunkte ($n + 1$ Gleichungen), d. h.: $s_3(x_i) = y_i$\n* Glattheitsbedingungen an den inneren Messpunkten ($i=1 \\dots n-1$), mit jeweils ($n − 1$ Gleichungen):\n$$\ns_3'(x_i)_- =s_3'(x_i)_+\n$$\n$$\ns_3''(x_i)_- =s_3''(x_i)_+\n$$\n$$\ns_3'''(x_i)_- =s_3'''(x_i)_+\n$$\n\n* Damit sind es $4n − 2$ Gleichungen für $4n$ Koeffizienten.\n\nUm die beiden fehlenden Gleichungen zu finden bzw. zu bestimmen, werden Randbedingungen oder Abschlussbedingungen benötigt. Die gängigsten Bedingungen sind:\n\n* natürliche Splines: die Krümung am Rand verschwindet, d. h.:\n$$\ns_3''(x_0) = s_3''(x_n) = 0\n$$\n\n* periodische Splines: die Steigung und Krümung ist an beiden Rändern gleich\n$$\ns_3'(x_0) = s_3'(x_n)\n$$\n\n$$\ns_3''(x_0) = s_3''(x_n)\n$$\n\n* Hermite Splines: die Steigungen am Rand werden explizit vorgegeben (hier durch $u$ und $v$)\n$$\ns_3'(x_0) = u\n$$\n$$\ns_3'(x_n) = v\n$$\n\n## Anwendung\n\nIm Folgenden werden zwei Beispiele, $s_1$ und $s_3$, für die Erstellung von Splines mit Python vorgestellt. \n\n::: {#08094c69 .cell execution_count=2}\n``` {.python .cell-code}\n# Erzeugung von Messpunkten\nn = 7\nxi = np.linspace(0, np.pi, n)\nyi = np.sin(xi)\n```\n:::\n\n\nFür die $s_1$ Splines, kann die Funktion `np.interp()` verwendet werden. Sie führt eine lineare Interpolation zwischen gegebenen Wertepaaren durch.\n\n::: {#120b42a3 .cell execution_count=3}\n``` {.python .cell-code}\n# Wertebereich für die Visualisierung der Interpolation\nx = np.linspace(0, np.pi, n*6)\ny = np.sin(x)\n```\n:::\n\n\n::: {#532ef727 .cell execution_count=4}\n``` {.python .cell-code}\n# Interpolation\ny_s1 = np.interp(x, xi, yi)\n```\n:::\n\n\n::: {#490d32b5 .cell execution_count=5}\n``` {.python .cell-code}\nplt.plot(x,y, alpha=0.3, color='C2', lw=5, \n         label='Generierende Funktion')\nplt.plot(x, y_s1, color='C0', label='Interpolation')\nplt.scatter(x, y_s1, s=3, zorder=3, color='C0')\nplt.scatter(xi, yi, color='C1', label='Messpunkte')\n\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend();\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](splines_files/figure-html/cell-6-output-1.png){fig-alt='Darstellung der generierenden Funktion in Form eines umgekehrten U und der Approximation durch 6 Geraden.'}\n:::\n:::\n\n\n&nbsp;\n\nDie $s_3$ Splines können mit Funktionen aus dem scipy-Modul berechnet werden. Dazu werden zunächst die Koeffizienten bestimmt (`scipy.interpolate.splrep`) und diese ermöglichen die gewünschte Auswertung, welche mit der Funktion `scipy.interpolate.splev` vorgenommen werden kann. \n\n::: {#a5446ff2 .cell execution_count=6}\n``` {.python .cell-code}\nimport scipy.interpolate as si\n```\n:::\n\n\n::: {#e8eeeb76 .cell execution_count=7}\n``` {.python .cell-code}\ns3 = si.splrep(xi, yi)\ny_s3 = si.splev(x, s3)\n```\n:::\n\n\n::: {#4d4e3284 .cell execution_count=8}\n``` {.python .cell-code}\nplt.plot(x,y, alpha=0.3, color='C2', lw=5, \n         label='Generierende Funktion')\nplt.plot(x, y_s3, color='C0', label='Interpolation')\nplt.scatter(x, y_s3, s=3, zorder=3, color='C0')\nplt.scatter(xi, yi, color='C1', label='Messpunkte')\n\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend();\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](splines_files/figure-html/cell-9-output-1.png){fig-alt='Darstellung der generierenden Funktion in Form eines umgekehrten U und der passgenauen Approximation durch kubische Polynomsplines.'}\n:::\n:::\n\n\n",
    "supporting": [
      "splines_files"
    ],
    "filters": [],
    "includes": {}
  }
}