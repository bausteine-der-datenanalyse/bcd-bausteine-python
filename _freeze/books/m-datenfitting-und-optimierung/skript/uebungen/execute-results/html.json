{
  "hash": "f5f4f249e9322a1be9ea08d626ddee1d",
  "result": {
    "engine": "jupyter",
    "markdown": "# Übungen\n\n\n\n## Übung: Ballonfahrt-Daten analysieren\nIn der Datei '01-daten/messdaten-ballonfahrt.txt' sind Messdaten zur Höhe eines Ballons während einer Ballonfahrt gespeichert. In der ersten Zeile der Datei sind die gemessenen Größen und ihre Einheit notiert.\n\n::: {#17199c80 .cell execution_count=2}\n``` {.python .cell-code}\n# Dateikopf als String einlesen\nballon = np.genfromtxt(\"01-daten/messdaten-ballonfahrt.txt\", delimiter=\",\", max_rows= 4, dtype='str')\n\nprint(\"Der Kopf der Datei:\")\nprint(ballon)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDer Kopf der Datei:\n[['Zeit (s)' 'Hoehe (m)']\n ['0.0' '49.93175839467537']\n ['2.0202020202020203' '52.11727320291297']\n ['4.040404040404041' '50.0624468191306']]\n```\n:::\n:::\n\n\nSchauen wir uns die Daten einmal an:\n\n::: {#5a0119bf .cell execution_count=3}\n\n::: {.cell-output .cell-output-display}\n![](uebungen_files/figure-html/cell-4-output-1.png){fig-alt='Darstellung der Höhe des Ballons über die auf der x-Achse abgetragene Zeit.'}\n:::\n:::\n\n\n&nbsp;\n\nGesucht ist ein Polynom, das die Steiggeschwindigkeit, also die Änderung der Höhe mit der Zeit, des Heißluftballons beschreibt. \n\nSchreiben Sie ein Programm, das:\n\n  - die Höhe aus den Daten ausliest und die Steiggeschwindigkeit berechnet,\n  - einen Fit der Steiggeschwindigkeit mit einem Polynom dritten Grades durchführt.\n\nStellen Sie die Höhe, die Geschwindigkeit und den Fit jeweils gegen die Zeit dar. Beschriften Sie die Achsen.\n\n::: {#tip-musterloesung-ballon .callout-tip collapse=\"true\"}\n## Musterlösung Ballonfahrt\n\nZuerst werden die Daten ausgelesen.\n\n::: {#0fef6cd9 .cell execution_count=4}\n``` {.python .cell-code}\n# Daten auslesen\nballon = np.genfromtxt(\"01-daten/messdaten-ballonfahrt.txt\", delimiter=\",\", skip_header=1)\nzeit = ballon[:, 0]\nhoehe = ballon[:, 1]\n```\n:::\n\n\nAnschließend berechnen wir die Steiggeschwindigkeit $\\frac{\\Delta Höhe}{\\Delta Zeit}$. Dazu verwenden wir die Funktion `np.diff()`. Diese berechnet die Differenz jedes Werts zu seinem Vorgänger `ergebnis[i] = wert[i+1] - wert[i]`. Für den i-ten Wert wird also keine Differenz berechnet und das Ergebnis ist um ein Element kürzer. Die Steiggeschwindigkeit in $\\frac{m}{s}$ ergibt sich aus dem Quotienten beider Reihen.\n\n::: {#2f854d6d .cell execution_count=5}\n``` {.python .cell-code}\n# Differenzen berechnen\ndelta_hoehe = np.diff(hoehe)\nprint(\"Veränderung der Höhe: \", delta_hoehe[0:4])\n\ndelta_zeit = np.diff(zeit)\nprint(\"Veränderung der Zeit: \", delta_zeit[0:4])\n\n# Steiggeschwindigkeit berechnen\nsteiggeschwindigkeit = delta_hoehe / delta_zeit\nprint(\"Steiggeschwindigkeit: \", steiggeschwindigkeit[0:4])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVeränderung der Höhe:  [ 2.18551481 -2.05482638  0.32026988  1.12796595]\nVeränderung der Zeit:  [2.02020202 2.02020202 2.02020202 2.02020202]\nSteiggeschwindigkeit:  [ 1.08182983 -1.01713906  0.15853359  0.55834314]\n```\n:::\n:::\n\n\nMit `numpy.polynomial.polynomial.polyfit()` berechnen wir erst ein Polynom dritten Grades und dann mit `numpy.polynomial.polynomial.polyval()` die gefitteten Daten.\n\n::: {#0871f16b .cell execution_count=6}\n``` {.python .cell-code}\npolynom3_steiggeschwindigkeit = poly.polyfit(zeit[:-1], steiggeschwindigkeit, deg = 3)\n\nfit_steiggeschwindigkeit = poly.polyval(x = zeit[:-1], c = polynom3_steiggeschwindigkeit)\n```\n:::\n\n\n::: {#bd42f404 .cell execution_count=7}\n``` {.python .cell-code}\n# plotten\nplt.suptitle(\"Ballonfahrt\")\n\n## subplot Höhe über Zeit\nplt.subplot(1, 3, 1)\nplt.scatter(zeit, hoehe)\nplt.title(\"Höhe\")\nplt.xlabel(\"Zeit (s)\")\nplt.ylabel(\"Höhe (m)\")\nplt.grid(True)\n\n## subplot Steiggeschwindigkeit über Zeit\n## Länge des Arrays Steiggeschwindigkeit ist n-1\nplt.subplot(1, 3, 2)\nplt.scatter(zeit[:-1], steiggeschwindigkeit)\nplt.title(\"Steiggeschwindigkeit\")\nplt.xlabel(\"Zeit (s)\")\nplt.ylabel(\"Steiggeschwindigkeit (m/s)\")\nplt.grid(True)\n\n## subplot Polynom 3. Grades Steiggeschwinkdigkeit über Zeit\n## Länge des Arrays Steiggeschwindigkeit ist n-1\nplt.subplot(1, 3, 3)\nplt.plot(zeit[:-1], fit_steiggeschwindigkeit)\nplt.title(\"interpolierte\\nSteiggeschwindigkeit\")\nplt.xlabel(\"Zeit (s)\")\nplt.ylabel(\"Steiggeschwindigkeit (m/s)\")\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](uebungen_files/figure-html/cell-8-output-1.png){fig-alt='Darstellung der Höhe des Ballons, der Steiggeschwindigkeit und der gefitteten Steiggeschwindigkeit über die auf der x-Achse abgetragene Zeit.'}\n:::\n:::\n\n\n:::\n\n## Übung: Balkenverformung im Bauingenieurwesen\n\nEin Träger wird in der Mitte belastet.\n\n::: {.border}\n![Beispiel für einen Versuchsaufbau Balkenverformung](00-bilder/balkenverformung-universit%C3%A4t-der-bundeswehr.jpeg){fig-alt=\"Versuchsaufbau zur Balkenverformung\"}\n\nBalkenverformung von Universität der Bundeswehr München. Das Werk ist abrufbar auf der Internetseite der [UniBw M](https://www.unibw.de/mechanik-und-statik/bs/labor-baustatik/ermittlung-der-verformung-von-geraden-balken). ohne Jahr\n\n:::\n\n&nbsp;\n\nSchauen wir uns die Struktur der Daten einmal an.\n\n::: {#17beeccb .cell execution_count=8}\n``` {.python .cell-code}\nbalken = np.genfromtxt(\"01-daten/balken-durchbiegung.csv\", delimiter=\",\", max_rows= 4, dtype='str')\n\nprint(\"Der Kopf der Datei:\")\nprint(balken)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDer Kopf der Datei:\n[['Position (m)' 'Durchbiegung (mm)']\n ['0.0' '-0.28820719619532215']\n ['0.20408163265306123' '-0.22193122300286544']\n ['0.40816326530612246' '0.013978362500916705']]\n```\n:::\n:::\n\n\nDie Durchbiegung wird an 50 Punkten gemessen. Glätten Sie die Daten und stellen Sie die gemessenen und die geglätteten Daten gemeinsam dar.\n\n::: {#tip-musterloesung-balken .callout-tip collapse=\"true\"}\n## Musterlösung Balken\n\n::: {#c0959cac .cell execution_count=9}\n``` {.python .cell-code}\nbalken = np.genfromtxt(\"01-daten/balken-durchbiegung.csv\", delimiter=\",\", skip_header=1)\nx = balken[:, 0]\ny = balken[:, 1]\n\nwindow = 7\nweights = np.ones(window) / window\ny_smooth = np.convolve(y, weights, mode='valid')\n\nplt.plot(x, y, label=\"Messung\", alpha=0.5)\nplt.plot(x[(window-1)//2:-(window//2)], y_smooth, label=\"Geglättet\", color='red')\nplt.title(\"Durchbiegung eines Trägers\")\nplt.xlabel(\"Position (m)\")\nplt.ylabel(\"Durchbiegung (mm)\")\nplt.legend()\nplt.grid(True)\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](uebungen_files/figure-html/cell-10-output-1.png){fig-alt='Darstellung der Messdaten und der geglätteten Balkenbiegung in Form eines umgekehrten U.'}\n:::\n:::\n\n\n:::\n\n## Übung: Neutronenstreuung\nDie Datei '01-daten/neutronen.txt' enthält Daten eines Neutronenstreuexperiments. Der Dateikopf:\n\n::: {#42eebc09 .cell execution_count=10}\n``` {.python .cell-code}\n# Dateikopf als String einlesen\nneutronen = np.genfromtxt(\"01-daten/neutronen.txt\", delimiter=\"\\t\", max_rows= 4, dtype='str')\nprint(neutronen)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[['E(MeV)' 'sigma(mb)' 'Delta sigma(mb)']\n ['0.00' '10.60' ' 1.39']\n ['25.00' '16.00' ' 2.09']\n ['50.00' '45.00' ' 3.85']]\n```\n:::\n:::\n\n\nIn der Spalte 'E(MeV)' ist die Energie eines Neutrons, das auf ein Ziel geschossen wird, in Megaelektronenvolt eingetragen. In der Spalte 'sigma(mb)' ist der Wirkungsquerschnitt, gemessen in Millibarn (mb), eingetragen. In der Spalte 'Delta sigma(mb)' ist die Unsicherheit des gemessenen Wirkungsquerschnitts, ebenfalls in Millibarn (mb), eingetragen. \n\n1. Lesen Sie die Daten ein\n2. Versuchen Sie die ersten zwei Spalten mit einem Polynom eines geeigneten Grades zu fitten und stellen Sie das Ergebnis graphisch dar.\n3. Fitten Sie die Daten erneut, aber nutzen Sie dieses Mal Splines.\n4. Stellen Sie das Ergebnis ebenfalls graphisch dar und vergleichen Sie mit den Polynomfit.\n5. Was sind die Vor- und Nachteile der jeweiligen Varianten?\n\n::: {#tip-musterloesung-neutronen .callout-tip collapse=\"true\"}\n## Musterlösung Neutronenstreuung\n\n1. Daten einlesen\n\n::: {#57def59f .cell execution_count=11}\n``` {.python .cell-code}\nneutronen = np.genfromtxt(\"01-daten/neutronen.txt\", delimiter=\"\\t\", skip_header=1)\nneutronenenergie = neutronen[:, 0]\nwirkungsquerschnitt = neutronen[:, 1]\n\nplt.plot(neutronenenergie, wirkungsquerschnitt, label=\"Messdaten\", alpha=0.5)\nplt.xlabel(\"Neutronenenergie (MeV)\")\nplt.ylabel(\"Wirkungsquerschnitt (mb)\")\nplt.legend()\nplt.grid(True)\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](uebungen_files/figure-html/cell-12-output-1.png){fig-alt='Darstellung der Messdaten'}\n:::\n:::\n\n\n&nbsp;\n\n2. + 3. Polynom und Splines fitten:\n\n::: {#6b9e75e3 .cell execution_count=12}\n``` {.python .cell-code}\n# Polynom \npolynom5 = poly.polyfit(neutronenenergie, wirkungsquerschnitt, deg = 5)\nfit =  poly.polyval(x = neutronenenergie, c = polynom5)\n\n# Splines mit scipy\nsplines3 = si.splrep(neutronenenergie, wirkungsquerschnitt)\ny_splines3 = si.splev(neutronenenergie, splines3)\n\n# Splines mit NumPy\nx_neu = np.linspace(neutronenenergie.min(), neutronenenergie.max(), num=50)\ny_splines1 = np.interp(x_neu, neutronenenergie, wirkungsquerschnitt) # linear interpolieren\n```\n:::\n\n\n4. Grafische Darstellung:\n\n::: {#fa3bd261 .cell execution_count=13}\n``` {.python .cell-code}\nplt.figure(figsize = [7, 5])\n\n# Vergleich mit kubischen Splines\nplt.subplot(2, 1, 1)\nplt.plot(neutronenenergie, wirkungsquerschnitt, linewidth = 5, alpha=0.3, label=\"Messdaten\")\nplt.plot(neutronenenergie, fit, label = \"gefittetes Polynom\")\nplt.plot(neutronenenergie, y_splines3, linestyle = 'dashdot', label = \"kubische Splines\")\nplt.xlabel(\"Neutronenenergie (MeV)\")\nplt.ylabel(\"Wirkungsquerschnitt (mb)\")\nplt.legend()\nplt.grid(True)\n\n# Vergleich mit linearen Splines\nplt.subplot(2, 1, 2)\nplt.plot(neutronenenergie, wirkungsquerschnitt, linewidth = 5, alpha=0.3, label=\"Messdaten\")\nplt.plot(neutronenenergie, fit, label = \"gefittetes Polynom\")\n\nplt.plot(x_neu, y_splines1, linestyle = 'dotted', label = 'lineare Splines')\nplt.xlabel(\"Neutronenenergie (MeV)\")\nplt.ylabel(\"Wirkungsquerschnitt (mb)\")\nplt.legend()\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](uebungen_files/figure-html/cell-14-output-1.png){fig-alt='In zwei übereinanderliegenden Subplots werden die Messdaten gemeinsam dargestellt mit einem gefitteten Polynom und kubischen Splines (oben) bzw. linearen Splines (unten). Beide Splines sind identisch.'}\n:::\n:::\n\n\n&nbsp;\n\n5.: Die Splines bilden die Daten exakt nach. Das kann ein Vorteil sein, wenn keine Glättung der Daten gewünscht ist. Das Polynom ist dagegen nicht exakt an die Daten angepasst. Dafür können alle Datenpunkte mit einer einzigen Modellgleichung approximiert werden.\n\n:::\n\n",
    "supporting": [
      "uebungen_files"
    ],
    "filters": [],
    "includes": {}
  }
}