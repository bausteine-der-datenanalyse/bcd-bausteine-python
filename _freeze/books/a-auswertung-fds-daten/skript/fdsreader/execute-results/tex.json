{
  "hash": "1cc20f0ca7b2eaf334421f0dfb50f3ed",
  "result": {
    "engine": "jupyter",
    "markdown": "# Fdsreader\n\nUm Simulationsdaten, die mit FDS berechnet wurden, mit Python auszuwerten, \nhat die Arbeitsgruppe von Prof. Lukas Arnold das Python-Modul `fdsreader` entwickelt. \nZiel ist es, die meisten von FDS erzeugten Ausgabeformate auszulesen und \nin Python-Datenstrukturen abzubilden.\n\nDas Modul ist frei verfügbar und Open Source. Der Quellcode ist auf GitHub \ngehostet: [FireDynamics/fdsreader](https://github.com/FireDynamics/fdsreader), \neine [API-Dokumentation](https://firedynamics.github.io/fdsreader/index.html) \nist ebenfalls verfügbar.\n\n## Installation und Import des Pakets\n\nDas `fdsreader`-Modul kann über pip installiert werden (siehe auch das GitHub-Repository):\n\n```default\npip install fdsreader\n```\n\nZur Einführung in die grundlegende Verwendung von `fdsreader` betrachten wir \nein einfaches FDS-Szenario. Zunächst importieren wir das Modul:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport fdsreader\n```\n:::\n\n\nDa wir die Daten auch visualisieren möchten, importieren wir zusätzlich `matplotlib`:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n```\n:::\n\n\n## Auswahl des richtigen Ordners\n\nAls Nächstes muss der Reader auf das Verzeichnis zeigen, das die Simulationsdaten enthält, \ninsbesondere die Smokeview-Datei:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# Pfad zu den Daten definieren\npath_to_data = '../skript/01-data/first_example'\n\nsim = fdsreader.Simulation(path_to_data)\n```\n:::\n\n\nDas `Simulation`-Objekt `sim` enthält nun alle Informationen und Daten \ndes Simulationsausgangs:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nsim\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nSimulation(chid=StecklerExample,\n           meshes=1,\n           obstructions=7,\n           slices=5,\n           data_3d=5,\n           smoke_3d=3,\n           devices=4)\n```\n:::\n:::\n\n\nDie Variable `sim` enthält Informationen über das Gitter (`MESH`), vier \nSchnittdaten (`SLCF`) und vier Punktmessungen (`DEVC`). Das zusätzliche \nMessgerät – in der FDS-Eingabedatei wurden nur drei definiert – ist die Zeitspalte.\n\n## Messgeräte-Daten\n\n::: {.callout-tip}\n## Messgeräte in FDS\nMessgeräte fungieren als virtuelle Sensoren, mit denen Daten wie Temperatur, \nWärmestrom, Gaskonzentration, Geschwindigkeit usw. an bestimmten Punkten im \nSimulationsbereich aufgezeichnet werden können. Diese Daten sind entscheidend \nfür das Verständnis des Verhaltens von Feuer und Rauch unter verschiedenen Bedingungen.\n\nEin Messgerät kann mit einem Label (`ID`) versehen werden, was die Identifizierung \nin der durch FDS erzeugten CSV-Datei vereinfacht. Es benötigt eine Position \nund eine zu messende Größe.\n\nPositionen können auf verschiedene Arten angegeben werden. Wir fokussieren uns \nhier auf einen Punkt über `XYZ`. Linien, Flächen und Volumen sind jedoch ebenso möglich.\n\nDer Parameter `QUANTITY` erwartet eine Zeichenkette, die angibt, welche Größe \naufgezeichnet werden soll, z. B. `TEMPERATURE` für die Gastemperatur.\n:::\n\nDie einfachste Datenstruktur ist die Ausgabe der `DEVC`-Direktiven. Die verfügbaren \nDaten und Metainformationen können direkt ausgegeben werden:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Kurzreferenz für Bequemlichkeit – `devc` enthält alle Messgeräte\ndevc = sim.devices\nprint(devc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[Device(id='Time', xyz=(0.0, 0.0, 0.0), quantity=Quantity('TIME')),\nDevice(id='Temp_Door_Low', xyz=(1.45, 0.05, 0.1), quantity=Quantity('TEMPERATURE')),\nDevice(id='Temp_Door_Mid', xyz=(1.45, 0.05, 1.0), quantity=Quantity('TEMPERATURE')),\nDevice(id='Temp_Door_High', xyz=(1.45, 0.05, 1.65), quantity=Quantity('TEMPERATURE'))]\n```\n:::\n:::\n\n\nDie `Device`-Klasse enthält alle relevanten Informationen (siehe \n[Geräte-Dokumentation](https://firedynamics.github.io/fdsreader/devc.html)):\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nfor i in devc:\n    print(f\"ID: {i.id},\\t Messgröße: {i.quantity_name}, \\t Position: {i.position}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nID: Time,\t Messgröße: TIME, \t Position: (0.0, 0.0, 0.0)\nID: Temp_Door_Low,\t Messgröße: TEMPERATURE, \t Position: (1.45, 0.05, 0.1)\nID: Temp_Door_Mid,\t Messgröße: TEMPERATURE, \t Position: (1.45, 0.05, 1.0)\nID: Temp_Door_High,\t Messgröße: TEMPERATURE, \t Position: (1.45, 0.05, 1.65)\n```\n:::\n:::\n\n\nEinzelne Messgeräte, einschließlich der Zeitspalte, sind über Dictionary-Einträge \nmit ihrer ID als Schlüssel zugänglich. Die Daten eines einzelnen Messgeräts \n(`Device.data`) sind als NumPy-Array gespeichert:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ntype(devc['Temp_Door_Mid'].data)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nnumpy.ndarray\n```\n:::\n:::\n\n\nDie Länge entspricht dem erwarteten Wert, also 1801, da die Simulation 1800 s \ndauerte und die Messgeräte jede Sekunde beschrieben wurden, einschließlich `t = 0 s`.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nlen(devc['Time'].data)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n1801\n```\n:::\n:::\n\n\nEin erster Blick auf die Rohdaten (`Device.data`):\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ndevc['Temp_Door_Mid'].data\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\narray([ 20.      ,  20.002083,  20.034418, ..., 105.32822 , 114.82179 ,\n       115.01705 ], shape=(1801,), dtype=float32)\n```\n:::\n:::\n\n\nDie Messgerät-Daten können auch mit Matplotlib visualisiert werden:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# Plot erstellen\nplt.plot(devc['Time'].data, devc['Temp_Door_High'].data)\n\n# Achsen beschriften\nplt.xlabel(\"Zeit / s\")\ndevc_id = devc['Temp_Door_High'].id\ndevc_q = devc['Temp_Door_High'].quantity_name\ndevc_u = devc['Temp_Door_High'].unit\nplt.ylabel(f\"{devc_q} ({devc_id}) / {devc_u}\")\n\n# Raster hinzufügen\nplt.grid()\n```\n\n::: {.cell-output .cell-output-display}\n![](fdsreader_files/figure-pdf/cell-11-output-1.png){fig-pos='H'}\n:::\n:::\n\n\nIn gleicher Weise können mehrere Messgeräte gleichzeitig geplottet werden, z. B. \nalle, deren Namen mit `Temp_` beginnen:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# Alle Messgeräte durchlaufen\nfor i in devc:\n    \n    # Nur Messgeräte mit ID, die mit 'Temp_' beginnt\n    if not i.id.startswith('Temp_'): \n        continue\n    \n    plt.plot(devc[\"Time\"].data, i.data, label=i.id)\n    \nplt.legend()\nplt.xlabel(\"Zeit / s\")\nplt.ylabel('Temperatur / $^\\circ$C')\nplt.grid()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n<>:12: SyntaxWarning: invalid escape sequence '\\c'\n<>:12: SyntaxWarning: invalid escape sequence '\\c'\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_81191/1963712746.py:12: SyntaxWarning: invalid escape sequence '\\c'\n  plt.ylabel('Temperatur / $^\\circ$C')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](fdsreader_files/figure-pdf/cell-12-output-2.png){fig-pos='H'}\n:::\n:::\n\n\n## HRR-Daten\n\n::: {.callout-tip}\n## Heat Release Rate (HRR)\nEin zentraler Parameter in der Brandmodellierung. Er beschreibt die \nFreisetzungsrate thermischer Energie und wird in Kilowatt (kW) oder \nMegawatt (MW) angegeben.\n:::\n\nWie bei den `DEVC`-Daten kann auch auf die im `HRR`-File gespeicherten \nDaten direkt zugegriffen werden. Diese befinden sich im Attribut `hrr` \ndes `Simulation`-Objekts und nicht bei den Messgeräten:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nplt.plot(sim.hrr['Time'], sim.hrr['HRR'], label='Freisetzung durch Brand')\n\nplt.plot(sim.hrr['Time'], sim.hrr['Q_RADI'], label='Strahlung')\nplt.plot(sim.hrr['Time'], sim.hrr['Q_COND'], label='Leitung')\nplt.plot(sim.hrr['Time'], sim.hrr['Q_CONV'], label='Konvektion')\n\nplt.plot(sim.hrr['Time'], \n         sim.hrr['HRR'] + sim.hrr['Q_RADI'] + sim.hrr['Q_COND'] + sim.hrr['Q_CONV'], \n         color='grey', label='Summe', zorder=0)\n\nplt.xlabel('Zeit / s')\nplt.ylabel('Wärmefreisetzung / kW')\nplt.legend()\nplt.grid()\n```\n\n::: {.cell-output .cell-output-display}\n![](fdsreader_files/figure-pdf/cell-13-output-1.png){fig-pos='H'}\n:::\n:::\n\n\n## Slice-Daten\n\n::: {.callout-tip}\n## Slices\nSlices sind eine Art der Ausgabe, bei der bestimmte physikalische Größen \n(z. B. Temperatur, Geschwindigkeit, Rauchkonzentration) innerhalb einer Ebene \ndes Simulationsraums visualisiert werden können. Diese Schnitte geben einen \nEinblick, wie sich Größen über einen Bereich verteilen.\n:::\n\nDie durch `SLCF` erzeugten Daten erstrecken sich über zwei oder drei \nräumliche Dimensionen sowie über die Zeit. Zusätzlich können sie auf mehrere \nMeshes verteilt sein.\n\nDie Slice-Daten werden pro Mesh gespeichert. In diesem Beispiel gibt es nur \nein Mesh, doch der Zugriff erfolgt trotzdem formell mit Index.\n\nDie Datenstruktur sieht wie folgt aus:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nsim.slices[sliceid][meshid].data[zeitindex, richtung1, richtung2]\n```\n:::\n\n\nDabei ist `sliceid` der Index des Slices, `meshid` der Mesh-Index \n(hier: 0), und der Zugriff erfolgt über den Zeitindex sowie zwei \nRaumrichtungen (für 2D-Slices).\n\nEs gibt mehrere Slice-Objekte:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# Verfügbare Slices ausgeben\nfor slice in sim.slices:\n    print(f\"Slicetyp [2D/3D]: {slice.type}\\n  Größe: {slice.quantity.name}\\n\", \n          f\" Ausdehnung: {slice.extent}\\n  Orientierung [1/2/3]: {slice.orientation}\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSlicetyp [2D/3D]: 2D\n  Größe: TEMPERATURE\n  Ausdehnung: Extent([0.00, 0.00] x [-1.40, 1.40] x [0.00, 2.20])\n  Orientierung [1/2/3]: 1\n\nSlicetyp [2D/3D]: 2D\n  Größe: TEMPERATURE\n  Ausdehnung: Extent([-1.40, 2.60] x [0.00, 0.00] x [0.00, 2.20])\n  Orientierung [1/2/3]: 2\n\nSlicetyp [2D/3D]: 2D\n  Größe: W-VELOCITY\n  Ausdehnung: Extent([0.00, 0.00] x [-1.40, 1.40] x [0.00, 2.20])\n  Orientierung [1/2/3]: 1\n\nSlicetyp [2D/3D]: 2D\n  Größe: U-VELOCITY\n  Ausdehnung: Extent([-1.40, 2.60] x [0.00, 0.00] x [0.00, 2.20])\n  Orientierung [1/2/3]: 2\n\nSlicetyp [2D/3D]: 2D\n  Größe: W-VELOCITY\n  Ausdehnung: Extent([-1.40, 2.60] x [-1.40, 1.40] x [1.80, 1.80])\n  Orientierung [1/2/3]: 3\n\n```\n:::\n:::\n\n\nEs gibt viele Wege einen bestimmten Slice unter den anderen zu finden. \nEine Möglichkeit, den gewünschten Slice zu finden, ist das Filtern \nnach Quantity über `filter_by_quantity`:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# Slice(s) mit W-Geschwindigkeit bekommen\nw_slice = sim.slices.filter_by_quantity(\"W-VELOCITY\")\nprint(w_slice)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSliceCollection([Slice([2D] quantity=Quantity('W-VELOCITY'), cell_centered=False, extent=Extent([0.00, 0.00] x [-1.40, 1.40] x [0.00, 2.20]), extent_dirs=('y', 'z'), orientation=1),\nSlice([2D] quantity=Quantity('W-VELOCITY'), cell_centered=False, extent=Extent([-1.40, 2.60] x [-1.40, 1.40] x [1.80, 1.80]), extent_dirs=('x', 'y'), orientation=3)])\n```\n:::\n:::\n\n\nOder die Auswahl über die Nähe zu einem Punkt:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# Auswahl basierend auf der Nähe zu einem Punkt\nslc = w_slice.get_nearest(x=1, z=2)\nprint(slc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSlice([2D] quantity=Quantity('W-VELOCITY'), cell_centered=False, extent=Extent([-1.40, 2.60] x [-1.40, 1.40] x [1.80, 1.80]), extent_dirs=('x', 'y'), orientation=3)\n```\n:::\n:::\n\n\nDer Zugriff auf Slice-Daten benötigt die Auswahl von einem bestimmten Mesh und Zeitindex. Die \nFunktion `get_nearest_timestep` hilft dabei:\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# Zeitindex nahe t=25 s auswählen\nit = slc.get_nearest_timestep(25)\nprint(f\"Zeitschritt: {it}\")\nprint(f\"Simulationszeit: {slc.times[it]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nZeitschritt: 25\nSimulationszeit: 25.021108627319336\n```\n:::\n:::\n\n\nDas folgende Beispiel zeigt eine Darstellung der Daten und die benötigten Schritte um diese anzupassen. Die Anpassungen finden anhand der Datenausrichtung aus der Function `imshow` statt.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# Temperaturslice in y-Richtung auswählen\nslc = sim.slices.filter_by_quantity('TEMPERATURE').get_nearest(x=3, y=0)\nprint(slc)\n# Nur ein Mesh\nslc_data = slc[0].data\nprint(slc_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSlice([2D] quantity=Quantity('TEMPERATURE'), cell_centered=False, extent=Extent([-1.40, 2.60] x [0.00, 0.00] x [0.00, 2.20]), extent_dirs=('x', 'z'), orientation=2)\n[[[ 20.        20.        20.       ...  20.        20.        20.      ]\n  [ 20.        20.        20.       ...  20.        20.        20.      ]\n  [ 20.        20.        20.       ...  20.        20.        20.      ]\n  ...\n  [ 20.        20.        20.       ...  20.        20.        20.      ]\n  [ 20.        20.        20.       ...  20.        20.        20.      ]\n  [ 20.        20.        20.       ...  20.        20.        20.      ]]\n\n [[ 20.030926  20.031328  20.032204 ...  20.001385  20.001268  20.00117 ]\n  [ 20.030703  20.031597  20.033634 ...  20.001493  20.001345  20.001238]\n  [ 20.031723  20.033785  20.038801 ...  20.001757  20.001535  20.001389]\n  ...\n  [ 20.006077  20.004908  20.002953 ...  20.001383  20.001154  20.00104 ]\n  [ 20.005085  20.004053  20.00236  ...  20.00129   20.001116  20.001026]\n  [ 20.004608  20.003656  20.0021   ...  20.00125   20.001104  20.001026]]\n\n [[ 20.12404   20.126698  20.133305 ...  20.026028  20.02525   20.025595]\n  [ 20.116137  20.11882   20.12633  ...  20.02626   20.025606  20.02608 ]\n  [ 20.114033  20.117645  20.128752 ...  20.02802   20.027351  20.027908]\n  ...\n  [ 20.018784  20.016739  20.013128 ...  20.00563   20.004776  20.004353]\n  [ 20.015898  20.014067  20.010876 ...  20.005054  20.004427  20.004118]\n  [ 20.01441   20.012737  20.00983  ...  20.004791  20.004278  20.00403 ]]\n\n ...\n\n [[ 44.00391   43.917053  43.920734 ... 143.89009  142.69537  142.16621 ]\n  [ 44.004223  43.863914  43.708996 ... 143.29715  142.09953  141.6622  ]\n  [ 43.81018   43.64982   43.4085   ... 142.64955  141.90448  141.75969 ]\n  ...\n  [ 20.284891  20.19156   20.076902 ...  90.631195  78.81051   72.00585 ]\n  [ 20.218634  20.140545  20.047134 ...  56.04536   43.176456  39.645744]\n  [ 20.151264  20.09307   20.028439 ...  34.67456   27.534237  27.970665]]\n\n [[ 45.228874  45.115242  44.938766 ... 150.18481  150.12732  149.83371 ]\n  [ 44.492287  44.350613  44.180614 ... 149.79759  150.0778   149.77635 ]\n  [ 43.646873  43.590538  43.562504 ... 147.7298   148.82109  149.29768 ]\n  ...\n  [ 20.281096  20.186028  20.071451 ... 106.69953   93.09295   83.79199 ]\n  [ 20.205025  20.13359   20.046276 ...  80.62758   71.11945   62.30358 ]\n  [ 20.16152   20.102564  20.033293 ...  65.56552   56.724525  46.839134]]\n\n [[ 42.762764  42.892406  42.67096  ... 146.0912   145.20709  144.58104 ]\n  [ 43.14627   43.263447  43.141045 ... 145.02187  144.6713   143.69063 ]\n  [ 43.753468  43.769325  43.798447 ... 141.0417   142.32797  141.77148 ]\n  ...\n  [ 20.268656  20.194078  20.08938  ...  72.89162   70.64532   65.348694]\n  [ 20.206676  20.136755  20.052374 ...  59.554634  49.809177  42.573883]\n  [ 20.180956  20.111738  20.035168 ...  48.16472   36.145966  31.134487]]]\n```\n:::\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# Erste Visualisierung bei t=50 s\nit = slc.get_nearest_timestep(50)\nplt.imshow(slc_data[it])\n```\n\n::: {.cell-output .cell-output-display}\n![](fdsreader_files/figure-pdf/cell-20-output-1.png){fig-pos='H'}\n:::\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# Auf transponierte Darstellung mithilfe von ndarray.T zugreifen und anpassung des Ursprungs\nplt.imshow(slc_data[it].T, origin='lower')\n```\n\n::: {.cell-output .cell-output-display}\n![](fdsreader_files/figure-pdf/cell-21-output-1.png){fig-pos='H'}\n:::\n:::\n\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# Erste Visualisierung bei t=50 s\n# Angabe der Ausdehnung um von Indexen in den physikalischen Raum zu wechseln\n# Festsetzen eines Maximalwerts mit Hilfe von vmax\n\nplt.imshow(slc_data[it].T, \n           origin='lower',\n           vmax=200,\n           extent=slc.extent.as_list())\nplt.colorbar(label='Temperatur / °C', orientation='horizontal')\nplt.xlabel('x-Koordinate / m')\nplt.ylabel('z-Koordinate / m')\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\nText(0, 0.5, 'z-Koordinate / m')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](fdsreader_files/figure-pdf/cell-22-output-2.png){fig-pos='H'}\n:::\n:::\n\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# Beispiel für Mehrfach-Plot\nlist_t = [0, 50, 100, 200, 300, 400]\nfig, axs = plt.subplots(2,3, sharex=True, sharey=True)\nfor i in range(len(list_t)):\n    it = slc.get_nearest_timestep(list_t[i])\n    axs.flat[i].imshow(slc_data[it].T,\n                       vmin=20,\n                       vmax=400,\n                       origin='lower', \n                       extent=slc.extent.as_list())\n    axs.flat[i].set_title(f\"t={slc.times[it]:.1f}\")\n```\n\n::: {.cell-output .cell-output-display}\n![](fdsreader_files/figure-pdf/cell-23-output-1.png){fig-pos='H'}\n:::\n:::\n\n\n",
    "supporting": [
      "fdsreader_files/figure-pdf"
    ],
    "filters": []
  }
}