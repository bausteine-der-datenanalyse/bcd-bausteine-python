{
  "hash": "c789754050074b30467eec450153268e",
  "result": {
    "engine": "jupyter",
    "markdown": "# Verfügbare sichere Evakuierungszeit (ASET)\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport fdsreader\nimport matplotlib.pyplot as plt\nimport numpy as np\n```\n:::\n\n\nDieses Beispiel demonstriert eine Analyse von Slice-Daten, um die Karte der **verfügbaren sicheren Evakuierungszeit (ASET)** sowie die zeitliche Entwicklung der Rauchsichtbarkeitsschicht zu bestimmen. Das verwendete Szenario ist eine Mehrraumwohnung.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\npfad_zur_simulation = '../skript/01-data/apartment_01'\n\nsim = fdsreader.Simulation(pfad_zur_simulation)\nprint(sim)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimulation(chid=Appartment,\n           meshes=8,\n           obstructions=23,\n           slices=20,\n           data_3d=5,\n           smoke_3d=3)\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# Rußdichte-Slice laden, senkrecht zur z-Achse in 1,5 m Höhe\nslc = sim.slices.get_by_id('SootDensityZ_1.5m')\n\n# Da die Simulation auf mehreren Gittern basiert, wird eine globale Datenstruktur erstellt;\n# Wände werden als ungültige Datenpunkte (NaN) dargestellt\nslc_data = slc.to_global(masked=True, fill=np.nan)\n```\n:::\n\n\nZuerst wird eine Visualisierung der Daten zu einem ausgewählten Zeitpunkt mit der Funktion `imshow` durchgeführt.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Zeitindex ermitteln\nit = slc.get_nearest_timestep(50)\n\n# Daten visualisieren\nplt.imshow(slc_data[it,:,:].T, origin='lower', extent=slc.extent.as_list())\n\n# Achsenbeschriftung und Farbleiste\nplt.title(f'Rußdichte bei t={slc.times[it]:.2f}s')\nplt.xlabel('Position / m')\nplt.ylabel('Position / m')\nplt.colorbar(orientation='horizontal', label=f'{slc.quantity.name} / {slc.quantity.unit}')\n```\n\n::: {.cell-output .cell-output-display}\n![](aset_files/figure-pdf/cell-5-output-1.png){fig-pos='H'}\n:::\n:::\n\n\nNun werden die lokalen ASET-Werte berechnet:\n\n1. Über alle räumlichen Elemente der Slice-Daten iterieren  \n2. Alle Zeitpunkte bestimmen, an denen der Begehbarkeits-Grenzwert überschritten wird  \n3. Falls dies der Fall ist, den ersten Zeitpunkt als lokalen ASET-Wert setzen\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Beliebiger Grenzwert für die Begehbarkeit\ngrenzwert_rußdichte = 1e-4\n\n# Karte mit maximaler ASET als Standardwert erstellen\naset_karte = np.full_like(slc_data[0], slc.times[-1])\n\n# Wände auf NaN setzen\naset_karte[np.isnan(slc_data[0,:,:])] = np.nan\n\n# 1D-Schleife über alle Array-Indizes, ix ist ein zweidimensionaler Index\nfor ix in np.ndindex(aset_karte.shape):\n    # Lokale Werte, die den Grenzwert überschreiten, ermitteln\n    lokaler_aset = np.where(slc_data[:, ix[0], ix[1]] > grenzwert_rußdichte)[0]\n    \n    # Falls vorhanden, ersten Zeitpunkt als ASET-Wert verwenden\n    if len(lokaler_aset) > 0:\n        aset_karte[ix] = slc.times[lokaler_aset[0]]\n```\n:::\n\n\nMit der berechneten Karte kann nun eine grafische Darstellung erzeugt werden, ähnlich wie bei anderen Größen – hier mit diskreter Farbskala.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# Diskrete (12 Werte) Farbskala erstellen\ncmap = plt.cm.get_cmap('jet_r', 12)\n\n# Visualisierung der ASET-Karte\nplt.imshow(aset_karte.T, origin='lower', extent=slc.extent.as_list(), cmap=cmap)\nplt.title(f'ASET-Karte mit Grenzwert der Rußdichte {grenzwert_rußdichte:.1e}')\nplt.xlabel('x-Position / m')\nplt.ylabel('y-Position / m')\nplt.colorbar(orientation='horizontal', label='Zeit / s')\n\n# Ausgabe in Datei speichern (optional)\n# plt.savefig('figs/appartment_aset_map.svg', bbox_inches='tight')\n# plt.close()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_81178/2604837150.py:2: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.\n  cmap = plt.cm.get_cmap('jet_r', 12)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](aset_files/figure-pdf/cell-7-output-2.png){fig-pos='H'}\n:::\n:::\n\n\n## Rauchsichtbarkeitsschicht\n\nIn diesem Beispiel wird die Höhe der Rauchsichtbarkeitsschicht analysiert. Die Unterscheidung erfolgt hier anhand eines einfachen Temperatur-Grenzwerts: Die lokale Schichthöhe ergibt sich aus dem niedrigsten Punkt, an dem eine bestimmte Temperatur überschritten wird. Die Auswertung erfolgt auf einem Slice entlang des Brenners (normal zur x-Achse).\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# Slice finden\nslc = sim.slices.get_by_id('BurnerTempX')\n\n# In globale Datenstruktur umwandeln und Koordinaten extrahieren\nslc_data, slc_coords = slc.to_global(masked=True, fill=np.nan, return_coordinates=True)\n```\n:::\n\n\nZunächst erfolgt eine Visualisierung der Daten zu einem beliebigen Zeitpunkt. Weiße Bereiche stellen Hindernisse dar.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# Zeitpunkt wählen\nit = slc.get_nearest_timestep(150)\n\n# Daten visualisieren\nplt.imshow(slc_data[it,:,:].T, origin='lower', vmax=200, extent=slc.extent.as_list())\nplt.title(f'Temperatur bei t={slc.times[it]:.2f}s')\nplt.xlabel('y-Position / m')\nplt.ylabel('z-Position / m')\nplt.colorbar(orientation='horizontal', label=f'{slc.quantity.name} / {slc.quantity.unit}')\n\n# plt.savefig('figs/appartment_temp_slice.svg', bbox_inches='tight')\n# plt.close()\n```\n\n::: {.cell-output .cell-output-display}\n![](aset_files/figure-pdf/cell-9-output-1.png){fig-pos='H'}\n:::\n:::\n\n\nNun wird für jede y-Position der z-Index gesucht, an dem die Temperatur den Grenzwert überschreitet. Der niedrigste dieser Punkte ist die lokale Höhe der Rauchsichtbarkeitsschicht.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# Grenzwert für Temperatur\ntemperatur_grenzwert = 75\n\n# Array zur Speicherung der lokalen Höhenwerte; Standard ist maximale z-Koordinate\nschicht_hoehe = np.full(slc_data.shape[1], slc_coords['z'][-1])\n\n# Schleife über y-Indizes\nfor ix in range(len(schicht_hoehe)):\n    # Indizes finden die den Grenzwert überschreiten\n    lt = np.where(slc_data[it, ix, :] > temperatur_grenzwert)[0]\n    # Wenn welche existieren, wähle den niedrigsten von ihnen\n    if len(lt) > 0:\n        schicht_hoehe[ix] = slc_coords['z'][lt[0]]\n```\n:::\n\n\nDie resultierenden Werte können nun über dem Slice dargestellt werden, um die Plausibilität zu überprüfen.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# Slice Daten\nplt.imshow(slc_data[it,:,:].T, origin='lower', vmax=200, extent=slc.extent.as_list())\nplt.title(f'Temperatur bei t={slc.times[it]:.2f}s')\nplt.xlabel('y-Position / m')\nplt.ylabel('z-Position / m')\nplt.colorbar(orientation='horizontal', label=f'{slc.quantity.name} / {slc.quantity.unit}')\n# Rauchsichtbarkeitsschichthöhe\nplt.plot(slc_coords['y'], schicht_hoehe, '.-', color='red')\n\n# plt.savefig('figs/appartment_temp_slice_height.svg', bbox_inches='tight')\n# plt.close()\n```\n\n::: {.cell-output .cell-output-display}\n![](aset_files/figure-pdf/cell-11-output-1.png){fig-pos='H'}\n:::\n:::\n\n\nDie obige Methode kann auch über alle Zeitpunkte angewendet werden, um z. B. Mittelwert und Standardabweichung der Schichthöhe zu berechnen.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nmittelwert = np.zeros_like(slc.times)\nstandardabweichung = np.zeros_like(slc.times)\nres = np.zeros(slc_data.shape[1])\n\nfor it in range(len(slc.times)):\n    res[:] = slc_coords['z'][-1]\n    for ix in range(len(res)):\n        lt = np.where(slc_data[it, ix, :] > temperatur_grenzwert)[0]\n        if len(lt) > 0:\n            res[ix] = slc_coords['z'][lt[0]]\n    mittelwert[it] = np.mean(res)\n    standardabweichung[it] = np.std(res)\n```\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# Darstellung des Mittelwerts und der Standartabweichung als Funktion der Zeit\nplt.plot(slc.times, mittelwert, label='Mittlere Schichthöhe')\nplt.plot(slc.times, standardabweichung, label='Standardabweichung')\nplt.grid()\nplt.legend()\nplt.xlabel('Zeit / s')\nplt.ylabel('Höhe / m')\n\n# Ergebnisse in Datei abspeichern\n# plt.savefig('figs/appartment_layer_mean_stddev.svg', bbox_inches='tight')\n# plt.close()\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nText(0, 0.5, 'Höhe / m')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](aset_files/figure-pdf/cell-13-output-2.png){fig-pos='H'}\n:::\n:::\n\n\nBeide Werte können kombiniert visualisiert werden. Die Standardabweichung ergibt ein Band um den Mittelwert.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# Mittelwert darstellen\nplt.plot(slc.times, mittelwert, label='Mittlere Schichthöhe')\n\n# Band um den Mittelwert darstellen mit Hilfe der Standartabweichung\nplt.fill_between(slc.times, mittelwert-standardabweichung, mittelwert+standardabweichung, color='C0', alpha=0.3)\n\n# Boden als Referenz zeigen\nplt.ylim(bottom=0)\nplt.grid()\nplt.legend()\nplt.xlabel('Zeit / s')\nplt.ylabel('Höhe / m')\n\n# plt.savefig('figs/appartment_layer_mean_band.svg', bbox_inches='tight')\n# plt.close()\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nText(0, 0.5, 'Höhe / m')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](aset_files/figure-pdf/cell-14-output-2.png){fig-pos='H'}\n:::\n:::\n\n\nWenn bestimmte Bereiche ausgeschlossen werden sollen, kann eine koordinatenabhängige Maske verwendet werden.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# Finde Indizes bei denen die y-Koordinate zwischen den angegebenen Werten liegt\nymin = 1\nymax = 4\nkoordinaten_maske = np.where((slc_coords['y'] > ymin) & (slc_coords['y'] < ymax))\n```\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# Slice Daten\nplt.imshow(slc_data[it,:,:].T, origin='lower', vmax=200, extent=slc.extent.as_list())\nplt.title(f'Temperatur bei t={slc.times[it]:.2f}s')\nplt.xlabel('y-Position / m')\nplt.ylabel('z-Position / m')\nplt.colorbar(orientation='horizontal', label=f'{slc.quantity.name} / {slc.quantity.unit}')\n# Rauchsichtbarkeitsschichthöhe\nplt.plot(slc_coords['y'][koordinaten_maske], schicht_hoehe[koordinaten_maske], '.-', color='red')\n\n# plt.savefig('figs/appartment_temp_slice_height_mask.svg', bbox_inches='tight')\n# plt.close()\n```\n\n::: {.cell-output .cell-output-display}\n![](aset_files/figure-pdf/cell-16-output-1.png){fig-pos='H'}\n:::\n:::\n\n\nDas gleiche Verfahren kann erneut verwendet werden, wobei Mittelwert und Standardabweichung nur auf die maskierten Werte berechnet werden.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nfor it in range(len(slc.times)):\n    res[:] = slc_coords['z'][-1]\n    for ix in np.ndindex(res.shape):\n        lt = np.where(slc_data[it, ix, :] > temperatur_grenzwert)[1]\n        if len(lt) > 0:\n            res[ix] = slc_coords['z'][lt[0]]\n    # Berechnungen werden nun mit den Werten aus der Maske durchgeführt\n    mittelwert[it] = np.mean(res[koordinaten_maske])\n    standardabweichung[it] = np.std(res[koordinaten_maske])\n```\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# Selbe Darstellung wie zuvor\nplt.plot(slc.times, mittelwert, label='Mittlere Schichthöhe')\nplt.fill_between(slc.times, mittelwert-standardabweichung, mittelwert+standardabweichung, color='C0', alpha=0.3)\nplt.ylim(bottom=0)\nplt.grid()\nplt.legend()\nplt.xlabel('Zeit / s')\nplt.ylabel('Höhe / m')\n\n# plt.savefig('figs/appartment_layer_mean_band_mask.svg', bbox_inches='tight')\n# plt.close()\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\nText(0, 0.5, 'Höhe / m')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](aset_files/figure-pdf/cell-18-output-2.png){fig-pos='H'}\n:::\n:::\n\n\n",
    "supporting": [
      "aset_files/figure-pdf"
    ],
    "filters": []
  }
}