{
  "hash": "be45436cde2e9db46ea2c301ab80d588",
  "result": {
    "engine": "jupyter",
    "markdown": "# Kalibrierung\nDie Genauigkeit von Messungen wird durch die Korrektion systemtischer Messabweichungen verbessert. In diesem Kapitel werden typische *Fehlerarten* bei Messungen behandelt:\n\n  - additive Fehler,\n  - multiplikative Fehler und\n  - Nichtlinearität.\n\nIn diesem Abschnitt greifen wir die etablierten Begriffe auf, auch wenn die Fehler besser als systematische Messabweichungen bezeichnet werden sollten.\n\n\n\n## Kalibrieren und Justieren\nDie Korrektion systemtischer Messabweichungen kann auf zwei Arten geschehen: durch Kalibrierung oder Justierung des Messgeräts.\n\nMit dem Begriff Kalibrierung wird im engeren Sinn die Ermittlung des Zusammenhangs zwischen Messwerten bzw. ihres arithmetischen Mittelwerts und dem vereinbarten richtigen Wert der Messgröße bezeichnet. \n\n::: {#imp-kalibrierung1 .callout-important}\n## Kalibrierung nach DIN 1319\n\n\"Ermitteln des Zusammenhangs zwischen Meßwert [...] oder Erwartungswert [...] der Ausgangsgröße [...] und dem zugehörigen wahren [...] oder richtigen Wert [...] der als Eingangsgröße vorliegenden Meßgröße für eine betrachtete Meßeinrichtung [...].\" [@DIN1319-1, S. 22]\n:::\n\nIm weiteren Sinn ist mit Kalibrierung auch \"die  Erstellung einer Korrektionstabelle [...], die Ermittlung von Kalibrierfaktoren oder einer (empirischen) Kalibrierfunktion\" [@DIN1319-1, S. 22] gemeint. Dabei handelt es sich um Methoden, um mit systematischen Messabweichungen behaftete Messwerte zu korrigieren, ohne das Messgerät zu verändern.\n\nIm Unterschied dazu verändert die Justierung das Messgerät dauerhaft.\n\n::: {#imp-justierung .callout-important}\n## Justierung nach DIN 1319\n\n\"Einstellen oder Abgleichen eines Meßgeräts [...], um systematische Meßabweichungen [...] soweit zu beseitigen, wie es für die vorgesehene Anwendung erforderlich ist.\" [@DIN1319-1, S. 22] \n:::\n\n## Kalibriermethoden nach DIN 1319\nIn der DIN 1319 werden drei Kalibriermethoden genannt, die hier nur kurz behandelt werden:\n\n1. Korrektionstabelle,\n2. Ermittlung von Kalibrierfaktoren und \n3. Ermittlung einer (empirischen) Kalibrierfunktion.\n\nWelche Methode verwendet wird, hängt von dem Anwendungsbereich, der Datenverfügbarkeit sowie von der gewünschten Genauigkeit ab. \n\n| Methode                | Anwendung bei …                  | Vorteile                         | Nachteile                         |\n| ---------------------- | -------------------------------- | -------------------------------- | --------------------------------- |\n| **Korrektionstabelle** | nichtlinear, schwer modellierbar | einfach zu nutzen                | viele Daten erforderlich, sonst Interpolation ungenau |\n| **Kalibrierfaktoren**  | lineare Abweichung               | leicht umsetzbar                 | unzureichend bei Nichtlinearität  |\n| **Kalibrierfunktion**  | nichtlinear, modellierbar        | sehr genau                       | höherer Aufwand                   |\n\n### Korrektionstabelle\nMit der Korrektionstabelle können beliebige Korrektionen dargestellt werden, sofern ausreichend Datenpunkte verfügbar sind. In @sec-pt100 werden wir ein Beispiel für eine Korrektionstabelle kennenlernen.\n\n### Ermittlung von Kalibrierfaktoren\nEin Kalibrierfaktor kann angegeben werden, wenn eine konstante relative Abweichung vorliegt. Ein Beispiel aus der Praxis ist [hier auf Seite 1](https://www.lanuk.nrw.de/fileadmin/lanuv/luft/immissionen/ber_trend/Aequivalenznachweis/AEquivalenztest_und_Faktorenbestimmung_2023.pdf) zu finden.\n\n### Ermittlung einer (empirischen) Kalibrierfunktion\nEine Kalibrierfunktion erlaubt die Modellierung komplexer Zusammenhänge. Die Methoden dafür werden im [Methodenbaustein Datenfitting und Datenoptimierung](https://bausteine-der-datenanalyse.github.io/m-datenfitting-und-optimierung/output/book/) vorgestellt.\n\n## Additive Fehler: Der Nullpunktfehler\nDer Nullpunktfehler beschreibt die Abweichung der Messgröße von Null, wenn der gesuchte Wert tatsächlich Null ist. Der Nullpunktfehler wird auch als Nullabgleich, Nullpunktverschiebung oder Offset-Fehler bezeichnet. Der Nullpunktfehler ist konstant und wirkt additiv auf jeden Messwert. ([ics Schneider Messtechnik](https://www.ics-schneider.de/wie-wirken-sich-nullpunktfehler-spannfehler-und-nichtlinearitaet-auf-die-genauigkeit-von-drucksensoren-aus/))\n\n$$\n\\text{Messwerte} = \\text{wahre Werte} + \\text{Nullpunktfehler}\n$$\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# Daten erzeugen\nmessgröße = np.arange(0, 11)\nmesswerte = messgröße + 4\n\n# plotten\nplt.plot(messgröße, marker = 'o', label = 'wahrer Wert')\nplt.plot(messwerte, marker = '^', label = 'gemessener Wert')\nplt.plot([0, 0], [messgröße[0], messwerte[0]], linestyle = 'dashed', label = 'Nullpunktfehler', color = 'red')\nplt.plot([4, 4], [messgröße[4], messwerte[4]], linestyle = 'dashed', color = 'red')\nplt.plot([8, 8], [messgröße[8], messwerte[8]], linestyle = 'dashed', color = 'red')\n\n# Achsenbeschriftung\nplt.xlabel('Index') \nplt.ylabel('Merkmalsausprägung')\n\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](kalibrierung_files/figure-pdf/cell-3-output-1.png){fig-alt='Schematische Darstellung des Nullpunktfehlers. Zwei parallele Geraden der wahren und der gemessenen Werte ist am Punkt x = 0 durch eine gestrichelte vertikale Linie verbunden, die den Unterschied zwischen dem wahren Wert y = 2 und dem gemessenen Wert y = 6 verdeutlicht. Die gestrichelte Linie erneut bei x = 4 und x = 8 eingezeichnet.' fig-pos='H'}\n:::\n:::\n\n\n&nbsp;\n\n### Nullpunktfehler quantifizieren\nDer Nullpunktfehler kann leicht bestimmt werden, wenn Messwerte für den Nullpunkt vorliegen und der wahre Wert bekannt ist. (Wenn außerdem bekannt ist, dass keine weiteren systematischen Messabweichungen vorliegen, kann der Nullpunktfehler über einen beliebigen wahren Referenzwert bestimmt werden.) Für die zur grafischen Darstellung angelegten Daten ist dies der Fall.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nprint(f\"Der Nullpunktfehler beträgt: {messwerte[0] - messgröße[0]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDer Nullpunktfehler beträgt: 4\n```\n:::\n:::\n\n\nWenn keine Daten für den Nullpunkt vorliegen, kann der Nullpunktfehler mit linearer Regression aus mindestens zwei bekannten Referenzpunkten geschätzt werden. Dazu wird wird eine lineare Regression mit den bekannten Referenzwerten als unabhängige Größe $x$ und den Messwerten als abhängige Größe $y$ durchgeführt. Der y-Achsenabschnitt der Regressionsgeraden ist der Nullpunktfehler.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# bekannte Referenzpunkte \nx1 = 4\nx2 = 8\ny1 = messgröße[x1]\ny2 = messgröße[x2]\n\n# Nullpunktfehler bestimmen\nlm_referenzpunkte = poly.polyfit(x = [messgröße[x1], messgröße[x2]], y = [messwerte[x1], messwerte[x2]], deg = 1)\nprint(f\"Der Nullpunktfehler beträgt: {round(lm_referenzpunkte[0], 2)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDer Nullpunktfehler beträgt: 4.0\n```\n:::\n:::\n\n\n:::{#wrn-regression .callout-warning appearance=\"simple\"}\n## Regression\nEine Schätzung der Regressionsgeraden aus 2 Punkten ist im Allgemeinen weniger zuverlässig als eine Schätzung aus mehreren Messpunkten. Die Beispieldaten sind perfekt linear.\n:::\n\nGrafisch wird das Vorgehen deutlich.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# lineare Funktionen berechnen\nlm_kennlinie = poly.polyfit(x = [x1, x2], y = [y1, y2], deg = 1)\ngeschätzte_ideale_kennlinie = poly.polyval(x = np.arange(messwerte.size), c = lm_kennlinie)\n\nlm_messwerte = poly.polyfit(x = [x1, x2], y = [messwerte[x1], messwerte[x2]], deg = 1)\nlineare_funktion_messwerte = poly.polyval(x = np.arange(messwerte.size), c = lm_messwerte)\n\n# plotten\n## Punkte\nplt.plot([x1, x2], [y1, y2], marker = 'o', linestyle = 'none', color = 'C0', label = 'bekannte Referenzwerte')\nplt.plot([x1, x2], [messwerte[x1], messwerte[x2]], marker = '^', linestyle = 'none', color = 'C1', label = 'Messwerte an Referenzpunkten')\n\n## Linien\nplt.plot(np.arange(messwerte.size), geschätzte_ideale_kennlinie, marker = 'none', linestyle = 'dashed', color = 'C0', label = 'ideale Kennlinie')\nplt.plot(np.arange(messwerte.size), lineare_funktion_messwerte , marker = 'none', linestyle = 'dashed', color = 'C1', label = 'lineare Funktion Messwerte')\n\nplt.plot([0, 0], [messgröße[0], messwerte[0]], linestyle = 'dashed', label = 'Nullpunktfehler', color = 'red')\nplt.plot([4, 4], [messgröße[4], messwerte[4]], linestyle = 'dashed', color = 'red')\nplt.plot([8, 8], [messgröße[8], messwerte[8]], linestyle = 'dashed', color = 'red')\n\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](kalibrierung_files/figure-pdf/cell-6-output-1.png){fig-alt='Eine gestrichelte Linie verläuft ausgehend vom Schnittpunkt der Achsen durch zwei Referenzpunkte. Diese gestrichelte Linie enstpricht der idealen Kennlinie. Eine parallele Linie geht durch die gemessenen Werte. Der Abstand zwischen beiden Linien ist über den Wertebereich konstant und entspricht dem Nullpunktfehler.' fig-pos='H'}\n:::\n:::\n\n\n&nbsp;\n\n### Nullpunktfehler korrigieren\nDer Nullpunktfehler wird durch Subtraktion von den Messwerten korrigiert.\n\n$$\n\\text{wahre Werte} = \\text{Messwerte} - \\text{Nullpunktfehler}\n$$\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# Daten erzeugen\nmessgröße = np.arange(0, 11) + 5\nmesswerte = messgröße + 2.5\n\n# bekannte Referenzpunkte \nx1 = 2\nx2 = 5\ny1 = messgröße[x1]\ny2 = messgröße[x2]\n\n# Nullpunktfehler bestimmen\nlm_referenzpunkte = poly.polyfit(x = [messgröße[x1], messgröße[x2]], y = [messwerte[x1], messwerte[x2]], deg = 1)\nnullpunktfehler = lm_referenzpunkte[0]\nprint(f\"Der Nullpunktfehler beträgt: {nullpunktfehler.round(2)}\")\n\n# Nullpunktfehler korrigieren\nkorrigierte_messwerte = messwerte - nullpunktfehler\nprint(f\"Wahre Werte:\\n{messgröße}\")\nprint(f\"Korrigierte Messwerte:\\n{korrigierte_messwerte}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDer Nullpunktfehler beträgt: 2.5\nWahre Werte:\n[ 5  6  7  8  9 10 11 12 13 14 15]\nKorrigierte Messwerte:\n[ 5.  6.  7.  8.  9. 10. 11. 12. 13. 14. 15.]\n```\n:::\n:::\n\n\n### Übung Nullpunktfehler\nDie Quantifizierung des Nullpunktfehlers ist manchmal schwierig, beispielsweise weil der wahre Nullpunkt einer Größe nur schwer vermessen werden kann oder die Messdaten nicht durch eine einfache Funktion approximiert werden können. In diesem Fall muss eine möglichst gute Schätzung gefunden werden. \n\nIn einem Klimaschrank wurden 16 Thermoelemente Temperaturen von -10 °C bis 140 °C in Schritten von 10 °C ausgesetzt. Die Messgenauigkeit des verwendeten Datenloggers TCTempX16 liegt bei 0,01 °C, die Auflösung bei 0,1 °C. **Für die Thermoelemente soll der Nullpunktfehler bestimmt werden**.\n\n:::{#wrn-celsius .callout-warning appearance=\"simple\"}\n## Nullpunkt\n0 ° C auf der Celsius-Skala ist kein sinnvoller Referenzpunkt zur Bestimmung des Nullpunktfehlers, weil die Abwesenheit von Wärme erst bei -273,15 °C gegeben ist. Da der Nullpunktfehler über alle Messwerte konstant ist, kann der Nullpunktfehler geschätzt werden, indem für jede Temperaturstufe der Nullpunktfehler separat geschätzt und die Ergebnisse anschließend gemittelt werden.\n:::\n\nDie Messdaten liegen in der Datei '01-daten/kalibration_tc.xlsx'. Die Daten können mit dem folgenden Befehl eingelesen werden.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nklimaschrank = pd.read_excel(io = '01-daten/kalibration_tc.xlsx', sheet_name = 'T15949 MultiChannel - Daten', skiprows = 6)\nprint(klimaschrank.info())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 2771 entries, 0 to 2770\nData columns (total 18 columns):\n #   Column                 Non-Null Count  Dtype         \n---  ------                 --------------  -----         \n 0   Datum                  2771 non-null   datetime64[ns]\n 1   Zeit                   2771 non-null   datetime64[ns]\n 2   Thermoelement 1 (°C)   2771 non-null   float64       \n 3   Thermoelement 2 (°C)   2771 non-null   float64       \n 4   Thermoelement 3 (°C)   2771 non-null   float64       \n 5   Thermoelement 4 (°C)   2771 non-null   float64       \n 6   Thermoelement 5 (°C)   2771 non-null   float64       \n 7   Thermoelement 6 (°C)   2771 non-null   float64       \n 8   Thermoelement 7 (°C)   2771 non-null   float64       \n 9   Thermoelement 8 (°C)   2771 non-null   float64       \n 10  Thermoelement 9 (°C)   2771 non-null   float64       \n 11  Thermoelement 10 (°C)  2771 non-null   float64       \n 12  Thermoelement 11 (°C)  2771 non-null   float64       \n 13  Thermoelement 12 (°C)  2771 non-null   float64       \n 14  Thermoelement 13 (°C)  2771 non-null   float64       \n 15  Thermoelement 14 (°C)  2771 non-null   float64       \n 16  Thermoelement 15 (°C)  2771 non-null   float64       \n 17  Thermoelement 16 (°C)  2771 non-null   float64       \ndtypes: datetime64[ns](2), float64(16)\nmemory usage: 389.8 KB\nNone\n```\n:::\n:::\n\n\nMit `klimaschrank.describe()` kann ein Überblick über die Daten gewonnen werden (hier aus Platzgründen für die ersten 4 Spalten).\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nprint(klimaschrank.iloc[: , 0:4].describe())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                               Datum                           Zeit  \\\ncount                           2771                           2771   \nmean   2026-01-13 14:46:20.314687744  2026-01-13 14:46:20.314687744   \nmin              2026-01-13 10:55:17            2026-01-13 10:55:17   \n25%       2026-01-13 12:50:48.500000     2026-01-13 12:50:48.500000   \n50%              2026-01-13 14:46:21            2026-01-13 14:46:21   \n75%              2026-01-13 16:41:52            2026-01-13 16:41:52   \nmax              2026-01-13 18:37:24            2026-01-13 18:37:24   \nstd                              NaN                            NaN   \n\n       Thermoelement 1 (°C)  Thermoelement 2 (°C)  \ncount           2771.000000           2771.000000  \nmean              59.761097             60.795669  \nmin               -9.100000            -11.400000  \n25%               20.900000             20.950000  \n50%               58.800000             60.400000  \n75%               98.300000            100.200000  \nmax              138.700000            140.500000  \nstd               43.075393             44.310769  \n```\n:::\n:::\n\n\nDie Spalten Datum und Zeit enthalten die selben Informationen. Eine der beiden Spalten kann deshalb entfernt werden.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nklimaschrank.drop(labels = 'Datum', axis = 1, inplace = True)\n```\n:::\n\n\nBetrachten wir den Verlauf der Daten für die ersten beiden Thermoelemente. (In der Darstellung mit `pd.plot()` ist die automatisch gewählte x-Achsenbeschriftung unansehnlich. Deshalb wird ein Datenobjekt für die Darstellung angelegt und die Spalte 'Zeit' auf die Uhrzeit reduziert.)\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# Darstellung mit automatischer Achsenbeschriftung\n# klimaschrank.iloc[: , 0:3].plot(x = 'Zeit', y = ['Thermoelement 1 (°C)', 'Thermoelement 2 (°C)'])\n\nplotting_data = klimaschrank.copy()\nplotting_data['Zeit'] = plotting_data['Zeit'].dt.time\n\nplotting_data.plot(x = 'Zeit', y = ['Thermoelement 1 (°C)', 'Thermoelement 2 (°C)'], grid = True)\nplt.ylabel(ylabel = '° C')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](kalibrierung_files/figure-pdf/cell-11-output-1.png){fig-alt='Darstellung der gemessenen Temperaturen der ersten beiden Thermoelemente über die Zeit.' fig-pos='H'}\n:::\n:::\n\n\n&nbsp;\n\nEs ist zu erkennen, dass der Klimaschrank beim Aufheizen auf die nächste Zieltemperatur zunächst zu stark aufheizt, bevor die eingestellte Temperatur für einige Zeit konstant gehalten wird. Die Temperatur von 140 °C wird nur kurz erreicht, es liegen aber kaum Messwerte vor. \n\n**Bestimmen Sie nun den Nullpunktfehler für alle Thermoelemente.**\n\n  1. Wählen Sie für jedes Thermoelement die Bereiche der Datenreihe für die Temperaturstufen -10 bis 130 °C aus.\n  2. Bestimmen Sie für jede Temperaturstufe die gemessene Temperatur im Bereich der Datenreihe, in der die Referenztemperatur konstant gehalten wird.\n  3. Berechnen Sie den Nullpunktfehler für jeden Ausschnitt der Datenreihe und mitteln Sie die Ergebnisse für jedes Thermoelement. \n\n:::{#tip-tipps .callout-tip collapse=\"true\"}\n## Lösungshinweise\n\nTipp 1: Lagemaße wie der Median, Mittelwert oder der Modus können eine einfacher zu bestimmende Schätzgröße für den Nullpunktfehler sein.\n\nTipp 2: Gehen Sie schrittweise vor: Versuchen Sie zunächst, eine Temperaturstufe eines Thermoelements zu isolieren und die gemessene Temperatur im konstanten Bereich der Datenreihe zu bestimmen. Schreiben Sie anschließend eine Funktion, um den Programmcode für mehrere Thermoelemente und Temperaturstufen zu wiederholen.\n\nTipp 3: Eine gleichermaßen für 13 Temperaturstufen und 16 Thermoelemente geeignete Lösung dürfte kaum zu finden sein. Manchmal wird ein Wert gesucht, manchmal liegt der gesuchte Wert zwischen zwei Messwerten. Eine geringfügige Unsicherheit kann durch die Automatisierung in Kauf genommen werden.\n:::\n\n:::{#tip-te .callout-tip collapse=\"true\"}\n## Musterlösung Thermoelemente\n\n**Lösung für ein Thermoelement.**\n\n1. Bereich der Datenreihe für eine Temperatur auswählen, z. B. 0 °C. Dazu grenzen wir die Messwerte grob um den gesuchten Wert $0 \\pm 2 °C$ ein.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# Thermoelement 1\n## Messwerte grob um den gesuchten Wert 0 °C eingrenzen\ngesuchter_wert = 0\n\nmaske1 = klimaschrank['Thermoelement 1 (°C)'].le(gesuchter_wert + 2) # le = kleiner gleich\nmaske2 = klimaschrank['Thermoelement 1 (°C)'].ge(gesuchter_wert - 2) # ge = größer gleich\n\nklimaschrank.loc[maske1 * maske2, 'Thermoelement 1 (°C)'].plot()\nplt.xlabel(xlabel = 'Index')\nplt.ylabel(ylabel = '°C')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](kalibrierung_files/figure-pdf/cell-12-output-1.png){fig-alt='Ausschnitt der Datenreihe von Thermoelement 1' fig-pos='H'}\n:::\n:::\n\n\n&nbsp;\n\nIn diesem Ausschnitt kann das Überschießen der Messwerte beobachtet werden, bevor sich die Messwerte etwa bei + 1 °C einpendeln. Auch ist der Anstieg zur folgenden Temperaturstufe zu erkennen.\n\n2. Im zweiten Schritt sollen die Daten im konstanten Temperaturbereich ausgewählt werden. Dazu soll ein möglichst einfaches Kriterium verwendet werden: der häufigste im Ausschnitt vorkommende Wert, also der Modus. Dazu wird die Methode `pd.value_counts()` verwendet, die eine absteigend sortierte Series der Häufigkeiten zurückgibt, wobei im Index die Werte gespeichert sind (siehe Beispiel). Der im Index gespeicherte häufigste Wert wird mit der Methode `pd.idxmax()` ausgelesen.\n\n:::: {#nte-valuecounts .callout-note collapse=\"true\"}\n## pd.value_counts()\n\nDie Ausgabe von `pd.value_counts()`:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ndaten = pd.Series([1, 2, 3, 3, 3, 3, 3, 4, 4, 5])\ndaten.value_counts()\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n3    5\n4    2\n1    1\n2    1\n5    1\nName: count, dtype: int64\n```\n:::\n:::\n\n\n::::\n\n::: {.cell figalt='Ausschnitt der Datenreihe von Thermoelement 1. Als horizontale Linie ist der Nullpunktfehler eingezeichnet.' execution_count=13}\n``` {.python .cell-code}\n# Thermoelement 1\n\n## Messwerte grob um den gesuchten Wert 0 °C eingrenzen\nmaske1 = klimaschrank['Thermoelement 1 (°C)'].le(gesuchter_wert + 2) # le = kleiner gleich\nmaske2 = klimaschrank['Thermoelement 1 (°C)'].ge(gesuchter_wert - 2) # ge = größer gleich\n\n## häufigster Wert im eingegrenzten Temperaturbereich\nmodus_bereich = klimaschrank.loc[maske1 * maske2, 'Thermoelement 1 (°C)'].value_counts().idxmax()\n\n## Nullpunktfehler bestimmen\nnullpunktfehler = modus_bereich - gesuchter_wert\nprint(f\"Nullpunktfehler: {nullpunktfehler}\")\n\n## plotten\nklimaschrank.loc[maske1 * maske2, 'Thermoelement 1 (°C)'].plot()\nplt.axhline(y = modus_bereich, color = 'r', linestyle = '--', label = 'Modus')\nplt.xlabel(xlabel = 'Index')\nplt.ylabel(ylabel = '°C')\n\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNullpunktfehler: 0.9\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](kalibrierung_files/figure-pdf/cell-14-output-2.png){fig-pos='H'}\n:::\n:::\n\n\n&nbsp;\n\nDer Nullpunktfehler für Thermoelement 1 wird somit mit 0,9 °C bestimmt.\n\n3. Um die Berechnung für die verschiedenen Temperaturstufen zu automatisieren, schreiben wir eine Funktion.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# Eingabe: data = pd.Series, gesuchter_wert = array like, schwellwert, puffer = Skalar\n# Verarbeitung: Elementweise werden die Werte in gesuchter_Wert ± puffer in data gesucht\n# Verarbeitung: Die Differenz aus dem Modus jedes Datenausschnitts und dem gesuchten Wert wird als Nullpunktfehler interpretiert \n# Ausgabe: Wenn output = True wird DataFrame der gesuchten Werte und Nullpunktfehler ausgegeben, wenn output = False wird der mittlere Nullpunktefehler ausgegeben\n\ndef nullpunktfehler(data, gesuchte_werte, puffer = 2, output = False):\n\n  # Zielobjekt und Zähler anlegen\n  ausgabe = pd.DataFrame({'Gesuchter Wert': pd.Series(), 'Nullpunktfehler': pd.Series()})\n  i = 0\n\n  for gesuchter_wert in gesuchte_werte:\n    \n    ## Messwerte grob um den gesuchten Wert eingrenzen\n    maske1 = data.le(gesuchter_wert + puffer) # le = kleiner gleich\n    maske2 = data.ge(gesuchter_wert - puffer) # ge = größer gleich\n\n    ## Kriterium häufigster Wert im eingegrenzten Temperaturbereich\n    modus_bereich = data.loc[maske1 * maske2].value_counts().idxmax()\n    \n    # Nullpunktfehler bestimmen\n    nullpunktfehler = modus_bereich - gesuchter_wert\n\n    # Werte eintragen\n    ausgabe.loc[i] = pd.Series([gesuchter_wert, nullpunktfehler]).values\n\n    # Zähler erhöhen\n    i += 1\n\n  # Optional Ausgabe\n  if output: # output is True\n    print(ausgabe)\n\n  # Rückgabe der gemittelten Nullpunktfehler\n  return ausgabe['Nullpunktfehler'].mean()\n```\n:::\n\n\nAngewendet auf Thermoelement 1 (°C):\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nnullpunktfehler(data = klimaschrank['Thermoelement 1 (°C)'],\n                gesuchte_werte = np.arange(-10, 140, 10),\n                output = True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Gesuchter Wert  Nullpunktfehler\n0            -10.0              1.5\n1              0.0              0.9\n2             10.0              0.7\n3             20.0              0.5\n4             30.0              0.0\n5             40.0             -0.4\n6             50.0             -0.9\n7             60.0             -1.2\n8             70.0             -1.7\n9             80.0             -2.0\n10            90.0             -2.0\n11           100.0             -1.6\n12           110.0             -1.8\n13           120.0             -1.7\n14           130.0             -1.6\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nnp.float64(-0.7533333333333327)\n```\n:::\n:::\n\n\n**Anwendung auf den Datensatz**\n\nIm letzten Schritt wenden wir die Funktion spaltenweise auf den DataFrame an.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# gibt pd.Series zurück\nnullpunktfehler_klimaschrank = klimaschrank.iloc[: , 1:].apply(nullpunktfehler, axis = 0, gesuchte_werte = np.arange(-10, 140, 10))\n\nprint(nullpunktfehler_klimaschrank.round(3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThermoelement 1 (°C)    -0.753\nThermoelement 2 (°C)     0.027\nThermoelement 3 (°C)    -0.000\nThermoelement 4 (°C)     0.547\nThermoelement 5 (°C)     0.513\nThermoelement 6 (°C)    -0.240\nThermoelement 7 (°C)     0.073\nThermoelement 8 (°C)    -0.773\nThermoelement 9 (°C)    -0.373\nThermoelement 10 (°C)   -0.980\nThermoelement 11 (°C)   -0.900\nThermoelement 12 (°C)    0.533\nThermoelement 13 (°C)   -0.760\nThermoelement 14 (°C)   -0.580\nThermoelement 15 (°C)   -0.027\nThermoelement 16 (°C)   -0.987\ndtype: float64\n```\n:::\n:::\n\n\n:::\n\n## Multiplikative Fehler: Der Empfindlichkeitsfehler\nAls Empfindlichkeits- oder Spannfehler wird ein über den Wertebereich (die Spanne) der gesuchten Größe zu- oder abnehmender Fehler bezeichnet. Die relative Messabweichung $\\delta$ ist dabei konstant, die absolute Messabweichung abhängig vom Messwert. ([ics Schneider Messtechnik](https://www.ics-schneider.de/wie-wirken-sich-nullpunktfehler-spannfehler-und-nichtlinearitaet-auf-die-genauigkeit-von-drucksensoren-aus/))\n\n$$\n\\text{Messwerte} = \\text{wahre Werte} \\cdot \\text{Empfindlichkeitsfehler}\n$$\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# Daten erzeugen\nmessgröße = np.arange(0, 11)\nmesswerte = messgröße - messgröße / 3\n\n# plotten\nplt.plot(messgröße, marker = 'o', label = 'wahrer Wert')\nplt.plot(messwerte, marker = '^', label = 'gemessener Wert')\n\n# füllen\nplt.fill_between(x = np.arange(messwerte.size), y1 = messgröße, y2 = messwerte, alpha = 0.2, label = 'Empfindlichkeitsfehler')\n\n# Achsenbeschriftung\nplt.xlabel('Index') \nplt.ylabel('Merkmalsausprägung')\n\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](kalibrierung_files/figure-pdf/cell-18-output-1.png){fig-alt='Schematische Darstellung des Empfindlichkeitsfehlers. Zwei Geraden der wahren und der gemessenen Werte verlaufen ausgehend von einem gemeinsamen Nullpunkt von links nach rechts mit zunehmend Abstand und sind am Punkt x = 0. Die Fläche zwischen den Geraden ist ausgefüllt - dies kennzeichnet den Empfindlichkeitsfehler.' fig-pos='H'}\n:::\n:::\n\n\n### Empfindlichkeitsfehler quantifizieren\nDer Empfindlichkeitsfehler kann geschätzt werden, wenn Referenzwerte bekannt sind. Dazu wird das Verhältnis der Größenänderung (des Anstiegs) der gemessenen und der wahren Werte gebildet.\n\n$$\n\\text{Empfindlichkeitsfehler} = \\frac{\\Delta \\text{gemessene Werte}}{\\Delta\\text{wahre Werte}}\n$$\n\nMit den vollständigen Beispieldaten geht es leicht (in dem Beispiel wird eine Warnung wegen Division durch 0 unterdrückt):\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nprint(f\"Der Empfindlichkeitsfehler beträgt: {round((np.nanmean((messwerte / messgröße)) - 1 ) * 100, 2)} %\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDer Empfindlichkeitsfehler beträgt: -33.33 %\n```\n:::\n:::\n\n\nBei nur punktuellen Daten wird eine ideale Kennlinie geschätzt, mit der der Empfindlichkeitsfehler geschätzt werden kann.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# bekannte Referenzwerte\nx1 = 4\nx2 = 8\ny1 = messgröße[x1]\ny2 = messgröße[x2]\n\n# ideale Kennlinie schätzen\nlm_kennlinie = poly.polyfit(x = [x1, x2], y = [y1, y2], deg = 1)\ngeschätzte_ideale_kennlinie = poly.polyval(x = np.arange(messwerte.size), c = lm_kennlinie)\n\n# lineare Regression der Messwerte\nlm_messwerte = poly.polyfit(x = np.arange(messwerte.size), y = messwerte, deg = 1)\n\n# Berechnung Empfindlichkeitsfehler\nspannfehler = lm_messwerte[1] / lm_kennlinie[1]\n\n# Ausgabe\nprint(f\"Der Anstieg der Messwerte: {round(lm_messwerte[1], 2)}\")\nprint(f\"Der Anstieg der idealen Kennlinie: {round(lm_kennlinie[1], 2)}\")\nprint(f\"Der Empfindlichkeitsfehler beträgt: {round((spannfehler - 1) * 100, 2)} %\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDer Anstieg der Messwerte: 0.67\nDer Anstieg der idealen Kennlinie: 1.0\nDer Empfindlichkeitsfehler beträgt: -33.33 %\n```\n:::\n:::\n\n\nDer Empfindlichkeitsfehler kann auch durch eine lineare Regression mit den bekannten Referenzwerten als unabhängige Größe $x$ und den Messwerten als abhängige Größe $y$ bestimmt werden. Der Anstieg der Regressionsgeraden ist der Empfindlichkeitsfehler.\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# Empfindlichkeitsfehler bestimmen\nlm_referenzpunkte = poly.polyfit(x = [messgröße[x1], messgröße[x2]], y = [messwerte[x1], messwerte[x2]], deg = 1)\nspannfehler = lm_referenzpunkte[1]\n\nprint(f\"Der Empfindlichkeitsfehler beträgt: {round((spannfehler - 1) * 100, 2)} %\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDer Empfindlichkeitsfehler beträgt: -33.33 %\n```\n:::\n:::\n\n\nGrafisch wird das Vorgehen deutlich.\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# Punkte und Linien\nplt.plot([0, 10], [messgröße[0], messgröße[-1]], marker = 'none', linestyle = 'dashed', color = 'C0', label = 'ideale Kennlinie')\nplt.plot([x1, x2], [y1, y2], marker = 'o', linestyle = 'none', color = 'C0', label = 'bekannte Referenzwerte')\nplt.plot(messwerte, marker = '^', color = 'C1', label = 'gemessene Werte')\n\n# füllen\nplt.fill_between(x = np.arange(messwerte.size), y1 = messgröße, y2 = messwerte, alpha = 0.2, label = 'Empfindlichkeitsfehler')\n\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](kalibrierung_files/figure-pdf/cell-22-output-1.png){fig-alt='Eine gestrichelte Linie verläuft ausgehend vom Schnittpunkt der Achsen durch zwei Referenzpunkte. Diese gestrichelte Linie enstpricht der idealen Kennlinie. Eine weitere Linie verbindet die gemessenen Werte. Der Abstand zwischen beiden Linien nimmt über den Wertebereich zu. Der Bereich zwischen den Linien ist farbig gefüllt und kennzeichnet den Empfindlichkeitsfehler' fig-pos='H'}\n:::\n:::\n\n\n### Empfindlichkeitsfehler korrigieren\nDer Empfindlichkeitsfehler wird durch die Division der Messwerte durch den Empfindlichkeitsfehler korrigiert.\n\n$$\n\\text{wahre Werte} = \\frac{\\text{Messwerte}}{\\text{Empfindlichkeitsfehler}}\n$$\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# Daten erzeugen\nmessgröße = np.arange(0, 11) + 5\nmesswerte = messgröße * 1.07\n\n# bekannte Referenzpunkte \nx1 = 2\nx2 = 5\ny1 = messgröße[x1]\ny2 = messgröße[x2]\n\n# ideale Kennlinie schätzen\nlm_kennlinie = poly.polyfit(x = [x1, x2], y = [y1, y2], deg = 1)\n\n# lineare Funktion der Messwerte schätzen\nlm_messwerte = poly.polyfit(x = np.arange(messwerte.size), y = messwerte, deg = 1)\n\n# Empfindlichkeitsfehler bestimmen\nspannfehler = lm_messwerte[1] / lm_kennlinie[1]\nprint(f\"Der Empfindlichkeitsfehler beträgt: {( (spannfehler - 1) * 100).round(2)} %\\n\")\n\n# Empfindlichkeitsfehler korrigieren\nkorrigierte_messwerte = messwerte / spannfehler\n\n# Ausgabe\nprint(f\"Wahre Werte:\\n{messgröße}\")\nprint(f\"Messwerte:\\n{messwerte}\")\nprint(f\"Korrigierte Messwerte:\\n{korrigierte_messwerte}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDer Empfindlichkeitsfehler beträgt: 7.0 %\n\nWahre Werte:\n[ 5  6  7  8  9 10 11 12 13 14 15]\nMesswerte:\n[ 5.35  6.42  7.49  8.56  9.63 10.7  11.77 12.84 13.91 14.98 16.05]\nKorrigierte Messwerte:\n[ 5.  6.  7.  8.  9. 10. 11. 12. 13. 14. 15.]\n```\n:::\n:::\n\n\n### Übung Empfindlichkeitsfehler\nIn einem Klimaschrank wurden 16 Thermoelemente einem Temperaturanstieg von -10 °C bis 140 °C ausgesetzt. Die Messgenauigkeit des verwendeten Datenloggers TCTempX16 liegt bei 0,01 °C, die Auflösung bei 0,1 °C. **Für die Thermoelemente soll der Empfindlichkeitsfehler bestimmt werden**.\n\nDie Messdaten liegen in der Datei '01-daten/kalibration_tc_lineare_rampe.xlsx'. Die Daten können mit dem folgenden Befehl eingelesen werden.\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nklimaschrank = pd.read_excel(io = '01-daten/kalibration_tc_lineare_rampe.xlsx', sheet_name = 'T15949 MultiChannel - Daten', skiprows = 6)\nprint(klimaschrank.info())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 2961 entries, 0 to 2960\nData columns (total 18 columns):\n #   Column                 Non-Null Count  Dtype         \n---  ------                 --------------  -----         \n 0   Datum                  2961 non-null   datetime64[ns]\n 1   Zeit                   2961 non-null   datetime64[ns]\n 2   Thermoelement 1 (°C)   2961 non-null   float64       \n 3   Thermoelement 2 (°C)   2961 non-null   float64       \n 4   Thermoelement 3 (°C)   2961 non-null   float64       \n 5   Thermoelement 4 (°C)   2961 non-null   float64       \n 6   Thermoelement 5 (°C)   2961 non-null   float64       \n 7   Thermoelement 6 (°C)   2961 non-null   float64       \n 8   Thermoelement 7 (°C)   2961 non-null   float64       \n 9   Thermoelement 8 (°C)   2961 non-null   float64       \n 10  Thermoelement 9 (°C)   2961 non-null   float64       \n 11  Thermoelement 10 (°C)  2961 non-null   float64       \n 12  Thermoelement 11 (°C)  2961 non-null   float64       \n 13  Thermoelement 12 (°C)  2961 non-null   float64       \n 14  Thermoelement 13 (°C)  2961 non-null   float64       \n 15  Thermoelement 14 (°C)  2961 non-null   float64       \n 16  Thermoelement 15 (°C)  2961 non-null   float64       \n 17  Thermoelement 16 (°C)  2961 non-null   float64       \ndtypes: datetime64[ns](2), float64(16)\nmemory usage: 416.5 KB\nNone\n```\n:::\n:::\n\n\nMit `klimaschrank.describe()` kann ein Überblick über die Daten gewonnen werden (hier aus Platzgründen für die ersten 4 Spalten).\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nprint(klimaschrank.iloc[: , 0:4].describe())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                            Datum                        Zeit  \\\ncount                        2961                        2961   \nmean   2026-01-15 14:43:19.065856  2026-01-15 14:43:19.065856   \nmin           2026-01-15 10:36:25         2026-01-15 10:36:25   \n25%           2026-01-15 12:39:52         2026-01-15 12:39:52   \n50%           2026-01-15 14:43:19         2026-01-15 14:43:19   \n75%           2026-01-15 16:46:46         2026-01-15 16:46:46   \nmax           2026-01-15 18:50:13         2026-01-15 18:50:13   \nstd                           NaN                         NaN   \n\n       Thermoelement 1 (°C)  Thermoelement 2 (°C)  \ncount           2961.000000           2961.000000  \nmean              79.988011             81.124688  \nmin               -8.500000            -10.700000  \n25%               41.300000             42.400000  \n50%               94.400000             96.200000  \n75%              117.200000            118.800000  \nmax              147.100000            148.700000  \nstd               45.318636             46.109421  \n```\n:::\n:::\n\n\nDie Spalten Datum und Zeit enthalten die selben Informationen. Eine der beiden Spalten kann deshalb entfernt werden.\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nklimaschrank.drop(labels = 'Datum', axis = 1, inplace = True)\n```\n:::\n\n\nBetrachten wir den Verlauf der Daten für die ersten beiden Thermoelemente. (In der Darstellung mit `pd.plot()` ist die automatisch gewählte x-Achsenbeschriftung unansehnlich. Deshalb wird ein Datenobjekt für die Darstellung angelegt und die Spalte 'Zeit' auf die Uhrzeit reduziert.)\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n# Darstellung mit automatischer Achsenbeschriftung\n# klimaschrank.iloc[: , 0:3].plot(x = 'Zeit', y = ['Thermoelement 1 (°C)', 'Thermoelement 2 (°C)'])\n\nplotting_data = klimaschrank.copy()\nplotting_data['Zeit'] = plotting_data['Zeit'].dt.time\n\nplotting_data.plot(x = 'Zeit', y = ['Thermoelement 1 (°C)', 'Thermoelement 2 (°C)'], grid = True)\nplt.ylabel(ylabel = '° C')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](kalibrierung_files/figure-pdf/cell-27-output-1.png){fig-alt='Darstellung der gemessenen Temperaturen der ersten beiden Thermoelemente über die Zeit.' fig-pos='H'}\n:::\n:::\n\n\n&nbsp;\n\nDie Messung startet kurz vor der Aufheizphase. Etwa 16:40 Uhr wurde der Klimaschrank abgeschaltet. Die Messung lief danach noch einige Zeit weiter. Es müssen also der Start- und der Endpunkt der Aufheizphase bestimmt werden.\n\nIn diesem Beispiel soll angenommen werden, dass bei der Messung kein Nullpunktfehler vorliegt. Dazu suchen wir mit der Funktion aus @tip-te passende Messreihen. Aus dem anfänglich konstanten Bereich -10 °C wird der Nullpunktfehler bestimmt.\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n# gibt pd.Series zurück\nnullpunktfehler_klimaschrank = klimaschrank.iloc[: , 1:].apply(nullpunktfehler, axis = 0, gesuchte_werte = [-10])\n\nprint(nullpunktfehler_klimaschrank)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThermoelement 1 (°C)     2.0\nThermoelement 2 (°C)    -0.2\nThermoelement 3 (°C)     2.0\nThermoelement 4 (°C)     0.0\nThermoelement 5 (°C)    -0.1\nThermoelement 6 (°C)     1.8\nThermoelement 7 (°C)     0.1\nThermoelement 8 (°C)     1.7\nThermoelement 9 (°C)     1.6\nThermoelement 10 (°C)    1.7\nThermoelement 11 (°C)    1.8\nThermoelement 12 (°C)   -0.1\nThermoelement 13 (°C)    1.6\nThermoelement 14 (°C)    1.9\nThermoelement 15 (°C)    0.0\nThermoelement 16 (°C)    1.8\ndtype: float64\n```\n:::\n:::\n\n\nDie Messreihen für Thermoelement 4 und Thermoelement 15 scheinen geeignet zu sein. Schauen wir uns die Messreihen einmal an:\n\n::: {.panel-tabset}\n## Thermoelement 4\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# Thermoelement 4\ngesuchter_wert = -10\n\n## Messwerte grob um den gesuchten Wert 0 °C eingrenzen\nmaske1 = klimaschrank['Thermoelement 4 (°C)'].le(gesuchter_wert + 2) # le = kleiner gleich\nmaske2 = klimaschrank['Thermoelement 4 (°C)'].ge(gesuchter_wert - 2) # ge = größer gleich\n\n## häufigster Wert im eingegrenzten Temperaturbereich\nmodus_bereich = klimaschrank.loc[maske1 * maske2, 'Thermoelement 4 (°C)'].value_counts().idxmax()\n\n## Nullpunktfehler bestimmen\nnullpunktfehler = modus_bereich - gesuchter_wert\nprint(f\"Nullpunktfehler: {nullpunktfehler}\")\n\n## plotten\nklimaschrank.loc[maske1 * maske2, 'Thermoelement 4 (°C)'].plot()\nplt.axhline(y = modus_bereich, color = 'r', linestyle = '--', label = 'Modus')\nplt.xlabel(xlabel = 'Index')\nplt.ylabel(ylabel = '°C')\n\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNullpunktfehler: 0.0\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](kalibrierung_files/figure-pdf/cell-29-output-2.png){fig-pos='H'}\n:::\n:::\n\n\n## Thermoelement 15\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# Thermoelement 15\ngesuchter_wert = -10\n\n## Messwerte grob um den gesuchten Wert 0 °C eingrenzen\nmaske1 = klimaschrank['Thermoelement 15 (°C)'].le(gesuchter_wert + 2) # le = kleiner gleich\nmaske2 = klimaschrank['Thermoelement 15 (°C)'].ge(gesuchter_wert - 2) # ge = größer gleich\n\n## häufigster Wert im eingegrenzten Temperaturbereich\nmodus_bereich = klimaschrank.loc[maske1 * maske2, 'Thermoelement 15 (°C)'].value_counts().idxmax()\n\n## Nullpunktfehler bestimmen\nnullpunktfehler = modus_bereich - gesuchter_wert\nprint(f\"Nullpunktfehler: {nullpunktfehler}\")\n\n## plotten\nklimaschrank.loc[maske1 * maske2, 'Thermoelement 15 (°C)'].plot()\nplt.axhline(y = modus_bereich, color = 'r', linestyle = '--', label = 'Modus')\nplt.xlabel(xlabel = 'Index')\nplt.ylabel(ylabel = '°C')\n\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNullpunktfehler: 0.0\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](kalibrierung_files/figure-pdf/cell-30-output-2.png){fig-pos='H'}\n:::\n:::\n\n\n:::\n\n**Bestimmen Sie den Empfindlichkeitsfehler für Thermoelement 4 und Thermoelement 15. Das wahre Minimum der Temperatur betrage -10 °C und das wahre Maximum betrage 140 °C.**\n\n1. Bestimmen Sie den Startpunkt der Aufheizphase.\n2. Bestimmen Sie den Endpunkt der Aufheizphase.\n3. Schätzen Sie eine ideale Kennlinie von -10 °C bis 140 °C für die Aufheizphase.\n4. Ermitteln und korrigieren Sie den Empfindlichkeitsfehler in den Daten.\n\n::: {#tip-spannfehler .callout-tip collapse=\"true\"}\n## Musterlösung Empfindlichkeitsfehler\n\n1. Startpunkt ermitteln, indem die Position des letzten Werts -10 °C bestimmt wird.\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\nstart4 = klimaschrank.loc[::-1, 'Thermoelement 4 (°C)'].eq(-10).idxmax()\nstart15 = klimaschrank.loc[::-1, 'Thermoelement 15 (°C)'].eq(-10).idxmax()\n```\n:::\n\n\n2. Endpunkt ermitteln, indem die Position des Maximums bestimmt wird.\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\nende4 = klimaschrank.loc[:, 'Thermoelement 4 (°C)'].idxmax()\nende15 = klimaschrank.loc[:, 'Thermoelement 15 (°C)'].idxmax()\n```\n:::\n\n\nAusgabe.\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nprint(f\"Messreihe Thermoelement 4 von Index {start4} bis Index {ende4}.\",\n      f\"Messreihe Thermoelement 15 von Index {start15} bis Index {ende15}.\",\n      sep = '\\n')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMessreihe Thermoelement 4 von Index 36 bis Index 2187.\nMessreihe Thermoelement 15 von Index 36 bis Index 2188.\n```\n:::\n:::\n\n\n3. Ideale Kennlinie und lineare Funktion der Messwerte schätzen, Empfindlichkeitsfehler bestimmen.\n\n:::: {.panel-tabset}\n## Thermoelement 4\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n# bekannte Referenzpunkte \nx1 = start4\nx2 = ende4\ny1 = -10\ny2 = 140\n\n# ideale Kennlinie schätzen\nlm_kennlinie = poly.polyfit(x = [x1, x2], y = [y1, y2], deg = 1)\n\n# lineare Funktion der Messwerte schätzen\nlm_messwerte = poly.polyfit(x = np.arange(x1, x2 + 1), y = klimaschrank.loc[x1 : x2, 'Thermoelement 4 (°C)'], deg = 1)\n\n# Empfindlichkeitsfehler bestimmen\nspannfehler = lm_messwerte[1] / lm_kennlinie[1]\nprint(f\"Der Empfindlichkeitsfehler beträgt: {( ((lm_messwerte[1] / lm_kennlinie[1]) - 1) * 100).round(2)} %\")\n\n# Empfindlichkeitsfehler korrigieren\nklimaschrank.loc[ : , 'Thermoelement 4 (°C)'] = klimaschrank.loc[ : , 'Thermoelement 4 (°C)'].div(spannfehler)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDer Empfindlichkeitsfehler beträgt: 6.66 %\n```\n:::\n:::\n\n\n## Thermoelement 15\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# bekannte Referenzpunkte \nx1 = start15\nx2 = ende15\ny1 = -10\ny2 = 140\n\n# ideale Kennlinie schätzen\nlm_kennlinie = poly.polyfit(x = [x1, x2], y = [y1, y2], deg = 1)\n\n# lineare Funktion der Messwerte schätzen\nlm_messwerte = poly.polyfit(x = np.arange(x1, x2 + 1), y = klimaschrank.loc[x1 : x2, 'Thermoelement 15 (°C)'], deg = 1)\n\n# Empfindlichkeitsfehler bestimmen\nspannfehler = lm_messwerte[1] / lm_kennlinie[1]\nprint(f\"Der Empfindlichkeitsfehler beträgt: {( ((lm_messwerte[1] / lm_kennlinie[1]) - 1) * 100).round(2)} %\")\n\n# Empfindlichkeitsfehler korrigieren\nklimaschrank.loc[ : , 'Thermoelement 15 (°C)'] = klimaschrank.loc[ : , 'Thermoelement 15 (°C)'].div(spannfehler)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDer Empfindlichkeitsfehler beträgt: 5.62 %\n```\n:::\n:::\n\n\n::::\n:::\n\n## Nullpunkt- und Empfindlichkeitsfehler\nAbsolute und multiplikative Abweichungen können gemeinsam auftreten.\n\n$$\n\\text{Messwerte} = \\text{wahre Werte} \\cdot Empfindlichkeitsfehler + \\text{Nullpunktfehler}\n$$\n\nIn diesem Beispiel wird die absolute Messabweichung über den dargestellten Wertebereich kleiner, da der Nullpunktfehler mit positivem Vorzeichen und der Empfindlichkeitsfehler mit negativen Vorzeichen auftreten.\n\n::: {.panel-tabset}\n\n## Grafik\n\n::: {.cell execution_count=35}\n\n::: {.cell-output .cell-output-display}\n![](kalibrierung_files/figure-pdf/cell-36-output-1.png){fig-alt='Schematische Darstellung einer Messreihe mit Nullpunkt- und Empfindlichkeitsfehler. Zwei Geraden der wahren und der gemessenen Werte verlaufen von links nach rechts mit abnehmenden Abstand und sind am Punkt x = 0 durch eine gestrichelte Linie verbunden (Nullpunktfehler). Die Fläche zwischen den Geraden ist ausgefüllt - dies kennzeichnet den Empfindlichkeitsfehler.'}\n:::\n:::\n\n\n## Code\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# Daten erzeugen\nmessgröße = np.arange(0, 11)\nmesswerte = messgröße + 4 - messgröße / 3\n\n# plotten\nplt.plot(messgröße, marker = 'o', label = 'wahrer Wert')\nplt.plot(messwerte, marker = '^', label = 'gemessener Wert')\nplt.plot([0, 0], [messgröße[0], messwerte[0]], linestyle = 'dashed', label = 'Nullpunktfehler')\n\n# füllen\nhilfslinie_spannfehler = messwerte - 4\nplt.fill_between(x = np.arange(messwerte.size), y1 = messgröße, y2 = hilfslinie_spannfehler, alpha = 0.2, label = 'Empfindlichkeitsfehler')\n\n# Nullpunktfehler abtragen\nplt.plot([4, 4], [hilfslinie_spannfehler[4] , messwerte[4]], linestyle = 'dashed', color = 'red')\nplt.plot([8, 8], [hilfslinie_spannfehler[8], messwerte[8]], linestyle = 'dashed', color = 'red')\n\n# Achsenbeschriftung\nplt.xlabel('Index') \nplt.ylabel('Merkmalsausprägung')\n\nplt.legend()\nplt.show()\n```\n:::\n\n\n:::\n\n### Nullpunkt- und Empfindlichkeitsfehler quantifizieren\nAus mindestens zwei bekannten Referenzpunkten können mit linearer Regression der Nullpunkt- und der Empfindlichkeitsfehler geschätzt werden.\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n# Daten erzeugen\nmessgröße = np.arange(0, 11) * 2 + 7\nmesswerte = messgröße + 24 - messgröße / 3\n\n# bekannte Referenzpunkte\nx1 = 4\nx2 = 8\ny1 = messgröße[x1]\ny2 = messgröße[x2]\n\n# lineare Regression mit x = Referenzwerte und y = Messwerte\nlm_referenzpunkte = poly.polyfit(x = [messgröße[x1], messgröße[x2]], y = [messwerte[x1], messwerte[x2]], deg = 1)\nprint(lm_referenzpunkte, \"\\n\")\n\n## Nullpunktfehler bestimmen\nnullpunktfehler = lm_referenzpunkte[0]\nprint(f\"Der Nullpunktfehler beträgt: {nullpunktfehler.round(2)}\")\n\n## Empfindlichkeitsfehler bestimmen\nspannfehler = lm_referenzpunkte[1]\nprint(f\"Der Empfindlichkeitsfehler beträgt: {((spannfehler - 1) * 100).round(2)} %\")\n\n## Alternativ: Empfindlichkeitsfehler bestimmen\n### ideale Kennlinie schätzen\nlm_kennlinie = poly.polyfit(x = [x1, x2], y = [y1, y2], deg = 1)\n# print(f\"lm_kennlinie: {lm_kennlinie}\")\n\n###lineare Regression der Messwerte\nlm_messwerte = poly.polyfit(x = np.arange(messwerte.size), y = messwerte, deg = 1)\n# print(f\"lm_messwerte: {lm_messwerte}\")\n\n### Empfindlichkeitsfehler bestimmen\nspannfehler = lm_messwerte[1] / lm_kennlinie[1]\nprint(f\"Der Empfindlichkeitsfehler beträgt: {((spannfehler - 1) * 100).round(2)} %\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[24.          0.66666667] \n\nDer Nullpunktfehler beträgt: 24.0\nDer Empfindlichkeitsfehler beträgt: -33.33 %\nDer Empfindlichkeitsfehler beträgt: -33.33 %\n```\n:::\n:::\n\n\n### Nullpunkt- und Empfindlichkeitsfehler korrigieren\nBei der Korrektur von Nullpunkt- und Empfindlichkeitsfehler unterscheidet sich das Vorgehen abhängig von der Reihenfolge der vorgenommenen Korrekturen.\n\n1. Zuerst wird der Nullpunktfehler korrigiert, danach der Empfindlichkeitsfehler.\n\n$$\nkorrigierte ~ Messwerte = \\frac{(Messwerte - Nullpunktfehler)}{Empfindlichkeitsfehler}\n$$\n\n2. Zuerst wird der Empfindlichkeitsfehler korrigiert, danach der Nullpunktfehler.\n\n$$\nkorrigierte ~ Messwerte = \\frac{Messwerte}{Empfindlichkeitsfehler} - \\frac{Nullpunktfehler}{Empfindlichkeitsfehler}\n$$\n\nEin Beispiel:\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\n# Daten erzeugen\nmessgröße = np.arange(0, 11) * 2 + 7\nmesswerte = messgröße + 4 - messgröße / 3\n\n# bekannte Referenzpunkte\nx1 = 4\nx2 = 8\ny1 = messgröße[x1]\ny2 = messgröße[x2]\n\n# Ausgabe\nprint(f\"Wahre Werte:\\n{messgröße}\")\nprint(f\"Messwerte:\\n{messwerte}\")\nprint()\n\n# ideale Kennlinie schätz# lineare Regression mit x = Referenzwerte und y = Messwerte\nlm_referenzpunkte = poly.polyfit(x = [messgröße[x1], messgröße[x2]], y = [messwerte[x1], messwerte[x2]], deg = 1)\n\n## Nullpunktfehler bestimmen\nnullpunktfehler = lm_referenzpunkte[0]\nprint(f\"Der Nullpunktfehler beträgt: {nullpunktfehler.round(2)}\")\n\n## Empfindlichkeitsfehler bestimmen\nspannfehler = lm_referenzpunkte[1]\nprint(f\"Der Empfindlichkeitsfehler beträgt: {spannfehler.round(2)}\")\nprint()\n\n# erst Nullpunktfehler, dann Empfindlichkeitsfehler korrigieren\nkorrigierte_messwerte = messwerte - nullpunktfehler\nkorrigierte_messwerte = korrigierte_messwerte / spannfehler\nprint(f\"erst Nullpunktfehler, dann Empfindlichkeitsfehler korrigiert:\\n{korrigierte_messwerte}\")\n\n# erst Empfindlichkeitsfehler, dann Nullpunkt korrigieren\nkorrigierte_messwerte = messwerte / spannfehler\nkorrigierte_messwerte = korrigierte_messwerte - (nullpunktfehler / spannfehler)\nprint(f\"erst Empfindlichkeitsfehler, dann Nullpunktfehler korrigiert:\\n{korrigierte_messwerte}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWahre Werte:\n[ 7  9 11 13 15 17 19 21 23 25 27]\nMesswerte:\n[ 8.66666667 10.         11.33333333 12.66666667 14.         15.33333333\n 16.66666667 18.         19.33333333 20.66666667 22.        ]\n\nDer Nullpunktfehler beträgt: 4.0\nDer Empfindlichkeitsfehler beträgt: 0.67\n\nerst Nullpunktfehler, dann Empfindlichkeitsfehler korrigiert:\n[ 7.  9. 11. 13. 15. 17. 19. 21. 23. 25. 27.]\nerst Empfindlichkeitsfehler, dann Nullpunktfehler korrigiert:\n[ 7.  9. 11. 13. 15. 17. 19. 21. 23. 25. 27.]\n```\n:::\n:::\n\n\n## Nichtlinearität: Linearitätsfehler\nBei einer idealen Messung hängt der gesuchte Wert linear vom gemessenen Wert ab. Viele analoge Sensoren reagieren aufgrund von Materialeigenschaften oder abhängig von der Temperatur nicht linear auf die gemessene Größe. Das heißt, die Messwerte sind nicht direkt proportional zur Messgröße. \n\nDem kann zum einen durch die Anwendung von Kalibriermethoden wie der Korrektionstabelle oder von nicht linearen Verfahren zur Parameterschätzung, die im [Methodenbaustein Datenfitting und Datenoptimierung](https://bausteine-der-datenanalyse.github.io/m-datenfitting-und-optimierung/output/book/) behandelt werden, begegnet werden. Zum anderen können die Daten linear approximiert werden, um mit den leichter zu handhabenden linearen Verfahren der Parameterschätzung arbeiten zu können. Der dabei auftretende **Linearitätsfehler** muss quantifiziert werden. Dieses Vorgehen wird hier vorgestellt.\n\n### Beispiel Pt100 {#sec-pt100}\nDas Pt100 ist ein Platin-Widerstandsthermometer (Pt = Platin) mit einem definierten Widerstandswert von  $100 \\Omega$ bei einer Temperatur von 0°C (daher der Name Pt**100**). Der Widerstand eines Pt100 steigt mit der Temperatur. Bei 100 °C beträgt der Widerstand beispielsweise $138,51 \\Omega$. Der Zusammenhang zwischen der Eingangsgröße, dem elektrischen Widerstand, und der so gemessenen Temperatur ist jedoch nur näherungsweise linear.\n\nDie Eigenschaften eines Pt100 Widerstandes sind in der Norm DIN EN IEC 60751 [@DIN60751] festgelegt. Dort wird der Zusammenhang durch zwei Polynome für den Temperaturbereich von -200 °C bis 0 °C und für den Temperaturbereich von 0 °C bis 850 °C  beschrieben.\n\nFür den Temperaturbereich –200 °C bis 0 °C:\n$$\nR_T = R_0 \\cdot \\left(1 + A \\cdot T + B \\cdot T^2 + C \\cdot (T - 100 ^\\circ\\text{C}) \\cdot T^3\\right)\n$$\n\nFür den Temperaturbereich von 0 °C bis +850 °C:\n$$\nR_T = R_0 \\cdot \\left(1 + A \\cdot T + B \\cdot T^2\\right)\n$$\n\nDabei gilt:\n\n  -  $R_T$ ist der Widerstand bei der Temperatur $T$,\n  -  $R_0$ ist der Widerstand bei $0^\\circ\\text{C}$,\n  -  $A$, $B$ und $C$ sind Konstanten, die den spezifischen Charakter des Sensors beschreiben. Dabei sind:\n\n      - $A = 3.9083 \\times 10^{-3} ~ {^\\circ\\text{C}}^{-1}$\n      - $B = -5.775 \\times 10^{-7} ~ {^\\circ\\text{C}}^{-2}$\n      - $C = -4.183 \\times 10^{-12} ~ {^\\circ\\text{C}}^{-4}$\n\n[@DIN60751, S. 13]\n\nIm Anhang der Norm befinden sich Tabellen, die die Beziehung zwischen Temperatur und gemessenem Widerstand wiedergeben. Das Format der Tabellen erlaubt es, aus einem gemessenen Widerstandswert schnell die gemessene Temperatur zu ermitteln. Dazu sind in der ersten Spalte die Temperaturen in Zehnerschritten, in den folgenden zehn Spalten die Einerstelle eingetragen. Für Temperaturen unter Null ist die Einerstelle jeweils zu subtrahieren (erkennbar am Vorzeichen $-$), für Temperaturen über Null dagegen zu addieren (erkennbar am Vorzeichen $+$). Eine zusammengefasste Darstellung finden Sie zum Beispiel [hier](https://s8b8d6a7.delivery.rocketcdn.me/wp-content/uploads/2022/08/Pt100-Tabelle-Screen.pdf).\n\n![Ausschnitt der Tabelle A.1](00-bilder/pt100-table-din60751.png){#fig-pt100 fig-alt=\"Ausschnitt der Tabelle A.1. Für die Temperaturen von -200 bis -170 Grad Celsius sind in 1-Grad-Schritten die von einem Pt100 gemessenen Widerstandswerte eingetragen.\"}\n\n[@DIN60751, S. 25]\n\nDie Notation $t_{90} / °C$ beruht auf der Internationalen Temperaturskala ITS-90 von 1990, die Temperaturen $T_{90}$ in Kelvin und $t_{90}$ in Grad Celsius definiert. Die Notation zeigt also an, dass in der Tabelle Angaben in Grad Celsius stehen. (@DIN60751, S. 10)\n\n::: {#nte-pt100 .callout-note collapse=\"true\"}\n## Pt100-Tabelle einlesen\nFür die Datenanalyse ist das tabellarische Format weniger geeignet. Die [hier](https://s8b8d6a7.delivery.rocketcdn.me/wp-content/uploads/2022/08/Pt100-Tabelle-Screen.pdf) zusammengefasste Darstellung wurde in zwei CSV-Dateien kopiert.\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\ndateipfad_belowzero = '01-daten/pt100-table-below-zero.csv'\ndateipfad_abovezero = '01-daten/pt100-table-above-zero.csv'\n```\n:::\n\n\nDie Dateien soll so eingelesen werden, dass der elektrische Widerstand und die Temperatur jeweils eine aufsteigende Datenreihe bilden. Zunächst betrachten wir die Datei mit mit Temperaturen unter 0 Grad Celsius.\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\n# belowzero\nbelowzero = pd.read_csv(filepath_or_buffer = dateipfad_belowzero, sep = ',')\n\nprint(belowzero.head(), \"\\n\")\nprint(belowzero.tail())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Temperatur in °C Unnamed: 1 Unnamed: 2 Unnamed: 3 Unnamed: 4 Unnamed: 5  \\\n0               NaN          0         -1         -2         -3         -4   \n1            -200.0      18,52        NaN        NaN        NaN        NaN   \n2            -190.0      22,83       22,4      21,97      21,54      21,11   \n3            -180.0       27,1      26,67      26,24      25,82      25,39   \n4            -170.0      31,34      30,91      30,49      30,07      29,64   \n\n  Unnamed: 6 Unnamed: 7 Unnamed: 8 Unnamed: 9 Unnamed: 10  \n0         -5         -6         -7         -8          -9  \n1        NaN        NaN        NaN        NaN         NaN  \n2      20,68      20,25      19,82      19,38       18,95  \n3      24,97      24,54      24,11      23,68       23,25  \n4      29,22       28,8      28,37      27,95       27,52   \n\n    Temperatur in °C Unnamed: 1 Unnamed: 2 Unnamed: 3 Unnamed: 4 Unnamed: 5  \\\n17             -40.0      84,27      83,87      83,48      83,08      82,69   \n18             -30.0      88,22      87,83      87,43      87,04      86,64   \n19             -20.0      92,16      91,77      91,37      90,98      90,59   \n20             -10.0      96,09      95,69       95,3      94,91      94,52   \n21               0.0        100      99,61      99,22      98,83      98,44   \n\n   Unnamed: 6 Unnamed: 7 Unnamed: 8 Unnamed: 9 Unnamed: 10  \n17      82,29      81,89       81,5       81,1        80,7  \n18      86,25      85,85      85,46      85,06       84,67  \n19      90,19       89,8       89,4      89,01       88,62  \n20      94,12      93,73      93,34      92,95       92,55  \n21      98,04      97,65      97,26      96,87       96,48  \n```\n:::\n:::\n\n\nEs gibt 201 Werte (von -200 bis 0). Die Daten beginnen in der Zeile mit dem Index 1 (wenn die erste Zeile als header eingelesen wird). Diese enthält nur einen Eintrag in der Spalte '0'. Die folgenden Zeilen sind von rechts nach links einzulesen. Das Dezimaltrennzeichen ist das `,`. Das Einlesen der Daten von rechts nach links kann auf viele  Arten bewerkstelligt werden. Eine einzeilige Lösung beginnt damit, der Methode `pd.iloc[::-1]` eine negative Schrittweite zu übergeben.\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\ndf = pd.DataFrame(np.array([[3, 2, 1], [6, 5, 4]]))\nprint(df, \"\\n\")\nprint(df.iloc[::-1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   0  1  2\n0  3  2  1\n1  6  5  4 \n\n   0  1  2\n1  6  5  4\n0  3  2  1\n```\n:::\n:::\n\n\nDas führt dazu, dass die *Zeilen* des DataFrame in umgekehrter Reihenfolge ausgegeben werden. Um die *Spalten* in umgekehrter Reihenfolge auszugeben, wird der DataFrame mit der Methode `pd.T` zwei mal transponiert.\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\nprint(df.T.iloc[::-1].T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   2  1  0\n0  1  2  3\n1  4  5  6\n```\n:::\n:::\n\n\nMit der NumPy-Methode `np.flatten()` kann ein Array in eine eindimensionale Struktur reduziert werden. Dafür wird mit der Methode `pd.to_numpy()` der DataFrame als NumPy-Array ausgegeben.\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\nprint(df.T.iloc[::-1].T.to_numpy())\nprint() # leere Zeile\nprint(df.T.iloc[::-1].T.to_numpy().flatten())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2 3]\n [4 5 6]]\n\n[1 2 3 4 5 6]\n```\n:::\n:::\n\n\nVersuchen wir es mit dem Kopf der Pt100-Daten.\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\nbelowzero = pd.read_csv(filepath_or_buffer = dateipfad_belowzero, sep = ',', decimal = ',', header = 0, skiprows = 1, index_col = 0)\n\nprint(belowzero.head())\nprint() # leere Zeile\nprint(belowzero.head().T.iloc[::-1].T.to_numpy().flatten())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          0     -1     -2     -3     -4     -5     -6     -7     -8     -9\n-200  18.52    NaN    NaN    NaN    NaN    NaN    NaN    NaN    NaN    NaN\n-190  22.83  22.40  21.97  21.54  21.11  20.68  20.25  19.82  19.38  18.95\n-180  27.10  26.67  26.24  25.82  25.39  24.97  24.54  24.11  23.68  23.25\n-170  31.34  30.91  30.49  30.07  29.64  29.22  28.80  28.37  27.95  27.52\n-160  35.54  35.12  34.70  34.28  33.86  33.44  33.02  32.60  32.18  31.76\n\n[  nan   nan   nan   nan   nan   nan   nan   nan   nan 18.52 18.95 19.38\n 19.82 20.25 20.68 21.11 21.54 21.97 22.4  22.83 23.25 23.68 24.11 24.54\n 24.97 25.39 25.82 26.24 26.67 27.1  27.52 27.95 28.37 28.8  29.22 29.64\n 30.07 30.49 30.91 31.34 31.76 32.18 32.6  33.02 33.44 33.86 34.28 34.7\n 35.12 35.54]\n```\n:::\n:::\n\n\nUm die fehlenden Werte zu überspringen, wandeln wir das bisherige Ergebnis wieder in eine `pd.Series()` um und verwenden die Methode `pd.Series.dropna()`.\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\npd.Series(belowzero.head().T.iloc[::-1].T.to_numpy().flatten()).dropna()\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\n9     18.52\n10    18.95\n11    19.38\n12    19.82\n13    20.25\n14    20.68\n15    21.11\n16    21.54\n17    21.97\n18    22.40\n19    22.83\n20    23.25\n21    23.68\n22    24.11\n23    24.54\n24    24.97\n25    25.39\n26    25.82\n27    26.24\n28    26.67\n29    27.10\n30    27.52\n31    27.95\n32    28.37\n33    28.80\n34    29.22\n35    29.64\n36    30.07\n37    30.49\n38    30.91\n39    31.34\n40    31.76\n41    32.18\n42    32.60\n43    33.02\n44    33.44\n45    33.86\n46    34.28\n47    34.70\n48    35.12\n49    35.54\ndtype: float64\n```\n:::\n:::\n\n\nUnd jetzt für die gesamte Datei:\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\nbelowzero_ohm = pd.Series(belowzero.T.iloc[::-1].T.to_numpy().flatten()).dropna()\nprint(belowzero_ohm.head(), belowzero_ohm.tail(), sep = '\\n')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n9     18.52\n10    18.95\n11    19.38\n12    19.82\n13    20.25\ndtype: float64\n205     98.44\n206     98.83\n207     99.22\n208     99.61\n209    100.00\ndtype: float64\n```\n:::\n:::\n\n\nDie Temperatur können wir einfach durch ein range-Objekt erzeugen:\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\nbelowzero_temperatur = pd.Series(range(-200, 1)) # range stop ist exklusiv\nprint(belowzero_temperatur.head(), belowzero_temperatur.tail(), sep = '\\n')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0   -200\n1   -199\n2   -198\n3   -197\n4   -196\ndtype: int64\n196   -4\n197   -3\n198   -2\n199   -1\n200    0\ndtype: int64\n```\n:::\n:::\n\n\nFür die Temperaturen oberhalb von 0 Grad kann das Vorgehen vereinfacht werden, da die Datei gleich aufgebaut ist und die Werte aufsteigend sortiert sind.\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\nabovezero = pd.read_csv(filepath_or_buffer = dateipfad_abovezero, sep = ',', decimal = ',', header = 0, skiprows = 1, index_col = 0)\n\nabovezero_ohm = pd.Series(abovezero.to_numpy().flatten()).dropna()\nprint(abovezero_ohm.head(), abovezero_ohm.tail(), sep = '\\n')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0    100.00\n1    100.39\n2    100.78\n3    101.17\n4    101.56\ndtype: float64\n846    389.31\n847    389.60\n848    389.90\n849    390.19\n850    390.48\ndtype: float64\n```\n:::\n:::\n\n\nBeide Datensätze enthalten einen Eintrag für die Temperatur 0 Grad, sodass dieser in der zweiten Datei entfernt werden kann.\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\nabovezero_ohm = abovezero_ohm[1:]\nprint(abovezero_ohm.head(), abovezero_ohm.tail(), sep = '\\n')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1    100.39\n2    100.78\n3    101.17\n4    101.56\n5    101.95\ndtype: float64\n846    389.31\n847    389.60\n848    389.90\n849    390.19\n850    390.48\ndtype: float64\n```\n:::\n:::\n\n\nDie Temperatur wird wieder durch ein range-Objekt erzeugt.\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\nabovezero_temperatur = pd.Series(range(1, 851)) # range stop ist exklusiv\n```\n:::\n\n\nDie aus beiden Datensätzen erzeugten Series können zusammengefasst werden:\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\npt100 = pd.DataFrame({'Temperatur': pd.concat([belowzero_temperatur, abovezero_temperatur], ignore_index = True), 'Ohm': pd.concat([belowzero_ohm, abovezero_ohm], ignore_index = True)})\nprint(pt100.head(), pt100.tail(), sep = '\\n')\n\nprint(pt100.info())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Temperatur    Ohm\n0        -200  18.52\n1        -199  18.95\n2        -198  19.38\n3        -197  19.82\n4        -196  20.25\n      Temperatur     Ohm\n1046         846  389.31\n1047         847  389.60\n1048         848  389.90\n1049         849  390.19\n1050         850  390.48\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 1051 entries, 0 to 1050\nData columns (total 2 columns):\n #   Column      Non-Null Count  Dtype  \n---  ------      --------------  -----  \n 0   Temperatur  1051 non-null   int64  \n 1   Ohm         1051 non-null   float64\ndtypes: float64(1), int64(1)\nmemory usage: 16.6 KB\nNone\n```\n:::\n:::\n\n\n:::\n\n### Nichtlinearität darstellen\nMit den Daten aus @nte-pt100 kann die Nichtlinearität des Sensors dargestellt werden.\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\nplt.plot(pt100['Temperatur'], pt100['Ohm'], marker = 'o', linestyle = '', label = 'elektrischer Widerstand', alpha = 0.6)\nplt.plot([pt100['Temperatur'].iloc[0], pt100['Temperatur'].iloc[-1]], [pt100['Ohm'].iloc[0], pt100['Ohm'].iloc[-1]], linewidth = 2, label = 'Referenzlinie')\nplt.yticks(pt100['Ohm'][::50]);\n\nplt.xlabel('Temperatur in °C')\nplt.ylabel('elektrischer Widerstand in Ohm')\nplt.grid()\nplt.legend()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](kalibrierung_files/figure-pdf/cell-53-output-1.png){fig-alt='Darstellung der Temperatur in Grad Celsius auf der x-Achse und des elektrischen Widerstands in Ohm auf der y-Achse' fig-pos='H'}\n:::\n:::\n\n\n&nbsp;\n\nEs fällt auf, dass die Daten einen Fehlwert enthalten. Die Position des Fehlwerts wird mit zwei Pandas-Methoden bestimmt. `pd.diff()` gibt die Differenz jedes Werts zu seinem Vorgänger zurück. `pd.idxmin()` gibt den Zeilenindex (genauer das label) des kleinsten Werts zurück. (Läge der Fehlwert oberhalb der Linie, würde `pd.idxmax()` verwendet werden.)\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\n # := ist der sog. Walross-Operator\nprint(( position_fehlwert := pt100['Ohm'].diff().idxmin() ))\nprint(pt100.iloc[list(range(position_fehlwert - 2, position_fehlwert + 3))])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n341\n     Temperatur     Ohm\n339         139  153.21\n340         140  153.58\n341         141   13.96\n342         142  154.33\n343         143  154.71\n```\n:::\n:::\n\n\nDer korrekte Wert kann aus der DIN-Norm [@DIN60751, S. 26] abgelesen werden (153,96). Man könnte den Wert aber auch interpolieren (siehe Beispiel).\n\n::: {#nte-interpolieren .callout-note collapse=\"true\"}\n## Interpolation\nDie einfachste Form der Interpolation ist die lineare Interpolation. \n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\ninterpolate_me = pt100.loc[position_fehlwert - 1 : position_fehlwert + 1, 'Ohm'].copy()\ninterpolate_me[position_fehlwert] = np.nan\nprint(interpolate_me, \"\\n\")\n\nprint(\"linear interpolierter Wert:\", interpolate_me.interpolate(), sep = \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n340    153.58\n341       NaN\n342    154.33\nName: Ohm, dtype: float64 \n\nlinear interpolierter Wert:\n340    153.580\n341    153.955\n342    154.330\nName: Ohm, dtype: float64\n```\n:::\n:::\n\n\nDurch Runden wird das korrekte Ergebnis erreicht (darauf verlassen sollte man sich aber nicht).\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\nprint(\"linear interpolierter Wert:\", interpolate_me.interpolate().round(2), sep = \"\\n\")\nkorrekter_wert = interpolate_me.interpolate().round(2)[position_fehlwert]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlinear interpolierter Wert:\n340    153.58\n341    153.96\n342    154.33\nName: Ohm, dtype: float64\n```\n:::\n:::\n\n\nEine andere Option ist die nichtlineare Interpolation (die nicht Inhalt dieses Bausteins ist). \n\n:::: {#nte-nonlinear .callout-note collapse=\"true\"}\n## Nichtlineare Interpolation\n\nDie nichtlineare Interpolation benötigt mehr Datenpunkte. Wir versuchen die kubische Interpolation:\n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\ninterpolate_me_again = pt100.loc[position_fehlwert - 3 : position_fehlwert + 4, 'Ohm'].copy()\ninterpolate_me_again[position_fehlwert] = np.nan\nprint(\"polynomial interpolierter Wert:\", interpolate_me_again.interpolate(method = 'polynomial', order = 3), sep = \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npolynomial interpolierter Wert:\n338    152.830000\n339    153.210000\n340    153.580000\n341    153.952213\n342    154.330000\n343    154.710000\n344    155.080000\n345    155.460000\nName: Ohm, dtype: float64\n```\n:::\n:::\n\n\nDas Ergebnis ist ungenauer. Warum das so ist, erfahren Sie im [Methodenbaustein Datenfitting und Datenoptimierung](https://bausteine-der-datenanalyse.github.io/m-datenfitting-und-optimierung/output/book/).\n\n::::\n:::\n\nDer Fehlwert (dessen Position in obigem Beispiel bestimmt wird) wird korrigiert:\n\n::: {.cell execution_count=57}\n``` {.python .cell-code}\npt100.loc[position_fehlwert, 'Ohm'] = korrekter_wert\nprint(pt100.loc[position_fehlwert - 1 : position_fehlwert + 1, 'Ohm'])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n340    153.58\n341    153.96\n342    154.33\nName: Ohm, dtype: float64\n```\n:::\n:::\n\n\nSodann kann die Nichtlinearität erneut dargestellt werden:\n\n::: {.cell execution_count=58}\n``` {.python .cell-code}\nplt.plot(pt100['Temperatur'], pt100['Ohm'], marker = 'o', linestyle = '', label = 'elektrischer Widerstand', alpha = 0.6)\nplt.plot([pt100['Temperatur'].iloc[0], pt100['Temperatur'].iloc[-1]], [pt100['Ohm'].iloc[0], pt100['Ohm'].iloc[-1]], linewidth = 2, label = 'Referenzlinie')\nplt.yticks(pt100['Ohm'][::50]);\n\nplt.xlabel('Temperatur in °C')\nplt.ylabel('elektrischer Widerstand in Ohm')\nplt.grid()\nplt.legend()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](kalibrierung_files/figure-pdf/cell-59-output-1.png){fig-alt='Darstellung der Temperatur in Grad Celsius auf der x-Achse und des elektrischen Widerstands in Ohm auf der y-Achse' fig-pos='H'}\n:::\n:::\n\n\n### Nichtlinearität quantifizieren\nZwei Methoden zur Quantifizierung der Nichtliniearität sind die Festpunkt- und die Toleranzbandmethode.\n\n#### Festpunktmethode\n\n::: {#imp-festpunktmethode .callout-important}\n## Festpunktmethode\nDie Endpunkte der realen Kennlinie werden durch eine Gerade verbunden. Der Linearitätsfehler ist das Maximum der Abweichung der Kennlinie zu dieser Geraden. [@Dubbel2011, S. W2-W3 (S. 1661-1662)]\n:::\n\nDazu bestimmen wir zunächst die Vorhersagewerte einer Geraden durch die Endpunkte.\n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\nlm = poly.polyfit(\n  x = [pt100['Temperatur'].iloc[0], pt100['Temperatur'].iloc[-1]],\n  y = [pt100['Ohm'].iloc[0], pt100['Ohm'].iloc[-1]],\n  deg = 1)\nprint(lm.round(2)) # intercept + slope\n\nvorhersagewerte = poly.polyval(x = pt100['Temperatur'], c = lm)\n\nplt.plot(pt100['Temperatur'], pt100['Ohm'], marker = 'o', linestyle = '', label = 'elektrischer Widerstand', alpha = 0.6)\nplt.plot(pt100['Temperatur'], vorhersagewerte, linewidth = 2, label = 'Vorhersagewerte endpunktverbindende Gerade')\nplt.yticks(pt100['Ohm'][::50]);\n\nplt.xlabel('Temperatur in °C')\nplt.ylabel('elektrischer Widerstand in Ohm')\nplt.grid()\nplt.legend()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[89.37  0.35]\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](kalibrierung_files/figure-pdf/cell-60-output-2.png){fig-alt='Darstellung der Temperatur in Grad Celsius auf der x-Achse und des elektrischen Widerstands in Ohm auf der y-Achse' fig-pos='H'}\n:::\n:::\n\n\n&nbsp;\n\nAus der Differenz des gemessenen elektrischen Widerstands und der linearen Vorhersagewerte kann der maximale Linearitätsfehler bestimmt werden.\n\n::: {.cell execution_count=60}\n``` {.python .cell-code}\nlinearitätsfehler_festpunkt = (pt100['Ohm'] - vorhersagewerte).abs().max()\nprint(f\"Linearitätsfehler nach Festpunktmethode: {linearitätsfehler_festpunkt:.2f} Ohm.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLinearitätsfehler nach Festpunktmethode: 16.43 Ohm.\n```\n:::\n:::\n\n\n#### Toleranzbandmethode\n\n::: {#imp-toleranzbandmethode .callout-important}\n## Toleranzbandmethode\nBei der Toleranzbandmethode wird eine Gerade so durch die Messpunkte gelegt, dass die Summe der quadrierten Abweichungen der Messpunkte zu dieser Geraden (Methode der kleinsten Quadrate) oder die größte einzelne Abweichung ([Tschebyscheff-Approximation](https://de.wikipedia.org/wiki/Tschebyschow-Polynom)) minimiert wird. Die Größe des Linearitätsfehlers ist die maximale senkrechte Entfernung der Kennlinie zu dieser Ausgleichsgeraden. [@Dubbel2011, S. W3 (S. 1662)]\n:::\n\nDas Prinzip der Methode der kleinsten Quadrate haben wir bereits kennengelernt.\n\n::: {.cell execution_count=61}\n``` {.python .cell-code}\nlm = poly.polyfit(\n  x = pt100['Temperatur'],\n  y = pt100['Ohm'],\n  deg = 1)\nprint(lm.round(2)) # intercept + slope\n\nvorhersagewerte = poly.polyval(x = pt100['Temperatur'], c = lm)\n\nplt.plot(pt100['Temperatur'], pt100['Ohm'], marker = 'o', linestyle = '', label = 'elektrischer Widerstand', alpha = 0.6)\nplt.plot(pt100['Temperatur'], vorhersagewerte, linewidth = 2, label = 'Regressionsgerade')\nplt.yticks(pt100['Ohm'][::50]);\n\nplt.xlabel('Temperatur in °C')\nplt.ylabel('elektrischer Widerstand in Ohm')\nplt.grid()\nplt.legend()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[100.67   0.35]\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](kalibrierung_files/figure-pdf/cell-62-output-2.png){fig-alt='Darstellung der Temperatur in Grad Celsius auf der x-Achse und des elektrischen Widerstands in Ohm auf der y-Achse' fig-pos='H'}\n:::\n:::\n\n\n&nbsp;\n\nAus der Differenz des gemessenen elektrischen Widerstands und der linearen Vorhersagewerte kann der maximale Linearitätsfehler (= das größte Residuum) bestimmt werden.\n\n::: {.cell execution_count=62}\n``` {.python .cell-code}\nlinearitätsfehler_toleranzband = (pt100['Ohm'] - vorhersagewerte).abs().max()\nprint(f\"Linearitätsfehler nach Toleranzbandmethode: {linearitätsfehler_toleranzband:.2f} Ohm.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLinearitätsfehler nach Toleranzbandmethode: 11.45 Ohm.\n```\n:::\n:::\n\n\n## Die Zweipunktkalibrierung\nDie Zweipunktkalibrierung ist ein praktisches Verfahren für die Kalibrierung von Messdaten. Die Zweipunktkalibrierung erfolgt über das bekannte wahre Minimum und das bekannte wahre Maximum einer Messreihe.\n\n$$\na = \\frac{(\\text{wahres Maximum} - \\text{wahres Minimum})}{(\\text{Maximum Messwerte} - \\text{Minimum Messwerte})}\n$$\n\n$$\nb = \\text{wahres Minimum} - a \\cdot \\text{Minimum Messwerte}\n$$\n\n$$\n\\text{kalibrierte Messwerte} = a \\cdot \\text{Messwerte} + b\n$$\n\nDie Variable $a$ ist der Korrekturfaktor für den Empfindlichkeitsfehler. Die Variable $b$ ist die Nullpunktkorrektur, nachdem der Empfindlichkeitsfehler korrigiert wurde. \n\n::: {.cell execution_count=63}\n``` {.python .cell-code}\n# Daten erzeugen\nmessgröße = np.arange(0, 11) + 7\nmesswerte = messgröße + 4 - messgröße / 3\n\n# bekannte Referenzpunkte\nwahres_minimum = messgröße.min()\nwahres_maximum = messgröße.max()\n\n# Zweipunktkalibrierung\na = (wahres_maximum - wahres_minimum) / (messwerte.max() - messwerte.min())\nb = wahres_minimum - a * messwerte.min()\nkorrigierte_messwerte = a * messwerte + b\n\n# Ausgabe\nprint(f\"Wahre Werte:\\n{messgröße}\")\nprint(f\"Messwerte:\\n{messwerte}\")\nprint()\nprint(f\"Zweipunktkalibrierung\\n\",\n      f\"a = {a:.1f}\\n\",\n      f\"b = {b:.1f}\\n\",\n      f\"\\na * messwerte + b\\n{korrigierte_messwerte}\",\n      sep = '')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWahre Werte:\n[ 7  8  9 10 11 12 13 14 15 16 17]\nMesswerte:\n[ 8.66666667  9.33333333 10.         10.66666667 11.33333333 12.\n 12.66666667 13.33333333 14.         14.66666667 15.33333333]\n\nZweipunktkalibrierung\na = 1.5\nb = -6.0\n\na * messwerte + b\n[ 7.  8.  9. 10. 11. 12. 13. 14. 15. 16. 17.]\n```\n:::\n:::\n\n\nDer Empfindlichkeitsfehler kann als ${1 \\over a} - 1$ ermittelt werden. Der Nullpunktfehler kann als $-1 * {b \\over a}$ ermittelt werden.\n\n::: {.cell execution_count=64}\n``` {.python .cell-code}\nprint(f\"Empfindlichkeitsfehler: {round( ((1 / a) - 1) * 100, 2)} %\")\nprint(f\"Nullpunktfehler: {round(-1 * b / a, 2)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEmpfindlichkeitsfehler: -33.33 %\nNullpunktfehler: 4.0\n```\n:::\n:::\n\n\n<!-- \n## Weitere Fehlerarten\n[Hysterese](https://de.wikipedia.org/wiki/Hysterese): Verzögerung zwischen Änderung des Wertes und Änderungsgeschwindigkeit des Messwerts\nDrift\nRauschen -->\n\n",
    "supporting": [
      "kalibrierung_files/figure-pdf"
    ],
    "filters": []
  }
}