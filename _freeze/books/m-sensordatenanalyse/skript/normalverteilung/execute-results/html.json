{
  "hash": "0af39e1620549625b568bd0a10a8e772",
  "result": {
    "engine": "jupyter",
    "markdown": "# Die Normalverteilung {#sec-normalverteilung}\n\nMit zunehmender Stichprobengröße wird eine immer bessere Schätzung des Erwartungswerts erreicht. Mathematisch liegt dieser Beobachtung der [zentrale Grenzwertsatz](https://de.wikipedia.org/wiki/Zentraler_Grenzwertsatz) zugrunde. So werden beim Würfeln mit mehreren Würfeln weit vom Erwartungswert entfernte Wurfergebnisse immer unwahrscheinlicher. Dies lässt sich bereits mit wenigen Würfeln zeigen (siehe Beispiel). \n\n\n\n::: {#nte-wuerfel .callout-note collapse=\"true\"}\n## Häufigkeitsverteilung von Würfelergebnissen\nFür einen Würfel gibt es 6 mögliche Ergebnisse, für 2 Würfel 6 * 6 mögliche Kombinationen, für 3 Würfel 6 * 6 * 6 Kombinationen und so weiter. Weil viele Kombinationen wertgleich sind, kommen Wurfergebnisse in der Nähe des Erwartungswerts häufiger vor als beispielsweise ein Einserpasch.\n\n:::: {.panel-tabset}\n## ein Würfel\n\n::: {#511bf522 .cell execution_count=2}\n``` {.python .cell-code}\nein_würfel = []\n\nfor i in range(1, 7):\n  ein_würfel.append(i)\n\nein_würfel = pd.Series(ein_würfel)\n\nprint(\"Häufigkeitsverteilung der Augensumme:\")\nprint(ein_würfel.value_counts(), \"\\n\")\nprint(f\"Durchschnitt: {ein_würfel.mean():.1f}\")\n\nplt.bar(ein_würfel.unique(), ein_würfel.value_counts())\nplt.xlabel('Augenzahl')\nplt.ylabel('Anzahl Kombinationen')\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHäufigkeitsverteilung der Augensumme:\n1    1\n2    1\n3    1\n4    1\n5    1\n6    1\nName: count, dtype: int64 \n\nDurchschnitt: 3.5\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-3-output-2.png){fig-alt='Häufigkeitsverteilung der Ergebnisse eines Würfels.'}\n:::\n:::\n\n\n## zwei Würfel\n\n::: {#032c0deb .cell execution_count=3}\n``` {.python .cell-code}\nzwei_würfel = []\n\nfor i in range(1, 7):\n  würfel_1 = i\n\n  for j in range (1, 7):\n    würfel_2 = j\n    zwei_würfel.append(würfel_1 + würfel_2)\n\nzwei_würfel = pd.Series(zwei_würfel)\n\nprint(\"Häufigkeitsverteilung der Augensumme:\")\nprint(zwei_würfel.value_counts().sort_index(ascending = True), \"\\n\")\nprint(f\"Durchschnitt: {zwei_würfel.mean():.1f}\")\nprint(f\"Durchschnitt pro Würfel: {zwei_würfel.mean() / 2:.1f}\")\n\nplt.bar(zwei_würfel.unique(), zwei_würfel.value_counts().sort_index(ascending = True))\nplt.xlabel('Augenzahl')\nplt.ylabel('Anzahl Kombinationen')\nplt.grid()\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHäufigkeitsverteilung der Augensumme:\n2     1\n3     2\n4     3\n5     4\n6     5\n7     6\n8     5\n9     4\n10    3\n11    2\n12    1\nName: count, dtype: int64 \n\nDurchschnitt: 7.0\nDurchschnitt pro Würfel: 3.5\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-4-output-2.png){fig-alt='Häufigkeitsverteilung der Ergebnisse von zwei Würfeln.'}\n:::\n:::\n\n\n## drei Würfel\n\n::: {#9c66af1b .cell execution_count=4}\n``` {.python .cell-code}\ndrei_würfel = []\n\nfor i in range(1, 7):\n  würfel_1 = i\n\n  for j in range (1, 7):\n    würfel_2 = j\n\n    for k in range (1, 7):\n      würfel_3 = k\n      drei_würfel.append(würfel_1 + würfel_2 + würfel_3)\n\ndrei_würfel = pd.Series(drei_würfel)\n\nprint(\"Häufigkeitsverteilung der Augensumme:\")\nprint(drei_würfel.value_counts().sort_index(ascending = True), \"\\n\")\nprint(f\"Durchschnitt: {drei_würfel.mean():.1f}\")\nprint(f\"Durchschnitt pro Würfel: {drei_würfel.mean() / 3:.1f}\")\n\nplt.bar(drei_würfel.unique(), drei_würfel.value_counts().sort_index(ascending = True))\nplt.xlabel('Augenzahl')\nplt.ylabel ('Anzahl Kombinationen')\nplt.grid()\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHäufigkeitsverteilung der Augensumme:\n3      1\n4      3\n5      6\n6     10\n7     15\n8     21\n9     25\n10    27\n11    27\n12    25\n13    21\n14    15\n15    10\n16     6\n17     3\n18     1\nName: count, dtype: int64 \n\nDurchschnitt: 10.5\nDurchschnitt pro Würfel: 3.5\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-5-output-2.png){fig-alt='Häufigkeitsverteilung der Ergebnisse von drei Würfeln.'}\n:::\n:::\n\n\n::::\n:::\n\nDie mit steigender Stichprobengröße zu beobachtende Annäherung von Messwerten an einen in der Grundgesamtheit geltenden Erwartungswert gilt auch, wenn der Erwartungswert und die Varianz in der Grundgesamtheit unbekannt sind. Mit zunehmender Stichprobengröße nähern sich die Messwerte der [Normalverteilung](https://de.wikipedia.org/wiki/Normalverteilung) an, die nach ihrem Entdecker Carl Friedrich Gauß auch als Gaußsche Glockenkurve bekannt ist.\n\nDie für größere Stichproben zu beobachtende Annäherung der Verteilung von Messwerten an die Normalverteilung kann anhand des Gewichts von Pinguinen aus dem Datensatz palmerpenguins gezeigt werden.\n\n::: {.border}\n\n**palmerpenguins**\n\n![Pinguine des Palmer-Station-Datensatzes](00-bilder/lter_penguins_allison_horst_CC0.png){fig-alt=\"illustrative Darstellung der Pinguine\"}\n\nMeet the Palmer penguins von \\@allison_horst steht unter der Lizenz [CC0-1.0](https://github.com/allisonhorst/palmerpenguins?tab=CC0-1.0-1-ov-file#creative-commons) und ist auf [GitHub](https://github.com/allisonhorst/palmerpenguins?tab=readme-ov-file#meet-the-palmer-penguins) abrufbar. 2020\n\nDer Datensatz steht unter der Lizenz [CCO](https://creativecommons.org/public-domain/cc0/) und ist in R sowie auf [GitHub](https://github.com/allisonhorst/palmerpenguins?tab=readme-ov-file) verfügbar. 2020\n\n``` {.raw}\n# R Befehle, um den Datensatz zu laden\ninstall.packages(\"palmerpenguins\")\nlibrary(palmerpenguins)\n```\n\nHorst AM, Hill AP und Gorman KB. 2020. palmerpenguins: Palmer Archipelago (Antarctica) penguin data. R package version 0.1.0. <https://allisonhorst.github.io/palmerpenguins/>. doi: 10.5281/zenodo.3960218.\n\n::: {#d152803c .cell execution_count=5}\n``` {.python .cell-code}\npenguins = pd.read_csv(filepath_or_buffer = \"01-daten/penguins.csv\")\n\n# Tiere mit unvollständigen Einträgen entfernen\npenguins.drop(np.where(penguins.apply(pd.isna).any(axis = 1))[0], inplace = True)\n\nprint(penguins.info(), \"\\n\");\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.frame.DataFrame'>\nIndex: 333 entries, 0 to 343\nData columns (total 8 columns):\n #   Column             Non-Null Count  Dtype  \n---  ------             --------------  -----  \n 0   species            333 non-null    object \n 1   island             333 non-null    object \n 2   bill_length_mm     333 non-null    float64\n 3   bill_depth_mm      333 non-null    float64\n 4   flipper_length_mm  333 non-null    float64\n 5   body_mass_g        333 non-null    float64\n 6   sex                333 non-null    object \n 7   year               333 non-null    int64  \ndtypes: float64(4), int64(1), object(3)\nmemory usage: 23.4+ KB\nNone \n\n```\n:::\n:::\n\n\n:::\n\n&nbsp;\n\nDer Datensatz enthält Daten für drei Pinguinarten.\n\n::: {#b2321504 .cell execution_count=6}\n``` {.python .cell-code}\nprint(penguins.groupby(by = penguins['species']).size())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nspecies\nAdelie       146\nChinstrap     68\nGentoo       119\ndtype: int64\n```\n:::\n:::\n\n\nUnter anderen wurde das Körpergewicht in Gramm gemessen, das in der Spalte 'body_mass_g' eingetragen ist. Die Gewichtsverteilung der drei Spezies wird jeweils mit einem Histogramm dargestellt. Außerdem werden für jede Spezies  der Stichprobenmittelwert und die Stichprobenstandardabweichung bestimmt. Mit diesen Werten kann eine Normalverteilungskurve berechnet und in das Histogramm eingezeichnet werden (wie das geht, wird in @nte-normalverteilungdarstellen gezeigt). So kann optisch geprüft werden, ob die empirische Verteilung der Werte in der Stichprobe einer Normalverteilung mit den selben Werten für Mittelwert und Standardabweichung entspricht. (Bei aus Messungen gewonnenen Daten ist dies häufig nicht so eindeutig, wie bei der Häufigkeitsverteilung von Würfelergebnissen.)\n\n::: {.panel-tabset}\n\n## Grafik\n\n::: {#8dc431c3 .cell execution_count=7}\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-8-output-1.png){fig-alt='Dargestellt sind drei Histogramme für die Pinguinarten Adelie, Chinstrap und Gentoo. Auf der x-Achse ist das Gewicht in Gramm und auf der y-Achse die Häufigkeitsdichte abgetragen. Auf jedes Histogramm ist eine Normalverteilungskurve mit den Parametern der Stichprobe gezeichnet.'}\n:::\n:::\n\n\n## Code\n\n::: {#0252ab87 .cell execution_count=8}\n``` {.python .cell-code}\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize = (7.5, 6), sharey = True, layout = 'tight')\nplt.suptitle('Gewichtsverteilung von Pinguinen')\n\n# Adelie\nspecies = 'Adelie'\ndata = penguins['body_mass_g'][penguins['species'] == species]\n\n## Histogramm\nax1.hist(data, alpha = 0.6, edgecolor = 'lightgrey', color = 'C0', density = True)\nax1.set_xlabel('Gewicht in Gramm')\nax1.set_ylabel('Häufigkeitsdichte')\nax1.set_title(label = str(species) + \" N = \" + str(data.size))\n\n## Normalverteilungskurve\nstichprobenmittelwert = data.mean()\nstichprobenstandardabweichung = data.std(ddof = 1)\nhist, bin_edges = np.histogram(data)\nx_values = np.linspace(min(bin_edges), max(bin_edges), 100)\ny_values =  1 / (stichprobenstandardabweichung * np.sqrt(2 * np.pi)) * np.exp(- (x_values - stichprobenmittelwert) ** 2 / (2 * stichprobenstandardabweichung ** 2))\n\nax1.plot(x_values, y_values, color = 'black', linewidth = 1, label = 'Normalverteilung')\nax1.legend()\n\n# Chinstrap\nspecies = 'Chinstrap'\ndata = penguins['body_mass_g'][penguins['species'] == species]\n\n## Histogramm\nax2.hist(data, alpha = 0.6, edgecolor = 'lightgrey', color = 'C1', density = True)\nax2.set_xlabel('Gewicht in Gramm')\nax2.set_title(label = str(species) + \" N = \" + str(data.size))\n\n## Normalverteilungskurve\nstichprobenmittelwert = data.mean()\nstichprobenstandardabweichung = data.std(ddof = 1)\nhist, bin_edges = np.histogram(data)\nx_values = np.linspace(min(bin_edges), max(bin_edges), 100)\ny_values =  1 / (stichprobenstandardabweichung * np.sqrt(2 * np.pi)) * np.exp(- (x_values - stichprobenmittelwert) ** 2 / (2 * stichprobenstandardabweichung ** 2))\n\nax2.plot(x_values, y_values, color = 'black', linewidth = 1)\n\n# Gentoo\nspecies = 'Gentoo'\ndata = penguins['body_mass_g'][penguins['species'] == species]\n\n## Histogramm\nax3.hist(data, alpha = 0.6, edgecolor = 'lightgrey', color = 'C2', density = True)\nax3.set_xlabel('Gewicht in Gramm')\nax3.set_title(label = str(species) + \" N = \" + str(data.size))\n\n## Normalverteilungskurve\nstichprobenmittelwert = data.mean()\nstichprobenstandardabweichung = data.std(ddof = 1)\nhist, bin_edges = np.histogram(data)\nx_values = np.linspace(min(bin_edges), max(bin_edges), 100)\ny_values =  1 / (stichprobenstandardabweichung * np.sqrt(2 * np.pi)) * np.exp(- (x_values - stichprobenmittelwert) ** 2 / (2 * stichprobenstandardabweichung ** 2))\n\nax3.plot(x_values, y_values, color = 'black', linewidth = 1)\n\nplt.show()\n```\n:::\n\n\n:::\n\nDie Normalverteilung ist eine Dichtekurve, an die sich der Verlauf eines Histogramms mit einer gegen unendlich gehenden Anzahl von Messwerten und einer gegen Null gehenden Klassenbreite annähert. \n\n::: {#imp-histogramm .callout-important collapse=\"false\"}\n## Histogramm\nDas Histogramm ist eine grafische Darstellung der Häufigkeitsverteilung kardinal skalierter Merkmale (d. h. mit numerischen, geordneten Merkmalsausprägungen). Die Daten werden in Klassen, die eine konstante oder variable Breite haben können, eingeteilt. Es werden direkt nebeneinanderliegende Rechtecke von der Breite der jeweiligen Klasse gezeichnet, deren Flächeninhalte die (relativen oder absoluten) Klassenhäufigkeiten darstellen. Die Höhe jedes Rechtecks stellt dann die (relative oder absolute) Häufigkeitsdichte dar, also die (relative oder\nabsolute) Häufigkeit dividiert durch die Breite der entsprechenden Klasse.\n\n:::: {#nte-histogram .callout-note collapse=\"true\"}\n## Histogramm berechnen und visualisieren\n\nAls Beispiel wird die Länge der zahnbildenden Zellen der Meerschweinchen verwendet, die eine Vitamin-C-Dosis von 2 erhielten.\n\n::: {#182193a8 .cell execution_count=9}\n``` {.python .cell-code}\ndose2 = meerschweinchen.loc[meerschweinchen['dose'] == 2, 'len']\nprint(*list(dose2)) # * = Ausgabe ohne Kommata\nprint(\"N\", len(dose2), \"Minimum:\", dose2.min(), \"Maximum:\", dose2.max(), \"Spannweite\", dose2.max() - dose2.min())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n23.6 18.5 33.9 25.5 26.4 32.5 26.7 21.5 23.3 29.5 25.5 26.4 22.4 24.5 24.8 30.9 26.4 27.3 29.4 23.0\nN 20 Minimum: 18.5 Maximum: 33.9 Spannweite 15.399999999999999\n```\n:::\n:::\n\n\nMit der Funktion `np.histogram(a, bins = 10, range = None, density = None)` kann ein Histogramm berechnet werden.\n\n  - `a` sind die zu berechnenden Daten\n  - `bins` spezifiziert die Anzahl an Klassen, standardmäßig werden 10 gewählt.\n  - `range = (float, float)` erlaubt es, die untere und obere Grenze der Klassen festzulegen.\n  - `density = True` erlaubt es statt der absoluten Häufigkeiten, den Wert der Häufigkeitsdichtefunktion darzustellen. Dies berechnet sich wie folgt:\n    - relative Häufigkeit = Anzahl Werte je Klasse / Anzahl aller Werte\n    - Häufigkeitsdichte =  Anzahl Werte je Klasse / (Anzahl aller Werte * Klassenbreite)\n    - Klassenbreite = Maximum(Werte) - Minimum(Werte) / Anzahl Klassen\n  \nFür die überschaubare Anzahl an Werten wird ein Histogramm mit 5 Klassen berechnet. Zum Vergleich wird auch die Häufigkeitsdichte ausgegeben.\n\n::: {#9fdd101b .cell execution_count=10}\n``` {.python .cell-code}\nprint(np.histogram(dose2, bins = 5))\nprint(\"Häufigkeitsdichte:\", np.histogram(dose2, bins = 5, density = True)[0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(array([2, 5, 8, 2, 3]), array([18.5 , 21.58, 24.66, 27.74, 30.82, 33.9 ]))\nHäufigkeitsdichte: [0.03246753 0.08116883 0.12987013 0.03246753 0.0487013 ]\n```\n:::\n:::\n\n\nDie Funktion `np.histogram()` gibt an erster Stelle ein array mit den absoluten Häufigkeiten bzw. der Häufigkeitsdichte jeder Klasse zurück. An zweiter Stelle wird ein array mit den x-Positionen der Klassenrechtecke zurückgegeben - dabei wird für jede Klasse die Position der linken Seite sowie für die letzte Klasse zusätzlich die Position der rechten Seite des Rechtecks ausgegeben. Für 5 Klassen werden also 6 Positionswerte ausgegeben.\n\nDie Klassenbreite kann zum Beispiel mit der Methode `np.diff()` ausgegeben werden.\n\n::: {#a915b8f3 .cell execution_count=11}\n``` {.python .cell-code}\nhist_abs, bin_edges = np.histogram(dose2, bins = 5)\nklassenbreite = np.diff(bin_edges)\nprint(klassenbreite)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[3.08 3.08 3.08 3.08 3.08]\n```\n:::\n:::\n\n\nDurch Multiplikation der Häufigkeitsdichte mit der Klassenbreite können die relativen Häufigkeiten berechnet werden.\n\n::: {#5bd95111 .cell execution_count=12}\n``` {.python .cell-code}\nhist_dichte = np.histogram(dose2, bins = 5, density = True)[0]\nhist_relativ = hist_dichte * klassenbreite\nprint(hist_relativ)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.1  0.25 0.4  0.1  0.15]\n```\n:::\n:::\n\n\nDie Summe der relativen Häufigkeiten ist 1.\n\nEin Histogramm kann mit der Funktion `plt.hist(x, bins = None, *, range = None, density = False)` aufgerufen werden, welche intern `np.histogram()` für die Berechnungen aufruft. Die Parameter der Funktion entsprechenen denen der NumPy-Funktion, wobei mit dem Argument `x` die darzustellenden Daten übergeben werden. Zusätzlich können verschiedene Grafikparameter übergeben werden.\n\nDie Funktion hat 3 Rückgabewerte: die absolute Häufigkeit der Klassen (bzw. wenn `density = True` die Häufigkeitsdichte), die x-Position der Rechtecke und die Objekte für die Grafikerstellung (letztere werden im folgenden Code im Objekt `ignore` gespeichert und nicht weiter verwendet.).\n\n::::: {.panel-tabset}\n## absolute Häufigkeit\n\n::: {#e7897af7 .cell execution_count=13}\n``` {.python .cell-code}\nplt.hist(dose2, bins = 5, edgecolor = 'black')\nplt.title('Länge zahnbildender Zellen bei Meerschweinchen')\n\n# Achsenbeschriftung\nplt.xlabel('Länge der zahnbildenden Zellen (μm)')\nplt.ylabel('absolute Häufigkeit')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-14-output-1.png){fig-alt='Ein Histogramm mit 5 Klassen'}\n:::\n:::\n\n\n## relative Häufigkeit\nEine Darstellung der relativen Häufigkeiten ist nicht direkt möglich.\n\n::: {#0d4e61c4 .cell execution_count=14}\n``` {.python .cell-code}\nhist_dichte, bins, ignore = plt.hist(dose2, bins = 5, density = True, edgecolor = 'black')\nplt.title('Länge zahnbildender Zellen bei Meerschweinchen')\n\n# relative Häufigkeit berechnen\nklassenbreite = np.diff(bins)[0]\nhist_relativ = hist_dichte * klassenbreite\n\n# yticks erzeugen an der Position von min(hist_dichte) bis max(hist_dichte)\n# aber mit Werten von hist_relativ\nplt.yticks(ticks = np.linspace(min(hist_dichte), max(hist_dichte), len(hist_relativ)),\nlabels = np.linspace(hist_relativ.round(2).min(), hist_relativ.round(2).max(), len(hist_relativ)).round(3));\n\n# Achsenbeschriftung\nplt.xlabel('Länge der zahnbildenden Zellen (μm)')\nplt.ylabel('relative Häufigkeit')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-15-output-1.png){fig-alt='Ein Histogramm mit 5 Klassen'}\n:::\n:::\n\n\n## Häufigkeitsdichte\n\n::: {#293cb9de .cell execution_count=15}\n``` {.python .cell-code}\nplt.hist(dose2, bins = 5, density = True, edgecolor = 'black')\nplt.title('Länge zahnbildender Zellen bei Meerschweinchen')\n\n# Achsenbeschriftung\nplt.xlabel('Länge der zahnbildenden Zellen (μm)')\nplt.ylabel('Häufigkeitsdichte')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-16-output-1.png){fig-alt='Ein Histogramm mit 5 Klassen'}\n:::\n:::\n\n\n:::::\n\n&nbsp;\n\nHistogramme sind nicht immer gut geeignet, um die Verteilung einer Stichprobe zu charakterisieren. Der visuelle Eindruck hängt von der gewählten Klassenzahl ab - ein Beispiel:\n\n::::: {.panel-tabset}\n\n## 3 Klassen\n\n::: {#1575f4dd .cell execution_count=16}\n``` {.python .cell-code}\nplt.hist(meerschweinchen['len'], bins = 3, density = True, edgecolor = 'black', alpha = 0.6);\nplt.title('Länge zahnbildender Zellen bei Meerschweinchen')\n\n# Achsenbeschriftung\nplt.xlabel('Länge der zahnbildenden Zellen (μm)')\nplt.ylabel('Häufigkeitsdichte')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-17-output-1.png){fig-alt='Häufigkeitsverteilung der Zahnlänge mit 3 Klassen'}\n:::\n:::\n\n\n## 5 Klassen\n\n::: {#25837d41 .cell execution_count=17}\n``` {.python .cell-code}\nplt.hist(meerschweinchen['len'], bins = 5, density = True, edgecolor = 'black', alpha = 0.6);\nplt.title('Länge zahnbildender Zellen bei Meerschweinchen')\n\n# Achsenbeschriftung\nplt.xlabel('Länge der zahnbildenden Zellen (μm)')\nplt.ylabel('Häufigkeitsdichte')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-18-output-1.png){fig-alt='Häufigkeitsverteilung der Zahnlänge mit 5 Klassen'}\n:::\n:::\n\n\n## 7 Klassen\n\n::: {#b6d2fcaa .cell execution_count=18}\n``` {.python .cell-code}\nplt.hist(meerschweinchen['len'], bins = 7, density = True, edgecolor = 'black', alpha = 0.6);\nplt.title('Länge zahnbildender Zellen bei Meerschweinchen')\n\n# Achsenbeschriftung\nplt.xlabel('Länge der zahnbildenden Zellen (μm)')\nplt.ylabel('Häufigkeitsdichte')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-19-output-1.png){fig-alt='Häufigkeitsverteilung der Zahnlänge mit 7 Klassen'}\n:::\n:::\n\n\n:::::\n::::\n:::\n\n::: {.border}\n\nDie Dichtefunktion der Normalverteilung beschreibt, welcher Anteil der Werte innerhalb eines bestimmten Wertebereichs liegt. Bei der Berechnung der relativen Häufigkeiten in @nte-histogram haben wir gesehen, dass die Summe der relativen Häufigkeiten 1 ist. Dies entspricht der Fläche unterhalb der Dichtekurve.\n\nDie Dichtefunktion der Normalverteilung ist definiert als: \n\n$$\nf(x) = \\frac{1}{\\sigma \\sqrt{2\\pi}} ~ e^{-\\frac{1}{2}\\left(\\frac{x - \\mu}{\\sigma}\\right)^2}\n$$\n\nDie Form der Normalverteilung ergibt sich aus dem Faktor $e^{-\\frac{1}{2}\\left(\\frac{x -\\mu}{\\sigma}\\right)^2}$ der Funktionsgleichung. Das Maximum der Funktion liegt am Punkt $x = \\mu$. Von dort fällt sie symmetrisch ab und nähert sich der x-Achse an. Der Abfall der Funktion erfolgt umso schneller, je kleiner $\\sigma$ ist. Die Wendepunkte der Kurve liegen jeweils eine Standardabweichung vom Mittelwert entfernt.\n\nEine Normalverteilung mit dem Mittelwert $\\mu = 0$ und einer Standardabweichung $\\sigma = 1$ heißt Standardnormalverteilung.\n\n[@Baitsch-2019, S. 51-54]\n\n:::\n\n&nbsp;\n\n## Normalverteilung anpassen\nUm die Verteilung in einem Datensatz durch eine Normalverteilung anzunähern, werden dessen Mittelwert und Standardabweichung in die Funktionsgleichung der Normalverteilung eingesetzt. Mit Python können die Berechnungen direkt vorgenommen werden. In der Handhabung einfacher sind die vom Paket SciPy bereitgestellten Funktionen, die im nächsten Abschnitt ausführlicher vorgestellt werden. Das folgende Beispiel zeigt die Berechnung und Visualisierung mit Python und mit SciPy.\n\n::: {#nte-normalverteilungdarstellen .callout-note collapse=\"true\"}\n## Dichtekurven berechnen und darstellen\n\nBetrachten wir die Verteilungskennwerte der Gruppe der Meerschweinchen, die eine Dosis von 2 Milligramm Vitamin C erhielten.\n\n::: {#1902266f .cell execution_count=19}\n``` {.python .cell-code}\nprint(verteilungskennwerte(dose2), \"\\n\");\n\ndose2_mean = verteilungskennwerte(dose2, output = False)[1]\ndose2_std = verteilungskennwerte(dose2, output = False)[4]\n\nprint(\"Exakter Mittelwert:\", dose2_mean)\nprint(\"Exakte Standardabweichung:\", dose2_std)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nN: 20\narithmetisches Mittel: 26.10\nStichprobenfehler: 0.84\nStichprobenvarianz: 14.24\nStichprobenstandardabweichung: 3.77\nNone \n\nExakter Mittelwert: 26.1\nExakte Standardabweichung: 3.7741503052098744\n```\n:::\n:::\n\n\nWenn wir die Standardabweichung und das arithmetische Mittel in die Normalverteilungsfunktion einsetzen, erhalten wir:\n\n$$\nf(x) = \\frac{1}{3.7742 \\sqrt{2\\pi}} ~ e^{-\\frac{1}{2}\\left(\\frac{x-26.10}{3.7742}\\right)^2}\n$$\n\n$$\nf(x) = 0.1057 \\cdot e^{-\\frac{1}{2}\\left(\\frac{x-26.10}{3.7742}\\right)^2}\n$$\n\nIn Python können die Berechnungen umgesetzt und grafisch dargestellt werden:\n\n::: {#2639b5ed .cell execution_count=20}\n``` {.python .cell-code}\n# Histogram der Häufigkeitsdichte zeichnen\nplt.hist(dose2, bins = 7, density = True, edgecolor = 'black', alpha = 0.6);\nplt.title('Länge zahnbildender Zellen bei Meerschweinchen')\n\n# Achsenbeschriftung\nplt.xlabel('Länge der zahnbildenden Zellen (μm)')\nplt.ylabel('Häufigkeitsdichte')\n\n# Normalverteilung berechnen.\nhist, bin_edges = np.histogram(dose2, bins = 7)\n\nx_values = np.linspace(min(bin_edges), max(bin_edges), 100)\n\n## Normalverteilungsfunktion mit Python berechnen\ny_values =  1 / (dose2_std * np.sqrt(2 * np.pi)) * np.exp(- (x_values - dose2_mean) ** 2 / (2 * dose2_std ** 2))\nplt.plot(x_values, y_values, label = 'Normalverteilung', lw = 4)\n\n## scipy\ny_values_scipy = scipy.stats.norm.pdf(x_values, loc = dose2_mean, scale = dose2_std)\nplt.plot(x_values, y_values_scipy, label = 'SciPy', linestyle = 'dashed')\n\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-21-output-1.png){fig-alt='Histogramm mit 7 Klassen und einer eingezeichneten Normalverteilungskurve mit den Stichprobenparametern.'}\n:::\n:::\n\n\n&nbsp;\n\nDie Verteilung der Länge zahnbildender Zellen bei Meerschweinchen, die eine Dosis von 2 Milligramm Vitamin C erhielten, könnte einer Normalverteilung entsprechen. Aufgrund der geringen Stichprobengröße ist dies aber schwer zu beurteilen.\n\n:::\n\n&nbsp;\n\n## Das Paket SciPy\nFunktionen zur Berechnung von Dichtekurven können über Paket SciPy importiert werden. Das Modul stats (statistical functions) umfasst zahlreiche Funktionen zum Testen von Hypothesen. Funktionen für die Normalverteilung werden wie folgt aufgerufen:\n\n::: {#d2423fd1 .cell execution_count=21}\n``` {.python .cell-code}\nimport scipy\nprint(\"Häufigkeitsdichte der Normalverteilung bei x = 0:\", scipy.stats.norm.pdf(0), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHäufigkeitsdichte der Normalverteilung bei x = 0: 0.3989422804014327 \n\n```\n:::\n:::\n\n\nFür die Normalverteilung sind vier Funktionen relevant:\n\n::: {layout=\"[45, 55]\"}\n\n::: {#269efaa1 .cell execution_count=22}\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-23-output-1.png){fig-alt='Eine Kurve der Häufigkeitsdichte der Normalverteilung mit einer am Punkt x = 0.5 eingezeichneten vertikalen Geraden.'}\n:::\n:::\n\n\n**Beschreibung**  \nDie Funktion `scipy.stats.norm.pdf(x)` berechnet die Dichte der Normalverteilung am Punkt `x` (pdf = probability density function). `x` kann auch ein array sein - so wurde die linksstehende Kurve mit dem Befehl `scipy.stats.norm.pdf(np.linspace(-4, 4, 100))` berechnet.\n\n::: {#602d9eda .cell execution_count=23}\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-24-output-1.png){fig-alt='Eine Kurve der Häufigkeitsdichte der Normalverteilung. Die Fläche unter der Kurve links des Punktes x = 0.5 ist ausgefüllt.'}\n:::\n:::\n\n\n**Beschreibung**  \nDie Funktion `scipy.stats.norm.cdf(x)` berechnet den Anteil der Werte $q$ links von `x` (cdf = cumulative density function).\n\n::: {#944c8239 .cell execution_count=24}\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-25-output-1.png){fig-alt='Eine Kurve der Häufigkeitsdichte der Normalverteilung. Bei x ~ -0.38 ist eine vertikale Linie unter der Kurve eingezeichnet. Die Flächen unter der Kurve links und rechts davon sind unterschiedlich eingefärbt.'}\n:::\n:::\n\n\n**Beschreibung**  \nDie Funktion `scipy.stats.norm.ppf(q)` ist die Quantilfunktion der Normalverteilung und die Umkehrfunktion der kumulativen Häufigkeitsdichtefunktion (cdf). Die Funktion berechnet für $0 \\le q \\le 1$ den Wert `x`, links von dem der Anteil `q` aller Werte liegt und rechts von dem der Anteil `1-q` liegt (ppf = percentile point function).\n\n::: {#246f2782 .cell execution_count=25}\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-26-output-1.png){fig-alt='Grafische Darstellung der Quantilfunktion. Für einen Wert q ist die Position unter der Glockenkurve eingezeichnet. Die Bereiche links und rechts davon sind farblich unterschiedlich gefüllt.'}\n:::\n:::\n\n\n**Beschreibung**  \nDie Funktion `scipy.stats.norm.rvs(size)` zieht `size` Zufallszahlen aus der Normalverteilung.  \n*Hinweis: Die Zufallszahlen werden im Skript dynamisch gezogen.*\n:::\n\nFür die vorgestellten Funktionen kann mit den Parametern `loc = mittelwert` und `scale = standardabweichung` die Form der Normalverteilung angepasst werden. Standardmäßig wird die Standardnormalverteilung mit `loc = 0` und `scale = 1` berechnet. Die Parameter der Funktionen können Einzelwerte (Skalare) oder auch Arrays bzw. Listen sein.\n\n## Aufgaben Normalverteilung\nMöglicherweise haben Sie schon einmal von Mensa International gehört, einer Vereinigung für Hochbegabte. Wer Mitglied in dieser Vereinigung werden möchte, soll einen höheren Intelligenzquotienten (IQ) haben als 98 % der Bevölkerung seines:ihres Herkunftslandes ([Wikipedia](https://de.wikipedia.org/wiki/Mensa_International)). \n\n1. Wenn der durchschnittliche IQ 100 und die Standardabweichung 15 beträgt, welchen IQ müssten Sie haben, um bei Mensa International aufgenommen zu werden?\n\n2. Mensa International ist nicht die einzige Organisation ihrer Art. Andere Organisationen haben sogar noch strengere Kriterien. Welcher IQ wird benötigt, um hier Mitglied zu werden?\n\n  - Intertel (Kriterium: IQ aus dem höchsten 1 %)\n  - Triple Nine Society (Kriterium: IQ aus dem höchsten 0,1 %)\n  - Prometheus Society (Kriterium: IQ aus dem höchsten 0,003 %)\n\n3. Der IQ ist nicht mit angeborener Intelligenz gleichzusetzen und auch abhängig davon, wie viel Gelegenheit man zum Gehirntraining hatte, etwa durch den Schulbesuch. Der niedrigste durchschnittliche IQ wurde mit 71 [im Land Niger](https://www.laenderdaten.info/iq-nach-laendern.php) gemessen. Angenommen Sie hätten einen IQ von 100. Würden Sie in Niger das Kriterium der Mensa International erfüllen?\n\n::: {.callout-tip collapse=\"true\"}\n## Musterlösung Normalverteilung\nAufgabe 1: Einen IQ von mehr als ...\n\n::: {#31c59b55 .cell execution_count=26}\n``` {.python .cell-code}\nprint(scipy.stats.norm.ppf(loc = 100, scale = 15, q = 0.98))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n130.80623365947733\n```\n:::\n:::\n\n\nAufgabe 2: \nSie benötigen einen IQ von mindestens...\n\n::: {#83de922f .cell execution_count=27}\n``` {.python .cell-code}\nprint(scipy.stats.norm.ppf(loc = 100, scale = 15, q = 0.99))\nprint(scipy.stats.norm.ppf(loc = 100, scale = 15, q = 0.999))\nprint(scipy.stats.norm.ppf(loc = 100, scale = 15, q = 1 - (0.003 / 100)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n134.8952181106126\n146.3534845925172\n160.19216216677682\n```\n:::\n:::\n\n\nAufgabe 3: Nicht ganz.\n\n::: {#0d1a6285 .cell execution_count=28}\n``` {.python .cell-code}\nprint(scipy.stats.norm.cdf(loc = 71, scale = 15, x = 100))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.9734024259789904\n```\n:::\n:::\n\n\n:::\n\nÜbrigens: Wie [der Spiegel berichtet](https://www.spiegel.de/lebenundlernen/intelligenz-von-studenten-neugier-schlaegt-iq-a-816084.html), schneiden Studierende mit mittelmäßigem Intelligenzquotienten ebenso erfolgreich ab wie Hochbegabte, vorausgesetzt sie sind neugierig genug und arbeiten gewissenhaft.\n\n## Konfidenzintervalle\nDie schließende Statistik beruht auf dem Prinzip, von Stichprobenwerten auf den tatsächlichen Wert in der Grundgesamtheit zu schließen. Die Überlegung ist wie folgt:\n\n1. Wenn eine Stichprobe aus einer Grundgesamtheit gezogen wird, dann streuen die Stichprobenwerte normalverteilt um den Mittelwert der Grundgesamtheit. Bei einer Normalverteilung liegen \n\n    - 68,27 % aller Werte im Intervall $\\pm 1 ~ s$,\n    - 95,45 % aller Werte im Intervall $\\pm 2 ~ s$ und\n    - 99,73 % aller Werte im Intervall $\\pm 3 ~ s$.\n\n2. Mit der gleichen Wahrscheinlichkeitsverteilung liegt der unbekannte Mittelwert der Grundgesamtheit um einen zufälligen Wert aus der Stichprobe.\n\n3. Der Erwartungswert kann mit einer gewissen Wahrscheinlichkeit aus dem Standardfehler des Mittelwerts einer Stichprobe geschätzt werden. Man wählt dazu ein Konfidenzniveau, also eine Vertrauenswahrscheinlichkeit, dass der Erwartungswert tatsächlich im Bereich der Schätzung liegt. Der umgekehrte Fall, dass der Erwartungswert nicht im Bereich der Schätzung liegt, wird Signifikanz- oder Alphaniveau genannt und mit dem griechischen Buchstaben $\\alpha$ (alpha) gekennzeichnet. $\\alpha$ liegt im Bereich 0 - 1, das Konfidenzniveau ist $1 - \\alpha$ (siehe: [Fehler 1. und 2. Art](https://de.wikipedia.org/wiki/Fehler_1._und_2._Art)).\n\n    - der Erwartungswert liegt in 68,27 % aller Fälle im Intervall $\\pm 1 ~ \\frac{s}{\\sqrt{n}}$,\n    - der Erwartungswert liegt in 95,45 % aller Fälle im Intervall $\\pm 2 ~ \\frac{s}{\\sqrt{n}}$ und\n    - der Erwartungswert liegt in 99,73 % aller Fälle im Intervall $\\pm 3 ~ \\frac{s}{\\sqrt{n}}$.\n\nHäufig wird das Alphaniveau $\\alpha = 0.05$ bzw. das Konfidenzintervall 95 % gewählt, was $\\pm 1.96 ~ \\frac{s}{\\sqrt{n}}$ entspricht. Dies gilt aber nur für große Stichproben. Für kleine Stichprobengrößen folgen die Stichprobenmittelwerte der t-Verteilung, die im nächsten Abschnitt vorgestellt wird.\n\n**to do Maik: hier könnte / müsste man noch einseitige und zweiseitige Hypothesentests und den Begriff \"Alpha-Halbe\" einführen. Das ließe sich auch gut grafisch mit nur nach rechts gehenden und beidseitigen Pfeilen darstellen.**\n\nIm folgenden Beispiel wird die Idee, dass mit einer gewissen  Wahrscheinlichkeit vom Stichprobenmittelwert auf den Mittelwert der Grundgesamtheit (Erwartungswert) geschlossen werden kann, noch einmal grafisch dargestellt.\n\n::: {#nte-statistik .callout-note collapse=\"true\"}\n## Prinzip der schließenden Statistik\n\n:::: {.panel-tabset}\n## Standardnormalverteilung\nIn einer Normalverteilung kommen Werte in der Nähe des Erwartungswerts häufiger vor als weit vom Erwartungswert entfernt liegende Werte. Wie häufig oder selten ein Wert relativ zum Mittelwert der Verteilung vorkommt, kann mit der Standardabweichung ausgedrückt werden.\n\nIn der Grafik sehen Sie zufällig gezogene Werte und eine Normalverteilungskurve.\n\n::: {#6c1f9ad0 .cell execution_count=29}\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-30-output-1.png){fig-alt='Dargestellt ist ein Histgramm mit 30 Klassen. Auf der x-Achse sind die Einheiten der Standardabweichung von -3 bis +3 abgetragen, auf der y-Achse die Häufigkeitsdichte. Zusätzlich sind der Stichprobenmittelwert 0 durch einer vertikale Linie und die ganzzahligen Einheiten der Standardabweichugn durch gestrichelte vertikale Linien eingezeichnet. Über dem Histogramm liegt die Kurve der Standardnormalverteilung. Mit horizontalen Pfeilen sind die Entfernungen zwischen den Standardabweichungen plus/minus 1, 2 und 3 markiert und der Anteil der dazwischen liegenden Werte annotiert (68,27 %, 95,45 %, 99,73 %).'}\n:::\n:::\n\n\n## Einzelner Messwert\nEin einzelner Messwert aus der Verteilung entspricht so gut wie nie dem Erwartungswert. Man weiß aber, dass ein Wert nahe des Erwartungswerts häufiger vorkommt, als ein weit entfernter.\n\n::: {#64fa012a .cell execution_count=30}\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-31-output-1.png){fig-alt='Aufbauend auf der vorherigen Grafik ist ein einzelner Messerwert bei s = -1.25 eingezeichnet, um den eine Normalverteilungskurve eingezeichnet ist.'}\n:::\n:::\n\n\n## Stichprobe N = 12\nDer Mittelwert einer Stichprobe entspricht ebenfalls so gut wie nie dem Erwartungswert. Der zu erwartende, in Einheiten des Standardfehlers des Mittelwerts ausgedrückte Streuungsbereich ist jedoch erheblich schmaler als der eines einzelnen Messwerts. Dies ist auch grafisch gut zu sehen. Die Dichtekurve ist erheblich schmaler und höher als die Normalverteilungskurve eines einzelnen Messwerts. Dies liegt an der geringen Standardabweichung in der Stichprobe von ~ 0.2, was die Kurve staucht.\n\n::: {#b8021524 .cell execution_count=31}\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-32-output-1.png){fig-alt='Aufbauend auf der ersten Grafik ist ein zufällig erzeugter Stichprobenmittelwert eingezeichnet, um den eine Normalverteilungskurve mit sigma = stichprobenfehler eingezeichnet ist.'}\n:::\n:::\n\n\n## Code\nCode für das Panel Stichprobe N = 12\n\n::: {#6a358e41 .cell execution_count=32}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy\n\n# Parameter der Standardnormalverteilung\nmu, sigma = 0, 1  # Mittelwert und Standardabweichung\n\n# Daten generieren\nseed = 4\nnp.random.seed(seed = seed)\ndata = np.random.default_rng().normal(mu, sigma, 1000)\n\n# Grafik\nplt.figure(figsize = (8.5, 6))\n\n# Histogramm plotten\narray, bins, patches = plt.hist(data, bins = 30, density = True, alpha = 0.6, color = 'lightgoldenrodyellow', edgecolor='black')\n\n# Mittelwert einzeichnen\nmean_line = plt.axvline(mu, color = 'steelblue', linestyle = 'solid', linewidth = 3)\n\n# positive und negative Standardabweichungen einzeichnen\npos_std_lines = [plt.axvline(mu + i * sigma, color = 'steelblue', linestyle = 'dotted', linewidth = 2) for i in range(1, 4)]\nneg_std_lines = [plt.axvline(mu - i * sigma, color = 'steelblue', linestyle = 'dotted', linewidth = 2) for i in range(1, 4)]\n\n# Normalverteilungskurve\nx_values = np.linspace(min(bins), max(bins), 100)\ny_values = 1 / (sigma * np.sqrt(2 * np.pi)) * np.exp(- (x_values - mu) ** 2 / (2 * sigma ** 2))\nnormal_dist_curve = plt.plot(x_values, y_values, color = 'steelblue', linestyle = 'solid', linewidth = 2)\n\n# Stichprobe\nN = 12\nnp.random.seed(seed = 4)\nstichprobe = np.random.default_rng().normal(mu, sigma, N)\n\nstichprobenstandardabweichung = stichprobe.std(ddof = 1)\nstichprobenmittelwert = stichprobe.mean()\nstandardfehler =  stichprobenstandardabweichung / np.sqrt(len(stichprobe))\n\n# Histogramm berechnen\n# hist, bins = np.histogram(stichprobe, bins = 30, density = True)\n\n# Standardfehlerkurve Stichprobe\n# x_values = np.linspace(min(bins), max(bins), 100)\nx = np.linspace(stichprobenmittelwert - 4 * stichprobenstandardabweichung, stichprobenmittelwert + 4 * stichprobenstandardabweichung, 100)\ny_values = scipy.stats.t.pdf(x = x_values, df = N - 1, loc = stichprobenmittelwert, scale = standardfehler) # t-Verteilung\n\n# Stichprobenmittelwert einzeichnen\nmean_stichprobe = plt.axvline(stichprobenmittelwert, color = 'black', linestyle = 'solid', linewidth = 2)\n\n# Verteilungskurve einzeichnen\nstichprobe_dist_curve = plt.plot(x_values, y_values, color = 'black', linestyle = 'solid', linewidth = 2)\n\n# Legende\nplt.legend([normal_dist_curve[0], mean_line, neg_std_lines[0], mean_stichprobe, stichprobe_dist_curve[0]],\n           ['Standardnormalverteilung', 'Mittelwert', 'Standardabweichung', 'Stichprobenmittelwert', 't-Verteilung'],\n           loc='upper right', handlelength = 3)\n\nplt.title('Standardnormalverteilung')\nplt.xlabel('Standardabweichung')\nplt.ylabel('Häufigkeitsdichte')\n\nplt.show()\n```\n:::\n\n\n::::\n:::\n\n&nbsp;\n\n## Die t-Verteilung\nDie t-Verteilung wurde von William Sealy Gosset entdeckt (wenngleich nicht als erstem) und popularisiert. Die Verteilung ist auch als Student'sche Verteilung bekannt: Da Gossets Arbeitgeber, die Guiness-Brauerei, die Veröffentlichung der Entdeckung nicht gestattete, publizierte Gosset unter dem Synonym Student. ([Wikipedia](https://de.wikipedia.org/wiki/Studentsche_t-Verteilung))\n\nDie t-Verteilung beschreibt die Verteilung von Stichprobenmittelwerten mit unbekannter Varianz in der Grundgesamtheit, deren Standardfehler mit der Stichprobenstandardabweichung geschätzt wird. Die t-Verteilung hat gegenüber der Normalverteilung die [Anzahl der Freiheitsgrade](https://de.wikipedia.org/wiki/Anzahl_der_Freiheitsgrade_(Statistik)) als zusätzlichen Parameter\n\n::: {#imp-freiheitsgrad .callout-important collapse=\"false\"}\n## Anzahl Freiheitsgrade\n\n\"Die Anzahl unabhängiger Information, die in die Schätzung eines Parameters einfließen, wird als Anzahl der Freiheitsgrade bezeichnet. Im Allgemeinen sind die Freiheitsgrade einer Schätzung eines Parameters gleich der Anzahl unabhängiger Einzelinformationen, die in die Schätzung einfließen, abzüglich der Anzahl der zu schätzenden Parameter, die als Zwischenschritte bei der Schätzung des Parameters selbst verwendet werden. Beispielsweise fließen $n$ Werte in die Berechnung der Stichprobenvarianz ein. Dennoch lautet die Anzahl der Freiheitsgrade $n − 1$, da als Zwischenschritt der Mittelwert geschätzt wird und somit ein Freiheitsgrad verloren geht.\"\n\nAnzahl der Freiheitsgrade (Statistik). von verschiedenen [Autor:innen](https://xtools.wmcloud.org/authorship/de.wikipedia.org/Anzahl_der_Freiheitsgrade_(Statistik)?uselang=de) steht unter der Lizenz [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/deed.de) ist abrufbar auf [Wikipedia](<https://de.wikipedia.org/wiki/Anzahl_der_Freiheitsgrade_(Statistik)>). 2025\n:::\n\nDie allgemeine Häufigkeitsdichtefunktion der t-Verteilung lautet:\n\n$$\nf(x) = \\frac{\\Gamma\\left(\\frac{\\nu + 1}{2}\\right)}{\\sqrt{\\nu \\pi} , \\Gamma\\left(\\frac{\\nu}{2}\\right)} \\left(1 + \\frac{x^2}{\\nu}\\right)^{-\\frac{\\nu + 1}{2}}\n$$\n\n  - $\\nu$ (ny) ist die Anzahl der Freiheitsgrade.\n  - $\\Gamma$ ist die [Gammafunktion](https://de.wikipedia.org/wiki/Gammafunktion), die für ganzzahlige Argumente $n$ den Wert $\\Gamma(n) = (n-1)!$ hat.\n\nDa für die Berechnung des Stichprobenmittelwerts die Anzahl der Freiheitsgrade $n - 1$ ist, kann auch geschrieben werden:\n$$\nf(x) = \\frac{\\Gamma\\left(\\frac{n}{2}\\right)}{\\sqrt{(n-1) \\pi} , \\Gamma\\left(\\frac{n-1}{2}\\right)} \\left(1 + \\frac{x^2}{n-1}\\right)^{-\\frac{n}{2}}\n$$\n\n  - $n$ ist die Stichprobengröße.\n\nDas Modul scipy.stats stellt Funktionen zur Berechnung der t-Verteilung bereit.\n\n  - `scipy.stats.t.pdf(x, df, loc=0, scale=1)` berechnet die Häufigkeitsdichte für die Werte `x` für eine t-Verteilung mit `df` Freiheitsgraden, Mittelwert `loc` und Standardabweichung `scale` (pdf = probability density function).\n  - `scipy.stats.t.cdf(x, df, loc=0, scale=1)` berechnet den Anteil der Werte links von `x` (cdf = cumulative density function). \n  - `scipy.stats.t.ppf(q, df, loc=0, scale=1)` ist die Quantilfunktion der t-Verteilung (ppf = percentile point function).\n  - `scipy.stats.t.rvs(df, loc=0, scale=1, size=1)` zieht `size` Zufallzahlen aus der t-Verteilung.\n\nDie Parameter der Funktionen können Einzelwerte (Skalare) oder auch Arrays bzw. Listen sein.\n\nMit zunehmender Stichprobengröße nähert sich die t-Verteilung der Normalverteilung an. Als Faustformel gilt $n > 30$. Untenstehende Grafik zeigt die Annäherung der t-Verteilung an die Normalverteilung.\n\n::: {.panel-tabset}\n\n## Grafik\n\n::: {#9ea4393e .cell execution_count=33}\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-34-output-1.png){fig-alt='Dargestellt sind Häufigkeitsdichtekurven der Normalverteilung und der t-Verteilung mit verschiedenen Freiheitsgraden.'}\n:::\n:::\n\n\n## Code\n\n::: {#e3da6064 .cell execution_count=34}\n``` {.python .cell-code}\nx_values = np.linspace(-4, 4, 100)\n\n# Normalverteilung\ny_values = scipy.stats.norm.pdf(x_values)\nplt.plot(x_values, y_values, color = 'black', lw = 3, label = 'Normalverteilung')\n# plt.ylim(bottom = 0, top = 0.5)\n\n# t-Verteilungen\nmarker = [\".\", \"1\", \"x\"]\n\n[plt.plot(x_values, scipy.stats.t.pdf(x_values, df = (i + (i - 1) * 2)), linestyle = 'dotted', marker = marker[i - 1] , linewidth = 2, alpha = 0.6, label = 'df = ' + str((i + (i - 1) * 2))) for i in range(1, 4)]\n\nplt.suptitle('Das Argument df der t-Verteilung')\nplt.xlabel('Standardabweichung')\nplt.ylabel('Häufigkeitsdichte')\nplt.legend(loc = 'upper left')\nplt.show()\n```\n:::\n\n\n:::\n\nDas Maximum der t-Verteilung ist weniger dicht, dafür sind die Ränder der Verteilung dichter als die Normalverteilung.\n\nSomit gilt für die t-Verteilung von Stichprobenmittelwerten:\n\n$$\n\\bar{x} \\pm t_{n-1} \\cdot \\frac{s}{\\sqrt{n}}\n$$\n\n  - $t$ ist der Rückgabewert der Funktion `scipy.stats.t.ppf(q, df = n - 1, loc = 0, scale = 1)`\n  - q ist das gewählte Alphaniveau bzw. für einen zweiseitigen Hypothesentest $\\frac{\\alpha}{2}$ und $1 - \\frac{\\alpha}{2}$.\n  - Das Ergebnis ist der Rückgabewert der Funktionen:\n    - `scipy.stats.t.ppf(q = alpha/2, df = n - 1, loc = stichprobenmittelwert, scale = stichprobenstandardfehler)`\n    - `scipy.stats.t.ppf(q = 1 - alpha/2, df = n - 1, loc = stichprobenmittelwert, scale = stichprobenstandardfehler)`\n\n::: {#tip-t .callout-tip collapse=\"false\"}\n## t-Verteilung oder Normalverteilung?\n\nAm Computer ist die t-Verteilung genauso leicht (oder schwer) zu berechnen wie die Normalverteilung. Da die t-Verteilung bessere Schätzwerte für kleine Stichproben liefert und sich für größere Stichprobengrößen ohnehin der Normalverteilung annähert, empfiehlt es sich, stets die t-Verteilung zu verwenden.\n\n:::\n\n### Beispiel Gewicht weiblicher Pinguine\nDie t-Verteilung des geschätzten Stichprobenmittelwerts für kleine Stichproben wird für im Jahr 2008 beobachtete weibliche Pinguine dargestellt.\n\n::: {#2d0f7267 .cell execution_count=35}\n``` {.python .cell-code}\nprint(penguins.groupby(by = [penguins['species'], penguins['sex'], penguins['year']]).size())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nspecies    sex     year\nAdelie     female  2007    22\n                   2008    25\n                   2009    26\n           male    2007    22\n                   2008    25\n                   2009    26\nChinstrap  female  2007    13\n                   2008     9\n                   2009    12\n           male    2007    13\n                   2008     9\n                   2009    12\nGentoo     female  2007    16\n                   2008    22\n                   2009    20\n           male    2007    17\n                   2008    23\n                   2009    21\ndtype: int64\n```\n:::\n:::\n\n\n::: {.panel-tabset}\n\n## Grafik\n\n::: {#1335ffe7 .cell execution_count=36}\n\n::: {.cell-output .cell-output-display}\n![](normalverteilung_files/figure-html/cell-37-output-1.png){fig-alt='Dargestellt sind drei Histogramme für die Pinguinarten Adelie, Chinstrap und Gentoo für im Jahr 2008 beobachtete weibliche Tiere. Auf der x-Achse ist das Gewicht in Gramm und auf der y-Achse die Häufigkeitsdichte abgetragen. Auf jedes Histogramm ist die t-Verteilung des Stichprobenmittelwerts eingezeichnet.'}\n:::\n:::\n\n\n## Code\n\n::: {#bfff623e .cell execution_count=37}\n``` {.python .cell-code}\nyear = 2008\nsex = 'female'\nspecies = 'Adelie'\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize = (7.5, 6), sharey = True, layout = 'tight')\nplt.suptitle('Gewichtsverteilung von weiblichen Pinguinen im Jahr 2008')\n\n# Adelie\ndata = penguins['body_mass_g'][(penguins['species'] == species) & (penguins['sex'] == sex) & (penguins['year'] == year)]\nstichprobengröße = data.size\n\n## Histogramm\nax1.hist(data, alpha = 0.6, edgecolor = 'lightgrey', color = 'C0', density = True)\nax1.set_xlabel('Gewicht in Gramm')\nax1.set_ylabel('Häufigkeitsdichte')\nax1.set_title(label = str(species) + \" N = \" + str(stichprobengröße))\n\n## t-Verteilung des Stichprobenmittelwerts\nstichprobenmittelwert = data.mean()\nstichprobenstandardabweichung = data.std(ddof = 1)\nstandardfehler = stichprobenstandardabweichung / np.sqrt(stichprobengröße)\nhist, bin_edges = np.histogram(data)\nx_values = np.linspace(min(bin_edges), max(bin_edges), 100)\ny_values = scipy.stats.t.pdf(x_values, loc = stichprobenmittelwert, scale = standardfehler, df = stichprobengröße - 1)\n\nax1.plot(x_values, y_values, color = 'black', linewidth = 1, label = 't-Verteilung')\nax1.legend(loc = 'upper left')\n\n# Chinstrap\nspecies = 'Chinstrap'\n\ndata = penguins['body_mass_g'][(penguins['species'] == species) & (penguins['sex'] == sex) & (penguins['year'] == year)]\nstichprobengröße = data.size\n\n## Histogramm\nax2.hist(data, alpha = 0.6, edgecolor = 'lightgrey', color = 'C1', density = True)\nax2.set_xlabel('Gewicht in Gramm')\nax2.set_title(label = str(species) + \" N = \" + str(stichprobengröße))\n\n## t-Verteilung des Stichprobenmittelwerts\nstichprobenmittelwert = data.mean()\nstichprobenstandardabweichung = data.std(ddof = 1)\nstandardfehler = stichprobenstandardabweichung / np.sqrt(stichprobengröße)\nhist, bin_edges = np.histogram(data)\nx_values = np.linspace(min(bin_edges), max(bin_edges), 100)\ny_values = scipy.stats.t.pdf(x_values, loc = stichprobenmittelwert, scale = standardfehler, df = stichprobengröße - 1)\n\nax2.plot(x_values, y_values, color = 'black', linewidth = 1)\n\n# Gentoo\nspecies = 'Gentoo'\n\ndata = penguins['body_mass_g'][(penguins['species'] == species) & (penguins['sex'] == sex) & (penguins['year'] == year)]\nstichprobengröße = data.size\n\n## Histogramm\nax3.hist(data, alpha = 0.6, edgecolor = 'lightgrey', color = 'C2', density = True)\nax3.set_xlabel('Gewicht in Gramm')\nax3.set_title(label = str(species) + \" N = \" + str(stichprobengröße))\n\n## t-Verteilung des Stichprobenmittelwerts\nstichprobenmittelwert = data.mean()\nstichprobenstandardabweichung = data.std(ddof = 1)\nstandardfehler = stichprobenstandardabweichung / np.sqrt(stichprobengröße)\nhist, bin_edges = np.histogram(data)\nx_values = np.linspace(min(bin_edges), max(bin_edges), 100)\ny_values = scipy.stats.t.pdf(x_values, loc = stichprobenmittelwert, scale = standardfehler, df = stichprobengröße - 1)\n\nax3.plot(x_values, y_values, color = 'black', linewidth = 1)\n\nplt.show()\n```\n:::\n\n\n:::\n\n\n## Aufgabe Konfidenzintervalle\n1. Schätzen Sie das Gewicht für im Jahr 2008 beobachtete weibliche Pinguine der Spezies Adelie, Chinstrap und Gentoo.\n\n2. Welches Konfidenzintervall können Sie für die Mittelwerte angeben, wenn eine Vertrauenswahrscheinlichkeit von 90 % gelten soll?\n\n::: {#tip-pinguinaufgabe .callout-tip collapse=\"true\"}\n## Tipp und Musterlösung\n\nFolgende Schritte helfen Ihnen bei der Lösung:\n\n1. Bestimmen Sie den Stichprobenmittelwert $\\bar{x}$.\n2. Bestimmen Sie die Stichprobenstandardabweichung $s$, die Stichprobengröße $N$ und den Standardfehler $\\frac{s}{\\sqrt{N}}$.\n3. Bestimmen Sie die z- oder t-Werte der Normal- bzw. t-Verteilung für das gewählte Konfidenzniveau - für einen zweiseitigen Hypothesentest $\\frac{\\alpha}{2}$ und $1 - \\frac{\\alpha}{2}$\n4. Berechnen Sie das Konfidenzintervall $\\bar{x} \\pm t_{\\alpha / 2} ~ \\frac{s}{\\sqrt{n}}$.\n\n:::: {.callout-tip collapse=\"true\"}\n## Musterlösung\n\nAlphaniveau definieren und Pinguine auswählen\n\n::: {#cd62d695 .cell execution_count=38}\n``` {.python .cell-code}\nalpha = 1 - 0.9\ndata = penguins[(penguins['sex'] == sex) & (penguins['year'] == year)]\n```\n:::\n\n\n1. Stichprobenmittelwerte bestimmen.\n\n::: {#88bc0bda .cell execution_count=39}\n``` {.python .cell-code}\npenguin_means = data['body_mass_g'].groupby(by = data['species']).mean()\nprint(penguin_means)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nspecies\nAdelie       3386.000000\nChinstrap    3472.222222\nGentoo       4627.272727\nName: body_mass_g, dtype: float64\n```\n:::\n:::\n\n\n2. Stichprobenstandardabweichung, Stichprobengröße und Standardfehler bestimmen.\n\n::: {#3a829da4 .cell execution_count=40}\n``` {.python .cell-code}\npenguin_stds = data['body_mass_g'].groupby(by = data['species']).std(ddof = 1)\npenguin_sizes = data['body_mass_g'].groupby(by = data['species']).size()\npenguin_stderrors = penguin_stds / np.sqrt(penguin_sizes)\n\nprint(\"Stichprobenstandardabweichungen:\\n\", penguin_stds)\nprint(\"\\nStichprobengrößen:\\n\", penguin_sizes)\nprint(\"\\nStandardfehler:\\n\", penguin_stderrors)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStichprobenstandardabweichungen:\n species\nAdelie       288.862712\nChinstrap    370.903551\nGentoo       339.722321\nName: body_mass_g, dtype: float64\n\nStichprobengrößen:\n species\nAdelie       25\nChinstrap     9\nGentoo       22\nName: body_mass_g, dtype: int64\n\nStandardfehler:\n species\nAdelie        57.772542\nChinstrap    123.634517\nGentoo        72.429042\nName: body_mass_g, dtype: float64\n```\n:::\n:::\n\n\n3. t-Werte bestimmen\n\n::: {#d5d03960 .cell execution_count=41}\n``` {.python .cell-code}\nt_unten = scipy.stats.t.ppf(alpha / 2, loc = 0, scale = 1, df = penguin_sizes - 1)\nprint(\"t-Wert untere Intervallgrenze:\", t_unten)\n\nt_oben = scipy.stats.t.ppf(1 - alpha / 2, loc = 0, scale = 1, df = penguin_sizes - 1)\nprint(\"t-Wert obere Intervallgrenze:\", t_oben)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nt-Wert untere Intervallgrenze: [-1.71088208 -1.85954804 -1.7207429 ]\nt-Wert obere Intervallgrenze: [1.71088208 1.85954804 1.7207429 ]\n```\n:::\n:::\n\n\n4. Konfidenzintervall bestimmen\n\n::: {#02372c65 .cell execution_count=42}\n``` {.python .cell-code}\n# mit scipy.stats.t.ppf\nuntere_intervalle = scipy.stats.t.ppf(alpha / 2, loc = penguin_means, scale = penguin_stderrors, df = penguin_sizes - 1)\nprint(\"untere Intervallgrenzen:\", untere_intervalle)\n\nobere_intervalle = scipy.stats.t.ppf(1 - alpha / 2, loc = penguin_means, scale = penguin_stderrors, df = penguin_sizes - 1)\nprint(\"obere Intervallgrenzen:\", obere_intervalle)\n\nprint(\"\\n'manuelle' Berechnung:\\n\")\n# 'manuell'\nprint(penguin_means + t_unten * penguin_stderrors)\nprint(penguin_means + t_oben * penguin_stderrors)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nuntere Intervallgrenzen: [3287.15799233 3242.31789851 4502.64096694]\nobere Intervallgrenzen: [3484.84200767 3702.12654593 4751.90448761]\n\n'manuelle' Berechnung:\n\nspecies\nAdelie       3287.157992\nChinstrap    3242.317899\nGentoo       4502.640967\nName: body_mass_g, dtype: float64\nspecies\nAdelie       3484.842008\nChinstrap    3702.126546\nGentoo       4751.904488\nName: body_mass_g, dtype: float64\n```\n:::\n:::\n\n\n::::\n:::\n\n",
    "supporting": [
      "normalverteilung_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}