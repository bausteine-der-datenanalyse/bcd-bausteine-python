{
  "hash": "bbcacfaa297c62de82a12e3285464f0b",
  "result": {
    "engine": "jupyter",
    "markdown": "# Beispiel Eis kochen\nIn diesem Kapitel werden die praktischen Herausforderungen bei der Auswertung von Messdaten demonstriert.\n\n\n\n## Versuchsaufbau\n![Versuchsaufbau Eis kochen](00-bilder/versuchsaufbau-eis-kochen.png){fig-alt=\"Auf einem Küchenherd wird ein Topf mit Eiswasser zum Kochen gebracht. Mit einer Wäscheklammer sind zwei Thermoelemente eines Widerstandsthermometers fixiert. Ein angeschlossener Laptop zeichnet die Daten auf.\"}\n\nIn einem thermodynamischen Feldlabor wurde ein induktives Heizelement benutzt, um Eiswasser in einem metallischen Flüssigkeitsbehälter mit hoher Wärmeleitfähigkeit zum Sieden zu bringen. Mit einer nichtleitenden Halterung wurden zwei Thermoelemente eines Widerstandsthermometers fixiert. Ein TCTempX16 zeichnete die Daten auf, die mit einem Gerät zur automatisierten Datenverarbeitung ausgelesen wurden.\n\n## Datei einlesen\nDie Messreihe ist in der Datei '01-daten/Eis_Messung_1.xlsx' im Tabellenblatt 'T15949 MultiChannel - Daten' gespeichert.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\neis = pd.read_excel(io = '01-daten/Eis_Messung_1.xlsx', sheet_name = 'T15949 MultiChannel - Daten')\n\nprint(eis.head(n = 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           Gerätename:           Unnamed: 1  \\\n0  Gerätebeschreibung:                  NaN   \n1       Serien-Nummer:                  NaN   \n2           Geräte-ID:                  NaN   \n3                  NaN                  NaN   \n4                  NaN                  NaN   \n5                Datum                 Zeit   \n6  2025-09-25 16:12:00  2025-09-25 16:12:00   \n7  2025-09-25 16:12:01  2025-09-25 16:12:01   \n8  2025-09-25 16:12:02  2025-09-25 16:12:02   \n9  2025-09-25 16:12:03  2025-09-25 16:12:03   \n\n                                       TCTempX16  \\\n0  16-Kanal Thermoelement Temperatur-Datenlogger   \n1                                         T15949   \n2                                   MultiChannel   \n3                                            NaN   \n4                                        Kanal 2   \n5                           Thermoelement 1 (°C)   \n6                                              1   \n7                                              1   \n8                                              1   \n9                                              1   \n\n                                     TCTempX16.1  \n0  16-Kanal Thermoelement Temperatur-Datenlogger  \n1                                         T15949  \n2                                   MultiChannel  \n3                                            NaN  \n4                                        Kanal 4  \n5                           Thermoelement 2 (°C)  \n6                                            0.5  \n7                                            0.5  \n8                                            0.5  \n9                                            0.5  \n```\n:::\n:::\n\n\nDas Einlesen und Bereinigen der Daten finden Sie in dem folgenden Beispiel.\n\n::: {#nte-eis .callout-note collapse=\"true\"}\n## Datensatz einlesen & bereinigen\n\nIm Kopf des Tabellenblatts stehen Metadaten der Messung. Es gibt vier Spalten mit Daten: Datum und Zeit sowie die Messreihen der beiden Thermoelemente.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\neis = pd.read_excel(io = '01-daten/Eis_Messung_1.xlsx', sheet_name = 'T15949 MultiChannel - Daten', skiprows = 6)\nprint(eis.info())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 565 entries, 0 to 564\nData columns (total 4 columns):\n #   Column                Non-Null Count  Dtype         \n---  ------                --------------  -----         \n 0   Datum                 565 non-null    datetime64[ns]\n 1   Zeit                  565 non-null    datetime64[ns]\n 2   Thermoelement 1 (°C)  565 non-null    float64       \n 3   Thermoelement 2 (°C)  565 non-null    float64       \ndtypes: datetime64[ns](2), float64(2)\nmemory usage: 17.8 KB\nNone\n```\n:::\n:::\n\n\nDie Daten wurden korrekt eingelesen. Mit der Methode `pd.describe()` wird der Wertebereich der Spalten überprüft, um numerisch kodierte fehlende oder fehlerhafte Werte zu identifizieren.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nprint(eis.describe())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                               Datum                           Zeit  \\\ncount                            565                            565   \nmean   2025-09-25 16:16:47.024778752  2025-09-25 16:16:47.024778752   \nmin              2025-09-25 16:12:00            2025-09-25 16:12:00   \n25%              2025-09-25 16:14:25            2025-09-25 16:14:25   \n50%              2025-09-25 16:16:47            2025-09-25 16:16:47   \n75%              2025-09-25 16:19:09            2025-09-25 16:19:09   \nmax              2025-09-25 16:21:32            2025-09-25 16:21:32   \nstd                              NaN                            NaN   \n\n       Thermoelement 1 (°C)  Thermoelement 2 (°C)  \ncount            565.000000            565.000000  \nmean              53.581239             55.451858  \nmin              -11.000000             -4.100000  \n25%               14.900000             20.300000  \n50%               56.200000             58.300000  \n75%               90.300000             91.200000  \nmax              149.800000            139.200000  \nstd               36.886184             36.542679  \n```\n:::\n:::\n\n\nDie Spalten Datum und Zeit enthalten die selben Informationen. Eine der beiden Spalten kann deshalb entfernt werden. Die Temperaturmessungen sollten näher betrachtet werden. Eishaltiges Wasser, das zum Kochen gebracht wird, sollte sich in einem Temperaturbereich von 0 bis 100 °C bewegen.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\neis.drop(labels = 'Datum', axis = 1, inplace = True)\n```\n:::\n\n\nWir stellen den Datensatz grafisch dar.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\neis.plot(x = 'Zeit', y = ['Thermoelement 1 (°C)', 'Thermoelement 2 (°C)'])\n```\n\n::: {.cell-output .cell-output-display}\n![](beispiel-eiskochen_files/figure-pdf/cell-7-output-1.png){fig-alt='Darstellung der gemessenen Temperaturen beider Thermoelemente über die Zeit.' fig-pos='H'}\n:::\n:::\n\n\n&nbsp;\n\nEtwa in der Mitte des Datensatzes verzeichnen beide Sensoren extreme Fehlwerte. Diese sollen entfernt werden.\n\n**Fehlwerte entfernen**\n\nZunächst betrachten wir den Bereich genauer.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nn_zeilen = eis.shape[0]\neis.iloc[int(n_zeilen * 0.45): int(n_zeilen * 0.65)].plot(x = 'Zeit', y = ['Thermoelement 1 (°C)', 'Thermoelement 2 (°C)'])\n```\n\n::: {.cell-output .cell-output-display}\n![](beispiel-eiskochen_files/figure-pdf/cell-8-output-1.png){fig-alt='Darstellung der gemessenen Temperaturen beider Thermoelemente über die Zeit im Bereich von ca. 55 bis 65 Grad Celsius.' fig-pos='H'}\n:::\n:::\n\n\n&nbsp;\n\nIn einem bestimmten Abschnitt scheinen keine gültigen Werte vorzuliegen und diese sollen als ungültig markiert werden. Dazu betrachten wir zunächst die typische Veränderung der Messwerte, also die Differenz jedes Werts zu seinem Vorgänger mit der Methode `pd.Series.diff()`. Ebenfalls wird die Veränderung in studentisierten z-Werten ausgedrückt.\n\nDie z-Werte werden mit der scipy-Funktion `scipy.stats.zscore(a, ddof = 1, nan_policy = 'omit'))` ermittelt. `a` steht für array-artige Daten, `ddof = 1` spezifiziert die Stichprobenstandardabweichung und das Argument `nan_policy = 'omit'` wird verwendet, um mit dem Wert `np.nan` an der ersten Stelle arbeiten zu können, der aus der Berechnung der Veränderung entsteht, da für den ersten Wert einer Reihe kein gültiger Wert berechnet werden kann.\n\n:::: {#wrn-diffinnpandpd .callout-warning appearance=\"simple\" collapse=\"true\"}\n## np.diff() und pd.diff()\nNumPy und Pandas verfügen über eine Funktion diff. Diese verhalten sich standardmäßig unterschiedlich. Um die Länge einer Datenreihe mit `np.diff()` zu erhalten, können die Parameter `prepend` oder `append` verwendet werden, um der Datenreihe vor Ausführung der Operation einen Wert voranzustellen oder einen Wert anzuhängen. So bleiben die Länge der Datenreihe und die Indexpositionen der Werte erhalten.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\narray = np.array([1, 3, 5, 6])\nprint(np.diff(array))\nseries = pd.Series(array)\nprint(series.diff())\nprint(\"\\n\", np.diff(array, prepend = np.nan))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2 2 1]\n0    NaN\n1    2.0\n2    2.0\n3    1.0\ndtype: float64\n\n [nan  2.  2.  1.]\n```\n:::\n:::\n\n\n::::\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# absolute Differenzen ermitteln\ndiff_thermoelement1 = eis['Thermoelement 1 (°C)'].diff()\ndiff_thermoelement2 = eis['Thermoelement 2 (°C)'].diff()\n\n# absolute z-scores ermitteln\nabs_z_score_thermoelement1 = np.abs(scipy.stats.zscore(diff_thermoelement1, ddof = 1, nan_policy = 'omit'))\nabs_z_score_thermoelement2 = np.abs(scipy.stats.zscore(diff_thermoelement2, ddof = 1, nan_policy = 'omit'))\n\n# plotten\nfig = plt.figure(figsize = (7.5, 7.5)) # sharex = True\n\nax = fig.add_subplot(2, 2, 1)\nax.plot(diff_thermoelement1, color = 'C0', label = 'Thermoelement 1')\nax.set_xlabel(xlabel = 'Index')\nax.set_ylabel(ylabel = 'Temperaturdifferenz in °C')\nax.grid()\n\nax = fig.add_subplot(2, 2, 2)\nax.plot(abs_z_score_thermoelement1, color = 'C0')\nax.set_xlabel(xlabel = 'Index')\nax.set_ylabel(ylabel = 'absolute z-Werte')\nax.grid()\n\nax = fig.add_subplot(2, 2, 3)\nax.plot(diff_thermoelement2, color = 'C1', label = 'Thermoelement 2')\nax.set_xlabel(xlabel = 'Index')\nax.set_ylabel(ylabel = 'Temperaturdifferenz in °C')\nax.grid()\n\nax = fig.add_subplot(2, 2, 4)\nax.plot(abs_z_score_thermoelement2, color = 'C1')\nax.set_xlabel(xlabel = 'Index')\nax.set_ylabel(ylabel = 'absolute z-Werte')\nax.grid()\n\nfig.legend(loc = 'outside upper center', ncols = 2,  bbox_to_anchor = (0.5, 1.05)) \n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](beispiel-eiskochen_files/figure-pdf/cell-10-output-1.png){fig-alt='Darstellung der Temperaturdifferenz in Grad (links) und der absoluten z-Werte (rechts) für beide Thermoelemente über den Index der gemessenen Werte.' fig-pos='H'}\n:::\n:::\n\n\n&nbsp;\n\nDie Position der ungültigen Werte kann sowohl über eine sinnvolle Schwelle der (absoluten) Temperaturveränderung oder der absoluten z-Werte bestimmt werden. In diesem Fall verwenden wir die absolute Temperaturveränderung und wählen den Schwellwert 10. Es wird die Position des ersten und des letzten Werts, der oberhalb dieses Schwellwerts liegt, bestimmt.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# absolute Änderung bestimmen\ndiff_thermoelement1 = eis['Thermoelement 1 (°C)'].diff().abs()\ndiff_thermoelement2 = eis['Thermoelement 2 (°C)'].diff().abs()\n\n# Schwellwert festlegen und prüfen\nschwellwert = 10\nbool_series_thermoelement1 = diff_thermoelement1 > schwellwert\nbool_series_thermoelement2 = diff_thermoelement2 > schwellwert\n\n# ersten und letzten Wert größer Schwellwert finden\n## Thermoelement 1\n### Wo steht nicht False?\n### np.nonzero() gibt ein Tupel zurück\n### Dieses enthält für jede Dimension ein array der Indexwerte\npositionen_thermoelement1 = np.nonzero(bool_series_thermoelement1)\n\n## Thermoelement 2\n### Wo steht nicht False?\n### np.nonzero() gibt ein Tupel zurück\n### Dieses enthält für jede Dimension ein array der Indexwerte\npositionen_thermoelement2 = np.nonzero(bool_series_thermoelement2)\n\n# Ausgabe\n## Thermoelement 1\nprint(\"Thermoelement 1\")\nprint(51 * \"=\")\nprint(\"Anzahl der Temperaturänderungen mit Betrag > 10:\", bool_series_thermoelement1.sum())\nprint(f\"Die Position des ersten Werts: {positionen_thermoelement1[0][0]}\")\nprint(f\"Die Position des letzten Werts: {positionen_thermoelement1[0][-1]}\")\n\n## Thermoelement 2\nprint(\"\\nThermoelement 2\")\nprint(51 * \"=\")\nprint(\"Anzahl der Temperaturänderungen mit Betrag > 10:\", bool_series_thermoelement2.sum())\nprint(f\"Die Position des ersten Werts: {positionen_thermoelement2[0][0]}\")\nprint(f\"Die Position des letzten Werts: {positionen_thermoelement2[0][-1]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThermoelement 1\n===================================================\nAnzahl der Temperaturänderungen mit Betrag > 10: 20\nDie Position des ersten Werts: 310\nDie Position des letzten Werts: 333\n\nThermoelement 2\n===================================================\nAnzahl der Temperaturänderungen mit Betrag > 10: 20\nDie Position des ersten Werts: 310\nDie Position des letzten Werts: 333\n```\n:::\n:::\n\n\nFür beide Thermoelemente kann der gleiche Bereich als ungültig markiert werden. Vor der weiteren Bearbeitung wird eine Kopie des aufgeräumten Datensatzes erstellt.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nvon = positionen_thermoelement1[0][0]\nbis = positionen_thermoelement1[0][-1]\neis.loc[von : bis, ['Thermoelement 1 (°C)', 'Thermoelement 2 (°C)']] = np.nan\n\n# Kopie von eis anlegen\neis_backup = eis.copy()\n```\n:::\n\n\n:::\n\n## Daten darstellen\nDer Datensatz wird dargestellt. (In der Darstellung mit `pd.plot()` ist die automatisch gewählte x-Achsenbeschriftung unansehnlich. Deshalb wird ein Datenobjekt für die Darstellung angelegt und die Spalte 'Zeit' auf die Uhrzeit reduziert.)\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# Darstellung mit automatischer Achsenbeschriftung\n# eis.plot(x = 'Zeit', y = ['Thermoelement 1 (°C)', 'Thermoelement 2 (°C)'], grid = True)\n\nplotting_data = eis.copy()\nplotting_data['Zeit'] = plotting_data['Zeit'].dt.time\n\nplotting_data.plot(x = 'Zeit', y = ['Thermoelement 1 (°C)', 'Thermoelement 2 (°C)'], grid = True, ylabel = '°C')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](beispiel-eiskochen_files/figure-pdf/cell-13-output-1.png){fig-alt='Darstellung der gemessenen Temperaturen beider Thermoelemente über die Zeit. Die fehlerhaften Messwerte wurden entfernt.' fig-pos='H'}\n:::\n:::\n\n\n## Referenzpunkte bestimmen\nFür die Korrektur des Nullpunkt- und des Empfindlichkeitsfehlers sind als Referenzpunkte die Temperaturen 0 und 100 Grad Celsius bekannt: Solange Eis im Wasser schwimmt, hat es 0 °C, und bei 100 °C erreicht das Wasser seinen Siedepunkt.\n\n::: {#wrn-100C .callout-warning appearance=\"simple\"}\n## Siedetemperatur von Wasser\n\nDie Siedetemperatur von Wasser ist abhängig vom Luftdruck und beträgt 100 °C bei 1013,25 hPa. In Deutschland liegt die tatsächliche Siedetemperatur typischerweise etwas niedriger.\n:::\n\n### 0 °C\nFür die wahre Temperatur 0 °C sind viele Messpunkte verfügbar. Schauen wir uns die ersten 100 Messwerte an:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\neis.loc[0 : 100, ['Thermoelement 1 (°C)', 'Thermoelement 2 (°C)']].plot(xlabel = 'Index', ylabel = 'gemessene Temperatur in °C')\n```\n\n::: {.cell-output .cell-output-display}\n![](beispiel-eiskochen_files/figure-pdf/cell-14-output-1.png){fig-alt='Darstellung der gemessenen Temperaturen beider Thermoelemente über die ersten 101 Messwerte.' fig-pos='H'}\n:::\n:::\n\n\n&nbsp;\n\nDer Zeitpunkt, ab dem die Wärmezufuhr beginnt, kann z. B. mit der Methode `pd.diff()` ermittelt werden:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\neis.loc[0 : 100, ['Thermoelement 1 (°C)', 'Thermoelement 2 (°C)']].diff().plot(xlabel = 'Index', ylabel = 'Temperaturdifferenz in °C')\n```\n\n::: {.cell-output .cell-output-display}\n![](beispiel-eiskochen_files/figure-pdf/cell-15-output-1.png){fig-alt='Darstellung der Temperaturdifferenz für beide Thermoelemente über die ersten 101 Messwerte.' fig-pos='H'}\n:::\n:::\n\n\n&nbsp;\n\nDa das Thermoelement 1 leichte Messabweichungen aufweist, wird ein Schwellwert etwas größer als 0 gewählt. Damit wird die Position des ersten Werts bestimmt, der oberhalb des Schwellwerts liegt.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# absolute Änderung bestimmen\ndiff_thermoelement1 = eis.loc[0 : 100, 'Thermoelement 1 (°C)'].diff().abs()\ndiff_thermoelement2 = eis.loc[0 : 100, 'Thermoelement 2 (°C)'].diff().abs()\n\n# Schwellwert festlegen und prüfen\nschwellwert = 0.2\nbool_series_thermoelement1 = diff_thermoelement1 > schwellwert\nbool_series_thermoelement2 = diff_thermoelement2 > schwellwert\n\n# ersten Wert größer Schwellwert finden\n## Thermoelement 1\n### Wo steht nicht False?\n### np.nonzero() gibt ein Tupel zurück\n### Dieses enthält für jede Dimension ein array der Indexwerte\npositionen_thermoelement1 = np.nonzero(bool_series_thermoelement1)\n\n## Thermoelement 2\n### Wo steht nicht False?\n### np.nonzero() gibt ein Tupel zurück\n### Dieses enthält für jede Dimension ein array der Indexwerte\npositionen_thermoelement2 = np.nonzero(bool_series_thermoelement2)\n\n# Ausgabe\n## Thermoelement 1\nprint(\"Thermoelement 1\")\nprint(f\"Die Position des ersten Werts: {positionen_thermoelement1[0][0]}\")\n\n## Thermoelement 2\nprint(\"\\nThermoelement 2\")\nprint(f\"Die Position des ersten Werts: {positionen_thermoelement2[0][0]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThermoelement 1\nDie Position des ersten Werts: 67\n\nThermoelement 2\nDie Position des ersten Werts: 67\n```\n:::\n:::\n\n\nDie Wärmezufuhr beginnt also bei dem Wert an Indexposition 67. Der Nullpunkt der Messreihe liegt somit an der Indexposition 67 - 1.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nstart_wärmezufuhr = 67\nstart = start_wärmezufuhr - 1\n```\n:::\n\n\n## Nullpunktfehler korrigieren\nSomit kann der Nullpunktfehler nun für beide Thermoelemente aus der Differenz zwischen dem Mittelwert der gemessenen Werte bis *exklusiv* Indexposition 67 und dem wahren Wert 0 direkt berechnet werden. Diese Position haben wir in der Variable start gespeichert, die für beide Thermoelemente gilt.\n\n::: {#wrn-slicingmitloc .callout-warning appearance=\"simple\"}\n## Slicing mit pd.loc[]\n\nDas Slicing mit `pd.loc[]` ist inklusiv.\n\n:::\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nnullpunktfehler_thermoelement1 = eis.loc[0 : start, 'Thermoelement 1 (°C)'].mean() - 0\nnullpunktfehler_thermoelement2 = eis.loc[0 : start, 'Thermoelement 2 (°C)'].mean() - 0\n\nprint(f\"Der Nullpunktfehler von Thermoelement 1 beträgt: {nullpunktfehler_thermoelement1}\")\nprint(f\"Der Nullpunktfehler von Thermoelement 2 beträgt: {nullpunktfehler_thermoelement2:.2f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDer Nullpunktfehler von Thermoelement 1 beträgt: 1.0\nDer Nullpunktfehler von Thermoelement 2 beträgt: 0.48\n```\n:::\n:::\n\n\nDamit kann der Nullpunktfehler für beide Messreihen korrigiert werden.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\neis['Thermoelement 1 (°C)'] -= nullpunktfehler_thermoelement1\neis['Thermoelement 2 (°C)'] -= nullpunktfehler_thermoelement2\n```\n:::\n\n\n### 100 °C\nAuch für die wahre Temperatur 100 Grad sind viele Messpunkte verfügbar. Wir wollen die letzten 120 Messwerte betrachten. Der Punkt, an dem das Wasser siedet, ist jedoch nicht so einfach zu bestimmen. Starke Messabweichungen erzeugen ein verrauschtes Bild. Um die grafische Analyse zu erleichtern wurden für beide Messreihen der gleitende Durchschnitt sowie der Mittelwert der geglätten Messreihen eingezeichnet. Diese Methoden werden Methoden im [Methodenbaustein Datenfitting und Datenoptimierung](https://bausteine-der-datenanalyse.github.io/m-datenfitting-und-optimierung/output/book/) vermittelt.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nanzahl = 120\n\neis.loc[eis.shape[0] - anzahl : , ['Thermoelement 1 (°C)', 'Thermoelement 2 (°C)']].plot(alpha = 0.3, xlabel = 'Index', ylabel = 'gemessene Temperatur in °C')\nplt.hlines(y = 100, xmin = eis.shape[0] - anzahl, xmax = eis.shape[0], linestyles = 'dashed', label = '100 °C')\n\n# Daten glätten\nwindow = 9\nweights = np.ones(window) / window\nthermoelement1_glatt = np.convolve(eis['Thermoelement 1 (°C)'], weights, mode = 'valid')\nthermoelement2_glatt = np.convolve(eis['Thermoelement 2 (°C)'], weights, mode = 'valid')\n\nplt.plot(eis.index[eis.shape[0] - anzahl + (window-1)//2 : -(window//2)], thermoelement1_glatt[eis.shape[0] - anzahl : ], label = 'Thermoel. 1 geglättet', color = 'C0')\nplt.plot(eis.index[eis.shape[0] - anzahl + (window-1)//2 : -(window//2)], thermoelement2_glatt[eis.shape[0] - anzahl : ], label = 'Thermoel. 2 geglättet', color = 'C1')\n\nmittelwert_der_sensoren = (thermoelement1_glatt[eis.shape[0] - anzahl : ] + thermoelement2_glatt[eis.shape[0] - anzahl : ]) / 2\nplt.plot(eis.index[eis.shape[0] - anzahl + (window-1)//2 : -(window//2)], mittelwert_der_sensoren, label = 'geglätteter Mittelwert', linestyle = 'dashed', color = 'red')\n\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](beispiel-eiskochen_files/figure-pdf/cell-20-output-1.png){fig-alt='Darstellung der letzten 100 Messwerte für Thermoelement 1 und Thermoelement 2. Für beide Messreihen ist ein mit dem gleitenden Mittelwert geglättete Kurve eingezeichnet. Zusätzlich ist der Mittelwert der geglätteten Reihen eingezeichnet. Horizontal ist die Temperatur 100 °C durch eine gestrichelte Linie gekennzeichnet.' fig-pos='H'}\n:::\n:::\n\n\n&nbsp;\n\nBehelfsweise bestimmen wir den Referenzpunkt für 100 °C, indem die Werte zwischen dem Indexwert 500 und bis zu den letzten 10 Werten des Datensatzes gemittelt werden. Anschließend wird der Index bestimmt, an dem die Messwerte diesen Mittelwert erstmalig erreichen. (*Hinweis: Die Daten wurden bereits um den ermittelten Nullpunktfehler korrigiert.*)\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nthermoelement1_max = eis['Thermoelement 1 (°C)'].iloc[500 : -10].mean()\nthermoelement2_max = eis['Thermoelement 2 (°C)'].iloc[500 : -10].mean()\n\n# ge = greater or equal, idxmax = find first occurrence of maximum value (0 and 1)\nende_thermoelement1 = eis['Thermoelement 1 (°C)'].ge(thermoelement1_max).idxmax()\nende_thermoelement2 = eis['Thermoelement 2 (°C)'].ge(thermoelement2_max).idxmax()\n\nprint(f\"Gemitteltes Maximum Thermoelement 1: {thermoelement1_max:.2f} °C\",\n      f\"Erstmalig erreicht an Position: {ende_thermoelement1 }\", sep = \"\\n\")\nprint(f\"Gemitteltes Maximum Thermoelement 2: {thermoelement2_max:.2f} °C\",\n      f\"Erstmalig erreicht an Position: {ende_thermoelement2 }\", sep = \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGemitteltes Maximum Thermoelement 1: 97.32 °C\nErstmalig erreicht an Position: 491\nGemitteltes Maximum Thermoelement 2: 99.93 °C\nErstmalig erreicht an Position: 476\n```\n:::\n:::\n\n\n## Empfindlichkeitsfehler korrigieren\nMit den bekannten Start- und Endwerten kann der Empfindlichkeitsfehler geschätzt werden. Als Referenzpunkte sind bekannt:\n\n  - Die Indexposition, an der die Wärmezufuhr beginnt und die in der Variable 'start_wärmezufuhr' gespeichert ist. An der Indexposition start_wärmezufuhr - 1 beträgt die wahre Temperatur 0 °C. Der Index dieses Werts ist in der Variable 'start' gespeichert (und ist für beide Thermoelemente identisch).\n  - Die Indexposition, an der die Temperatur ihr Maximum erreicht. Solange Wasser im Topf ist, beträgt die wahre Temperatur 100 °C. Die Position dieses Werts konnte nur geschätzt werden und ist in den Variablen 'ende_thermoelement1' und 'ende_thermoelement1' gespeichert.\n\nThermoelement 1\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nende =  ende_thermoelement1\n\n# Empfindlichkeitsfehler bestimmen\nlm_referenzpunkte = poly.polyfit(x = [0, 100], y = [eis.loc[start, 'Thermoelement 1 (°C)'], eis.loc[ende, 'Thermoelement 1 (°C)']], deg = 1)\nspannfehler_thermoelement1 = lm_referenzpunkte[1]\n\nprint(f\"Der Empfindlichkeitsfehler beträgt: {round((spannfehler_thermoelement1 - 1) * 100, 2)} %\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDer Empfindlichkeitsfehler beträgt: -2.0 %\n```\n:::\n:::\n\n\nThermoelement 2\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nende =  ende_thermoelement2\n\n# Empfindlichkeitsfehler bestimmen\nlm_referenzpunkte = poly.polyfit(x = [0, 100], y = [eis.loc[start, 'Thermoelement 2 (°C)'], eis.loc[ende, 'Thermoelement 2 (°C)']], deg = 1)\nspannfehler_thermoelement2 = lm_referenzpunkte[1]\n\nprint(f\"Der Empfindlichkeitsfehler beträgt: {round((spannfehler_thermoelement2 - 1) * 100, 2)} %\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDer Empfindlichkeitsfehler beträgt: 0.2 %\n```\n:::\n:::\n\n\nSomit kann der Empfindlichkeitsfehler korrigiert werden.\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n# Empfindlichkeitsfehler Thermoelement 1 korrigieren\neis['Thermoelement 1 (°C)'] = eis['Thermoelement 1 (°C)'].div(spannfehler_thermoelement1)\neis['Thermoelement 2 (°C)'] = eis['Thermoelement 2 (°C)'].div(spannfehler_thermoelement2)\n\nprint(f\"Maximum kalibriertes Thermoelement 1: {eis['Thermoelement 1 (°C)'].max():.2f}\",\n      f\"Maximum kalibriertes Thermoelement 2: {eis['Thermoelement 2 (°C)'].max():.2f}\",\n      sep = '\\n')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMaximum kalibriertes Thermoelement 1: 100.71\nMaximum kalibriertes Thermoelement 2: 102.32\n```\n:::\n:::\n\n\nSchauen wir uns die kalibrierten Daten erneut an:\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nplotting_data = eis.copy()\nplotting_data['Zeit'] = plotting_data['Zeit'].dt.time\n\nplotting_data.plot(x = 'Zeit', y = ['Thermoelement 1 (°C)', 'Thermoelement 2 (°C)'], grid = True)\nplt.xlabel(xlabel = 'Index')\nplt.ylabel(ylabel = '° C')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](beispiel-eiskochen_files/figure-pdf/cell-25-output-1.png){fig-alt='Darstellung der kalibrierten Temperaturen beider Thermoelemente über die Zeit. Die fehlerhaften Messwerte wurden entfernt.' fig-pos='H'}\n:::\n:::\n\n\n## Linearitätsfehler ermitteln\nDie Daten wurden mit einem linearen Verfahren kalibriert, obwohl die Messwerte nichtlinear sind. Der Linearitätsfehler soll quantifiziert werden.\n\n#### Festpunktmethode\nThermoelement 1\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nende = ende_thermoelement1\n\n# Endpunktverbindende Gerade schätzen\n# x muss bei Null beginnen\nlm = poly.polyfit(\n  x = [start - start, ende - start],\n  y = [eis.loc[start, 'Thermoelement 1 (°C)'], eis.loc[ende, 'Thermoelement 1 (°C)']],\n  deg = 1)\n## print(lm.round(2)) # intercept + slope\n\n# Vorhersagewerte schätzen\n## np.arange() ist exklusiv\nvorhersagewerte = poly.polyval(x = np.arange(start - start, ende - start + 1), c = lm)\n### print(len(vorhersagewerte))\n### print(len(np.arange(eis.loc[start:ende, :].shape[0])))\n\n# Linearitätsfehler berechnen\nlinearitätsfehler_festpunkt = eis.loc[start:ende, 'Thermoelement 1 (°C)'].sub(vorhersagewerte).abs().max()\nprint(f\"Linearitätsfehler nach Festpunktmethode: {linearitätsfehler_festpunkt:.2f} °C.\")\n\n# grafische Darstellung\nplt.plot(np.arange(eis.shape[0]),\n         eis['Thermoelement 1 (°C)'],\n         label = 'Thermoelement 1')\nplt.plot(np.arange(start, ende + 1),\n         vorhersagewerte,\n         label = 'Festpunktmethode')\n\n# Position und Beschriftung der x-Achse setzen\nplt.xticks(ticks = np.arange(0, eis.shape[0], 100), labels = eis['Zeit'].dt.time[::100]) \n\nplt.xlabel(xlabel = 'Zeit')\nplt.ylabel(ylabel = '° C')\nplt.grid()\nplt.legend()\n\n\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLinearitätsfehler nach Festpunktmethode: 10.09 °C.\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](beispiel-eiskochen_files/figure-pdf/cell-26-output-2.png){fig-alt='Darstellung der kalibrierten Temperatur von Thermoeelement 1 und der linearen Schätzung nach der Festpunktmethode über die Zeit.' fig-pos='H'}\n:::\n:::\n\n\n&nbsp;\n\nThermoelement 2\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nende = ende_thermoelement2\n\n# Endpunktverbindende Gerade schätzen\n# x muss bei Null beginnen\nlm = poly.polyfit(\n  x = [start - start, ende - start],\n  y = [eis.loc[start, 'Thermoelement 2 (°C)'], eis.loc[ende, 'Thermoelement 2 (°C)']],\n  deg = 1)\n## print(lm.round(2)) # intercept + slope\n\n# Vorhersagewerte schätzen\n## np.arange() ist exklusiv\nvorhersagewerte = poly.polyval(x = np.arange(start - start, ende - start + 1), c = lm)\n### print(len(vorhersagewerte))\n### print(len(np.arange(eis.loc[start:ende, :].shape[0])))\n\n# Linearitätsfehler berechnen\nlinearitätsfehler_festpunkt = eis.loc[start:ende, 'Thermoelement 2 (°C)'].sub(vorhersagewerte).abs().max()\nprint(f\"Linearitätsfehler nach Festpunktmethode: {linearitätsfehler_festpunkt:.2f} °C.\")\n\n# grafische Darstellung\nplt.plot(np.arange(eis.shape[0]),\n         eis['Thermoelement 2 (°C)'],\n         label = 'Thermoelement 2')\nplt.plot(np.arange(start, ende + 1),\n         vorhersagewerte,\n         label = 'Festpunktmethode')\n\n# Position und Beschriftung der x-Achse setzen\nplt.xticks(ticks = np.arange(0, eis.shape[0], 100), labels = eis['Zeit'].dt.time[::100]) \n\nplt.xlabel(xlabel = 'Zeit')\nplt.ylabel(ylabel = '° C')\nplt.grid()\nplt.legend()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLinearitätsfehler nach Festpunktmethode: 10.95 °C.\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](beispiel-eiskochen_files/figure-pdf/cell-27-output-2.png){fig-alt='Darstellung der kalibrierten Temperatur von Thermoeelement 2 und der linearen Schätzung nach der Festpunktmethode über die Zeit.' fig-pos='H'}\n:::\n:::\n\n\n&nbsp;\n\n#### Toleranzbandmethode\nFür die Anwendung der Toleranzbandmethode wird die [Funktion linregress](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.linregress.html#scipy.stats.linregress) aus dem Paket SciPy verwendet, da diese mit fehlenden Werten umgehen kann.\n\n`linregress(x, y, alternative='two-sided', *, axis=0, nan_policy='propagate')`\n\nDafür wird der Parameter `nan_policy = 'omit'` gesetzt, wodurch Fehlwerte verworfen werden. Die Funktion gibt ein LinregressResult-Objekt zurück, dass den Zugriff auf die Regressionsobjekte über Attribute erlaubt. Für uns relevant sind die Attribute `LinregressResult.intercept` und `LinregressResult.slope`.\n\nThermoelement 1\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nende = ende_thermoelement1\n\n# Regression durch die Messwerte\n# x muss bei Null beginnen\nlm = scipy.stats.linregress(\n  x = np.arange(start - start, ende - start + 1),\n  y = eis.loc[start:ende, 'Thermoelement 1 (°C)'],\n  nan_policy = 'omit')\n# print(lm.intercept, lm.slope)\n\n# Vorhersagewerte schätzen\n## np.arange() ist exklusiv\nvorhersagewerte = poly.polyval(x = np.arange(start - start, ende - start + 1), c = [lm.intercept, lm.slope])\n\n# Linearitätsfehler berechnen\nlinearitätsfehler_toleranzband = eis.loc[start:ende, 'Thermoelement 1 (°C)'].sub(vorhersagewerte).abs().max()\nprint(f\"Linearitätsfehler nach Toleranzbandmethode: {linearitätsfehler_toleranzband:.2f} °C.\")\n\n# grafische Darstellung\nplt.plot(np.arange(eis.shape[0]),\n         eis['Thermoelement 1 (°C)'],\n         label = 'Thermoelement 1')\nplt.plot(np.arange(start, ende + 1),\n         vorhersagewerte,\n         label = 'Toleranzbandmethode')\n\n# Position und Beschriftung der x-Achse setzen\nplt.xticks(ticks = np.arange(0, eis.shape[0], 100), labels = eis['Zeit'].dt.time[::100]) \n\nplt.xlabel(xlabel = 'Zeit')\nplt.ylabel(ylabel = '° C')\nplt.grid()\nplt.legend()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLinearitätsfehler nach Toleranzbandmethode: 8.22 °C.\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](beispiel-eiskochen_files/figure-pdf/cell-28-output-2.png){fig-alt='Darstellung der kalibrierten Temperatur von Thermoeelement 1 und der linearen Schätzung nach der Toleranzbandmethode über die Zeit.' fig-pos='H'}\n:::\n:::\n\n\n&nbsp;\n\nThermoelement 2:\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nende = ende_thermoelement2\n\n# Regression durch die Messwerte\n# x muss bei Null beginnen\nlm = scipy.stats.linregress(\n  x = np.arange(start - start, ende - start + 1),\n  y = eis.loc[start:ende, 'Thermoelement 2 (°C)'],\n  nan_policy = 'omit')\n# print(lm.intercept, lm.slope)\n\n# Vorhersagewerte schätzen\n## np.arange() ist exklusiv\nvorhersagewerte = poly.polyval(x = np.arange(start - start, ende - start + 1), c = [lm.intercept, lm.slope])\n\n# Linearitätsfehler berechnen\nlinearitätsfehler_toleranzband = eis.loc[start:ende, 'Thermoelement 2 (°C)'].sub(vorhersagewerte).abs().max()\nprint(f\"Linearitätsfehler nach Toleranzbandmethode: {linearitätsfehler_toleranzband:.2f} °C.\")\n\n# grafische Darstellung\nplt.plot(np.arange(eis.shape[0]),\n         eis['Thermoelement 2 (°C)'],\n         label = 'Thermoelement 2')\nplt.plot(np.arange(start, ende + 1),\n         vorhersagewerte,\n         label = 'Toleranzbandmethode')\n\n# Position und Beschriftung der x-Achse setzen\nplt.xticks(ticks = np.arange(0, eis.shape[0], 100), labels = eis['Zeit'].dt.time[::100]) \n\nplt.xlabel(xlabel = 'Zeit')\nplt.ylabel(ylabel = '° C')\nplt.grid()\nplt.legend()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLinearitätsfehler nach Toleranzbandmethode: 6.78 °C.\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](beispiel-eiskochen_files/figure-pdf/cell-29-output-2.png){fig-alt='Darstellung der kalibrierten Temperatur von Thermoeelement 2 und der linearen Schätzung nach der Toleranzbandmethode über die Zeit.' fig-pos='H'}\n:::\n:::\n\n\n## Zweipunktkalibrierung\nFür die Zweipunktkalibrierung stellen wir den in @nte-eis eingelesenen Datensatz wieder her.\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\neis = eis_backup.copy()\n\nwahres_minimum = 0\nwahres_maximum = 100\n\n# Thermoelement 1\nende = ende_thermoelement1\n\na = (wahres_maximum - wahres_minimum) / (eis.loc[start:ende, 'Thermoelement 1 (°C)'].max() - eis.loc[start:ende, 'Thermoelement 1 (°C)'].min())\nb = wahres_minimum - a * eis.loc[start:ende, 'Thermoelement 1 (°C)'].min()\n\neis['Thermoelement 1 (°C)'] = a * eis['Thermoelement 1 (°C)'] + b\n\n## Ausgabe\nprint(f\"Thermoelement 1\",\n      f\"a = {a:.1f}\",\n      f\"b = {b:.1f}\",\n      f\"Nullpunktfehler: {round(-1 * b / a, 2)}\",\n      f\"Empfindlichkeitsfehler: {round( ((1 / a) - 1) * 100, 2)} %\",\n      sep = '\\n')\nprint()\n\n# Thermoelement 2\nende = ende_thermoelement2\n\na = (wahres_maximum - wahres_minimum) / (eis.loc[start:ende, 'Thermoelement 2 (°C)'].max() - eis.loc[start:ende, 'Thermoelement 2 (°C)'].min())\nb = wahres_minimum - a * eis.loc[start:ende, 'Thermoelement 2 (°C)'].min()\n\neis['Thermoelement 2 (°C)'] = a * eis['Thermoelement 2 (°C)'] + b\n\n## Ausgabe\nprint(f\"Thermoelement 2\",\n      f\"a = {a:.1f}\",\n      f\"b = {b:.1f}\",\n      f\"Nullpunktfehler: {round(-1 * b / a, 2)}\",\n      f\"Empfindlichkeitsfehler: {round( ((1 / a) - 1) * 100, 2)} %\",\n      sep = '\\n')\n\n# plotten\nplotting_data = eis.copy()\nplotting_data['Zeit'] = plotting_data['Zeit'].dt.time\n\nplotting_data.plot(x = 'Zeit', y = ['Thermoelement 1 (°C)', 'Thermoelement 2 (°C)'], grid = True, ylabel = '°C')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThermoelement 1\na = 1.0\nb = -1.0\nNullpunktfehler: 1.0\nEmpfindlichkeitsfehler: -2.0 %\n\nThermoelement 2\na = 1.0\nb = -0.5\nNullpunktfehler: 0.5\nEmpfindlichkeitsfehler: 0.2 %\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](beispiel-eiskochen_files/figure-pdf/cell-30-output-2.png){fig-alt='Darstellung der kalibrierten Temperaturen von Thermoeelement 1 und 2 über die Zeit.' fig-pos='H'}\n:::\n:::\n\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\nprint(f\"Maximum kalibriertes Thermoelement 1: {eis['Thermoelement 1 (°C)'].max():.2f}\",\n      f\"Maximum kalibriertes Thermoelement 2: {eis['Thermoelement 2 (°C)'].max():.2f}\",\n      sep = '\\n')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMaximum kalibriertes Thermoelement 1: 100.71\nMaximum kalibriertes Thermoelement 2: 102.30\n```\n:::\n:::\n\n\n",
    "supporting": [
      "beispiel-eiskochen_files/figure-pdf"
    ],
    "filters": []
  }
}