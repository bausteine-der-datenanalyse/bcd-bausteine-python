{
  "hash": "001501da79fba25ce1cb69e0223e4f16",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"2 Vorverarbeitung & Validierung einer Zeitreihe\"\n---\n\n# 2 Vorverarbeitung & Validierung einer Zeitreihe\n\nBevor eine Zeitreihe analysiert wird, muss sie **formal korrekt und konsistent** sein.\n\nViele Fehler in späteren Analysen entstehen durch:\n\n- unsortierte Zeitstempel\n- doppelte Zeitpunkte\n- fehlende Werte\n- unregelmäßige Abtastung\n- implizite Zeitlücken\n\n::: {.callout-note title=\"Merke\"}\nZeitreihenanalyse ist nur so gut wie die Datenbasis.\nValidierung ist kein optionaler Schritt.\n:::\n\n## 2.1 Beispiel-Zeitreihe mit Problemen\n\nWir erzeugen bewusst eine fehlerhafte Zeitreihe (unsortiert, Duplikate, Missing Values).\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\n\nrng = np.random.default_rng(1)\n\nt = pd.date_range(\"2025-01-01\", periods=24*3, freq=\"h\")\ny = pd.Series(10 + rng.normal(size=len(t)), index=t, name=\"signal\")\n\n# Probleme erzeugen\ny = y.sample(frac=1)                      # unsortiert\ny = pd.concat([y, y.iloc[5:8]])           # Duplikate (append ist deprecated/entfernt)\ny.iloc[10:15] = np.nan                    # fehlende Werte\n\ny.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2025-01-01 06:00:00    9.463047\n2025-01-01 21:00:00    9.724397\n2025-01-02 01:00:00    8.110987\n2025-01-03 14:00:00    9.017812\n2025-01-03 10:00:00    8.751251\nName: signal, dtype: float64\n```\n:::\n:::\n\n\n## 2.2 Schritt 1: Sortierung sicherstellen\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ny = y.sort_index()\n```\n:::\n\n\n## 2.3 Schritt 2: Duplikate erkennen und behandeln\n\nDuplikate erkennen:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndup_mask = y.index.duplicated(keep=False)\ny[dup_mask].head(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n2025-01-01 01:00:00    10.821618\n2025-01-01 01:00:00    10.821618\n2025-01-03 05:00:00     9.498560\n2025-01-03 05:00:00     9.498560\n2025-01-03 17:00:00     9.533250\n2025-01-03 17:00:00     9.533250\nName: signal, dtype: float64\n```\n:::\n:::\n\n\nDuplikate müssen methodisch entschieden behandelt werden, z. B.:\n\n- Mittelwert pro Zeitstempel (typisch bei Messwerten)\n- ersten/letzten Wert behalten (typisch bei Status-Updates)\n- entfernen (wenn klar fehlerhaft)\n\nBeispiel: Mittelwert pro Zeitstempel\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ny = y.groupby(level=0).mean()\n```\n:::\n\n\n## 2.4 Schritt 3: Fehlende Werte analysieren\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ny.isna().sum()\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nnp.int64(5)\n```\n:::\n:::\n\n\n### Visualisierung der Lücken\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\ny.plot(title=\"Zeitreihe mit Missing Values\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](02-vorverarbeitung-validierung_files/figure-pdf/cell-7-output-1.png){fig-pos='H'}\n:::\n:::\n\n\n### Behandlungsmöglichkeiten\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ny_ffill = y.ffill()\ny_interp = y.interpolate(\"time\")\n```\n:::\n\n\n::: {.callout-tip title=\"Entscheidungshilfe\"}\n- `ffill`: sinnvoll bei Zustandsdaten („gilt bis zur nächsten Messung“)\n- `interpolate(\"time\")`: sinnvoll bei kontinuierlichen Messgrößen\n:::\n\n## 2.5 Schritt 4: Abtastrate prüfen\n\nIst die Zeitreihe regelmäßig?\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndiffs = y.index.to_series().diff()\ndiffs.value_counts().head()\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n0 days 01:00:00    71\nName: count, dtype: int64\n```\n:::\n:::\n\n\nWenn mehrere Zeitabstände auftreten → unregelmäßige Abtastung oder Zeitlücken.\n\n## 2.6 Zeitlücken explizit machen\n\nMit `asfreq` wird die erwartete Frequenz erzwungen.\nFehlende Zeitpunkte werden als NaN sichtbar.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ny_regular = y.asfreq(\"h\")\ny_regular.isna().sum()\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nnp.int64(5)\n```\n:::\n:::\n\n\n::: {.callout-warning title=\"Achtung\"}\nOhne explizite Frequenz können Zeitlücken unsichtbar bleiben.\n:::\n\n## 2.7 Validierungs-Checkliste\n\nBevor Sie weiter analysieren:\n\n- [ ] Index ist `DatetimeIndex`\n- [ ] Zeitreihe ist sortiert\n- [ ] Duplikate identifiziert und begründet behandelt\n- [ ] Fehlende Werte identifiziert und Strategie gewählt\n- [ ] Abtastrate geprüft\n- [ ] Frequenz (falls sinnvoll) explizit gesetzt\n\n## 2.8 Mini-Aufgabe\n\nErzeugen Sie selbst eine Zeitreihe mit:\n\n- unregelmäßiger Abtastung\n- 5 fehlenden Zeitpunkten\n- 3 Duplikaten\n\nImplementieren Sie anschließend eine saubere Validierung gemäß Checkliste.\n\n",
    "supporting": [
      "02-vorverarbeitung-validierung_files/figure-pdf"
    ],
    "filters": []
  }
}