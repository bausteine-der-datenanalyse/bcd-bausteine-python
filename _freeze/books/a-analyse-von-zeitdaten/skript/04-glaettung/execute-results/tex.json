{
  "hash": "22e71dfb7c230ed23d1bdf987f3a6219",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"4 Glättung & Rauschreduktion\"\n---\n\n# 4 Glättung & Rauschreduktion\n\nGlättung ist eine der wichtigsten Standardmethoden in der Zeitreihenanalyse.\nSie hilft dabei,\n\n- Rauschen zu reduzieren,\n- Trend/Saison besser sichtbar zu machen,\n- eine **Baseline** zu definieren (z. B. für Anomalien).\n\n::: {.callout-note title=\"Merke\"}\nDie Fensterbreite ist eine methodische Entscheidung:\nSie sollte zur **Zeitskala der Fragestellung** passen.\n:::\n\n## 4.1 Beispielsignal\n\nWir nutzen eine Zeitreihe mit Tagesmuster, Rauschen und einzelnen Ausreißern.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nrng = np.random.default_rng(42)\n\nt = pd.date_range(\"2025-01-01\", periods=24*10, freq=\"H\")  # 10 Tage stündlich\ntrend = np.linspace(0, 2, len(t))\nseason = 0.9 * np.sin(2*np.pi*(t.hour)/24)\nnoise = 0.35 * rng.normal(size=len(t))\n\ns = pd.Series(10 + trend + season + noise, index=t, name=\"signal\")\n\n# Ausreißer\ns.iloc[30] += 3.0\ns.iloc[120] -= 2.5\n\ns.plot(title=\"Beispielsignal (roh)\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_21258/3372949856.py:7: FutureWarning: 'H' is deprecated and will be removed in a future version, please use 'h' instead.\n  t = pd.date_range(\"2025-01-01\", periods=24*10, freq=\"H\")  # 10 Tage stündlich\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](04-glaettung_files/figure-pdf/cell-2-output-2.png){fig-pos='H'}\n:::\n:::\n\n\n## 4.2 Rolling Mean (gleitender Mittelwert)\n\nRolling Mean ist die klassische Glättung: Mittelwert über ein Fenster.\n\n::: {.panel-tabset}\n\n## Pandas (empfohlen)\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nroll_6h = s.rolling(\"6H\").mean()\nroll_24h = s.rolling(\"24H\").mean()\n\nax = s.plot(alpha=0.45, label=\"Signal\")\nroll_6h.plot(ax=ax, label=\"Rolling 6H\")\nroll_24h.plot(ax=ax, label=\"Rolling 24H\")\nplt.legend()\nplt.title(\"Rolling Mean (Pandas)\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_21258/1470441625.py:1: FutureWarning: 'H' is deprecated and will be removed in a future version, please use 'h' instead.\n  roll_6h = s.rolling(\"6H\").mean()\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_21258/1470441625.py:2: FutureWarning: 'H' is deprecated and will be removed in a future version, please use 'h' instead.\n  roll_24h = s.rolling(\"24H\").mean()\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](04-glaettung_files/figure-pdf/cell-3-output-2.png){fig-pos='H'}\n:::\n:::\n\n\n::: {.callout-tip title=\"Entscheidungshilfe\"}\n- **6H**: reduziert kurzfristiges Rauschen, Ereignisse bleiben sichtbar  \n- **24H**: zeigt eher Grundniveau/Trend, dämpft Tagesmuster stark  \n:::\n\n## NumPy (Prinzip)\n\nNumPy-Variante: Moving Average als Faltung (`convolve`).\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ny = s.to_numpy()\n\ndef moving_average(y, window):\n    kernel = np.ones(window) / window\n    return np.convolve(y, kernel, mode=\"same\")\n\nma_6 = moving_average(y, 6)\nma_24 = moving_average(y, 24)\n\nplt.plot(y, alpha=0.45, label=\"Signal\")\nplt.plot(ma_6, label=\"MA 6 Samples\")\nplt.plot(ma_24, label=\"MA 24 Samples\")\nplt.legend()\nplt.title(\"Moving Average (NumPy)\")\nplt.xlabel(\"Sample\")\nplt.ylabel(\"Wert\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](04-glaettung_files/figure-pdf/cell-4-output-1.png){fig-pos='H'}\n:::\n:::\n\n\n::: {.callout-warning title=\"Achtung\"}\nBei der Faltung müssen Sie Randbehandlung bewusst akzeptieren (hier: `mode=\"same\"`).\nPandas behandelt Randbereiche konsistent mit `min_periods` und NaNs.\n:::\n\n:::\n\n## 4.3 EWMA (Exponentially Weighted Moving Average)\n\nEWMA glättet, gewichtet aber **neuere Werte stärker**.\n\n::: {.panel-tabset}\n\n## Pandas (empfohlen)\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\newm_fast = s.ewm(span=6, adjust=False).mean()\newm_slow = s.ewm(span=24, adjust=False).mean()\n\nax = s.plot(alpha=0.45, label=\"Signal\")\newm_fast.plot(ax=ax, label=\"EWMA span=6\")\newm_slow.plot(ax=ax, label=\"EWMA span=24\")\nplt.legend()\nplt.title(\"EWMA (Pandas)\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](04-glaettung_files/figure-pdf/cell-5-output-1.png){fig-pos='H'}\n:::\n:::\n\n\n::: {.callout-note title=\"Merke\"}\nEWMA reagiert schneller auf Änderungen als Rolling Mean,\nweil ältere Werte exponentiell weniger Einfluss haben.\n:::\n\n## NumPy (Prinzip)\n\nEWMA kann rekursiv berechnet werden:\n\n\\[\nm_t = \\alpha \\cdot y_t + (1-\\alpha)\\cdot m_{t-1}\n\\]\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ny = s.to_numpy()\n\ndef ewma(y, alpha):\n    m = np.empty_like(y, dtype=float)\n    m[0] = y[0]\n    for i in range(1, len(y)):\n        m[i] = alpha * y[i] + (1 - alpha) * m[i-1]\n    return m\n\nm_fast = ewma(y, alpha=0.30)\nm_slow = ewma(y, alpha=0.08)\n\nplt.plot(y, alpha=0.45, label=\"Signal\")\nplt.plot(m_fast, label=\"EWMA alpha=0.30\")\nplt.plot(m_slow, label=\"EWMA alpha=0.08\")\nplt.legend()\nplt.title(\"EWMA (NumPy)\")\nplt.xlabel(\"Sample\")\nplt.ylabel(\"Wert\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](04-glaettung_files/figure-pdf/cell-6-output-1.png){fig-pos='H'}\n:::\n:::\n\n\n:::\n\n## 4.4 Methodische Wahl: welches Verfahren wann?\n\n::: {.callout-tip title=\"Entscheidungshilfe\"}\n**Rolling Mean** eignet sich gut, wenn…  \n- Sie ein klar definiertes Zeitfenster mitteln wollen (z. B. „letzte 24h“).\n\n**EWMA** eignet sich gut, wenn…  \n- Sie eine smoothe Baseline wollen, die schneller auf Änderungen reagiert.  \n- Sie Anomalien als Abweichung von einer dynamischen Baseline erkennen möchten.\n:::\n\n## 4.5 Mini-Aufgaben\n\n1. **Fensterwahl:** Testen Sie Rolling-Fenster von 3H, 12H, 48H.  \n   - Welche Strukturen werden jeweils sichtbar bzw. verschwinden?\n\n2. **Anomalien & Glättung:** Erhöhen Sie die Ausreißer-Amplitude.  \n   - Ab welcher Glättungsstärke „verschwindet“ der Ausreißer im geglätteten Signal?\n\n3. **EWMA-Empfindlichkeit:** Variieren Sie `span` (Pandas) bzw. `alpha` (NumPy).  \n   - Welche Parameter reagieren „schnell“, welche „träge“? Begründen Sie.\n\n",
    "supporting": [
      "04-glaettung_files/figure-pdf"
    ],
    "filters": []
  }
}