{
  "hash": "fadde5146e11e41b3dbfe9aa64688d6f",
  "result": {
    "engine": "jupyter",
    "markdown": "# Einleitung\n\n<div style=\"position: relative; width: 100%; aspect-ratio: 16 / 9;\">\n  <iframe src=\"https://av.tib.eu/player/71640\" allowfullscreen style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%;\"></iframe>\n</div>\n\n&nbsp; \n\nDas Modul Pandas wurde für die Arbeit mit strukturierten Daten konzipiert. Pandas erleichtert die Analyse insbesondere von in Tabellenform vorliegenden Daten, da es mit dem DataFrame eine leicht zu benutzende Struktur für die Verarbeitung unterschiedlicher Datentypen und fehlenden Werten bietet. Wie NumPy erlaubt Pandas vektorisierte Operationen, ohne mit Hilfe einer Schleife jedes Element eines Sammeltyps durchlaufen zu müssen. Pandas integriert darüber hinaus Funktionalitäten anderer Module und bietet unter anderem einen einheitlichen Zugang zu:\n\n  - Datumsinformationen und Zeitreihen\n  - Grafikerstellung\n  - Einlesen von Dateien\n\nDas Modul Pandas wird mit dem Befehl `import pandas` geladen. Als Kürzel hat sich pd etabliert. Da Pandas auf dem Modul NumPy aufbaut, werden häufig beide Module geladen. Viele Funktionen und Methoden von NumPy und Pandas sind miteinander kompatibel.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\n```\n:::\n\n\n## Die Datenstrukturen Series und DataFrame\nPandas führt die zwei Klassen `Series` und `DataFrame` ein.\n\n  - `Series` sind eindimensionale Arrays, die genau einen Datentyp haben.\n\n  - `DataFrame` sind zweidimensionale Arrays, die spaltenweise aus `Series` bestehen und so verschiedene Datentypen enthalten können. (Durch hierarchische Indexierung sind mehrdimensionale Datenstrukturen möglich, siehe [MultiIndex](https://pandas.pydata.org/docs/user_guide/advanced.html).)\n\nBeide Datenstrukturen verfügen über einen Index, der in der Ausgabe angezeigt wird. \n\n::: {.cell execution_count=2}\n\n::: {.cell-output .cell-output-stdout}\n```\nDer Index beginnt wie in der Pythonbasis bei 0.\n0    Frühschicht\n1    Frühschicht\n2    Spätschicht\ndtype: string\n```\n:::\n:::\n\n\nDer Index ist standardmäßig numerisch, kann aber mit beliebigen Werten versehen werden.\n\n::: {.cell execution_count=3}\n\n::: {.cell-output .cell-output-stdout}\n```\nDer Index kann angepasst werden.\nMontag      Frühschicht\nDienstag    Frühschicht\nMittwoch    Spätschicht\ndtype: string\n```\n:::\n:::\n\n\n### Series\n`Series` werden mit der Funktion `pd.Series(data)` erstellt. data kann ein Einzelwert, ein Sammeltyp oder ein NumPy-Array sein.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\neinzelwert_series = pd.Series('Hallo Welt!')\nprint(f\"Series aus Einzelwert:\\n{einzelwert_series}\")\n\nnumerische_series = pd.Series([1, 2, 3])\nprint(f\"\\nSeries aus Liste:\\n{numerische_series}\")\n\nalphanumerische_series = pd.Series(('a', '5', 'g'))\nprint(f\"\\nSeries aus Tupel:\\n{alphanumerische_series}\")\n\nboolean_series = pd.Series(np.array([True, False, True])) # NumPy-Array\nprint(f\"\\nSeries aus NumPy-Array:\\n{boolean_series}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSeries aus Einzelwert:\n0    Hallo Welt!\ndtype: object\n\nSeries aus Liste:\n0    1\n1    2\n2    3\ndtype: int64\n\nSeries aus Tupel:\n0    a\n1    5\n2    g\ndtype: object\n\nSeries aus NumPy-Array:\n0     True\n1    False\n2     True\ndtype: bool\n```\n:::\n:::\n\n\nBeim Anlegen einer `pd.Series` können verschiedene Parameter übergeben werden:\n\n  - `pd.Series(data, dtype = 'float')` legt den Datentyp der Series fest.\n\n  - `pd.Series(data, index = ['A1', 'B2', 'C3'])` übergibt Werte für den Index.\n\n  - `pd.Series(data, name = 'der Name')` legt einen Namen für die Series fest.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nnumerische_series = pd.Series([1, 2, 3], dtype = 'float', index = ['A1', 'B2', 'C3'], name = 'Gleitkommazahlen')\nprint(numerische_series)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA1    1.0\nB2    2.0\nC3    3.0\nName: Gleitkommazahlen, dtype: float64\n```\n:::\n:::\n\n\nFür eine bestehende Series können Name und Index über entsprechende Attribute aufgerufen und geändert werden. Um den Datentyp zu ändern, wird die Methode `pd.Series.astype()` verwendet. Eine Übersicht der in Pandas verfügbaren Datentypen finden Sie in der [Pandas-Dokumentation](https://pandas.pydata.org/docs/user_guide/basics.html#dtypes).\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nprint(f\"Name der Series: {numerische_series.name}\")\nnumerische_series.name = 'Fließkommazahlen'\n\nprint(f\"Index der Series: {numerische_series.index}\")\nnumerische_series.index =  ['eins', 'zwei', 'drei']\n\nnumerische_series = numerische_series.astype('string')\nprint(f\"\\nDie geänderte Series:\\n{numerische_series}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nName der Series: Gleitkommazahlen\nIndex der Series: Index(['A1', 'B2', 'C3'], dtype='object')\n\nDie geänderte Series:\neins    1.0\nzwei    2.0\ndrei    3.0\nName: Fließkommazahlen, dtype: string\n```\n:::\n:::\n\n\n### Aufgabe Series\nÄndern Sie den Datentyp des Objekts 'numerische_series' in Ganzzahl und wählen Sie einen neuen Namen für die Series aus.\n`numerische_series = pd.Series([1, 2, 3], dtype = 'float', index = ['A1', 'B2', 'C3'], name = 'Gleitkommazahlen')`\n\n::: {#tip-dtype .callout-tip collapse=\"true\"}\n## Musterlösung dtype\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nnumerische_series = pd.Series([1, 2, 3], dtype = 'float', index = ['A1', 'B2', 'C3'], name = 'Gleitkommazahlen')\n\nnumerische_series.name = 'Ganzzahlen'\n\n# falls numerische_series vorher vom dtype string ist,\n# muss erst in dtype float konvertiert werden\n# numerische_series = numerische_series.astype('float')\n\nnumerische_series = numerische_series.astype('int')\n\nprint(numerische_series)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA1    1\nB2    2\nC3    3\nName: Ganzzahlen, dtype: int64\n```\n:::\n:::\n\n\n:::\n\n### DataFrame\nEin `DataFrame` wird mit der Funktion `pd.DataFrame([data])` angelegt. data ist listenartig, kann aber aus einem Einzelwert, einer Series, einem Numpy-Array oder aus mehreren Series und Sammeltypen bestehen.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\neinzelwert_df = pd.DataFrame(['Hallo Welt!'])\nprint(einzelwert_df, \"\\n\")\n\ndf_aus_listen = pd.DataFrame([[1, 2, 3], [4, 5, 6]])\nprint(df_aus_listen, \"\\n\")\n\ndf_aus_series = pd.DataFrame([alphanumerische_series, boolean_series])\nprint(df_aus_series, \"\\n\")\n\ndf_aus_verschieden = pd.DataFrame([np.array([True, False, True]), alphanumerische_series, [1, 2, 3]]) # NumPy-Array\nprint(df_aus_verschieden)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             0\n0  Hallo Welt! \n\n   0  1  2\n0  1  2  3\n1  4  5  6 \n\n      0      1     2\n0     a      5     g\n1  True  False  True \n\n      0      1     2\n0  True  False  True\n1     a      5     g\n2     1      2     3\n```\n:::\n:::\n\n\nBeim Anlegen eines DataFrames können ebenfalls verschiedene Parameter übergeben werden:\n\n  - `pd.DataFrame(data, dtype = 'float')` legt den Datentyp des DataFrames für alle Werte fest. Wird der Parameter nicht übergeben, wählt Pandas einen passenden Datentyp für jede Spalte aus.\n\n  - `pd.DataFrame(data, index = ['A1', 'B2', 'C3'])` übergibt Werte für den Index.\n\n  - `pd.DataFrame(data, columns = ['Spalte1', 'Spalte2'])` übergibt Werte für die Spaltenbeschriftung.\n\nUm Daten spaltenweise einzutragen, kann der DataFrame zum einen mit dem Attribut `DataFrame.T` transponiert werden. Dabei müssen die Spaltenbeschriftungen als Argument `index` und die Indexbeschriftung als Argument `columns` übergeben werden.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ndf_transponiert = pd.DataFrame([[1, 2, 3], [True, False, True]], index = ['Spalte 1', 'Spalte 2'], columns = ['Zeile 1', 'Zeile 2', 'Zeile 3']).T\nprint(df_transponiert)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Spalte 1 Spalte 2\nZeile 1        1     True\nZeile 2        2    False\nZeile 3        3     True\n```\n:::\n:::\n\n\nEine direkte Zuordnung der Beschriftungen ist möglich, indem zuerst der transponierte DataFrame angelegt und anschließend über die Attribute `.index` und `.columns` die Beschriftungen eingetragen werden.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ndf_transponiert = pd.DataFrame([[1, 2, 3], [True, False, True]]).T\ndf_transponiert.columns = ['Spalte 1', 'Spalte 2']\ndf_transponiert.index = ['Zeile 1', 'Zeile 2', 'Zeile 3']\nprint(df_transponiert)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Spalte 1 Spalte 2\nZeile 1        1     True\nZeile 2        2    False\nZeile 3        3     True\n```\n:::\n:::\n\n\nDas Anlegen von transponierten DataFrames hat den Nachteil, dass Pandas die Datentypen der eingegebenen Daten spaltenweise verwaltet. Bei der zeilenweise erfolgenden Eingabe von Daten unterschiedlichen Datentyps wird ein für alle Spalten passender Datentyp gewählt. Im folgenden Beispiel wird deshalb von Pandas der Datentyp `object` für gemischte Datentypen gewählt.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ndf_transponiert = pd.DataFrame([[1, 2, 3], ['a', 'b', 'c']], index = ['Zahlen', 'Buchstaben']).T\nprint(df_transponiert)\nprint(f\"\\n{df_transponiert.dtypes}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Zahlen Buchstaben\n0      1          a\n1      2          b\n2      3          c\n\nZahlen        object\nBuchstaben    object\ndtype: object\n```\n:::\n:::\n\n\nZum anderen kann ein DataFrame direkt aus einem Dictionary erzeugt werden. Dabei werden die Schlüssel als Spaltenbeschriftung verwendet.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ndf = pd.DataFrame({'Spalte 1': [1, 2, 3], 'Spalte 2': [4.1, 5.6, 6.0]}, index = ['oben', 'mitte', 'unten'])\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Spalte 1  Spalte 2\noben          1       4.1\nmitte         2       5.6\nunten         3       6.0\n```\n:::\n:::\n\n\nAußerdem kann ein DataFrame durch Zuweisung von Daten erweitert werden.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# einen leeren DataFrame erzeugen\ndf = pd.DataFrame()\n\n# Zuweisung von Daten\ndf['Spaltenbeschriftung'] = [1, 2, 3]\ndf['zweite Spalte'] = alphanumerische_series\n\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Spaltenbeschriftung zweite Spalte\n0                    1             a\n1                    2             5\n2                    3             g\n```\n:::\n:::\n\n\n::: {#tip-index .callout-tip collapse=\"false\"}\n## Der Index\n\nIn den meisten Fällen ist der von 0 bis n-1 reichende Index am praktischsten. Der numerische Index hilft bei der Auswahl von Indexbereichen (Slicing) und der Arbeit mit mehreren Datenstrukturen. Probieren Sie einmal aus, was passiert, wenn Sie einen DataFrame aus zwei Series mit unterschiedlichen Indizes erstellen.\n\nAuch widerspricht das Auslagern beschreibender oder gemessener Variablen in den Index dem Konzept tidy data, einem System zum Strukturieren von Datensätzen, das Sie im [Methodenbaustein Einlesen strukturierter Datensätze](https://bausteine-der-datenanalyse.github.io/m-einlesen-strukturierter-datens-tze/einlesen-strukturierter-datens%C3%A4tze.html) kennenlernen. \n\n:::\n\nBestehende DataFrames können ähnlich wie Series modifiziert werden. Um den Datentyp einer oder mehrerer Spalten zu ändern, wird die Methode `pd.DataFrame.astype()` verwendet.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\ndf = pd.DataFrame({'Spalte 1': ['1', '2', '3'], 'Spalte 2': [True, False, True]})\nprint(f\"Die Datentypen von df:\\n{df.dtypes}\")\n\n# Datentyp von Spalte 1 ändern\ndf['Spalte 1'] = df['Spalte 1'].astype('string')\nprint(f\"\\nDie Datentypen von df:\\n{df.dtypes}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDie Datentypen von df:\nSpalte 1    object\nSpalte 2      bool\ndtype: object\n\nDie Datentypen von df:\nSpalte 1    string[python]\nSpalte 2              bool\ndtype: object\n```\n:::\n:::\n\n\nEbenso kann allen Spalten eines DataFrames ein Datentyp zugewiesen werden.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\ndf = df.astype('string')\nprint(f\"\\nDie Datentypen von df:\\n{df.dtypes}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nDie Datentypen von df:\nSpalte 1    string[python]\nSpalte 2    string[python]\ndtype: object\n```\n:::\n:::\n\n\nUm unterschiedliche Datentypen zuzweisen, wird ein Dictionary verwendet.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\ndf = df.astype({'Spalte 1': 'int', 'Spalte 2': 'bool'})\nprint(f\"\\nDie Datentypen von df:\\n{df.dtypes}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nDie Datentypen von df:\nSpalte 1    int64\nSpalte 2     bool\ndtype: object\n```\n:::\n:::\n\n\nSpaltennamen und Index eines bestehenden `DataFrame` können über entsprechende Attribute oder Methoden verändert werden. Die Spaltennamen können über das Attribut `pd.DataFrame.columns` geändert werden. Dabei wird eine Liste übergeben, deren Länge der Spaltenanzahl entsprechen muss. Der Index kann über das Attribut `pd.DataFrame.index` geändert werden, indem eine Liste zugewiesen wird. Dabei muss die Länge der Liste der Anzahl Zeilen entsprechen. \n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# ändern der Spaltennamen über das Attribut .columns\ndf.columns = ['Spalte1', 'Spalte2']\ndf.index = [1, 2, 3]\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Spalte1  Spalte2\n1        1     True\n2        2     True\n3        3     True\n```\n:::\n:::\n\n\nMit der Methode `pd.DataFrame.rename(columns = {\"alt1\": \"neu1\", \"alt2\": \"neu2\"}, index = {\"alt1\": \"neu1\", \"alt2\": \"neu2\"}, inplace = True)` können Spalten- und Zeilenbeschriftungen als Dictionary übergeben werden. Auf diese Weise können alle oder ausgewählte Beschriftungen geändert werden. Durch das Argument `inplace = True` erfolgt die Zuweisung direkt ohne Neuzuweisung des Objekts.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\ndf.rename(columns = {'Spalte1': 'Spalte_1', 'Spalte2': 'Spalte_2'}, index = {1: 'A1', 2: 'B2', 3: 'C3'}, inplace = True)\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Spalte_1  Spalte_2\nA1         1      True\nB2         2      True\nC3         3      True\n```\n:::\n:::\n\n\nMit der Methode `pd.DataFrame.reset_index(inplace = True, drop = True)` wird der Index auf die Standardwerte zurückgesetzt. Wird der Parameter `drop = False` gesetzt, wird der alte Index als Spalte an Indexposition 0 in den DataFrame eingefügt.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ndf.reset_index(inplace = True, drop = True)\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Spalte_1  Spalte_2\n0         1      True\n1         2      True\n2         3      True\n```\n:::\n:::\n\n\n### Aufgabe DataFrame\nErstellen Sie einen DataFrame.\n  \n  - Die erste Spalte soll die Zahlen von 1 bis 12 enthalten und mit 'Nummer' beschriftet werden. Die zweite Spalte soll die Monatsnamen des Jahres enthalten und mit 'Monat' beschriftet werden.\n  - Fügen Sie nachträglich die Series 'ferien' als dritte Spalte mit der Spaltenbeschriftung 'Ferien' ein.  \n  `ferien = [False, False, False, True, False, True, True, True, False, True, False, True]`\n\n::: {#tip-musterloesungdataframe .callout-tip collapse=\"true\"}\n## Musterlösung\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nferien = [False, False, False, True, False, True, True, True, False, True, False, True]\n\ndf = pd.DataFrame({\n  'Nummer': list(range(1,13)),\n  'Monat': ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],\n})\n\ndf['Ferien'] = ferien\n\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Nummer      Monat  Ferien\n0        1     Januar   False\n1        2    Februar   False\n2        3       März   False\n3        4      April    True\n4        5        Mai   False\n5        6       Juni    True\n6        7       Juli    True\n7        8     August    True\n8        9  September   False\n9       10    Oktober    True\n10      11   November   False\n11      12   Dezember    True\n```\n:::\n:::\n\n\n:::\n\n## Deskriptive Datenanalyse mit Pandas\nPandas bietet einige praktische Funktionen, um den Aufbau eines Datensatzes und die enthaltenen Daten zu beschreiben. Als Beispieldatensatz dienen Daten zur Länge zahnbildender Zellen bei Meerschweinchen, die Vitamin C direkt (VC) oder in Form von Orangensaft (OJ) in unterschiedlichen Dosen erhielten.\n\n:::: {.border}\n\n::::: {#lst-readfile}\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\ndateipfad = \"01-daten/ToothGrowth.csv\"\nmeerschweinchen = pd.read_csv(filepath_or_buffer = dateipfad, sep = ',', header = 0, \\\n  names = ['ID', 'len', 'supp', 'dose'], dtype = {'ID': 'int', 'len': 'float', 'dose': 'float', 'supp': 'category'})\n```\n:::\n\n\n:::::\n\nCrampton, E. W. 1947. „THE GROWTH OF THE ODONTOBLASTS OF THE INCISOR TOOTH AS A CRITERION OF THE VITAMIN C INTAKE OF THE GUINEA PIG“. The Journal of Nutrition 33 (5): 491–504. <https://doi.org/10.1093/jn/33.5.491> \n\nDer Datensatz kann in R mit dem Befehl \"ToothGrowth\" aufgerufen werden.\n::::\n\n&nbsp;\n\nEin Aussschnitt des Datensatzes:\n\n::: {.cell execution_count=22}\n\n::: {.cell-output .cell-output-display execution_count=22}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ID</th>\n      <th>len</th>\n      <th>supp</th>\n      <th>dose</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>4.2</td>\n      <td>VC</td>\n      <td>0.5</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>11</td>\n      <td>16.5</td>\n      <td>VC</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>20</th>\n      <td>21</td>\n      <td>23.6</td>\n      <td>VC</td>\n      <td>2.0</td>\n    </tr>\n    <tr>\n      <th>30</th>\n      <td>31</td>\n      <td>15.2</td>\n      <td>OJ</td>\n      <td>0.5</td>\n    </tr>\n    <tr>\n      <th>40</th>\n      <td>41</td>\n      <td>19.7</td>\n      <td>OJ</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>50</th>\n      <td>51</td>\n      <td>25.5</td>\n      <td>OJ</td>\n      <td>2.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n&nbsp;\n\nDie Methode `pd.DataFrame.info()` erzeugt eine Beschreibung des Datensatzes. \n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nmeerschweinchen.info()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 60 entries, 0 to 59\nData columns (total 4 columns):\n #   Column  Non-Null Count  Dtype   \n---  ------  --------------  -----   \n 0   ID      60 non-null     int64   \n 1   len     60 non-null     float64 \n 2   supp    60 non-null     category\n 3   dose    60 non-null     float64 \ndtypes: category(1), float64(2), int64(1)\nmemory usage: 1.7 KB\n```\n:::\n:::\n\n\nDie Dimensionen einer Series oder eines DataFrame können mit dem Attribut `shape` abgerufen werden. Der DataFrame hat 60 Zeilen und 4 Spalten.\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nprint(meerschweinchen.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(60, 4)\n```\n:::\n:::\n\n\nDie Methode `pd.DataFrame.describe()` erzeugt eine beschreibende Statistik für einen DataFrame. Standardmäßig werden alle numerischen Spalten berücksichtigt. Mit dem Parameter `include` können die zu berücksichtigenden Spalten vorgegeben werden. `include = all` berücksichtigt alle Spalten, was nicht unbedingt sinnvoll ist, da auf diese Weise auch die Spalte mit den ID-Nummern der Meerschweinchen ausgewertet wird.\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nprint(meerschweinchen.describe(include = 'all'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               ID        len supp       dose\ncount   60.000000  60.000000   60  60.000000\nunique        NaN        NaN    2        NaN\ntop           NaN        NaN   OJ        NaN\nfreq          NaN        NaN   30        NaN\nmean    30.500000  18.813333  NaN   1.166667\nstd     17.464249   7.649315  NaN   0.628872\nmin      1.000000   4.200000  NaN   0.500000\n25%     15.750000  13.075000  NaN   0.500000\n50%     30.500000  19.250000  NaN   1.000000\n75%     45.250000  25.275000  NaN   2.000000\nmax     60.000000  33.900000  NaN   2.000000\n```\n:::\n:::\n\n\nMit dem Parameter `include` kann eine Liste zu berücksichtigender Datentypen übergeben werden. Der Parameter `exclude` schließt auf die gleiche Weise Datentypen von der Ausgabe aus.\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nprint(meerschweinchen.describe(include = ['float']))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             len       dose\ncount  60.000000  60.000000\nmean   18.813333   1.166667\nstd     7.649315   0.628872\nmin     4.200000   0.500000\n25%    13.075000   0.500000\n50%    19.250000   1.000000\n75%    25.275000   2.000000\nmax    33.900000   2.000000\n```\n:::\n:::\n\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nprint(meerschweinchen.describe(include = ['category']))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       supp\ncount    60\nunique    2\ntop      OJ\nfreq     30\n```\n:::\n:::\n\n\nDie Methode `pd.DataFrame.count()` zählt alle nicht fehlenden Werte in jeder Spalte oder  mit `pd.DataFrame.count(axis = 'columns')` in jeder Zeile.\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nmeerschweinchen.count(axis = 'rows') # der Standardwert von axis ist 'rows'\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\nID      60\nlen     60\nsupp    60\ndose    60\ndtype: int64\n```\n:::\n:::\n\n\nDie Methode `pd.Series.value_counts()` zählt die Anzahl der Merkmalsausprägungen in einer Series. Die Methode kann auch auf einen DataFrame angewendet werden, dann wird die Häufigkeit jeder einzigartigen Zeile gezählt (was hier nicht sinnvoll ist).\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\nmeerschweinchen['dose'].value_counts()\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\ndose\n0.5    20\n1.0    20\n2.0    20\nName: count, dtype: int64\n```\n:::\n:::\n\n\nDie Methode `pd.unique()` listet alle einzigartigen Werte einer Series auf.\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\nmeerschweinchen['dose'].unique()\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\narray([0.5, 1. , 2. ])\n```\n:::\n:::\n\n\n## Slicing\n::: {.border}\n![zweidimensionaler Datensatz](00-bilder/zweidimensionaler-datensatz-slicing-mf-mp.png){width=\"45%\" fig-alt=\"Dargestellt ist ein zweidimensionaler Block, der einen zweidimensionalen Datensatz repräsentiert. Pfeile repräsentieren die zwei Achsen. Die nullte Achse entspricht der Länge (von oben nach unten) und die erste Achse der Breite des Datensatzes.\"}\n\nslicing von Marc Fehr ist lizensiert unter [CC-BY-4.0](https://github.com/bausteine-der-datenanalyse/w-python-numpy-grundlagen#CC-BY-4.0-1-ov-file) und abrufbar auf [GitHub](https://github.com/bausteine-der-datenanalyse/w-python-numpy-grundlagen). Die Grafik wurde auf den gezeigten Teil beschnitten und die obenstehende Beschriftung entfernt. 2024\n:::\n\n&nbsp;\n\nPandas bringt eigene Werkzeuge für die Auswahl von Indexbereichen mit. Der Slice Operator aus der Pythonbasis wird deshalb nur kurz vorgestellt.\n\n### Slice Operator\nMit dem Slice Operator können wie bei einer Liste Indexbereiche aus einer Series ausgewählt werden.\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\nzehn_zahlen = pd.Series(range(0, 10))\nprint(zehn_zahlen[3:6])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3    3\n4    4\n5    5\ndtype: int64\n```\n:::\n:::\n\n\nMit dem Slice Operator werden die Zeilen eines DataFrames ausgewählt.\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nprint(meerschweinchen[7:12])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    ID   len supp  dose\n7    8  11.2   VC   0.5\n8    9   5.2   VC   0.5\n9   10   7.0   VC   0.5\n10  11  16.5   VC   1.0\n11  12  16.5   VC   1.0\n```\n:::\n:::\n\n\nDurch Angabe eines Spaltennamens wird die entsprechende Spalte ausgewählt, die als Series zurückgegeben wird. Durch das Anfügen eines zweiten Slice Operators ist es möglich, wie bei einem eindimensionalen Datensatz die Werte in einem bestimmten Indexbereich abzurufen. Dies wird verkettete Indexierung genannt.\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\nprint(meerschweinchen['dose'][10:15], \"\\n\")\nprint(type(meerschweinchen['dose'][10:15]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10    1.0\n11    1.0\n12    1.0\n13    1.0\n14    1.0\nName: dose, dtype: float64 \n\n<class 'pandas.core.series.Series'>\n```\n:::\n:::\n\n\n::: {#wrn-chainedassignment .callout-warning appearance=\"simple\"}\n## Verkettete Indexierung\n\nDie verkettete Indexierung erzeugt in Pandas abhängig vom Kontext eine Kopie des Objekts oder greift auf den Speicherbereich des Objekts zu. Mit Pandas 3.0 wird die verkettete Indexierung nicht mehr unterstützt, das Anlegen einer Kopie wird zum Standard werden. Weitere Informationen erhalten Sie im zitierten Link.\n\n:::: {.border layout=\"[5, 90, 5]\"}\n\n&nbsp;\n\n\"Whether a copy or a reference is returned for a setting operation, may depend on the context. This is sometimes called `chained assignment` and should be avoided. See [Returning a View versus Copy](https://pandas.pydata.org/docs/user_guide/indexing.html#indexing-view-versus-copy).\"\n\n&nbsp;\n\n::::\n\n([Pandas Dokumentation](https://pandas.pydata.org/docs/user_guide/indexing.html))\n:::\n\n### Slicing mit Pandas-Methoden\nFür das Slicing von Series und DataFrames werden in Pandas die Methoden `.iloc[]` und `.loc[]` verwendet.\n\n  - `.loc[]` arbeitet mit Index- oder Spaltenbeschriftungen, akzeptiert aber auch ein boolsches Array. \n\n  - `.iloc[]` arbeitet mit Ganzzahlen, akzeptiert aber auch ein boolsches Array.\n\nFür das Slicing von Series wird eine Bereichsangabe übergeben, bspw. `pd.Series.iloc[5:8]`. Für das Slicing von DataFrames werden zwei durch ein Komma getrennte Bereichsangaben übergeben, wobei an erster Stelle die Zeilen und an zweiter Stelle die Spalten ausgewählt werden, bspw. `pd.DataFrame.iloc[5, 2:4]`. Um alle Zeilen oder Spalten auszuwählen kann der Doppelpunkt verwendet werden, etwa `pd.DataFrame.iloc[5, :]`.\n\n#### Beschriftungsbasiertes Slicing mit .loc[]\n\nFür eine Series interpretiert `.loc` übergebene Zeichen als Indexbeschriftung. Buchstaben und andere Zeichen werden wie strings in Anführungszeichen übergeben, bspw. `.loc['e']`, Zahlen ohne Anführungszeichen. Neben Einzelwerten (`'a'` oder `0`) können Listen oder Arrays (`['a', 'b', 'c']` oder `[1, 2, 3]`) und Slices übergeben werden (`'a':'c'` oder `0:2`). Das Slicing mit einem Einzelwert führt zur Rückgabe eines Einzelwerts (sog. Skalar).\n\n::: {#wrn-inklusiveslicing .callout-warning appearance=\"simple\"}\n## inklusives Slicing\n\nAnders als die Pythonbasis und das Slicing mit `.iloc[]` zählt Pandas beim beschriftungsbasiertem Slicing inklusiv, gibt also die letzte ausgewählte Position mit aus.\n:::\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# Nummern\nzehn_zahlen = pd.Series(range(0, 10))\nprint(\"Rückgabe eines Einzelwerts:\", zehn_zahlen.loc[5]) # Einzelwert\nprint(zehn_zahlen.loc[[2, 4, 7]]) # Liste\nprint(zehn_zahlen.loc[5:7], \"\\n\") # Slice\n\n# Buchstaben und andere Zeichen\nsechs_zahlen = pd.Series(list(range(0, 6)), index = ['a', 'b', 'c', 'd', 'e', 'f'])\nprint(\"Rückgabe eines Einzelwerts:\", sechs_zahlen.loc['c']) # Einzelwert\nprint(sechs_zahlen.loc[['c', 'f', 'a']]) # Liste\nprint(sechs_zahlen.loc['c':'e']) # Slice\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRückgabe eines Einzelwerts: 5\n2    2\n4    4\n7    7\ndtype: int64\n5    5\n6    6\n7    7\ndtype: int64 \n\nRückgabe eines Einzelwerts: 2\nc    2\nf    5\na    0\ndtype: int64\nc    2\nd    3\ne    4\ndtype: int64\n```\n:::\n:::\n\n\nDie Interpretation als Beschriftung bedeutet, dass bei einem nicht numerischen Index  als Slice übergebene Zahlen nicht gefunden werden. Hier muss mit der übergebenen Beschriftung gearbeitet werden.\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\ntry:\n  print(sechs_zahlen.loc[2:4])\nexcept Exception as error:\n  print(error)\n\nprint(\"\\n\", sechs_zahlen.loc['c':'e'], sep = \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncannot do slice indexing on Index with these indexers [2] of type int\n\n\nc    2\nd    3\ne    4\ndtype: int64\n```\n:::\n:::\n\n\nFür DataFrames funktioniert das Slicing genauso.\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\nprint(meerschweinchen.loc[18:22, ['len', 'dose']])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     len  dose\n18  18.8   1.0\n19  15.5   1.0\n20  23.6   2.0\n21  18.5   2.0\n22  33.9   2.0\n```\n:::\n:::\n\n\n### Indexbasiertes Slicing mit .iloc[]\nDie Methode `.iloc[]` ermöglicht die Auswahl von Ausschnitten basierend auf Indexpositionen. Die Methode akzeptiert die gleichen Eingaben wie die Methode `.loc[]`.\n\n::: {#wrn-exklusiveslicing .callout-warning appearance=\"simple\"}\n## exklusives Slicing\n\nBeim Slicing mit der Methode `.iloc[]` zählt Pandas wie die Pythonbasis exklusiv.\n:::\n\nDas Slicing mit Einzelwerten führt zur Ausgabe eines Einzelwertes. Die Methode akzeptiert ebenfalls eine Liste oder ein Slice.\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\nprint(\"Rückgabe eines Einzelwerts:\", meerschweinchen.iloc[27, 2]) # Einzelwerte\nprint(meerschweinchen.iloc[[27, 29, 52], 2:4]) # Liste und Slice\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRückgabe eines Einzelwerts: VC\n   supp  dose\n27   VC   2.0\n29   VC   2.0\n52   OJ   2.0\n```\n:::\n:::\n\n\n#### Die Methoden .head() und .tail()\nVereinfachte Varianten des indexbasierten Slicings sind die Methoden `.head(n=5)` und `.tail(n=5)`, mit denen die ersten bzw. letzten n Zeilen eines DataFrame oder einer Series ausgegeben werden  können. Über den optionalen Paramenter `n` kann die Anzahl der angezeigten Zeilen gesteuert werden. Die Methoden eignen sich gut, um sich einen ersten Eindruck von einem Datensatz zu verschaffen.\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\nprint(meerschweinchen.head(3), \"\\n\")\nprint(meerschweinchen.tail(3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   ID   len supp  dose\n0   1   4.2   VC   0.5\n1   2  11.5   VC   0.5\n2   3   7.3   VC   0.5 \n\n    ID   len supp  dose\n57  58  27.3   OJ   2.0\n58  59  29.4   OJ   2.0\n59  60  23.0   OJ   2.0\n```\n:::\n:::\n\n\nEbenso können Series damit betrachtet werden.\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\nprint(meerschweinchen['len'].tail(3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n57    27.3\n58    29.4\n59    23.0\nName: len, dtype: float64\n```\n:::\n:::\n\n\n## Aufgaben Slicing\nGegeben ist eine Pandas Series 'temperaturen_2021' mit den durchschnittlichen Monatstemperaturen.\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\ntemperaturen_2021 = pd.Series([2, 4, 7, 12, 19, 23, 25, 23, 18, 15, 9, 5],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n```\n:::\n\n\n1. Wählen Sie die Temperaturen für die Frühlingsmonate (März bis Mai) aus.\n\n2. Wählen Sie die Temperaturen für die letzten drei Monate des Jahres einmal mit Hilfe des Slicing Operators und einmal mit Hilfe der Pandas-Methoden aus.\n\n3. Wählen Sie mit der Methode `.loc[]` die Spalten 'dose' und 'len' des DataFrame meerschweinchen aus und geben Sie die ersten 4 und die letzten 3 Zeilen aus. (Code zum Einlesen der Datei siehe @lst-readfile)  \n\n4. Die Methoden `.loc[]` und `.iloc[]` akzeptieren auch ein boolsches Array als Eingabe. Geben Sie aus der Spalte 'dose' des DataFrame meerschweinchen alle Zeilen mit dem Wert 2.0 aus.\n\n::: {#tip-dose .callout-tip collapse=\"true\"}\n## Musterlösung Slicing\n\nAufgabe 1\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\nprint(temperaturen_2021.loc[['Mär', 'Apr', 'Mai']])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMär     7\nApr    12\nMai    19\ndtype: int64\n```\n:::\n:::\n\n\nAufgabe 2\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\nprint(temperaturen_2021[-3:], \"\\n\")\nprint(temperaturen_2021.iloc[-3:])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOkt    15\nNov     9\nDez     5\ndtype: int64 \n\nOkt    15\nNov     9\nDez     5\ndtype: int64\n```\n:::\n:::\n\n\nAufgabe 3\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\nprint(meerschweinchen.loc[ :, ['dose', 'len']].head(n = 4), \"\\n\")\nprint(meerschweinchen.loc[ :, ['dose', 'len']].tail(n = 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   dose   len\n0   0.5   4.2\n1   0.5  11.5\n2   0.5   7.3\n3   0.5   5.8 \n\n    dose   len\n57   2.0  27.3\n58   2.0  29.4\n59   2.0  23.0\n```\n:::\n:::\n\n\nAufgabe 4\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\n# Slice aus Series\n# print(meerschweinchen['dose'].loc[meerschweinchen['dose'] == 2.0])\n\n# Slice aus DataFrame\nprint(meerschweinchen.loc[meerschweinchen['dose'] == 2.0, ['dose']])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    dose\n20   2.0\n21   2.0\n22   2.0\n23   2.0\n24   2.0\n25   2.0\n26   2.0\n27   2.0\n28   2.0\n29   2.0\n50   2.0\n51   2.0\n52   2.0\n53   2.0\n54   2.0\n55   2.0\n56   2.0\n57   2.0\n58   2.0\n59   2.0\n```\n:::\n:::\n\n\n:::\n\n## Datenstrukturen verbinden\nDataFrames sind flexible Datenspeicher. Mit der Funktion `pd.concat()` können Series und DataFrames zusammengeführt werden.\n\n - Mit dem Argument `pd.concat(ignore_index = True)` wird ein neuer Index generiert.\n - Mit dem Argument `pd.concat(axis = 1)` werden die übergebenen objekte spaltenweise zusammengeführt.\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\nseries_1 = pd.Series([1, 2])\nseries_2 = pd.Series([4, 5])\nprint(pd.concat([series_1, series_2]), \"\\n\")\nprint(pd.concat([series_1, series_2], ignore_index = True), \"\\n\")\nprint(pd.concat([series_1, series_2], ignore_index = True, axis = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0    1\n1    2\n0    4\n1    5\ndtype: int64 \n\n0    1\n1    2\n2    4\n3    5\ndtype: int64 \n\n   0  1\n0  1  4\n1  2  5\n```\n:::\n:::\n\n\nGleichermaßen können DataFrames verbunden werden.\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\ntemperaturen_2021 = pd.Series([2, 4, 7, 12, 19, 23, 25, 23, 18, 15, 9, 5],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\ntemperaturen_2022 = pd.Series([3, 6, 9, 13, 18, 21, 24, 23, 19, 14, 8, 4],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\ntemperaturen_2023 = pd.Series([-3, -1, 4, 9, 15, 20, 20, 19, 16, 15, 7, 6],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\ntemperaturen_2024 = pd.Series([-1, 2, 5, 8, 17, 24, 25, 20, 17, 14, 9, 2],\n                         index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', \n                         'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'])\n\n# Series zu DataFrame verbinden\ndf1 = pd.concat([temperaturen_2021, temperaturen_2022], axis = 1)\ndf2 = pd.concat([temperaturen_2023, temperaturen_2024], axis = 1)\n\n# DataFrames verbinden\ntemperaturen = pd.concat([df1, df2], axis = 1)\ntemperaturen.columns = [2021, 2022, 2023, 2024]\nprint(temperaturen)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     2021  2022  2023  2024\nJan     2     3    -3    -1\nFeb     4     6    -1     2\nMär     7     9     4     5\nApr    12    13     9     8\nMai    19    18    15    17\nJun    23    21    20    24\nJul    25    24    20    25\nAug    23    23    19    20\nSep    18    19    16    17\nOkt    15    14    15    14\nNov     9     8     7     9\nDez     5     4     6     2\n```\n:::\n:::\n\n\n## Einfügen und löschen in Datenstrukturen\nDer Operator `del` aus der Pythonbasis löscht Spalten aus einem DataFrame, zum Beispiel: `del DataFrame['Spaltenname']`. Pandas bringt aber auch eigene Methoden mit, um Einträge zeilen- / oder spaltenweise zu ergänzen und zu löschen.\n\n  - `pd.DataFrame.drop(labels = None, axis = 0, index = None, columns = None, inplace = False)` entfernt Zeilen oder Spalten nach den mit dem Parameter `labels` als Einzelwert (`'Spalte 1'`) oder als Liste (`['Spalte 1', 'Spalte 2']`) übergebenen Beschriftungen. Der Parameter `axis` steuert, ob Zeilen oder Spalten (`axis = 1`) entfernt werden sollen. Die Parameter `index` und `columns` sind  alternative Möglichkeiten, Index- oder Spaltenbeschriftungen direkt zu übergeben und ersetzen die Parameter `labels` und `axis`.\n\n  - `pd.DataFrame.insert(loc, column, value)` fügt eine Spalte an Position `loc` mit dem Spaltennamen `column` und dem Inhalt `value` ein. Falls `value` eine Series mit abweichendem Index ist, kann über das Attribut `value = Series.values` auf die enthaltenen Werte der Series zugegriffen und diese in den bestehenden Index einfgefügt werden (andernfalls gleicht Pandas die Indizes der Series und des DataFrames ab und fügt nur die Werte übereinstimmender Indizes ein).\n\n  - Werte können zeilenweise mit der Methode `pd.DataFrame.loc[index] = value` eingefügt werden. Falls `value` eine Series ist, muss über das Attribut `value = Series.values` auf die enthaltenen Werte der Series zugegriffen werden, da Pandas andernfalls versucht, den Index der Series mit den Spaltennamen des DataFrames abzugleichen. Wird als `value` ein Einzelwert übergeben, füllt dieser die gesamte Zeile aus.\n\n## Aufgaben verbinden und löschen\nLegen Sie einen leeren DataFrame `df = pd.DataFrame()` an.\n\n1. Fügen Sie die Spalten 'len' und 'dose' aus dem DataFrame 'meerschweinchen' ein.\n\n2. Löschen Sie alle ungeraden Zeilen aus dem DataFrame df.\n\n3. Benutzen Sie die Indizes der verbleibenden geraden Zeilen des DataFrame df, um die entsprechenden Zeilen aus der Spalte 'ID' des DataFrame 'meerschweinchen' auszuwählen. Fügen Sie diese als Spalte an Indexposition 0 in den DataFrame df ein.\n\n::: {#tip-mergeanddelete .callout-tip collapse=\"true\"}\n## Musterlösung verbinden und löschen\n\n1. Aufgabe\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\ndf = pd.DataFrame()\n\n# Alternative 1\ndf['len'] = meerschweinchen['len']\n\n# Alternative 2\ndf.insert(loc = 1, column = 'dose', value = meerschweinchen['dose'])\n\nprint(df.head(), \"\\n\", df.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    len  dose\n0   4.2   0.5\n1  11.5   0.5\n2   7.3   0.5\n3   5.8   0.5\n4   6.4   0.5 \n (60, 2)\n```\n:::\n:::\n\n\n2. Aufgabe\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\ndf = df.drop(index = range(1, len(df), 2))\n\nprint(df.head(), \"\\n\", df.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    len  dose\n0   4.2   0.5\n2   7.3   0.5\n4   6.4   0.5\n6  11.2   0.5\n8   5.2   0.5 \n (30, 2)\n```\n:::\n:::\n\n\n3. Aufgabe\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\ndf.insert(loc = 0, column = 'ID', value = meerschweinchen.loc[df.index, 'ID'])\n\nprint(df.head(), \"\\n\")\nprint(df.tail(), \"\\n\")\nprint(\"df.shape:\", df.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   ID   len  dose\n0   1   4.2   0.5\n2   3   7.3   0.5\n4   5   6.4   0.5\n6   7  11.2   0.5\n8   9   5.2   0.5 \n\n    ID   len  dose\n50  51  25.5   2.0\n52  53  22.4   2.0\n54  55  24.8   2.0\n56  57  26.4   2.0\n58  59  29.4   2.0 \n\ndf.shape: (30, 3)\n```\n:::\n:::\n\n\n:::\n\n## Quellen {-}\n<https://pandas.pydata.org/docs/user_guide/dsintro.html>\n<https://pandas.pydata.org/docs/user_guide/basics.html>\n\n",
    "supporting": [
      "einleitung_files/figure-pdf"
    ],
    "filters": []
  }
}