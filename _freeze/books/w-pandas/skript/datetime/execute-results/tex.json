{
  "hash": "160a7535b9b65e902edf8e4ce75998c8",
  "result": {
    "engine": "jupyter",
    "markdown": "# Zeitreihen\nDie Verarbeitung von Datums- und Zeitinformationen wird in Python durch verschiedene Module ermöglicht. Einleitend werden einige dieser Module kurz vorgestellt, da in der Dokumentation gelegentlich auf diese verwiesen wird. Pandas bietet einen einheitlichen Zugang zu den meisten dieser Funktionen und verwendet die NumPy Datentypen `datetime64` und `timedelta64`.\n\n  - Der Datentyp `datetime64` beschreibt einen bestimmten Zeitpunkt an einem bestimmten Datum und gehört zu der Klasse `Timestamp`. Der Datentyp hat die Einheit Nanosekunden und kann Informationen über die Zeitzone speichern.\n\n  - Der Datentyp `timedelta64` beschreibt eine absolute Zeitdauer in der Einheit Nanosekunden und gehört zu der Klasse `Timedelta`.\n\n\n\n## Datums- und Zeitinformationen in Python\nIn Python gibt es einige Module zur Verarbeitung von Datums- und Zeitinformationen.\n\n  - Das Modul time stellt Zeit- und Datumsoperationen mit Objekten vom Typ `struct_time` bereit. ([Dokumentation des Moduls time](https://docs.python.org/3/library/time.html))\n\n  - Das Modul datetime führt die Datentypen `datetime` und `timedelta`, zusätzliche Methoden für die Bearbeitung und die Ausgabe von Datums- und Zeitinformationen ein. Das Modul kann Jahreszahlen von 1 bis 9999 nach unserer Zeitrechnung im Gregorianischen Kalender verarbeiten. ([Dokumentation des Moduls datetime](https://docs.python.org/3/library/datetime.html#))\n       \n  - Das Modul calendar führt verschiedene Kalenderfunktionen ein und erweitert den verarbeitbaren Zeitraum. Basierend auf dem Gregorianischen Kalender reicht dieser in beide Richtungen ins Unendliche. ([Dokumentation des Moduls calendar](https://docs.python.org/3/library/calendar.html#module-calendar))\n\n  - Das Modul pytz führt die IANA-Zeitzonendatenbank (Internet Assigned Numbers Authority) für Anwendungsprogramme und Betriebssysteme ein (auch Olsen-Datenbank genannt). Die IANA-Datenbank beinhaltet die Zeitzonen und Änderungen der Zeit seit 1970. ([Wikipedia](https://de.wikipedia.org/wiki/Zeitzonen-Datenbank)) Das Modul pytz sorgt für eine korrekte Berechnung von Zeiten zum Ende der Zeitumstellung (Ende Sommerzeit) über Zeitzonen hinweg. ([Dokumentation pytz](https://pythonhosted.org/pytz/))\n\n  - NumPy führt die Datentypen `datetime64` und `timedelta64` ein. Diese basieren auf dem Gregorianischen Kalender und reichen in beide Richtungen ins Unendliche. <https://numpy.org/doc/stable/reference/arrays.datetime.html>\n\n  - Pandas nutzt die NumPy-Datentypen `datetime64` und `timedelta64` und ergänzt zahlreiche Funktionen zur Verarbeitung von Datums- und Zeitinformationen aus anderen Paketen. <https://pandas.pydata.org/docs/user_guide/timeseries.html>\n\nNumPy und Pandas können Datetime-Objekte anderer Module in den Datentyp `datetime64` umwandeln.\n\n### Naive und bewusste Datetime-Objekte\nDatetime-Objekte werden abhängig davon, ob sie Informationen über Zeitzonen enthalten, als naiv (naive) oder als bewusst (aware) bezeichnet. Naiven Datetime-Objekten fehlt diese Information, bewusste Datetime-Objekte enthalten diese. Objekte der Module time, datetime und Pandas verfügen über ein Zeitzonenattribut, sind also bewusst. `np.datetime64` ist seit NumPy-Version 1.11.0 ein naiver Datentyp, unterstützt aber Zeitzonen aus Gründen der Rückwärtskompatibilität.\n\n::: {.border layout=\"[5, 90, 5]\"}\n\n&nbsp;\n\n\"Deprecated since version 1.11.0: NumPy does not store timezone information. For backwards compatibility, datetime64 still parses timezone offsets, which it handles by converting to UTC±00:00 (Zulu time). This behaviour is deprecated and will raise an error in the future.\" [NumPy Dokumentation](https://numpy.org/doc/stable/reference/arrays.datetime.html)  \n\n&nbsp;\n\n:::\n\n#### Zeitzonen\nPandas kann mit Zeitzonen umgehen und datetime-Objekte von einer in eine andere Zeitzone umwandeln. Über das Argument `tz` kann in verschiedenen Funktionen die Zeitzone angegeben werden.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nzeitreihe = pd.Series(pd.date_range(start = \"2023-03-26T00:00\", end = \"2023-03-27T00:00\", freq = \"3h\", tz = \"turkey\"))\nzeitreihe\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n0   2023-03-26 00:00:00+03:00\n1   2023-03-26 03:00:00+03:00\n2   2023-03-26 06:00:00+03:00\n3   2023-03-26 09:00:00+03:00\n4   2023-03-26 12:00:00+03:00\n5   2023-03-26 15:00:00+03:00\n6   2023-03-26 18:00:00+03:00\n7   2023-03-26 21:00:00+03:00\n8   2023-03-27 00:00:00+03:00\ndtype: datetime64[ns, Turkey]\n```\n:::\n:::\n\n\nMit der Funktion `pd.to_datetime(arg, utc = True)` kann die Zeitzone in die koordinierte Universalzeit UTC umgewandelt werden.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\npd.to_datetime(zeitreihe, utc = True)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n0   2023-03-25 21:00:00+00:00\n1   2023-03-26 00:00:00+00:00\n2   2023-03-26 03:00:00+00:00\n3   2023-03-26 06:00:00+00:00\n4   2023-03-26 09:00:00+00:00\n5   2023-03-26 12:00:00+00:00\n6   2023-03-26 15:00:00+00:00\n7   2023-03-26 18:00:00+00:00\n8   2023-03-26 21:00:00+00:00\ndtype: datetime64[ns, UTC]\n```\n:::\n:::\n\n\nEine Umwandlung in beliebige Zeitzonen ist mit der Methode `pd.Series.dt.tz_convert(tz = 'utc')` möglich.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nzeitreihe.dt.tz_convert(tz = 'portugal')\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n0   2023-03-25 21:00:00+00:00\n1   2023-03-26 00:00:00+00:00\n2   2023-03-26 04:00:00+01:00\n3   2023-03-26 07:00:00+01:00\n4   2023-03-26 10:00:00+01:00\n5   2023-03-26 13:00:00+01:00\n6   2023-03-26 16:00:00+01:00\n7   2023-03-26 19:00:00+01:00\n8   2023-03-26 22:00:00+01:00\ndtype: datetime64[ns, Portugal]\n```\n:::\n:::\n\n\n::: {#nte-zeitzonen .callout-note collapse=\"true\"}\n## verfügbare Zeitzonen ermitteln\nDer folgende Code gibt die in Python verfügbaren Zeitzonen aus.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nfrom zoneinfo import available_timezones\n\nfor timezone in sorted(available_timezones()):\n  print(timezone)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAfrica/Abidjan\nAfrica/Accra\nAfrica/Addis_Ababa\nAfrica/Algiers\nAfrica/Asmara\nAfrica/Asmera\nAfrica/Bamako\nAfrica/Bangui\nAfrica/Banjul\nAfrica/Bissau\nAfrica/Blantyre\nAfrica/Brazzaville\nAfrica/Bujumbura\nAfrica/Cairo\nAfrica/Casablanca\nAfrica/Ceuta\nAfrica/Conakry\nAfrica/Dakar\nAfrica/Dar_es_Salaam\nAfrica/Djibouti\nAfrica/Douala\nAfrica/El_Aaiun\nAfrica/Freetown\nAfrica/Gaborone\nAfrica/Harare\nAfrica/Johannesburg\nAfrica/Juba\nAfrica/Kampala\nAfrica/Khartoum\nAfrica/Kigali\nAfrica/Kinshasa\nAfrica/Lagos\nAfrica/Libreville\nAfrica/Lome\nAfrica/Luanda\nAfrica/Lubumbashi\nAfrica/Lusaka\nAfrica/Malabo\nAfrica/Maputo\nAfrica/Maseru\nAfrica/Mbabane\nAfrica/Mogadishu\nAfrica/Monrovia\nAfrica/Nairobi\nAfrica/Ndjamena\nAfrica/Niamey\nAfrica/Nouakchott\nAfrica/Ouagadougou\nAfrica/Porto-Novo\nAfrica/Sao_Tome\nAfrica/Timbuktu\nAfrica/Tripoli\nAfrica/Tunis\nAfrica/Windhoek\nAmerica/Adak\nAmerica/Anchorage\nAmerica/Anguilla\nAmerica/Antigua\nAmerica/Araguaina\nAmerica/Argentina/Buenos_Aires\nAmerica/Argentina/Catamarca\nAmerica/Argentina/ComodRivadavia\nAmerica/Argentina/Cordoba\nAmerica/Argentina/Jujuy\nAmerica/Argentina/La_Rioja\nAmerica/Argentina/Mendoza\nAmerica/Argentina/Rio_Gallegos\nAmerica/Argentina/Salta\nAmerica/Argentina/San_Juan\nAmerica/Argentina/San_Luis\nAmerica/Argentina/Tucuman\nAmerica/Argentina/Ushuaia\nAmerica/Aruba\nAmerica/Asuncion\nAmerica/Atikokan\nAmerica/Atka\nAmerica/Bahia\nAmerica/Bahia_Banderas\nAmerica/Barbados\nAmerica/Belem\nAmerica/Belize\nAmerica/Blanc-Sablon\nAmerica/Boa_Vista\nAmerica/Bogota\nAmerica/Boise\nAmerica/Buenos_Aires\nAmerica/Cambridge_Bay\nAmerica/Campo_Grande\nAmerica/Cancun\nAmerica/Caracas\nAmerica/Catamarca\nAmerica/Cayenne\nAmerica/Cayman\nAmerica/Chicago\nAmerica/Chihuahua\nAmerica/Ciudad_Juarez\nAmerica/Coral_Harbour\nAmerica/Cordoba\nAmerica/Costa_Rica\nAmerica/Coyhaique\nAmerica/Creston\nAmerica/Cuiaba\nAmerica/Curacao\nAmerica/Danmarkshavn\nAmerica/Dawson\nAmerica/Dawson_Creek\nAmerica/Denver\nAmerica/Detroit\nAmerica/Dominica\nAmerica/Edmonton\nAmerica/Eirunepe\nAmerica/El_Salvador\nAmerica/Ensenada\nAmerica/Fort_Nelson\nAmerica/Fort_Wayne\nAmerica/Fortaleza\nAmerica/Glace_Bay\nAmerica/Godthab\nAmerica/Goose_Bay\nAmerica/Grand_Turk\nAmerica/Grenada\nAmerica/Guadeloupe\nAmerica/Guatemala\nAmerica/Guayaquil\nAmerica/Guyana\nAmerica/Halifax\nAmerica/Havana\nAmerica/Hermosillo\nAmerica/Indiana/Indianapolis\nAmerica/Indiana/Knox\nAmerica/Indiana/Marengo\nAmerica/Indiana/Petersburg\nAmerica/Indiana/Tell_City\nAmerica/Indiana/Vevay\nAmerica/Indiana/Vincennes\nAmerica/Indiana/Winamac\nAmerica/Indianapolis\nAmerica/Inuvik\nAmerica/Iqaluit\nAmerica/Jamaica\nAmerica/Jujuy\nAmerica/Juneau\nAmerica/Kentucky/Louisville\nAmerica/Kentucky/Monticello\nAmerica/Knox_IN\nAmerica/Kralendijk\nAmerica/La_Paz\nAmerica/Lima\nAmerica/Los_Angeles\nAmerica/Louisville\nAmerica/Lower_Princes\nAmerica/Maceio\nAmerica/Managua\nAmerica/Manaus\nAmerica/Marigot\nAmerica/Martinique\nAmerica/Matamoros\nAmerica/Mazatlan\nAmerica/Mendoza\nAmerica/Menominee\nAmerica/Merida\nAmerica/Metlakatla\nAmerica/Mexico_City\nAmerica/Miquelon\nAmerica/Moncton\nAmerica/Monterrey\nAmerica/Montevideo\nAmerica/Montreal\nAmerica/Montserrat\nAmerica/Nassau\nAmerica/New_York\nAmerica/Nipigon\nAmerica/Nome\nAmerica/Noronha\nAmerica/North_Dakota/Beulah\nAmerica/North_Dakota/Center\nAmerica/North_Dakota/New_Salem\nAmerica/Nuuk\nAmerica/Ojinaga\nAmerica/Panama\nAmerica/Pangnirtung\nAmerica/Paramaribo\nAmerica/Phoenix\nAmerica/Port-au-Prince\nAmerica/Port_of_Spain\nAmerica/Porto_Acre\nAmerica/Porto_Velho\nAmerica/Puerto_Rico\nAmerica/Punta_Arenas\nAmerica/Rainy_River\nAmerica/Rankin_Inlet\nAmerica/Recife\nAmerica/Regina\nAmerica/Resolute\nAmerica/Rio_Branco\nAmerica/Rosario\nAmerica/Santa_Isabel\nAmerica/Santarem\nAmerica/Santiago\nAmerica/Santo_Domingo\nAmerica/Sao_Paulo\nAmerica/Scoresbysund\nAmerica/Shiprock\nAmerica/Sitka\nAmerica/St_Barthelemy\nAmerica/St_Johns\nAmerica/St_Kitts\nAmerica/St_Lucia\nAmerica/St_Thomas\nAmerica/St_Vincent\nAmerica/Swift_Current\nAmerica/Tegucigalpa\nAmerica/Thule\nAmerica/Thunder_Bay\nAmerica/Tijuana\nAmerica/Toronto\nAmerica/Tortola\nAmerica/Vancouver\nAmerica/Virgin\nAmerica/Whitehorse\nAmerica/Winnipeg\nAmerica/Yakutat\nAmerica/Yellowknife\nAntarctica/Casey\nAntarctica/Davis\nAntarctica/DumontDUrville\nAntarctica/Macquarie\nAntarctica/Mawson\nAntarctica/McMurdo\nAntarctica/Palmer\nAntarctica/Rothera\nAntarctica/South_Pole\nAntarctica/Syowa\nAntarctica/Troll\nAntarctica/Vostok\nArctic/Longyearbyen\nAsia/Aden\nAsia/Almaty\nAsia/Amman\nAsia/Anadyr\nAsia/Aqtau\nAsia/Aqtobe\nAsia/Ashgabat\nAsia/Ashkhabad\nAsia/Atyrau\nAsia/Baghdad\nAsia/Bahrain\nAsia/Baku\nAsia/Bangkok\nAsia/Barnaul\nAsia/Beirut\nAsia/Bishkek\nAsia/Brunei\nAsia/Calcutta\nAsia/Chita\nAsia/Choibalsan\nAsia/Chongqing\nAsia/Chungking\nAsia/Colombo\nAsia/Dacca\nAsia/Damascus\nAsia/Dhaka\nAsia/Dili\nAsia/Dubai\nAsia/Dushanbe\nAsia/Famagusta\nAsia/Gaza\nAsia/Harbin\nAsia/Hebron\nAsia/Ho_Chi_Minh\nAsia/Hong_Kong\nAsia/Hovd\nAsia/Irkutsk\nAsia/Istanbul\nAsia/Jakarta\nAsia/Jayapura\nAsia/Jerusalem\nAsia/Kabul\nAsia/Kamchatka\nAsia/Karachi\nAsia/Kashgar\nAsia/Kathmandu\nAsia/Katmandu\nAsia/Khandyga\nAsia/Kolkata\nAsia/Krasnoyarsk\nAsia/Kuala_Lumpur\nAsia/Kuching\nAsia/Kuwait\nAsia/Macao\nAsia/Macau\nAsia/Magadan\nAsia/Makassar\nAsia/Manila\nAsia/Muscat\nAsia/Nicosia\nAsia/Novokuznetsk\nAsia/Novosibirsk\nAsia/Omsk\nAsia/Oral\nAsia/Phnom_Penh\nAsia/Pontianak\nAsia/Pyongyang\nAsia/Qatar\nAsia/Qostanay\nAsia/Qyzylorda\nAsia/Rangoon\nAsia/Riyadh\nAsia/Saigon\nAsia/Sakhalin\nAsia/Samarkand\nAsia/Seoul\nAsia/Shanghai\nAsia/Singapore\nAsia/Srednekolymsk\nAsia/Taipei\nAsia/Tashkent\nAsia/Tbilisi\nAsia/Tehran\nAsia/Tel_Aviv\nAsia/Thimbu\nAsia/Thimphu\nAsia/Tokyo\nAsia/Tomsk\nAsia/Ujung_Pandang\nAsia/Ulaanbaatar\nAsia/Ulan_Bator\nAsia/Urumqi\nAsia/Ust-Nera\nAsia/Vientiane\nAsia/Vladivostok\nAsia/Yakutsk\nAsia/Yangon\nAsia/Yekaterinburg\nAsia/Yerevan\nAtlantic/Azores\nAtlantic/Bermuda\nAtlantic/Canary\nAtlantic/Cape_Verde\nAtlantic/Faeroe\nAtlantic/Faroe\nAtlantic/Jan_Mayen\nAtlantic/Madeira\nAtlantic/Reykjavik\nAtlantic/South_Georgia\nAtlantic/St_Helena\nAtlantic/Stanley\nAustralia/ACT\nAustralia/Adelaide\nAustralia/Brisbane\nAustralia/Broken_Hill\nAustralia/Canberra\nAustralia/Currie\nAustralia/Darwin\nAustralia/Eucla\nAustralia/Hobart\nAustralia/LHI\nAustralia/Lindeman\nAustralia/Lord_Howe\nAustralia/Melbourne\nAustralia/NSW\nAustralia/North\nAustralia/Perth\nAustralia/Queensland\nAustralia/South\nAustralia/Sydney\nAustralia/Tasmania\nAustralia/Victoria\nAustralia/West\nAustralia/Yancowinna\nBrazil/Acre\nBrazil/DeNoronha\nBrazil/East\nBrazil/West\nCET\nCST6CDT\nCanada/Atlantic\nCanada/Central\nCanada/Eastern\nCanada/Mountain\nCanada/Newfoundland\nCanada/Pacific\nCanada/Saskatchewan\nCanada/Yukon\nChile/Continental\nChile/EasterIsland\nCuba\nEET\nEST\nEST5EDT\nEgypt\nEire\nEtc/GMT\nEtc/GMT+0\nEtc/GMT+1\nEtc/GMT+10\nEtc/GMT+11\nEtc/GMT+12\nEtc/GMT+2\nEtc/GMT+3\nEtc/GMT+4\nEtc/GMT+5\nEtc/GMT+6\nEtc/GMT+7\nEtc/GMT+8\nEtc/GMT+9\nEtc/GMT-0\nEtc/GMT-1\nEtc/GMT-10\nEtc/GMT-11\nEtc/GMT-12\nEtc/GMT-13\nEtc/GMT-14\nEtc/GMT-2\nEtc/GMT-3\nEtc/GMT-4\nEtc/GMT-5\nEtc/GMT-6\nEtc/GMT-7\nEtc/GMT-8\nEtc/GMT-9\nEtc/GMT0\nEtc/Greenwich\nEtc/UCT\nEtc/UTC\nEtc/Universal\nEtc/Zulu\nEurope/Amsterdam\nEurope/Andorra\nEurope/Astrakhan\nEurope/Athens\nEurope/Belfast\nEurope/Belgrade\nEurope/Berlin\nEurope/Bratislava\nEurope/Brussels\nEurope/Bucharest\nEurope/Budapest\nEurope/Busingen\nEurope/Chisinau\nEurope/Copenhagen\nEurope/Dublin\nEurope/Gibraltar\nEurope/Guernsey\nEurope/Helsinki\nEurope/Isle_of_Man\nEurope/Istanbul\nEurope/Jersey\nEurope/Kaliningrad\nEurope/Kiev\nEurope/Kirov\nEurope/Kyiv\nEurope/Lisbon\nEurope/Ljubljana\nEurope/London\nEurope/Luxembourg\nEurope/Madrid\nEurope/Malta\nEurope/Mariehamn\nEurope/Minsk\nEurope/Monaco\nEurope/Moscow\nEurope/Nicosia\nEurope/Oslo\nEurope/Paris\nEurope/Podgorica\nEurope/Prague\nEurope/Riga\nEurope/Rome\nEurope/Samara\nEurope/San_Marino\nEurope/Sarajevo\nEurope/Saratov\nEurope/Simferopol\nEurope/Skopje\nEurope/Sofia\nEurope/Stockholm\nEurope/Tallinn\nEurope/Tirane\nEurope/Tiraspol\nEurope/Ulyanovsk\nEurope/Uzhgorod\nEurope/Vaduz\nEurope/Vatican\nEurope/Vienna\nEurope/Vilnius\nEurope/Volgograd\nEurope/Warsaw\nEurope/Zagreb\nEurope/Zaporozhye\nEurope/Zurich\nFactory\nGB\nGB-Eire\nGMT\nGMT+0\nGMT-0\nGMT0\nGreenwich\nHST\nHongkong\nIceland\nIndian/Antananarivo\nIndian/Chagos\nIndian/Christmas\nIndian/Cocos\nIndian/Comoro\nIndian/Kerguelen\nIndian/Mahe\nIndian/Maldives\nIndian/Mauritius\nIndian/Mayotte\nIndian/Reunion\nIran\nIsrael\nJamaica\nJapan\nKwajalein\nLibya\nMET\nMST\nMST7MDT\nMexico/BajaNorte\nMexico/BajaSur\nMexico/General\nNZ\nNZ-CHAT\nNavajo\nPRC\nPST8PDT\nPacific/Apia\nPacific/Auckland\nPacific/Bougainville\nPacific/Chatham\nPacific/Chuuk\nPacific/Easter\nPacific/Efate\nPacific/Enderbury\nPacific/Fakaofo\nPacific/Fiji\nPacific/Funafuti\nPacific/Galapagos\nPacific/Gambier\nPacific/Guadalcanal\nPacific/Guam\nPacific/Honolulu\nPacific/Johnston\nPacific/Kanton\nPacific/Kiritimati\nPacific/Kosrae\nPacific/Kwajalein\nPacific/Majuro\nPacific/Marquesas\nPacific/Midway\nPacific/Nauru\nPacific/Niue\nPacific/Norfolk\nPacific/Noumea\nPacific/Pago_Pago\nPacific/Palau\nPacific/Pitcairn\nPacific/Pohnpei\nPacific/Ponape\nPacific/Port_Moresby\nPacific/Rarotonga\nPacific/Saipan\nPacific/Samoa\nPacific/Tahiti\nPacific/Tarawa\nPacific/Tongatapu\nPacific/Truk\nPacific/Wake\nPacific/Wallis\nPacific/Yap\nPoland\nPortugal\nROC\nROK\nSingapore\nTurkey\nUCT\nUS/Alaska\nUS/Aleutian\nUS/Arizona\nUS/Central\nUS/East-Indiana\nUS/Eastern\nUS/Hawaii\nUS/Indiana-Starke\nUS/Michigan\nUS/Mountain\nUS/Pacific\nUS/Samoa\nUTC\nUniversal\nW-SU\nWET\nZulu\n```\n:::\n:::\n\n\n:::\n\n### Alles ist relativ: die Epoche\nPython speichert Zeit relativ zu einem zeitlichen Bezugspunkt, der Unix-Zeit, der sogenannten Epoche. Die Epoche kann mit der Funktion `pd.to_datetime(0)` ausgegeben werden. Die Funktion konvertiert Argumente in Zeitpunkte (Timestamp). Ganzzahlen werden dabei als Nanosekunden seit der Epoche interpretiert. Die Funktion werden wir später noch ausführlicher behandeln.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nimport pandas as pd\nprint(pd.to_datetime(0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1970-01-01 00:00:00\n```\n:::\n:::\n\n\n::: {#wrn-datetimetimezones .callout-warning appearance=\"simple\" collapse=\"true\"}\n\n## Zeit - atomar, koordiniert oder universal?\nNumPy nutzt die Internationale Atomzeit (abgekürzt TAI für französisch Temps Atomique International). Diese nimmt für jeden Kalendertag eine Länge von 86.400 Sekunden an, kennt also keine Schaltsekunde. Die Atomzeit bildet die Grundlage für die koordinierte Weltzeit UTC.\n\nUTC steht für Coordinated Universal Time (auch bekannt als Greenwich Mean Time). Das Kürzel UTC ist ein Kompromiss für die englische und die französische Sprache. Die koordinierte Weltzeit gleicht die Verlangsamung der Erdrotation (astronomisch gemessen als Universalzeit, Universal Time UT) durch Schaltsekunden aus, um die geringfügige Verlängerung eines Tages auszugleichen. Die TAI geht deshalb gegenüber der UTC vor. Seit 1972 unterscheiden sich beide Zeiten um eine ganzzahlige Anzahl von Sekunden. Aktuell (2024) geht die TAI 37 Sekunden gegenüber UTC vor.\n\nEine Umwandlung in die koordinierte Weltzeit ist in NumPy bislang noch nicht umgesetzt. ([Dokumentation NumPy](https://numpy.org/doc/stable/reference/arrays.datetime.html), [Wikipedia](https://de.wikipedia.org/wiki/Internationale_Atomzeit)).\n:::\n\n### Zeitumstellung - Daylight Saving Time\n::: {.border layout=\"[5, 90, 5]\"}\n\n&nbsp;\n\n\"DST is Daylight Saving Time, an adjustment of the timezone by (usually) one hour during part of the year. DST rules are magic (determined by local law) and can change from year to year. The C library has a table containing the local rules (often it is read from a system file for flexibility) and is the only source of True Wisdom in this respect.\" ([Dokumentation time](https://docs.python.org/3/library/time.html))\n\n&nbsp;\n:::\n\n&nbsp;\n\nPandas arbeitet standardmäßig mit der koordinierten Weltzeit UTC. Die UTC selbst ist keine Zeitzone und kennt deshalb keine Zeitumstellung. Die Zeitumstellung wird abhängig von der Zeitzone berücksichtigt. Beispielsweise wurde die Zeitumstellung in der Türkei 2016 abgeschafft (und die Sommerzeit dauerhaft eingeführt).\n\nIn den folgenden Beispielen wird am Tag vor der Zeitumstellung um 9 Uhr eine Zeitdifferenz von 24 Stunden addiert. Da über die Nacht (der Morgen des Folgetages) die Uhr um eine Stunde vorgestellt wird, zeigt der resultierende Zeitstempel die Uhrzeit 10 Uhr an, sofern die Zeitumstellung gilt.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nprint(\"Keine Zeitumstellung in UTC:\")\nprint(pd.Timestamp(\"2025-03-29T09:00\") + pd.Timedelta(24, \"h\"), \"\\n\")\n\nprint(\"Zeitzone mit Zeitumstellung:\")\nprint(pd.Timestamp(\"2025-03-29T09:00\", tz=\"Europe/Berlin\") + pd.Timedelta(24, \"h\"), \"\\n\")\n\nprint(\"Heute keine Zeitumstellung in Türkei:\")\nprint(pd.Timestamp(\"2025-03-29T09:00\", tz=\"Turkey\") + pd.Timedelta(24, \"h\"), \"\\n\")\n\nprint(\"Türkei vor der Abschaffung der Zeitumstellung:\")\nprint(pd.Timestamp(\"2014-03-30T09:00\", tz=\"Turkey\")  + pd.Timedelta(24, \"h\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nKeine Zeitumstellung in UTC:\n2025-03-30 09:00:00 \n\nZeitzone mit Zeitumstellung:\n2025-03-30 10:00:00+02:00 \n\nHeute keine Zeitumstellung in Türkei:\n2025-03-30 09:00:00+03:00 \n\nTürkei vor der Abschaffung der Zeitumstellung:\n2014-03-31 10:00:00+03:00\n```\n:::\n:::\n\n\nEine Liste der Zeitzonen finden Sie auf Wikipedia: <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones>\n\n### Kalender\nDie Module calendar, NumPy und Pandas verwenden den um die Zeit vor seiner Einführung 1582 erweiterten Gregorianische Kalender, den [proleptischen Gregorianischen Kalender](https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar). Während das Modul date nur die Jahre 1-9999 nach unserer Zeit unterstützt, erlaubt der Datentyp `datetime64` auch Jahre vor unserer Zeit in [astronomischer Jahresnumerierung](https://en.wikipedia.org/wiki/Astronomical_year_numbering). Das bedeutet, es gibt ein Jahr 0 (das erste Jahr vor unserer Zeit) und vorausgehende Jahre werden mit negativen Zahlen dargestellt (-1 ist das zweite Jahr vor unserer Zeit). [NumPy Dokumentation](https://numpy.org/doc/stable/reference/arrays.datetime.html#datetime64-conventions-and-assumptions)\n\n\n## datetime in Pandas\nPandas nutzt den NumPy-Datentyp `datetime64`, um Datums- und Zeitinformationen zu verarbeiten. In Pandas werden `datetime64`-Objekte mit den Funktionen `pd.to_datetime()` oder `pd.date_range()` angelegt.  \n*Hinweis: Eine weitere Möglichkeit ist die Funktion `pd.Timestamp()`, die umfangreichere Möglichkeiten zur Erzeugung eines Zeitpunkts bietet, aber kein string-parsing unterstützt.*\n\n`pd.to_datetime()` erzeugt Werte des Datentyps `datetime64[ns]` (mit `pd.to_datetime()` erzeugte Skalare (Einzelwerte) werden als Timestamp (Zeitpunkt) ausgegeben, die kein Attribut `dtype` haben). Die Funktion `pd.to_datetime()` akzeptiert als Eingabewerte:\n\n  - datetime-Objekte anderer Module.\n\n  - Zahlen und eine Zeiteinheit `pd.to_datetime(1, unit = None)` (Standard sind Nanosekunden). Das Argument `unit` nimmt die Werte 'ns', 'ms', 's', 'm', 'h', 'D', 'W', 'M', 'Y' für Nanosekunde, Millisekunde, Sekunde, Minute, Stunde, Tag, Woche, Monat bzw. Jahr entgegen. Erzeugt wird ein Zeitpunkt relativ zur Epoche.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nprint(pd.to_datetime(1000, unit = 'D'))\nprint(pd.to_datetime(1000 * 1000, unit = 'h'))\nprint(pd.to_datetime(1000 * 1000 * 1000, unit = 's'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1972-09-27 00:00:00\n2084-01-29 16:00:00\n2001-09-09 01:46:40\n```\n:::\n:::\n\n\n  - Zeichenketten, die ein Datum oder ein Datum mit Uhrzeit ausdrücken, formatiert nach [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html).\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nprint(pd.to_datetime('2017'))\nprint(pd.to_datetime('2017-01-01T00'))\nprint(pd.to_datetime('2017-01-01 00:00:00'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2017-01-01 00:00:00\n2017-01-01 00:00:00\n2017-01-01 00:00:00\n```\n:::\n:::\n\n\n  - Anders formatierte Zeichenketten mit dem Argument `format = \"%d/%m/%Y\"` (siehe [Dokumentation strftime zur string-Formatierung](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior)).\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nprint(pd.to_datetime('Monday, 12. August `24', format = \"%A, %d. %B `%y\"))\nprint(pd.to_datetime('Monday, 12. August 2024, 12:15 Uhr CET', format = \"%A, %d. %B %Y, %H:%M Uhr %Z\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2024-08-12 00:00:00\n2024-08-12 12:15:00+02:00\n```\n:::\n:::\n\n\n  - Dictionary oder DataFrame.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nprint(pd.to_datetime({'year':[2020, 2024], 'month': [1, 11], 'day': [1, 21]}), \"\\n\")\nprint(pd.to_datetime(pd.DataFrame({'year':[2020, 2024], 'month': [1, 11], 'day': [1, 21]})))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0   2020-01-01\n1   2024-11-21\ndtype: datetime64[ns] \n\n0   2020-01-01\n1   2024-11-21\ndtype: datetime64[ns]\n```\n:::\n:::\n\n\nDie Funktion `pd.date_range()` erzeugt ein Array vom Typ `DatetimeIndex` mit dtype `datetime64`. Genau drei der folgenden vier Argumente sind für die Erzeugung erforderlich: \n\n  - `start`: Beginn der Reihe.\n\n  - `end`: Ende der Reihe (inklusiv)\n\n  - `freq`: Schrittweite (bspw. Jahr, Tag, Geschäftstag, Stunde oder Vielfache wie '6h' - siehe [Liste verfügbarer strings](https://pandas.pydata.org/docs/user_guide/timeseries.html#timeseries-offset-aliases))\n\n  - `periods`: Anzahl der zu erzeugenden Werte.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nprint(pd.date_range(start = '2017', end = '2024', periods = 3), \"\\n\")\n\nprint(pd.date_range(start = '2017', end = '2024', freq = 'Y'), \"\\n\")\n\nprint(pd.date_range(end = '2024', freq = 'h', periods = 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDatetimeIndex(['2017-01-01', '2020-07-02', '2024-01-01'], dtype='datetime64[ns]', freq=None) \n\nDatetimeIndex(['2017-12-31', '2018-12-31', '2019-12-31', '2020-12-31',\n               '2021-12-31', '2022-12-31', '2023-12-31'],\n              dtype='datetime64[ns]', freq='YE-DEC') \n\nDatetimeIndex(['2023-12-31 22:00:00', '2023-12-31 23:00:00',\n               '2024-01-01 00:00:00'],\n              dtype='datetime64[ns]', freq='h')\n```\n:::\n:::\n\n\n::: {#wrn-daterange .callout-warning appearance=\"simple\" collapse=\"true\"}\n## pd.date_range()\nDie Funktion `pd.date_range()` wird künftig das Kürzel 'Y' nicht mehr unterstützen. Stattdessen können die Kürzel 'YS' (Jahresbeginn) oder 'YE' (Jahresende) verwendet werden. Ebenso wird das Kürzel 'M' künftig durch 'MS' (Monatsstart), 'ME' (Monatsende) ersetzt.\n:::\n\n## timedelta in Pandas\n\nZeitdifferenzen werden mit der Funktion `pd.Timedelta()` erzeugt. Zeitdifferenzen können zum einen durch Angabe einer Ganzzahl und einer Zeiteinheit angelegt werden. Außerdem ist die Übergabe mit Argumenten möglich (zulässige Argumente sind: weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds).\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nprint(pd.Timedelta(1, 'D'))\nprint(pd.Timedelta(days = 1, hours = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 days 00:00:00\n1 days 01:00:00\n```\n:::\n:::\n\n\n**Wichtig:** Anders als in NumPy werden Zeitdifferenzen in Monaten und Jahren nicht mehr von Pandas unterstützt.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\ntry:\n  print(pd.Timedelta(1, 'Y'))\nexcept ValueError as error:\n  print(error)\nelse:\n  print(pd.Timedelta(1, 'Y'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnits 'M', 'Y', and 'y' are no longer supported, as they do not represent unambiguous timedelta values durations.\n```\n:::\n:::\n\n\nZum anderen können Zeitdifferenzen mit einer Zeichenkette erzeugt werden.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nprint(pd.Timedelta('10sec'))\nprint(pd.Timedelta('10min'))\nprint(pd.Timedelta('10hours'))\nprint(pd.Timedelta('10days'))\nprint(pd.Timedelta('10w'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0 days 00:00:10\n0 days 00:10:00\n0 days 10:00:00\n10 days 00:00:00\n70 days 00:00:00\n```\n:::\n:::\n\n\nMit Hilfe einer Zeitdifferenz können Zeitreihen leicht verschoben werden.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\npd.date_range(start = '2024-01-01T00:00', end = '2024-01-01T02:00', freq = '15min') + pd.Timedelta('30min')\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\nDatetimeIndex(['2024-01-01 00:30:00', '2024-01-01 00:45:00',\n               '2024-01-01 01:00:00', '2024-01-01 01:15:00',\n               '2024-01-01 01:30:00', '2024-01-01 01:45:00',\n               '2024-01-01 02:00:00', '2024-01-01 02:15:00',\n               '2024-01-01 02:30:00'],\n              dtype='datetime64[ns]', freq='15min')\n```\n:::\n:::\n\n\n## Zugriff auf Zeitreihen\nPandas bietet zahlreiche Attribute und Methoden, um Informationen aus `datetime64`-Objekten auszulesen. Eine Übersicht aller verfügbaren Attribute und Methoden liefert `dir(pd.to_datetime(0))` bzw. der im folgenden Beispiel gezeigte Code.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# Attribute\nprint(\"Jahr:\", pd.to_datetime(0).year)\nprint(\"Monat:\", pd.to_datetime(0).month)\nprint(\"Tag:\", pd.to_datetime(0).day)\nprint(\"Stunde:\", pd.to_datetime(0).hour)\nprint(\"Minute:\", pd.to_datetime(0).minute)\nprint(\"Sekunde:\", pd.to_datetime(0).second)\nprint(\"Tag des Jahres:\", pd.to_datetime(0).dayofyear)\nprint(\"Wochentag:\", pd.to_datetime(0).dayofweek)\nprint(\"Tage im Monat:\", pd.to_datetime(0).days_in_month)\nprint(\"Schaltjahr:\", pd.to_datetime(0).is_leap_year)\n\n# Methoden\nprint(\"\\nDatum:\", pd.to_datetime(0).date())\nprint(\"Zeit:\", pd.to_datetime(0).time())\nprint(\"Wochentag (0-6):\", pd.to_datetime(0).weekday())\nprint(\"Monatsname:\",  pd.to_datetime(0).month_name())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJahr: 1970\nMonat: 1\nTag: 1\nStunde: 0\nMinute: 0\nSekunde: 0\nTag des Jahres: 1\nWochentag: 3\nTage im Monat: 31\nSchaltjahr: False\n\nDatum: 1970-01-01\nZeit: 00:00:00\nWochentag (0-6): 3\nMonatsname: January\n```\n:::\n:::\n\n\n::: {#nte-attributeundmethoden .callout-note collapse=\"true\"}\n## Attribute und Methoden eines datetime-Objekts\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nobjekt = pd.to_datetime(0)\n\nattribute = [attr for attr in dir(objekt) if not (callable(getattr(objekt, attr)) or attr.startswith('_'))]\nprint(\"Attribute:\")\nprint(30 * \"=\")\nprint(attribute)\n\nmethoden = [attr for attr in dir(objekt) if (callable(getattr(objekt, attr)) and not attr.startswith('__'))]\nprint(\"\\nMethoden:\")\nprint(30 * \"=\")\nprint(methoden)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAttribute:\n==============================\n['asm8', 'day', 'day_of_week', 'day_of_year', 'dayofweek', 'dayofyear', 'days_in_month', 'daysinmonth', 'fold', 'hour', 'is_leap_year', 'is_month_end', 'is_month_start', 'is_quarter_end', 'is_quarter_start', 'is_year_end', 'is_year_start', 'max', 'microsecond', 'min', 'minute', 'month', 'nanosecond', 'quarter', 'resolution', 'second', 'tz', 'tzinfo', 'unit', 'value', 'week', 'weekofyear', 'year']\n\nMethoden:\n==============================\n['_from_dt64', '_from_value_and_reso', '_round', 'as_unit', 'astimezone', 'ceil', 'combine', 'ctime', 'date', 'day_name', 'dst', 'floor', 'fromisocalendar', 'fromisoformat', 'fromordinal', 'fromtimestamp', 'isocalendar', 'isoformat', 'isoweekday', 'month_name', 'normalize', 'now', 'replace', 'round', 'strftime', 'strptime', 'time', 'timestamp', 'timetuple', 'timetz', 'to_datetime64', 'to_julian_date', 'to_numpy', 'to_period', 'to_pydatetime', 'today', 'toordinal', 'tz_convert', 'tz_localize', 'tzname', 'utcfromtimestamp', 'utcnow', 'utcoffset', 'utctimetuple', 'weekday']\n```\n:::\n:::\n\n\n:::\n\nFür `pd.Series` erfolgt der Zugriff über den .dt-Operator (siehe [.dt accessor](https://pandas.pydata.org/docs/user_guide/basics.html#basics-dt-accessors)). Der Zugriff auf verschiedene Informationen über ein Attribut (ohne Klammern) oder über eine Methode (mit Klammern) unterscheidet sich jedoch teilweise (siehe folgendes Beispiel).\n\n:::: {.callout-note collapse=\"true\"}\n## Der dt-Operator\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# Attribute\nprint(\"Datum:\", pd.Series(pd.to_datetime(0)).dt.date) # Unterschied\nprint(\"Zeit:\", pd.Series(pd.to_datetime(0)).dt.time) # Unterschied\nprint(\"Jahr\", pd.Series(pd.to_datetime(0)).dt.year)\nprint(\"Monat\", pd.Series(pd.to_datetime(0)).dt.month)\nprint(\"Tag\", pd.Series(pd.to_datetime(0)).dt.day)\nprint(\"Stunde\", pd.Series(pd.to_datetime(0)).dt.hour)\nprint(\"Minute\", pd.Series(pd.to_datetime(0)).dt.minute)\nprint(\"Sekunde\", pd.Series(pd.to_datetime(0)).dt.second)\n\nprint(\"\\nTag des Jahres\", pd.Series(pd.to_datetime(0)).dt.dayofyear)\nprint(\"Wochentag:\", pd.Series(pd.to_datetime(0)).dt.dayofweek)\nprint(\"Wochentag:\", pd.Series(pd.to_datetime(0)).dt.weekday) # Unterschied\nprint(\"Tage im Monat:\", pd.Series(pd.to_datetime(0)).dt.days_in_month)\nprint(\"Schaltjahr:\", pd.Series(pd.to_datetime(0)).dt.is_leap_year)\n\n# Methoden\nprint(\"\\nName des Monats:\", pd.Series(pd.to_datetime(0)).dt.month_name())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDatum: 0    1970-01-01\ndtype: object\nZeit: 0    00:00:00\ndtype: object\nJahr 0    1970\ndtype: int32\nMonat 0    1\ndtype: int32\nTag 0    1\ndtype: int32\nStunde 0    0\ndtype: int32\nMinute 0    0\ndtype: int32\nSekunde 0    0\ndtype: int32\n\nTag des Jahres 0    1\ndtype: int32\nWochentag: 0    3\ndtype: int32\nWochentag: 0    3\ndtype: int32\nTage im Monat: 0    31\ndtype: int32\nSchaltjahr: 0    False\ndtype: bool\n\nName des Monats: 0    January\ndtype: object\n```\n:::\n:::\n\n\n::::\n\n## Aufgaben\n\n1. Wie alt sind Sie in Tagen? Wie alt in Sekunden?\n\n2. An welchem Wochentag war ihr Geburtstag?\n\n3. Wie viele Tage sind es noch bis Weihnachten?\n\n4. Erstellen Sie eine Liste aller Schaltjahre im 20. Jahrhundert.\n\n:::: {#tip-musterlösungaufgaben .callout-tip collapse=\"true\"}\n## Musterlösung\n\nAufgabe 1\n\nErsetzen sie in der Lösung die Zeichenkette 'YYYY-MM-DD' bzw., wenn Sie die Uhrzeit Ihrer Geburt kennen, die Zeichenkette 'YYYY-MM-DDTHH:MM' durch Ihren Geburtstag.\n\nIn Pandas werden die Schlüsselwörter `pd.to_datetime('today')` und `pd.to_datetime('now')` in Nanosekunden aufgelöst.  \n\n``` {.raw}\nprint((pd.to_datetime('today') - pd.to_datetime('YYYY-MM-DD')).days)\nprint(pd.to_datetime('now') - pd.to_datetime('YYYY-MM-DDTHH:MM')).total_seconds())\n```\n\nAufgabe 2\n\n``` {.raw}\nprint(pd.to_datetime('YYYY-MM-DD').day_of_week)\n``` \n\nAufgabe 3\n\n```\n(pd.to_datetime('2025-12-25') - pd.to_datetime('now')).days\n```\n\nAufgabe 4\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nschaltjahre = pd.date_range(start = '1901', end = '2000', freq = 'YE')\nschaltjahre = schaltjahre[schaltjahre.is_leap_year]\nprint(schaltjahre.year)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIndex([1904, 1908, 1912, 1916, 1920, 1924, 1928, 1932, 1936, 1940, 1944, 1948,\n       1952, 1956, 1960, 1964, 1968, 1972, 1976, 1980, 1984, 1988, 1992, 1996],\n      dtype='int32')\n```\n:::\n:::\n\n\n::::\n\n",
    "supporting": [
      "datetime_files/figure-pdf"
    ],
    "filters": []
  }
}