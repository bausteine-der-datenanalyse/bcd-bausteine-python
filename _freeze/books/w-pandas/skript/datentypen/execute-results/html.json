{
  "hash": "3a7ccf59298b8d11464557a339c135d8",
  "result": {
    "engine": "jupyter",
    "markdown": "# Datentypen\nDas Modul Pandas ist auf den Umgang mit unterschiedlichen Datentypen spezialisiert. Ein Dataframe kann unterschiedliche Datentypen enthalten (bspw. Zahlen und Wahrheitswerte).\n\n\n\nNumPy unterstützt folgende Datentypen:\n\n|      Datentyp NumPy-Array  |      Datentyp in Python |\n|---|---|\n|     int_    |     int    |\n|     double    |     float    |\n|     cdouble    |     complex    |\n|     bytes_    |     bytes    |\n|     str_    |     str    |\n|     bool_    |     bool    |\n|     datetime64    |     datetime.datetime    |\n|     timedelta64    |     datetime.timedelta    |\n\n&nbsp;\n\nDie NumPy-Datentypen haben betriebssystemabhängige Synonyme. Beispielsweise wird für ein Array vom Datentyp `int_` der Datentyp `int` ausgegeben, für ein Array aus Gleitkommazahlen der Datentyp `float64`. \n\n::: {#0e3f1bbe .cell execution_count=2}\n``` {.python .cell-code}\nskalar = np.array([2])\nprint(skalar.dtype, \"\\n\")\n\nskalar = np.array([2.1])\n\nprint(skalar.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nint64 \n\nfloat64\n```\n:::\n:::\n\n\nAußerdem gibt es für jeden NumPy-Datentyp ein Kürzel, das aus einem einzigen Buchstaben besteht. Beispielsweise wird für Zeichenfolgen das Kürzel `U` für Unicode-Zeichen und die Anzahl der Stellen ausgegeben (Für alle anderen Datentypen repräsentiert die Zahl die Anzahl der Bytes, die im Speicher benötigt werden.). Der Ausgabe ist ein Zeichen zur Kodiererung der [Byte-Reihenfolge](https://de.wikipedia.org/wiki/Byte-Reihenfolge) im Speicher vorangestellt '>' (big-endian), '<' (little-endian) oder '=' (Systemstandard).\n\n::: {#a5e1ee71 .cell execution_count=3}\n``` {.python .cell-code}\nskalar = np.array(['2'])\nprint(skalar.dtype, \"\\n\")\n\nskalar = np.array(['2.1'])\nprint(skalar.dtype, \"\\n\")\n\n# Ein Datentyp mit mehr Speicherplatzbedarf kann zugewiesen werden\nskalar = np.array([2], dtype = 'U3')\nprint(skalar.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<U1 \n\n<U3 \n\n<U3\n```\n:::\n:::\n\n\nAlle Synonyme und Kürzel können Sie der [NumPy-Dokumentation](https://numpy.org/devdocs/reference/arrays.scalars.html) entnehmen.\n\nHäufig verwendet das Modul Pandas die NumPy-Datentypen. Pandas führt aber auch einige zusätzliche Datentypen ein. Eine vollständige Liste finden Sie in der [Pandas Dokumentation](https://pandas.pydata.org/docs/reference/arrays.html). Die wichtigsten zusätzlichen Datentypen sind:\n\n  - [Kategorie](https://pandas.pydata.org/docs/user_guide/categorical.html) `dtype = 'category'` für kategoriale, also ungeordnete, Daten.\n\n  - [Zeitzonenbewusstes Datumsformat](https://pandas.pydata.org/docs/reference/api/pandas.Timestamp.html#pandas.Timestamp) `dtype = 'datetime64[ns, US/Eastern]'`\n\n  - Erweiterungen der NumPy-Datentypen mit Unterstützung fehlender Werte. Diese sind an der Großschreibung zu erkennen.\n\n::: {#13f847a9 .cell execution_count=4}\n``` {.python .cell-code}\n# NumPy-Datentyp int\nseries = pd.Series([1, 2, 3], dtype = 'int')\nprint(series, \"\\n\")\n\n# NumPy-Datentyp int unterstützt fehlende Werte nicht\ntry:\n  series = pd.Series([1, 2, 3, np.nan], dtype = 'int')\nexcept Exception as error:\n    print(error, \"\\n\")\n\n# Pandas-Datentyp Int64 unterstützt fehlende Werte\nseries = pd.Series([1, 2, 3, np.nan], dtype = 'Int64')\nprint(series)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0    1\n1    2\n2    3\ndtype: int64 \n\ncannot convert float NaN to integer \n\n0       1\n1       2\n2       3\n3    <NA>\ndtype: Int64\n```\n:::\n:::\n\n\n::: {#wrn-string .callout-warning appearance=\"simple\" collapse=\"false\"}\n## Pandas-Datentyp string\nPandas nutzt wie die Pythonbasis den Datentyp 'string', der unveränderlich (immutable) ist. Das bedeutet, es gibt keine Methode, die eine angelegte Zeichenkette verändern kann. Operationen mit diesem Datentyp geben ein neues Objekt mit dem Datentyp 'string' zurück.\n\nDie Übergabe des Datentyps 'str' führt zur Verwendung des NumPy-Datentyps string (dtype = 'str'), der veränderlich (mutable) ist.\n\nJe nach Situation kann die Verwendung des einen oder des anderen Datentyps nützlich sein. Beispielsweise kann der NumPy-Datentyp 'str' mit der Methode `pd.Series.sum()` verkettet werden.\n\n::: {#7f9cac6c .cell execution_count=5}\n``` {.python .cell-code}\n# mit NumPy-Datentyp 'str'\nstring_series = pd.Series(['H', 'a', 'l', 'l', 'o', '!'], dtype = 'str')\nprint(f\"Mit NumPy-Datentyp 'str': {string_series.sum()}\")\n\n# mit Pandas-Datentyp 'string'\ntry:\n  string_series.astype('string').sum()\nexcept Exception as error:\n  print(\"\\nMit Pandas-Datentyp 'string':\")\n  print(error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMit NumPy-Datentyp 'str': Hallo!\n\nMit Pandas-Datentyp 'string':\nCannot perform reduction 'sum' with string dtype\n```\n:::\n:::\n\n\n:::\n\n",
    "supporting": [
      "datentypen_files"
    ],
    "filters": [],
    "includes": {}
  }
}