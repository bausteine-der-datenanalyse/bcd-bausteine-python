{
  "hash": "5bb1da9fc1284ae29ad486dffb4223fb",
  "result": {
    "engine": "jupyter",
    "markdown": "# Dateien lesen und schreiben\nPandas bietet eine Reihe von Funktionen, um Dateien einzulesen und zu schreiben, deren Namensgebung einem einheitlichen Schema folgt. Funktionen zum Lesen von Dateien werden in der Form `pd.read_csv()` und Funktionen zum Schreiben in der Form `pd.to_csv()` aufgerufen. Mit Pandas können auch Dateien aus dem Internet abgerufen werden `pd.read_csv(URL)`.\n\n\n\n:::: {.border}\n| Format Type | Data Description | Reader | Writer |\n|:---:|:---:|:---:|:---:|\n| text | CSV | read_csv | to_csv |\n| text | Fixed-Width Text File | read_fwf | NA |\n| text | JSON | read_json | to_json |\n| text | HTML | read_html | to_html |\n| text | LaTeX | Styler.to_latex | NA |\n| text | XML | read_xml | to_xml |\n| text | Local clipboard | read_clipboard | to_clipboard |\n| binary | MS Excel | read_excel | to_excel |\n| binary | OpenDocument | read_excel | NA |\n| binary | HDF5 Format | read_hdf | to_hdf |\n| binary | Feather Format | read_feather | to_feather |\n| binary | Parquet Format | read_parquet | to_parquet |\n| binary | ORC Format | read_orc | to_orc |\n| binary | Stata | read_stata | to_stata |\n| binary | SAS | read_sas | NA |\n| binary | SPSS | read_spss | NA |\n| binary | Python Pickle Format | read_pickle | to_pickle |\n| SQL | SQL | read_sql | to_sql |\n\n([Pandas Dokumentation](https://pandas.pydata.org/docs/user_guide/io.html))\n::::\n\n&nbsp;\n\nIm Folgenden wird der Datensatz palmerpenguins mit Pandas eingelesen.\n\n::: {.border}\n\n**palmerpenguins**\n\n![Pinguine des Palmer-Station-Datensatzes](00-bilder/lter_penguins_allison_horst_CC0.png){fig-alt=\"illustrative Grafik der Pinguine\"}\n\nMeet the Palmer penguins von \\@allison_horst steht unter der Lizenz [CC0-1.0](https://github.com/allisonhorst/palmerpenguins?tab=CC0-1.0-1-ov-file#creative-commons) und ist auf [GitHub](https://github.com/allisonhorst/palmerpenguins?tab=readme-ov-file#meet-the-palmer-penguins) abrufbar. 2020\n\nDer Datensatz steht unter der Lizenz [CCO](https://creativecommons.org/public-domain/cc0/) und ist in R sowie auf [GitHub](https://github.com/allisonhorst/palmerpenguins?tab=readme-ov-file) verfügbar. 2020\n\n``` {.raw}\n# R Befehle, um den Datensatz zu laden\ninstall.packages(\"palmerpenguins\")\nlibrary(palmerpenguins)\n```\n\nHorst AM, Hill AP und Gorman KB. 2020. palmerpenguins: Palmer Archipelago (Antarctica) penguin data. R package version 0.1.0. <https://allisonhorst.github.io/palmerpenguins/>. doi: 10.5281/zenodo.3960218.\n\n:::\n\n&nbsp;\n\nDie Funktionen zum Lesen von Dateien erwarten eine Pfadangabe, die positional oder mit einem Schlüsselwort übergeben werden kann. Das Schlüsselwort für die Pfadangabe variiert abhängig vom Dateityp und lautet für eine kommaseparierte CSV-Datei `filepath_or_buffer`.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\npenguins = pd.read_csv(filepath_or_buffer = '01-daten/penguins.csv')\n```\n:::\n\n\nEin Blick auf die Daten mit der Methode `penguins.head()`:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nprint(penguins.head())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  species     island  bill_length_mm  bill_depth_mm  flipper_length_mm  \\\n0  Adelie  Torgersen            39.1           18.7              181.0   \n1  Adelie  Torgersen            39.5           17.4              186.0   \n2  Adelie  Torgersen            40.3           18.0              195.0   \n3  Adelie  Torgersen             NaN            NaN                NaN   \n4  Adelie  Torgersen            36.7           19.3              193.0   \n\n   body_mass_g     sex  year  \n0       3750.0    male  2007  \n1       3800.0  female  2007  \n2       3250.0  female  2007  \n3          NaN     NaN  2007  \n4       3450.0  female  2007  \n```\n:::\n:::\n\n\n::: {.border}\n\n![Schnabeldimensionen](00-bilder/culmen_depth_allison_horst_CC0.png){fig-alt:\"illustrative Grafik des Pinguinschnabels\"}\n\nBill dimensions von \\@allison_horst steht unter der Lizenz [CC0-1.0](https://github.com/allisonhorst/palmerpenguins?tab=CC0-1.0-1-ov-file#creative-commons) und ist auf [GitHub](https://github.com/allisonhorst/palmerpenguins?tab=readme-ov-file#meet-the-palmer-penguins) abrufbar. 2020\n\n:::\n\n&nbsp;\n\nEinen Überblick über den Datensatz verschafft die Methode `DataFrame.info()`.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nprint(penguins.info())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 344 entries, 0 to 343\nData columns (total 8 columns):\n #   Column             Non-Null Count  Dtype  \n---  ------             --------------  -----  \n 0   species            344 non-null    object \n 1   island             344 non-null    object \n 2   bill_length_mm     342 non-null    float64\n 3   bill_depth_mm      342 non-null    float64\n 4   flipper_length_mm  342 non-null    float64\n 5   body_mass_g        342 non-null    float64\n 6   sex                333 non-null    object \n 7   year               344 non-null    int64  \ndtypes: float64(4), int64(1), object(3)\nmemory usage: 21.6+ KB\nNone\n```\n:::\n:::\n\n\nEinige Datentypen wurden nicht erkannt. Den betreffenden Spalten wurde der Sammeltyp object zugeordnet. Den Funktionen zum Einlesen von Daten kann mit dem Argument `dtype` der Datentyp übergeben werden. Für mehrere Spalten ist dies in Form eines Dictionaries in der Form `{'Spaltenname': 'dtype'}` möglich. Mit der Methode `DataFrame.astype()` ist dies auch nachträglich möglich.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\npenguins = pd.read_csv(filepath_or_buffer = '01-daten/penguins.csv', dtype = {'species': 'category', 'island': 'category', 'sex': 'category'})\n\n# nachträglich\n# penguins = penguins.astype({'species': 'category', 'island': 'category', 'sex': 'category'})\n\nprint(penguins.info())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 344 entries, 0 to 343\nData columns (total 8 columns):\n #   Column             Non-Null Count  Dtype   \n---  ------             --------------  -----   \n 0   species            344 non-null    category\n 1   island             344 non-null    category\n 2   bill_length_mm     342 non-null    float64 \n 3   bill_depth_mm      342 non-null    float64 \n 4   flipper_length_mm  342 non-null    float64 \n 5   body_mass_g        342 non-null    float64 \n 6   sex                333 non-null    category\n 7   year               344 non-null    int64   \ndtypes: category(3), float64(4), int64(1)\nmemory usage: 15.0 KB\nNone\n```\n:::\n:::\n\n\nEinige Spalten weisen ungültige Werte auf. Die Tiere mit unvollständigen Werten sollen aus dem Datensatz entfernt werden. \n\n  - Mit der Methode `DataFrame.apply(pd.isna)` werden fehlende Werte bestimmt.\n  - Mit der Methode `DataFrame.any(axis = 1)` wird das Ergebnis zeilenweise aggregiert. any gibt True zurück, wenn mindestens ein Element True ist.\n  - Mit der Methode `sum()` wird die Anzahl der Zeilen mit fehlenden Werten bestimmt.\n  - Mit `np.where()` wird deren Indexposition bestimmt.\n  - Mit der Methode `DataFrame.drop()` werden die betreffenden Zeilen entfernt.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# Fehlende Werte bestimmen\nprint(penguins.apply(pd.isna).head(), \"\\n\")\n\n# zeilenweise aggregieren\nprint(penguins.apply(pd.isna).any(axis = 1).head(), \"\\n\")\n\n# Anzahl der Zeilen mit fehlenden Werten\nprint(f\"Für {penguins.apply(pd.isna).any(axis = 1).sum()} Pinguine liegen unvollständige Werte vor.\\n\")\n\n# Indexpositionen bestimmen\nprint(np.where(penguins.apply(pd.isna).any(axis = 1))[0])\n\n# Zeilen entfernen\npenguins.drop(np.where(penguins.apply(pd.isna).any(axis = 1))[0], inplace = True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   species  island  bill_length_mm  bill_depth_mm  flipper_length_mm  \\\n0    False   False           False          False              False   \n1    False   False           False          False              False   \n2    False   False           False          False              False   \n3    False   False            True           True               True   \n4    False   False           False          False              False   \n\n   body_mass_g    sex   year  \n0        False  False  False  \n1        False  False  False  \n2        False  False  False  \n3         True   True  False  \n4        False  False  False   \n\n0    False\n1    False\n2    False\n3     True\n4    False\ndtype: bool \n\nFür 11 Pinguine liegen unvollständige Werte vor.\n\n[  3   8   9  10  11  47 178 218 256 268 271]\n```\n:::\n:::\n\n\nKontrolle:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nprint(penguins.info())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.frame.DataFrame'>\nIndex: 333 entries, 0 to 343\nData columns (total 8 columns):\n #   Column             Non-Null Count  Dtype   \n---  ------             --------------  -----   \n 0   species            333 non-null    category\n 1   island             333 non-null    category\n 2   bill_length_mm     333 non-null    float64 \n 3   bill_depth_mm      333 non-null    float64 \n 4   flipper_length_mm  333 non-null    float64 \n 5   body_mass_g        333 non-null    float64 \n 6   sex                333 non-null    category\n 7   year               333 non-null    int64   \ndtypes: category(3), float64(4), int64(1)\nmemory usage: 17.0 KB\nNone\n```\n:::\n:::\n\n\n## Zeitreihen einlesen\nMit Pandas ist es leicht möglich, Zeitreihen einzulesen. Durch string parsing können beliebige Zeichenketten als datetime interpretiert werden.\n\nWenn der innere Aufbau einer Datei bekannt ist, können die notwendigen Parameter direkt beim Einlesen beispielsweise mit `pd.read_csv()` übergeben werden. Dazu werden die Parameter `parse_dates` und `date_format` verwendet.\n\n`parse_dates` gibt an, an welcher Stelle sich datetime-Informationen befinden. Es können verschiedene Argumente übergeben werden.\n\n  - `parse_dates = True` bewirkt, dass der Index als datetime interpretiert wird.\n  - Eine Liste von Ganzzahlen oder Spaltenbeschriftungen bewirkt, dass diese Spalten jeweils als eigene Spalte in datetime übersetzt werden, bspw `parse_dates = [1, 2, 3]`.\n  - Eine von einer Liste umschlossene Liste bewirkt, dass die übergebenen Spalten in einer einzigen Spalte zusammengeführt werden, bspw. `parse_dates = [[1, 2, 3]]`. Die Werte der Spalten werden mit einem Leerzeichen getrennt und anschließend interpretiert.\n\nPandas interpretiert die Zeichenketten nach [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) als Repräsentation eines Datums in der festgelegten Reihenfolge Jahr, Monat, Tag, Stunde, Minute, Sekunde, Millisekunde im Format `YYYY-MM-DD 12:00:00.000`. Als Zeichentrenner zwischen Datum und Uhrzeit sind ein Leerzeichen oder der Buchstabe T zulässig. Der Datentyp und die kleinste verwendete Einheit werden im Attribut `dtype` gespeichert.\n\nAndere Formate werden mit dem Parameter `date_format` spezifiziert. Mit Hilfe der [strftime-Dokumentation](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior) kann das Datumsformat übergeben werden.\n\nDatumsinformationen können aber auch nachträglich als solche deklariert werden. Dafür wird die Funktion `pd.to_datetime(arg, format = \" ... \")` verwendet. Mit dem Parameter `arg` wird die zu konvertierende Spalte übergeben. Mit dem Parameter `format` kann wie mit dem Parameter `date_format` ein von der ISO8601 abweichendes Datumsformat spezifiziert werden.  \n\n## Aufgaben Zeitreihen einlesen\nUnter dem Pfad '01-daten/Microsoft_Stock.csv' sind Kursdaten der Microsoft-Aktie gespeichert.\n\n::: {.border}\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nstock = pd.read_csv(filepath_or_buffer = '01-daten/Microsoft_Stock.csv')\n\nprint(stock.head(), \"\\n\")\nprint(stock.info())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                Date   Open   High    Low  Close    Volume\n0  4/1/2015 16:00:00  40.60  40.76  40.31  40.72  36865322\n1  4/2/2015 16:00:00  40.66  40.74  40.12  40.29  37487476\n2  4/6/2015 16:00:00  40.34  41.78  40.18  41.55  39223692\n3  4/7/2015 16:00:00  41.61  41.91  41.31  41.53  28809375\n4  4/8/2015 16:00:00  41.48  41.69  41.04  41.42  24753438 \n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 1511 entries, 0 to 1510\nData columns (total 6 columns):\n #   Column  Non-Null Count  Dtype  \n---  ------  --------------  -----  \n 0   Date    1511 non-null   object \n 1   Open    1511 non-null   float64\n 2   High    1511 non-null   float64\n 3   Low     1511 non-null   float64\n 4   Close   1511 non-null   float64\n 5   Volume  1511 non-null   int64  \ndtypes: float64(4), int64(1), object(1)\nmemory usage: 71.0+ KB\nNone\n```\n:::\n:::\n\n\nMicrosoft Stock- Time Series Analysis von Vijay V Venkitesh steht unter der Lizenz [CC0](https://creativecommons.org/publicdomain/zero/1.0/) und ist auf [kaggle](https://www.kaggle.com/datasets/vijayvvenkitesh/microsoft-stock-time-series-analysis) abrufbar. 2021\n\n:::\n\n&nbsp;\n\nIn der Spalte 'Date' sind Datums- und Zeitinformationen in der Form 'Monat/Tag/Jahr Stunde:Minute:Sekunde' verzeichnet, die von Pandas nicht automatisch erkannt wurden. Die Spalte hat deshalb den Datentyp object erhalten.\n\n1. Übergeben Sie der Funktion `pd.read_csv()` die erforderlichen Argumente, um die Spalte Date korrekt als datetime einzulesen.\n\n2. Berechnen Sie die Höchstkurse für jede Woche (intraday).\n\n::: {#tip-musterloesungzeitreihe .callout-tip collapse=\"true\"} \n## Musterlösung Zeitreihen einlesen\n\n1. Aufgabe\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nstock = pd.read_csv(filepath_or_buffer = '01-daten/Microsoft_Stock.csv',\n        parse_dates = ['Date'], # alternativ: [0]\n        date_format = '%m/%d/%Y %H:%M:%S')\n\nprint(stock.head(), \"\\n\")\nprint(stock.info())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                 Date   Open   High    Low  Close    Volume\n0 2015-04-01 16:00:00  40.60  40.76  40.31  40.72  36865322\n1 2015-04-02 16:00:00  40.66  40.74  40.12  40.29  37487476\n2 2015-04-06 16:00:00  40.34  41.78  40.18  41.55  39223692\n3 2015-04-07 16:00:00  41.61  41.91  41.31  41.53  28809375\n4 2015-04-08 16:00:00  41.48  41.69  41.04  41.42  24753438 \n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 1511 entries, 0 to 1510\nData columns (total 6 columns):\n #   Column  Non-Null Count  Dtype         \n---  ------  --------------  -----         \n 0   Date    1511 non-null   datetime64[ns]\n 1   Open    1511 non-null   float64       \n 2   High    1511 non-null   float64       \n 3   Low     1511 non-null   float64       \n 4   Close   1511 non-null   float64       \n 5   Volume  1511 non-null   int64         \ndtypes: datetime64[ns](1), float64(4), int64(1)\nmemory usage: 71.0 KB\nNone\n```\n:::\n:::\n\n\n2. Aufgabe\n\nDie Pandas-Methode `Series.dt.weekofyear()` wird seit einiger Zeit nicht mehr unterstützt ([siehe Dokumentation](https://pandas.pydata.org/pandas-docs/version/1.5/reference/api/pandas.Series.dt.weekofyear.html)). Die Funktion wurde durch `Series.dt.isocalendar().week` ersetzt. \n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# Jahr und Woche isolieren\nprint(stock['Date'].dt.isocalendar().week.head(), \"\\n\")\nprint(stock['Date'].dt.isocalendar().year.tail())\n\n# Jahr und Woche in den DataFrame einfügen\nstock.insert(loc = 1, column = 'week', value = stock['Date'].dt.isocalendar().week)\nstock.insert(loc = 1, column = 'year', value = stock['Date'].dt.isocalendar().year)\n\n# Maximum für jede Woche mit groupby bestimmen\nprint(stock.groupby(by = ['year', 'week'])['High'].max())\n\n# grafisch darstellen\nstock.groupby(by = ['year', 'week'])['High'].max().plot(ylabel = 'Wochenhöchstkurs (intraday)', title = 'Kursentwicklung der Microsoft-Aktie')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0    14\n1    14\n2    15\n3    15\n4    15\nName: week, dtype: UInt32 \n\n1506    2021\n1507    2021\n1508    2021\n1509    2021\n1510    2021\nName: year, dtype: UInt32\nyear  week\n2015  14       40.76\n      15       41.95\n      16       42.46\n      17       48.14\n      18       49.54\n               ...  \n2021  9       237.47\n      10      239.17\n      11      240.06\n      12      241.05\n      13      239.10\nName: High, Length: 314, dtype: float64\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](dateien_files/figure-pdf/cell-11-output-2.png){fig-alt='Kursentwicklung der Microsoft-Aktie' fig-pos='H'}\n:::\n:::\n\n\n:::\n\n## Schwierige Dateien einlesen\nDas Einlesen von Dateien ist nicht immer einfach. Werkzeuge und Strategien zur Bewältigung schwieriger Fälle finden Sie im [Methodenbaustein Einlesen strukturierter Datensätze](https://bausteine-der-datenanalyse.github.io/m-einlesen-strukturierter-datensaetze/output/book/). Dort wird auch der Umgang mit fehlenden Werten ausführlich behandelt.\n\n",
    "supporting": [
      "dateien_files/figure-pdf"
    ],
    "filters": []
  }
}