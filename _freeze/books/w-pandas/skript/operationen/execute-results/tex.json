{
  "hash": "858651dd5772cbde6d39c32d997b637c",
  "result": {
    "engine": "jupyter",
    "markdown": "# Operationen\nPandas erlaubt wie NumPy vektorisierte Operationen, dass heißt, Berechnungen mit einer Series oder einem DataFrame werden auf jedes Element angewendet. So können die Rechenoperatoren direkt verwendet werden.\n\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nprint(\"Temperaturen in Celsius:\")\nprint(27 * \"=\")\nprint(temperaturen, \"\\n\")\n\nprint(\"Temperaturen in Fahrenheit:\")\nprint(27 * \"=\")\nprint(temperaturen  * 9/5 + 32)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTemperaturen in Celsius:\n===========================\n     2021  2022  2023  2024\nJan     2     3    -3    -1\nFeb     4     6    -1     2\nMär     7     9     4     5\nApr    12    13     9     8\nMai    19    18    15    17\nJun    23    21    20    24\nJul    25    24    20    25\nAug    23    23    19    20\nSep    18    19    16    17\nOkt    15    14    15    14\nNov     9     8     7     9\nDez     5     4     6     2 \n\nTemperaturen in Fahrenheit:\n===========================\n     2021  2022  2023  2024\nJan  35.6  37.4  26.6  30.2\nFeb  39.2  42.8  30.2  35.6\nMär  44.6  48.2  39.2  41.0\nApr  53.6  55.4  48.2  46.4\nMai  66.2  64.4  59.0  62.6\nJun  73.4  69.8  68.0  75.2\nJul  77.0  75.2  68.0  77.0\nAug  73.4  73.4  66.2  68.0\nSep  64.4  66.2  60.8  62.6\nOkt  59.0  57.2  59.0  57.2\nNov  48.2  46.4  44.6  48.2\nDez  41.0  39.2  42.8  35.6\n```\n:::\n:::\n\n\nAuch boolsche Operationen können direkt ausgeführt werden. \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nprint(\"Minusgrade:\")\nprint(27 * \"=\")\nprint(temperaturen  < 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMinusgrade:\n===========================\n      2021   2022   2023   2024\nJan  False  False   True   True\nFeb  False  False   True  False\nMär  False  False  False  False\nApr  False  False  False  False\nMai  False  False  False  False\nJun  False  False  False  False\nJul  False  False  False  False\nAug  False  False  False  False\nSep  False  False  False  False\nOkt  False  False  False  False\nNov  False  False  False  False\nDez  False  False  False  False\n```\n:::\n:::\n\n\n## Zeilen- und spaltenweise Operationen\nPandas umfasst eine Vielzahl von Methoden, die arithmetische, summarische, boolsche und Indexfunktionen umsetzen. Eine vollständige Übersicht finden Sie hier: <https://pandas.pydata.org/docs/reference/index.html>.\n\nIn der Regel werden die Funktionen standardmäßig spaltenweise angewendet. Mit dem Argument `axis = 1` wird die jeweilige Funktion zeilenweise ausgeführt. Die Funktionen sind auch für Series verfügbar.\n\nIm Folgenden werden einige Methoden exemplarisch vorgestellt.\n\n### arithmetische Funktionen\nDie Methoden `pd.DataFrame.add()`, `pd.DataFrame.sub()`, `pd.DataFrame.mul()`, `pd.DataFrame.div()`, `pd.DataFrame.floordiv()`, `pd.DataFrame.mod()` und `pd.DataFrame.pow()` entsprechen den Grundrechenarten mit den Operatoren  +, -, *, /, //, %, **. Sie eignen sich gut für verkettete Operationen.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nprint(\"Temperaturen in Fahrenheit:\")\nprint(27 * \"=\")\nprint(temperaturen.mul(9).div(5).add(32))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTemperaturen in Fahrenheit:\n===========================\n     2021  2022  2023  2024\nJan  35.6  37.4  26.6  30.2\nFeb  39.2  42.8  30.2  35.6\nMär  44.6  48.2  39.2  41.0\nApr  53.6  55.4  48.2  46.4\nMai  66.2  64.4  59.0  62.6\nJun  73.4  69.8  68.0  75.2\nJul  77.0  75.2  68.0  77.0\nAug  73.4  73.4  66.2  68.0\nSep  64.4  66.2  60.8  62.6\nOkt  59.0  57.2  59.0  57.2\nNov  48.2  46.4  44.6  48.2\nDez  41.0  39.2  42.8  35.6\n```\n:::\n:::\n\n\nAußerdem kann mit dem Parameter ` fill_value` ein Füllwert für fehlende Werte spezifiziert werden (dieser wird vor der Operation eingesetzt). Wie NumPys `np.nan` umfasst auch Pandas einen speziellen fehlenden Wert: `pd.NA` (achten Sie auf den Datentyp der Ausgabe). Der Umgang mit fehlenden Werten wird ausführlich im [Methodenbaustein Einlesen strukturierter Datensätze](https://bausteine-der-datenanalyse.github.io/m-einlesen-strukturierter-datensaetze/output/book/) behandelt.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nmissing_value = pd.Series([1, pd.NA, 3])\nprint(missing_value.add(1, fill_value = -999), \"\\n\")\nprint(missing_value.add(1, fill_value = np.nan), \"\\n\")\nprint(missing_value.add(1, fill_value = pd.NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0      2\n1   -998\n2      4\ndtype: int64 \n\n0    2.0\n1    NaN\n2    4.0\ndtype: float64 \n\n0       2\n1    <NA>\n2       4\ndtype: object\n```\n:::\n:::\n\n\n### summarische Funktionen\n\n  - `pd.DataFrame.mean()` ermittelt den Durchschnitt.\n  - `pd.DataFrame.median()` ermittelt den Median.\n  - `pd.DataFrame.mode()` ermittelt den Modus.\n  - `pd.DataFrame.sum()` ermittelt die Summe.\n  - `pd.DataFrame.cumsum()` ermittelt die kummulierte Summe.\n  - `pd.DataFrame.min()` und `pd.DataFrame.max()` ermitteln Minimum bzw. Maximum.\n  - `pd.DataFrame.cummin()` und `pd.DataFrame.cummax()` ermittelt das kummulierte Minimum bzw. Maximum.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# spaltenweise\nprint(\"Mittlere Jahrestemperaturen\")\nprint(27 * \"=\")\nprint(temperaturen.mean(), \"\\n\")\n\n# zeilenweise\nprint(\"Monatliche Mindesttemperatur\")\nprint(28 * \"=\")\nprint(temperaturen.min(axis = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMittlere Jahrestemperaturen\n===========================\n2021    13.500000\n2022    13.500000\n2023    10.583333\n2024    11.833333\ndtype: float64 \n\nMonatliche Mindesttemperatur\n============================\nJan    -3\nFeb    -1\nMär     4\nApr     8\nMai    15\nJun    20\nJul    20\nAug    19\nSep    16\nOkt    14\nNov     7\nDez     2\ndtype: int64\n```\n:::\n:::\n\n\n### boolsche Funktionen\nPandas bietet wie die Pythonbasis verschiedene boolsche Funktionen.\n\n`pd.DataFrame.isin(values)` prüft für jedes Element des DataFrame, ob dieses in `values` enthalten ist. Mit dem Operator `~` kann geprüft werden, ob die Elemente eines DataFrame nicht in `values` enthalten sind: `~pd.DataFrame.isin(values)`.  \n  Die Funktionsausführung ist abhängig vom Datentyp des in `values` übergebenen Objekts.\n\n  - Wenn `values` eine Liste oder ein NumPy-Array ist, ist das Ergebnis True, wenn es eine Übereinstimmung mit einem der enthaltenen Elemente gibt.\n  - Ist `value` eine Series oder ein DataFrame, wird die Übereinstimmung positionsbasiert überprüft (siehe Beispiel).\n\n::: {#nte-isin .callout-note collapse=\"true\"}\n## klassenabhängige Funktionsausführung\n\n:::: {.panel-tabset}\n## Einzelwerte oder Liste\nFür Einzelwerte oder eine Liste wird die Übereinstimmung elementweise überprüft.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nprint(temperaturen, \"\\n\")\n\nprint(temperaturen.isin([2, 3]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     2021  2022  2023  2024\nJan     2     3    -3    -1\nFeb     4     6    -1     2\nMär     7     9     4     5\nApr    12    13     9     8\nMai    19    18    15    17\nJun    23    21    20    24\nJul    25    24    20    25\nAug    23    23    19    20\nSep    18    19    16    17\nOkt    15    14    15    14\nNov     9     8     7     9\nDez     5     4     6     2 \n\n      2021   2022   2023   2024\nJan   True   True  False  False\nFeb  False  False  False   True\nMär  False  False  False  False\nApr  False  False  False  False\nMai  False  False  False  False\nJun  False  False  False  False\nJul  False  False  False  False\nAug  False  False  False  False\nSep  False  False  False  False\nOkt  False  False  False  False\nNov  False  False  False  False\nDez  False  False  False   True\n```\n:::\n:::\n\n\n## NumPy-Array\nFür ein NumPy-Array wird die Übereinstimmung elementweise überprüft (vergleiche zum nächsten Reiter).\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nprint(type(temperaturen[2021].values), \"\\n\")\n\nprint(temperaturen.isin(temperaturen[2021].values))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'numpy.ndarray'> \n\n     2021   2022   2023   2024\nJan  True  False  False  False\nFeb  True  False  False   True\nMär  True   True   True   True\nApr  True  False   True  False\nMai  True   True   True  False\nJun  True  False  False  False\nJul  True  False  False   True\nAug  True   True   True  False\nSep  True   True  False  False\nOkt  True  False   True  False\nNov  True  False   True   True\nDez  True   True  False   True\n```\n:::\n:::\n\n\n## Series\nFür eine Series wird die Übereinstimmung positionsweise geprüft (vergleiche zum vorherigen Reiter). Der Index muss übereinstimmen.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nprint(temperaturen.isin(temperaturen[2021]), \"\\n\")\n\ntemperaturen_2021_falscher_index = pd.Series([2, 4, 7, 12, 19, 23, 25, 23, 18, 15, 9, 5])\ntemperaturen_2021_falscher_index.index = ['A', 'B', 'C', 'D', 'E', 'F', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez']\n\nprint(\"Der Index der Series lautet:\\n['A', 'B', 'C', 'D', 'E', 'F', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'].\\nDas Ergebnis an den Indexpositionen A-F ist immer False.\")\nprint(temperaturen.isin(temperaturen_2021_falscher_index))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     2021   2022   2023   2024\nJan  True  False  False  False\nFeb  True  False  False  False\nMär  True  False  False  False\nApr  True  False  False  False\nMai  True  False  False  False\nJun  True  False  False  False\nJul  True  False  False   True\nAug  True   True  False  False\nSep  True  False  False  False\nOkt  True  False   True  False\nNov  True  False  False   True\nDez  True  False  False  False \n\nDer Index der Series lautet:\n['A', 'B', 'C', 'D', 'E', 'F', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'].\nDas Ergebnis an den Indexpositionen A-F ist immer False.\n      2021   2022   2023   2024\nJan  False  False  False  False\nFeb  False  False  False  False\nMär  False  False  False  False\nApr  False  False  False  False\nMai  False  False  False  False\nJun  False  False  False  False\nJul   True  False  False   True\nAug   True   True  False  False\nSep   True  False  False  False\nOkt   True  False   True  False\nNov   True  False  False   True\nDez   True  False  False  False\n```\n:::\n:::\n\n\n## DataFrame\nFür einen DataFrame wird die Übereinstimmung positionsweise geprüft. Index und Spaltennamen müssen übereinstimmen (Index siehe Reiter Series).\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ntemperaturen_2021_df = pd.DataFrame(temperaturen[2021])\nprint(temperaturen.isin(temperaturen_2021_df), \"\\n\")\n\ntemperaturen_2021_df.columns = [2035]\nprint(temperaturen.isin(temperaturen_2021_df), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     2021   2022   2023   2024\nJan  True  False  False  False\nFeb  True  False  False  False\nMär  True  False  False  False\nApr  True  False  False  False\nMai  True  False  False  False\nJun  True  False  False  False\nJul  True  False  False  False\nAug  True  False  False  False\nSep  True  False  False  False\nOkt  True  False  False  False\nNov  True  False  False  False\nDez  True  False  False  False \n\n      2021   2022   2023   2024\nJan  False  False  False  False\nFeb  False  False  False  False\nMär  False  False  False  False\nApr  False  False  False  False\nMai  False  False  False  False\nJun  False  False  False  False\nJul  False  False  False  False\nAug  False  False  False  False\nSep  False  False  False  False\nOkt  False  False  False  False\nNov  False  False  False  False\nDez  False  False  False  False \n\n```\n:::\n:::\n\n\n::::\n:::\n\n\n::: {#tip-documentation .callout-tip}\n## Überraschungen vermeiden\n\nEine klassenabhängige Funktionsausführung kann, wenn das Verhalten unbemerkt bleibt, die Ergebnisse einer Datenanalyse verfälschen. Um dies zu verhindern, sollten Sie 3 allgemeine Ratschläge befolgen:\n\n1. Schauen Sie in die Dokumentation der jeweiligen Funktion. Python und viele Module entwickeln sich dynamisch, sodass sich das Verhalten einer Funktion verändern kann.\n\n2. Gehen Sie schrittweise vor und lassen sich die Zwischenergebnisse von Arbeitsschritten mit der Funktion `print()` ausgeben.\n\n3. Bei großen Datenmengen ist es häufig einfacher, mit eigens erzeugten Testdaten zu arbeiten. Ein zehnzeiliger DataFrame mit den Datentypen und der Struktur der Arbeitsdaten, ist leichter zu überblicken. Nutzen Sie einen solchen Testdatensatz um die von Ihnen verwendeten Funktionen zu überprüfen.\n:::\n\nEine Gruppe von Funktionen setzt logische Vergleiche um.\n\n| Funktion | Vergleich |\n|---|---|\n| `pd.DataFrame.lt(other)` | kleiner |\n| `pd.DataFrame.le(other)` | kleiner gleich |\n| `pd.DataFrame.eq(other)` | gleich |\n| `pd.DataFrame.ne(other)` | ungleich |\n| `pd.DataFrame.ge(other)` | größer gleich |\n| `pd.DataFrame.gt(other)` | größer |\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nprint(temperaturen.le(2), \"\\n\")\nprint(temperaturen[2021].gt(5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      2021   2022   2023   2024\nJan   True  False   True   True\nFeb  False  False   True   True\nMär  False  False  False  False\nApr  False  False  False  False\nMai  False  False  False  False\nJun  False  False  False  False\nJul  False  False  False  False\nAug  False  False  False  False\nSep  False  False  False  False\nOkt  False  False  False  False\nNov  False  False  False  False\nDez  False  False  False   True \n\nJan    False\nFeb    False\nMär     True\nApr     True\nMai     True\nJun     True\nJul     True\nAug     True\nSep     True\nOkt     True\nNov     True\nDez    False\nName: 2021, dtype: bool\n```\n:::\n:::\n\n\n### Verwendung der Methoden .agg() und .apply()\nPandas bringt zwei eigene Methoden mit, um Operationen zeilen- oder spaltenweise auszuführen. `DataFrame.agg()` (oder auch `DataFrame.aggregate()`) aggregiert einen DataFrame zeilen- oder spaltenweise durch eine Funktion. Die Pandas-Methode `DF.apply()` wendet eine Funktion zeilen- oder spaltenweise auf einen DataFrame an. Die Methoden sind also sehr ähnlich und führen in den meisten Fällen zum selben Ergebnis.\n\nBeide Funktionen führen mit dem Argument `axis = 1` Operationen zeilenweise aus.\n\n::: {.panel-tabset}\n\n## Funktion\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ndef my_plus_ten(x):\n  y = x + 10\n  return y\n\nprint(temperaturen.agg(my_plus_ten), \"\\n\")\nprint(temperaturen.apply(my_plus_ten))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     2021  2022  2023  2024\nJan    12    13     7     9\nFeb    14    16     9    12\nMär    17    19    14    15\nApr    22    23    19    18\nMai    29    28    25    27\nJun    33    31    30    34\nJul    35    34    30    35\nAug    33    33    29    30\nSep    28    29    26    27\nOkt    25    24    25    24\nNov    19    18    17    19\nDez    15    14    16    12 \n\n     2021  2022  2023  2024\nJan    12    13     7     9\nFeb    14    16     9    12\nMär    17    19    14    15\nApr    22    23    19    18\nMai    29    28    25    27\nJun    33    31    30    34\nJul    35    34    30    35\nAug    33    33    29    30\nSep    28    29    26    27\nOkt    25    24    25    24\nNov    19    18    17    19\nDez    15    14    16    12\n```\n:::\n:::\n\n\n## Funktionsname\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nprint(temperaturen.agg(\"sum\"), \"\\n\")\nprint(temperaturen.apply(\"sum\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2021    162\n2022    162\n2023    127\n2024    142\ndtype: int64 \n\n2021    162\n2022    162\n2023    127\n2024    142\ndtype: int64\n```\n:::\n:::\n\n\n## Liste von Funktionen\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nprint(temperaturen.agg([\"sum\", \"mean\", \"median\"]), \"\\n\")\nprint(temperaturen.apply([\"sum\", \"mean\", \"median\"]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         2021   2022        2023        2024\nsum     162.0  162.0  127.000000  142.000000\nmean     13.5   13.5   10.583333   11.833333\nmedian   13.5   13.5   12.000000   11.500000 \n\n         2021   2022        2023        2024\nsum     162.0  162.0  127.000000  142.000000\nmean     13.5   13.5   10.583333   11.833333\nmedian   13.5   13.5   12.000000   11.500000\n```\n:::\n:::\n\n\n## Dictionary von Funktionen\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nprint(temperaturen.agg({2021: \"sum\", 2022: \"mean\", 2023: \"median\", 2024: \"min\"}), \"\\n\")\nprint(temperaturen.apply({2021: \"sum\", 2022: \"mean\", 2023: \"median\", 2024: \"min\"}), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2021    162.0\n2022     13.5\n2023     12.0\n2024     -1.0\ndtype: float64 \n\n2021    162.0\n2022     13.5\n2023     12.0\n2024     -1.0\ndtype: float64 \n\n```\n:::\n:::\n\n\n:::\n\nBesonders nützlich ist die Möglichkeit, Funktionen, die normalerweise auf eine Series angewendet werden, auf jedes Element der Series anzuwenden. Dafür wird die lambda Syntax verwendet: `lambda x: x + 1`. lambda ist ein Platzhalter und kann als \"für jedes x tue:\" gelesen werden. So kann beispielsweise die Anzahl der Zeichen in jeder Zeile bestimmt werden.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# Auf die Series angewendet\nprint(len(str(temperaturen[2021])), \"\\n\")\n\n# Elementweise angewendet\nprint(temperaturen[2021].agg(lambda x: len(str(x))), \"\\n\") # deprecated\nprint(temperaturen[2021].apply(lambda x: len(str(x))), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n144 \n\nJan    1\nFeb    1\nMär    1\nApr    2\nMai    2\nJun    2\nJul    2\nAug    2\nSep    2\nOkt    2\nNov    1\nDez    1\nName: 2021, dtype: int64 \n\nJan    1\nFeb    1\nMär    1\nApr    2\nMai    2\nJun    2\nJul    2\nAug    2\nSep    2\nOkt    2\nNov    1\nDez    1\nName: 2021, dtype: int64 \n\n```\n:::\n:::\n\n\nDetails zur Verwendung des [Lambda-Ausdrucks](https://docs.python.org/3/reference/expressions.html#lambda) finden Sie in der Dokumentation. \n\nDer Vollständigkeit wegen ist zu erwähnen, dass mit den Methoden `.map()` und `.transform()` weitere, sehr ähnliche Alternativen bestehen. Bei Interesse können Sie die Unterschiede [in diesem Artikel](https://towardsdatascience.com/pandas-apply-map-or-transform-dd931659e9cf/) nachlesen.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# print(temperaturen[2021].map(lambda x: len(str(x))))\n# print(temperaturen[2021].transform(lambda x: len(str(x))), \"\\n\") \n```\n:::\n\n\n## Aufgaben Operationen\nGegeben ist der DataFrame temperaturen.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# Temperaturdaten\ntemperaturen_2021 = pd.Series([2, 4, 7, 12, 19, 23, 25, 23, 18, 15, 9, 5])\ntemperaturen_2022 = pd.Series([3, 6, 9, 13, 18, 21, 24, 23, 19, 14, 8, 4])\ntemperaturen_2023 = pd.Series([-3, -1, 4, 9, 15, 20, 20, 19, 16, 15, 7, 6])\ntemperaturen_2024 = pd.Series([-1, 2, 5, 8, 17, 24, 25, 20, 17, 14, 9, 2])\n\n# DataFrame erzeugen\ntemperaturen = pd.concat([temperaturen_2021, temperaturen_2022, temperaturen_2023, temperaturen_2024], axis = 1)\ntemperaturen.columns = [2021, 2022, 2023, 2024]\ntemperaturen.index = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez']\n```\n:::\n\n\n1. Bestimmen Sie für den Dataframe temperaturen die monatliche Mediantemperatur.\n\n2. Ermitteln Sie die Monate mit einer Mediantemperatur größer gleich 21 Grad.\n\n3. Geben Sie die Indexbeschriftung dieser Monate aus.\n\n::: {#tip-loesungoperationen .callout-tip collapse=\"true\"}\n## Musterlösung Aufgaben Operationen\n\n1. Aufgabe \n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nprint(temperaturen.mean(axis = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJan     0.25\nFeb     2.75\nMär     6.25\nApr    10.50\nMai    17.25\nJun    22.00\nJul    23.50\nAug    21.25\nSep    17.50\nOkt    14.50\nNov     8.25\nDez     4.25\ndtype: float64\n```\n:::\n:::\n\n\n2. Aufgabe \n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nprint(temperaturen.mean(axis = 1).ge(21))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJan    False\nFeb    False\nMär    False\nApr    False\nMai    False\nJun     True\nJul     True\nAug     True\nSep    False\nOkt    False\nNov    False\nDez    False\ndtype: bool\n```\n:::\n:::\n\n\n3. Aufgabe \n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nprint(temperaturen.index[temperaturen.mean(axis = 1).ge(21)], \"\\n\")\n\n# als Liste\nprint(list(temperaturen.index[temperaturen.mean(axis = 1).ge(21)]), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIndex(['Jun', 'Jul', 'Aug'], dtype='object') \n\n['Jun', 'Jul', 'Aug'] \n\n```\n:::\n:::\n\n\n:::\n\n## Suchen und ersetzen\nUm die Indexposition eines bestimmten Werts zu bestimmen, kann die Numpy-Funktion `np.where()` verwendet werden. Diese gibt zwei Arrays mit den jeweiligen Zeilen- und Spaltennummern zurück.\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nprint(np.where(temperaturen == 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(array([ 1,  2, 11]), array([0, 2, 1]))\n```\n:::\n:::\n\n\nUnter anderem befindet sich der Wert 4 in Zeile 1 in Spalte 0 oder auch in Zeile 2 in Spalte 2.\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nprint(temperaturen.iloc[1, 0])\nprint(temperaturen.iloc[2, 2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\n4\n```\n:::\n:::\n\n\nPandas bietet zwei Methoden, um Werte zu ersetzen.\n  \n  - `pd.DataFrame.replace(to_replace, value, *, inplace = False)` ersetzt `to_replace` mit `value`. Mit dem Argument `inplace = True` erfolgt dies direkt im Objekt.\n\n  - `pd.where(cond, other = nan, inplace = False)` behält `cond` und ersetzt alle anderen Werte mit `other` (standardmäßig ein Platzhalter für fehlende Werte). Mit dem Argument `inplace = True` erfolgt dies direkt im Objekt.\n\nDie Syntax beider Funktionen unterscheidet sich leicht, wie im folgenden Beispiel zu sehen ist.\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nprint(temperaturen.replace(to_replace = 25, value = 1000), \"\\n\")\nprint(temperaturen.where(temperaturen == 25, other = 1000))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     2021  2022  2023  2024\nJan     2     3    -3    -1\nFeb     4     6    -1     2\nMär     7     9     4     5\nApr    12    13     9     8\nMai    19    18    15    17\nJun    23    21    20    24\nJul  1000    24    20  1000\nAug    23    23    19    20\nSep    18    19    16    17\nOkt    15    14    15    14\nNov     9     8     7     9\nDez     5     4     6     2 \n\n     2021  2022  2023  2024\nJan  1000  1000  1000  1000\nFeb  1000  1000  1000  1000\nMär  1000  1000  1000  1000\nApr  1000  1000  1000  1000\nMai  1000  1000  1000  1000\nJun  1000  1000  1000  1000\nJul    25  1000  1000    25\nAug  1000  1000  1000  1000\nSep  1000  1000  1000  1000\nOkt  1000  1000  1000  1000\nNov  1000  1000  1000  1000\nDez  1000  1000  1000  1000\n```\n:::\n:::\n\n\n## Aufgaben suchen und ersetzen\n1. Bestimmen Sie die Position der Werte im DataFrame 'temperaturen', die kleiner als 0 sind und geben Sie die Werte aus.\n\n2. Ersetzen Sie alle Werte im DataFrame 'temperaturen', die kleiner sind als 0 durch den Wert 0 und geben Sie das Ergebnis aus.\n\n::: {#tip-loesung-suchenersetzen .callout-tip collapse=\"true\"}\n## Musterlösung suchen und ersetzen\n\n1. Aufgabe\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nprint(np.where(temperaturen <= 0))\nprint(\"Anzahl Werte:\", len(np.where(temperaturen <= 0)[0]))\n\nfor i in range(len(np.where(temperaturen <= 0)[0])):\n  print(temperaturen.iloc[np.where(temperaturen <= 0)[0][i], np.where(temperaturen <= 0)[1][i]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(array([0, 0, 1]), array([2, 3, 2]))\nAnzahl Werte: 3\n-3\n-1\n-1\n```\n:::\n:::\n\n\n2. Aufgabe\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nprint(temperaturen.where(temperaturen > 0, other = 0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     2021  2022  2023  2024\nJan     2     3     0     0\nFeb     4     6     0     2\nMär     7     9     4     5\nApr    12    13     9     8\nMai    19    18    15    17\nJun    23    21    20    24\nJul    25    24    20    25\nAug    23    23    19    20\nSep    18    19    16    17\nOkt    15    14    15    14\nNov     9     8     7     9\nDez     5     4     6     2\n```\n:::\n:::\n\n\n:::\n\n## Sortieren\nDie Methode `DataFrame.sort_index(axis = 0, ascending = True, inplace = False)` sortiert entlang einer Achse, standardmäßig aufsteigend nach dem Index. Durch die Übergabe des Arguments `axis = 1` werden die Spalten sortiert. Mit dem Argument `ascending = False` wird absteigend sortiert. Das Argument `inplace = True` sorgt, wie gewohnt, dafür, dass das Ergebnis des Sortiervorgangs direkt im Objekt gespeichert wird.\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nprint(temperaturen.sort_index(), \"\\n\")\nprint(temperaturen.sort_index(axis = 1, ascending = False))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     2021  2022  2023  2024\nApr    12    13     9     8\nAug    23    23    19    20\nDez     5     4     6     2\nFeb     4     6    -1     2\nJan     2     3    -3    -1\nJul    25    24    20    25\nJun    23    21    20    24\nMai    19    18    15    17\nMär     7     9     4     5\nNov     9     8     7     9\nOkt    15    14    15    14\nSep    18    19    16    17 \n\n     2024  2023  2022  2021\nJan    -1    -3     3     2\nFeb     2    -1     6     4\nMär     5     4     9     7\nApr     8     9    13    12\nMai    17    15    18    19\nJun    24    20    21    23\nJul    25    20    24    25\nAug    20    19    23    23\nSep    17    16    19    18\nOkt    14    15    14    15\nNov     9     7     8     9\nDez     2     6     4     5\n```\n:::\n:::\n\n\nDie Methode `DataFrame.sort_values(by, *, axis = 0, ascending = True, inplace = False)` sortiert Werte entlang einer Achse, standardmäßig entlang des Index (`axis = 0`). Dem Parameter `by` sind [laut Dokumentation](https://pandas.pydata.org/pandas-docs/version/2.1/reference/api/pandas.DataFrame.sort_values.html) der Spaltenname als string bzw. eine Liste von Spaltennamen als string zu übergeben, nach denen sortiert werden soll. Wie im folgenden Code-Beispiel zu sehen ist, muss die numerische Spaltenbeschriftung jedoch auch in numerischer Form übergeben werden.\n\nWird mit dem Argument `axis = 1` entlang der zweiten Dimension sortiert, werden entsprechend Indexbeschriftungen übergeben.\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# Sortieren nach numerischen Spaltenbeschriftungen\nprint(temperaturen.sort_values(by = 2021), \"\\n\")\nprint(temperaturen.sort_values(by = [2021, 2023]), \"\\n\")\n\n# Sortieren nach als string übergebenen Spaltenbeschriftungen\n# führt zu KeyError, die Fehlermeldung wird nicht vollständig abgefangen\ntry:\n  print(temperaturen.sort_values(by = '2021'))\nexcept Exception as error:\n  print(error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     2021  2022  2023  2024\nJan     2     3    -3    -1\nFeb     4     6    -1     2\nDez     5     4     6     2\nMär     7     9     4     5\nNov     9     8     7     9\nApr    12    13     9     8\nOkt    15    14    15    14\nSep    18    19    16    17\nMai    19    18    15    17\nJun    23    21    20    24\nAug    23    23    19    20\nJul    25    24    20    25 \n\n     2021  2022  2023  2024\nJan     2     3    -3    -1\nFeb     4     6    -1     2\nDez     5     4     6     2\nMär     7     9     4     5\nNov     9     8     7     9\nApr    12    13     9     8\nOkt    15    14    15    14\nSep    18    19    16    17\nMai    19    18    15    17\nAug    23    23    19    20\nJun    23    21    20    24\nJul    25    24    20    25 \n\n'2021'\n```\n:::\n:::\n\n\n## Aufgaben Sortieren\n1. Sortieren Sie den DataFrame 'meerschweinchen' absteigend nach der Zahnlänge ('len'). Welches Meerschweinchen hat die längste zahnbildende Zelle (gesucht ist die ID)?\n\n2. Welches Meerschweinchen, welches die Dosis 1.0 erhielt, hat die längste zahnbildende Zelle (gesucht ist die ID)?\n\n::: {#tip-musterloesungsortieren .callout-tip collapse = \"true\"}\n## Musterlösung Sortieren\n\n1. Aufgabe\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\nprint(meerschweinchen.sort_values(by = 'len', ascending = False).head(), \"\\n\")\n\nprint(\"Die ID lautet:\", meerschweinchen.sort_values(by = 'len', ascending = False).iloc[0, 0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    ID   len supp  dose\n22  23  33.9   VC   2.0\n25  26  32.5   VC   2.0\n55  56  30.9   OJ   2.0\n29  30  29.5   VC   2.0\n58  59  29.4   OJ   2.0 \n\nDie ID lautet: 23\n```\n:::\n:::\n\n\n2. Aufgabe\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\ndose_1 = meerschweinchen[meerschweinchen['dose'] == 1.0]\n\nprint(dose_1.sort_values(by = 'len', ascending = False).head(), \"\\n\")\n\nprint(\"Die ID lautet:\", dose_1.sort_values(by = 'len', ascending = False).iloc[0, 0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    ID   len supp  dose\n49  50  27.3   OJ   1.0\n43  44  26.4   OJ   1.0\n46  47  25.8   OJ   1.0\n45  46  25.2   OJ   1.0\n42  43  23.6   OJ   1.0 \n\nDie ID lautet: 50\n```\n:::\n:::\n\n\n:::\n\n## GroupBy\nDie Methode `pd.groupby()` teilt einen DataFrame (oder eine Series) in Gruppen auf und gibt ein GroupBy-Objekt zurück. Das GroupBy-Objekt hat dieselben Spalten- und Zeilenbeschriftungen wie der DataFrame, das GroupBy-Objekt ist aber nach der Gruppenaufteilung sortiert. Operationen, die auf das GroupBy-Objekt angewendet werden, werden für jede Gruppe separat ausgeführt. \n\nDies kann am Datensatz 'meerschweinchen' im folgenden Panel nachvollzogen werden.\n\n  1. Reiter: Der Datensatz enthält 60 Einträge. Die ersten 30 Einträge haben in der Spalte 'supp' die Ausprägung VC für Vitamin C, die letzten 30 Einträge die Ausprägung OJ für Orangensaft.\n  \n  2. Reiter: Mit der Methode `pd.groupby('supp')` kann der Datensatz nach den Merkmalsausprägungen in der Spalte 'dose' (0.5, 1 und 2) gruppiert werden.\n\n  3. Reiter: Auf das Groupby-Objekt können Operationen ausgeführt werden. Beispielsweise kann die Spalte 'len' ausgewählt und mit der Methode `.mean()` die mittlere Länge der zahnbildenden Zelle bestimmt werden.\n\n  4. Reiter: Ebenso kann nach den Ausprägungen mehrerer Merkmale gruppiert werden, indem diese als Liste übergeben werden `pd.groupby(by = ['supp', 'dose'])`.\n\n::: {.panel-tabset}\n## DataFrame meerschweinchen\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\nprint(meerschweinchen.head(n = 12))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    ID   len supp  dose\n0    1   4.2   VC   0.5\n1    2  11.5   VC   0.5\n2    3   7.3   VC   0.5\n3    4   5.8   VC   0.5\n4    5   6.4   VC   0.5\n5    6  10.0   VC   0.5\n6    7  11.2   VC   0.5\n7    8  11.2   VC   0.5\n8    9   5.2   VC   0.5\n9   10   7.0   VC   0.5\n10  11  16.5   VC   1.0\n11  12  16.5   VC   1.0\n```\n:::\n:::\n\n\n## meerschweinchen gruppiert nach Verabreichungsart\nFür die Methode `.head()` wurde das Argument n halbiert, um die gleiche Zeilenzahl in der Ausgabe anzeigen zu lassen, da auch diese Methode für jede der beiden Gruppen (VC und OJ) ausgeführt wird. \n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nprint(meerschweinchen.groupby('supp').head(n = 6))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    ID   len supp  dose\n0    1   4.2   VC   0.5\n1    2  11.5   VC   0.5\n2    3   7.3   VC   0.5\n3    4   5.8   VC   0.5\n4    5   6.4   VC   0.5\n5    6  10.0   VC   0.5\n30  31  15.2   OJ   0.5\n31  32  21.5   OJ   0.5\n32  33  17.6   OJ   0.5\n33  34   9.7   OJ   0.5\n34  35  14.5   OJ   0.5\n35  36  10.0   OJ   0.5\n```\n:::\n:::\n\n\n## Länge nach Verabreichungsart\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\nprint(meerschweinchen.groupby(by = 'supp')['len'].mean())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsupp\nOJ    20.663333\nVC    16.963333\nName: len, dtype: float64\n```\n:::\n:::\n\n\n## Länge nach Verabreichungsart und Dosis\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\nprint(meerschweinchen.groupby(by = ['supp', 'dose'])['len'].mean())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsupp  dose\nOJ    0.5     13.23\n      1.0     22.70\n      2.0     26.06\nVC    0.5      7.98\n      1.0     16.77\n      2.0     26.14\nName: len, dtype: float64\n```\n:::\n:::\n\n\n:::\n\n## Aufgaben GroupBy\n\nDer Datensatz Motor Trend Car Road Tests (mtcars) stammt aus der us-amerikanischen \nZeitschrift Motor Trend von 1974 und enthalt Daten für 32 Autos.\n\n::: {.border}\n\n:::: {#lst-readfile2}\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\nmtcars = pd.read_csv(filepath_or_buffer = \"01-daten/mtcars.csv\", sep = \",\")\nmtcars.rename(columns = {'Unnamed: 0': 'car'}, inplace = True)\n\nmtcars.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>car</th>\n      <th>mpg</th>\n      <th>cyl</th>\n      <th>disp</th>\n      <th>hp</th>\n      <th>drat</th>\n      <th>wt</th>\n      <th>qsec</th>\n      <th>vs</th>\n      <th>am</th>\n      <th>gear</th>\n      <th>carb</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Mazda RX4</td>\n      <td>21.0</td>\n      <td>6</td>\n      <td>160.0</td>\n      <td>110</td>\n      <td>3.90</td>\n      <td>2.620</td>\n      <td>16.46</td>\n      <td>0</td>\n      <td>1</td>\n      <td>4</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Mazda RX4 Wag</td>\n      <td>21.0</td>\n      <td>6</td>\n      <td>160.0</td>\n      <td>110</td>\n      <td>3.90</td>\n      <td>2.875</td>\n      <td>17.02</td>\n      <td>0</td>\n      <td>1</td>\n      <td>4</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Datsun 710</td>\n      <td>22.8</td>\n      <td>4</td>\n      <td>108.0</td>\n      <td>93</td>\n      <td>3.85</td>\n      <td>2.320</td>\n      <td>18.61</td>\n      <td>1</td>\n      <td>1</td>\n      <td>4</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Hornet 4 Drive</td>\n      <td>21.4</td>\n      <td>6</td>\n      <td>258.0</td>\n      <td>110</td>\n      <td>3.08</td>\n      <td>3.215</td>\n      <td>19.44</td>\n      <td>1</td>\n      <td>0</td>\n      <td>3</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Hornet Sportabout</td>\n      <td>18.7</td>\n      <td>8</td>\n      <td>360.0</td>\n      <td>175</td>\n      <td>3.15</td>\n      <td>3.440</td>\n      <td>17.02</td>\n      <td>0</td>\n      <td>0</td>\n      <td>3</td>\n      <td>2</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::::\n\n| Spalte | Bedeutung  |\n|---|---|\n| mpg | Kraftstoffverbrauch in Meilen pro Gallone |\n| cyl | Anzahl Zylinder |\n| disp | Hubraum in Kubikzoll |\n| hp | Pferdestärken  |\n| drat | Hinterachsübersetzung |\n| wt | Gewicht in 1000 Pfund |\n| qsec | Zeit auf der Viertelmeile  |\n| vs | Motor (0 = V-Motor, 1 = Reihenmotor)  |\n| am | Schaltung (0 = Automatik, 1 = Handschaltung) |\n| gear | Anzahl der Vorwärtsgänge  |\n| carb | Anzahl der Vergaser  |\n\nHenderson and Velleman 1981. Building multiple regression models interactively. Biometrics 37: 391–411. Der Datensatz ist abrufbar auf [GitHub](https://gist.github.com/seankross/a412dfbd88b3db70b74b) und in R verfügbar.\n:::\n\n&nbsp;\n\n1. Gruppieren Sie den Datensatz nach der Anzahl Zylinder und ermitteln Sie den durchschnittlichen Kraftstoffverbrauch für jede Gruppe.\n\n2. Wie viele Liter auf 100 Kilometer sind es?\n\n3. Gruppieren Sie den Datensatz nach der Anzahl der Zylinder und der Vergaser. Welche Gruppe ist am schnellsten auf der Viertelmeile?\n\n::: {#tip-loesunggroupby .callout-tip collapse=\"true\"}\n## Musterlösung GroupBy\n\n1. Aufgabe\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\nmtcars.groupby(by = 'cyl')['mpg'].mean() \n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\ncyl\n4    26.663636\n6    19.742857\n8    15.100000\nName: mpg, dtype: float64\n```\n:::\n:::\n\n\n2. Aufgabe\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n# 1 Meile = 1.60934 Kilometer\n# 1 Gallone = 3.78541 Liter\n\nmpg = mtcars.groupby(by = 'cyl')['mpg'].mean()\n\nliter_100km = 1 / mpg.mul(1.60934).div(3.78541).div(100)\n\nprint(liter_100km)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncyl\n4     8.821567\n6    11.913932\n8    15.577156\nName: mpg, dtype: float64\n```\n:::\n:::\n\n\n3. Aufgabe\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\nprint(mtcars.groupby(by = ['cyl', 'carb'])['qsec'].mean(), \"\\n\")\nprint(mtcars.groupby(by = ['cyl', 'carb'])['qsec'].mean().index[-1], \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncyl  carb\n4    1       19.378000\n     2       18.936667\n6    1       19.830000\n     4       17.670000\n     6       15.500000\n8    2       17.060000\n     3       17.666667\n     4       16.495000\n     8       14.600000\nName: qsec, dtype: float64 \n\n(np.int64(8), np.int64(8)) \n\n```\n:::\n:::\n\n\nDie Gruppe mit 8 Zylindern und 8 Vergasern ist am schnellsten. (Hinweis: Es handelt sich hierbei um einen sogenannten [MultiIndex](https://pandas.pydata.org/docs/user_guide/advanced.html).)\n\n:::\n\n",
    "supporting": [
      "operationen_files/figure-pdf"
    ],
    "filters": []
  }
}