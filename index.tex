% Options for packages loaded elsewhere
% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrreprt}
\usepackage{xcolor}
\usepackage{amsmath,amssymb}
\setcounter{secnumdepth}{5}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
% Make \paragraph and \subparagraph free-standing
\makeatletter
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}{
    \@ifstar
      \xxxParagraphStar
      \xxxParagraphNoStar
  }
  \newcommand{\xxxParagraphStar}[1]{\oldparagraph*{#1}\mbox{}}
  \newcommand{\xxxParagraphNoStar}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}{
    \@ifstar
      \xxxSubParagraphStar
      \xxxSubParagraphNoStar
  }
  \newcommand{\xxxSubParagraphStar}[1]{\oldsubparagraph*{#1}\mbox{}}
  \newcommand{\xxxSubParagraphNoStar}[1]{\oldsubparagraph{#1}\mbox{}}
\fi
\makeatother

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\usepackage{longtable,booktabs,array}
\usepackage{multirow}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\newsavebox\pandoc@box
\newcommand*\pandocbounded[1]{% scales image to fit in text height/width
  \sbox\pandoc@box{#1}%
  \Gscale@div\@tempa{\textheight}{\dimexpr\ht\pandoc@box+\dp\pandoc@box\relax}%
  \Gscale@div\@tempb{\linewidth}{\wd\pandoc@box}%
  \ifdim\@tempb\p@<\@tempa\p@\let\@tempa\@tempb\fi% select the smaller of both
  \ifdim\@tempa\p@<\p@\scalebox{\@tempa}{\usebox\pandoc@box}%
  \else\usebox{\pandoc@box}%
  \fi%
}
% Set default figure placement to htbp
\def\fps@figure{htbp}
\makeatother





\setlength{\emergencystretch}{3em} % prevent overfull lines

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}



 


\KOMAoption{captions}{tableheading}
\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[skins,breakable]{tcolorbox}}
\@ifpackageloaded{fontawesome5}{}{\usepackage{fontawesome5}}
\definecolor{quarto-callout-color}{HTML}{909090}
\definecolor{quarto-callout-note-color}{HTML}{0758E5}
\definecolor{quarto-callout-important-color}{HTML}{CC1914}
\definecolor{quarto-callout-warning-color}{HTML}{EB9113}
\definecolor{quarto-callout-tip-color}{HTML}{00A047}
\definecolor{quarto-callout-caution-color}{HTML}{FC5300}
\definecolor{quarto-callout-color-frame}{HTML}{acacac}
\definecolor{quarto-callout-note-color-frame}{HTML}{4582ec}
\definecolor{quarto-callout-important-color-frame}{HTML}{d9534f}
\definecolor{quarto-callout-warning-color-frame}{HTML}{f0ad4e}
\definecolor{quarto-callout-tip-color-frame}{HTML}{02b875}
\definecolor{quarto-callout-caution-color-frame}{HTML}{fd7e14}
\makeatother
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\newcounter{quartocalloutimpno}
\newcommand{\quartocalloutimp}[1]{\refstepcounter{quartocalloutimpno}\label{#1}}
\newcounter{quartocallouttipno}
\newcommand{\quartocallouttip}[1]{\refstepcounter{quartocallouttipno}\label{#1}}
\newcounter{quartocalloutnteno}
\newcommand{\quartocalloutnte}[1]{\refstepcounter{quartocalloutnteno}\label{#1}}
\newcounter{quartocalloutwrnno}
\newcommand{\quartocalloutwrn}[1]{\refstepcounter{quartocalloutwrnno}\label{#1}}
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={Bausteine Python},
  pdfauthor={Lukas Arnold; Simone Arnold; Florian Bagemihl; Matthias Baitsch; Marc Fehr; Maik Poetzsch; Sebastian Seipel},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}


\title{Bausteine Python}
\author{Lukas Arnold \and Simone Arnold \and Florian
Bagemihl \and Matthias Baitsch \and Marc Fehr \and Maik
Poetzsch \and Sebastian Seipel}
\date{2026-02-27}
\begin{document}
\maketitle

\renewcommand*\contentsname{Table of contents}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}

\bookmarksetup{startatroot}

\chapter*{Übersicht}\label{uxfcbersicht}
\addcontentsline{toc}{chapter}{Übersicht}

\markboth{Übersicht}{Übersicht}

\part{w-pseudocode}

\chapter{Werkzeugbaustein Pseudocode}\label{werkzeugbaustein-pseudocode}

~

~

\phantomsection\label{Lizenz}
\begin{figure}

\begin{minipage}{0.20\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/w-pseudocode/skript/00-bilder/CC-BY.pdf}}
\end{minipage}%
%
\begin{minipage}{0.80\linewidth}
Bausteine Computergestützter Datenanalyse von Lukas Arnold, Simone
Arnold, Florian Bagemihl, Matthias Baitsch, Marc Fehr, Franca Hollmann,
Maik Poetzsch und Sebastian Seipel. Werkzeugbaustein Pseudocode von Maik
Poetzsch ist lizensiert unter
\href{https://creativecommons.org/licenses/by/4.0/deed.de}{CC BY 4.0}.
Das Werk ist abrufbar auf
\href{https://github.com/bausteine-der-datenanalyse}{GitHub}.
Ausgenommen von der Lizenz sind alle Logos und anders gekennzeichneten
Inhalte. 2025\end{minipage}%

\end{figure}%

Zitiervorschlag

Arnold, Lukas, Simone Arnold, Florian Bagemihl, Matthias Baitsch, Marc
Fehr, Franca Hollmann, Maik Poetzsch, und Sebastian Seipel. 2025.
„Bausteine Computergestützter Datenanalyse. Werkzeugbaustein
Pseudocode``.
\url{https://github.com/bausteine-der-datenanalyse/w-pseudocode}.

BibTeX-Vorlage

\begin{verbatim}
@misc{BCD-pseudocode-2025,
 title={Bausteine Computergestützter Datenanalyse. Werkzeugbaustein Pseudocode},
 author={Arnold, Lukas and Arnold, Simone and Bagemihl, Florian and Baitsch, Matthias and Fehr, Marc and Hollmann, Franca and Poetzsch, Maik and Seipel, Sebastian},
 year={2025},
 url={https://github.com/bausteine-der-datenanalyse/w-pseudocode}} 
\end{verbatim}

\newpage{}

\chapter{Voraussetzungen}\label{voraussetzungen}

Für die Bearbeitung dieses Bausteins bestehen keine Voraussetzungen. Die
Bearbeitungszeit beträgt je nach Umfang der bearbeiteten Übungsaufgaben
circa 120 bis 300 Minuten.

Während der Bearbeitung des Bausteins \emph{können} Flussdiagramme unter
anderem mit Python oder R erstellt werden. Dazu werden folgende
Bibliotheken benötigt:

\begin{itemize}
\item
  Python: \href{https://pypi.org/project/schemdraw/}{Schemdraw} und/oder
  \href{https://pypi.org/project/graphviz/}{graphviz}. Zur Ausführung
  von Graphviz wird außerdem eine lokale Installation des Programms
  \href{https://www.graphviz.org/}{Graphviz} benötigt.
\item
  R:
  \href{https://cran.r-project.org/web/packages/DiagrammeR/index.html}{DiagrammeR}
\end{itemize}

Am Ende des Bausteins besteht die Möglichkeit, ein Programm zur
Überprüfung einer Börsenstrategie zu entwickeln. Zur Veranschaulichung
wird ein Auszug aus der von Robert Shiller erstellten Datei
\texttt{ie\_data.xls} mit historischen Börsenkursen des S\&P 500
verwendet. Die Datei kann unter \url{https://shillerdata.com/} bezogen
werden.

\chapter{Lernziele}\label{lernziele}

In diesem Baustein lernen Sie, mit Hilfe von Pseudocode (komplexe)
Aufgabenstellungen zu strukturieren und Schritt für Schritt ein Programm
für die computergestützte Datenanalyse zu entwickeln. Außerdem lernen
Sie, den Programmablauf für das eigene Verständnis und den Austausch mit
Dritten in Form eines Flussdiagramms zu visualisieren.

Wenn Sie dieses Modul durchgearbeitet haben, können Sie \ldots{}

\begin{itemize}
\item
  die Entwicklung von Pseudocode als Kreativitätstechnik einsetzen,
\item
  ein Programm in Pseudocode beschreiben,
\item
  ein Programm in abgegrenzte Zwischenschritte aufteilen und diese in
  eine zweckmäßige Reihenfolge bringen,
\item
  die Abhängigkeiten zwischen den Zwischenschritten beschreiben,
\item
  die Voraussetzungen für die Ausführung jedes Zwischenschritts und des
  gesamten Programms benennen sowie
\item
  den Programmablauf als Flussdiagramm visualisieren.
\end{itemize}

Schlagworte: Ideen entwickeln, Programmbeschreibung, Pseudocode,
Programmablaufplan, DIN 66001

\chapter{Pseudocode}\label{pseudocode}

~

\section{Was ist Pseudocode?}\label{was-ist-pseudocode}

\begin{figure}[H]

{\centering \includegraphics[width=0.5\linewidth,height=\textheight,keepaspectratio]{index_files/mediabag/books/w-pseudocode/skript/00-bilder/festmahl-PCL.pdf}

}

\caption{~}

\end{figure}%

Toast Dining Eating von OpenClipart-Vectors ist lizensiert unter
\href{https://pixabay.com/service/license-summary/}{Pixabay Content
License}. Das Werk ist abrufbar auf
\href{https://pixabay.com/vectors/toast-dining-eating-event-festive-153723/}{Pixabay}.
2013

~

Denken Sie an die Zubereitung eines Festtagsmahls. Sie haben im Internet
ein Rezept gefunden, alle Zutaten von der Zutatenliste eingekauft und
beginnen entsprechend der angegebenen Zubereitungszeit vor der Ankunft
Ihrer Gäste zu kochen. Klingt gut, oder? Nun, dieses Vorgehen verspricht
hungrig wartende Gäste, denn Rezepte sind häufig keine fertige
Schritt-für-Schritt-Anleitung, sondern erfordern einige Vorarbeit:

\begin{itemize}
\item
  Mal fehlen Zutaten auf der Zutatenliste, mal bleibt eine zu besorgende
  Zutat im Rezept unerwähnt und am Ende übrig. Im vierten Schritt ruht
  der Teig bereits seit zwei Stunden im Kühlschrank und der Ofen ist
  schon auf 250 Grad vorgeheizt. Eine vollständige Aufgabenbeschreibung
  erfordert Vorbereitung: Nur wer alle Abhängigkeiten kennt, wird
  pünktlich fertig.
\item
  In der Küche gilt eine eigene Fachsprache: Wissen Sie, was blanchieren
  bedeutet, wieso selbst sauberes Gemüse geputzt werden soll, wann
  Nudeln al dente sind oder ob die Soße erst lichterloh brennen sollte,
  damit man sie ablöschen kann? Falls nicht, ist zunächst etwas
  Übersetzungsarbeit in eine für Sie verständliche Sprache gefragt.
\item
  Wer kein Messer hat, kann kein Brot schneiden: Die Zutaten sind nicht
  alles, zu einem gelungenen Gericht gehört auch das richtige Werkzeug.
  Haben Sie alles in der Küche, was Sie zur Zubereitung brauchen?
\end{itemize}

Kurz: Sie brauchen einen eigenen Plan -- nicht nur beim Kochen, sondern
auch bei der computergestützten Datenanalyse. Denn auch die Datenanalyse
erfolgt selten linear. Stattdessen wechseln sich Schritte zur
Organisation, Visualisierung, Auswertung und Weiterverarbeitung von
Daten ab. Dazu steht eine Vielzahl unterschiedlicher Programme mit
eigener Syntax zur Auswahl. Oder ist eine selbst geschriebene Funktion
besser geeignet? Häufig liegen Daten in unterschiedlichen Formaten vor
und müssen für die Verwendung spezialisierter Programme transformiert
werden. Dies sind typische Herausforderungen der Datenanalyse, die durch
eine gute Planung aufgefangen werden können. Bei der Planung hilft Ihnen
Pseudocode.

Pseudocode beschreibt ein Programm und informatische Konzepte in einer
leicht verständlichen, alltäglichen Sprache. Die Entwicklung von
Pseudocode kann sowohl als Kreativitätstechnik als auch als Schablone
zur strukturierten Lösung von Aufgabenstellungen genutzt werden.
Pseudocode erlaubt es, sich zunächst auf die konzeptionelle Lösung einer
Aufgabenstellung und die Planung des Programmaufbaus zu fokussieren.
Dies kann sinnvoll sein, um durch die Unterteilung des Programms in
Zwischenschritte die Entwicklung zu vereinfachen, benötigte Programme,
Pakete und Methoden zu identifizieren oder den Arbeitsaufwand
abzuschätzen.

Pseudocode ist auch ein Instrument, um sich mit Dritten über ein
Programm auszutauschen, zum Beispiel um ein Problem im Code zu erörtern.
Denn Pseudocode setzt keine Kenntnis einer bestimmten Programmiersprache
voraus und ist intuitiv verständlich. Zur Unterstützung der
Kommunikationsfunktion von Pseudocode kann dieser zum Beispiel als
Flussdiagramm visualisiert werden.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-Pseudocode}: Pseudocode}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-Pseudocode} 

Pseudocode beschreibt einen Lösungsweg für informatische
Aufgabenstellungen in formalisierter Alltagssprache statt mit den
Ausdrücken und der Syntax einer Programmiersprache. Das Präfix pseudo
stammt aus dem Griechischen und bedeutet falsch oder nur so aussehen als
ob. Pseudocode ist ‚falscher` Programmcode, der mit natürlicher Sprache
gebildet wird. {[}@Pseudocode-was-ist{]} Pseudocode ist darüber hinaus
auch ein Kommunikationsmittel, um sich mit anderen über informatische
Probleme und deren Lösung auszutauschen (z. B. Kommiliton:innen,
Betreuer:innen).

\end{tcolorbox}

\section{Pseudocode von einfach bis
ausführlich}\label{pseudocode-von-einfach-bis-ausfuxfchrlich}

In welcher Form und wie detailliert Sie Pseudocode formulieren, ist
abhängig von Ihrem Kenntnisstand und Ihrem Ziel: Für die Strukturierung
Ihres Programms in aufeinanderfolgende Zwischenschritte und die
Identifizierung von Abhängigkeiten ist eine einfache Auflistung von
Arbeitsschritten ausreichend. Für die Entwicklung eines Algorithmus
sowie die Identifizierung von benötigten Methoden (z. B. Schleifen) und
Werkzeugen (z. B. spezialisierte Pakete) wird es erforderlich sein,
Programmanweisungen detaillierter zu beschreiben. Eine ausführliche
Darstellung hilft Ihnen zum Beispiel, wiederkehrende Arbeitsschritte zu
identifizieren, die in eine Funktion ausgelagert werden können. Für die
Präsentation Ihres Programms auf einer Fachtagung oder die Dokumentation
in einem Benutzer:innenhandbuch kann ein Flussdiagramm zweckmäßig sein.

\section{einfach}

Programmanweisung mit sprechendem Namen

\texttt{SortiereAufsteigend}

\section{mittel}

Anweisungsblock in Alltagssprache

\begin{verbatim}
  SortiereAufsteigend
    DurchlaufeDatensatz (LängeDatensatz - 1) mal # Anzahl Wiederholungen
      Von Anfang bis (LängeDatensatz - 1) # Paarweise Vergleiche
        Vergleiche Wert und Nachfolger
        WENN Wert größer als Nachfolger DANN
          Vertausche Wert und Nachfolger
    AusgabeDatensatz 
\end{verbatim}

\section{ausführlich}

Anweisungsblock im Stil und mit Begriffen der Programmierung

\begin{verbatim}

  SortiereAufsteigend  
    WENN LängeDatensatz > 1 DANN
      VON Datensatz[IndexA = 1] BIS Datensatz [IndexA = LängeDatensatz - 1] TUE # Anzahl Schleifendurchläufe
        VON Datensatz[IndexB = 1] BIS Datensatz [IndexB = LängeDatensatz - 1] TUE # Paarweise Vergleiche
          WENN Datensatz[IndexB] > Datensatz[IndexB + 1] DANN
            Vertausche(Datensatz[IndexB], Datensatz[IndexB + 1])
              Schreibe(Datensatz[IndexB], nach = Zwischenlager)
              Schreibe(Datensatz[IndexB + 1], nach = Datensatz[IndexB])
              Schreibe(Zwischenlager, nach = Datensatz[IndexB + 1])
          WENN IndexB < LängeDatensatz - 1 DANN
            Erhöhe IndexB
      WENN IndexA < LängeDatensatz - 1 DANN
        Erhöhe IndexA
    AusgabeDatensatz
\end{verbatim}

\section{Flussdiagramm}

\begin{figure}[H]

{\centering \includegraphics[width=0.5\linewidth,height=\textheight,keepaspectratio]{books/w-pseudocode/skript/00-bilder/flussdiagramm-bubblesort-ms-mp.png}

}

\caption{Flussdiagramm Sortiere Aufsteigend}

\end{figure}%

Flussdiagramm von Marc Sönnecken und Maik Poetzsch

~

\chapter{Pseudocode erstellen}\label{pseudocode-erstellen}

Das im Folgenden vorgestellte Schema unterstützt Sie dabei, Ideen zu
entwickeln, ein Programm zu beschreiben und den Programmablauf zu
visualisieren. Pseudocode hilft Ihnen, Ihr Programm sowie die benötigten
Werkzeuge und Methoden in einer für Sie und Dritte verständlichen Weise
zu beschreiben. Wie Sie Pseudocode verfassen, ist eine individuelle
Angelegenheit, denn für die Erstellung von Pseudocode gibt es nur wenige
Regeln. Pseudocode soll vor allem Ihnen helfen, einen Lösungsweg für
eine Aufgabenstellung zu entwickeln. Pseudocode ist dann ‚richtig`
geschrieben, wenn er Ihnen hilft:

\begin{itemize}
\item
  Ihre Gedanken zu fokussieren,
\item
  eine Aufgabenstellung für Sie nachvollziehbar zu beschreiben,
\item
  die Aufgabenstellung in abgegrenzte Teilaufgaben zu untergliedern,
\item
  für die Teilaufgaben eine Lösungsvorschrift (Algorithmus) zu
  entwickeln,
\item
  benötigte Methoden und Werkzeuge zu identifizieren,
\item
  Ihre Lösungsvorschriften als ein Programm aufeinanderfolgender
  Arbeitsschritte zu beschreiben,
\item
  den Zeitaufwand für die Umsetzung abzuschätzen sowie
\item
  sich mit Dritten über Ihr Programm auszutauschen.
\end{itemize}

\section{Übungsaufgaben}\label{uxfcbungsaufgaben}

Für die Bearbeitung dieses Bausteins stehen zwei Übungsaufgaben zur
Auswahl. Die Übungsaufgaben sprechen auch Studierende ohne Vorkenntnisse
in der Datenanalyse an und verdeutlichen Teilaspekte der
Programmentwicklung. Am besten eignet sich jedoch ein eigenes Projekt,
das Sie bearbeiten möchten. Dazu haben Sie im Reiter ``Eigenes Projekt''
die Möglichkeit, eine eigene Aufgabenstellung zu formulieren.

\section{Übersicht}

\begin{itemize}
\item
  ohne Vorkenntnisse Datenanalyse: Hefezopf backen\\
  Lernziele: Aufgabenstellung in aufeinanderfolgende Arbeitsschritte
  untergliedern, Arbeitsschritte vollständig beschreiben, Abhängigkeiten
  und Voraussetzungen identifizieren (benötigte Werkzeuge
  identifizieren, Zeitaufwand schätzen)
\item
  mit Vorkenntnissen Datenanalyse: Vitamin C bei Meerschweinchen\\
  Lernziele: Datenanalyse in Pseudocode beschreiben.
\end{itemize}

\section{Eigenes Projekt}

Hier können Sie die Aufgabenstellung bzw. das Ziel Ihres Projekts
festhalten. Bitte beachten Sie, dass Ihr Text nicht gespeichert wird.

\section{Hefezopf backen}

Ihre Freundin Lisa schickt Ihnen ein Rezept, dass Sie im Internet
gefunden hat. Sie schreibt, dass Sie morgen schon eine Stunde früher zum
geplanten Treffen kommen kann, um vorher gemeinsam mit Ihnen zu backen
-- zu zweit würde man schon schneller fertig werden als in den im Rezept
angegebenen 65 Minuten. Lisa fragt auch, ob Sie noch Zutaten mitbringen
soll.

\textbf{Wie antworten Sie Lisa? Modellieren Sie den Backprozess.}

Das folgende Rezept wurde von Anna-Lena erstellt und ist abrufbar unter
\url{https://www.einfachbacken.de/rezepte/hefezopf}.

\textbf{\emph{Zarter Hefezopf}}\\
Arbeitszeit 40 Min.\\
Backen 25 Min.

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Zutaten & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
250 ml & Milch \\
475 g & Weizenmehl (Type 405) \\
60 g & Zucker \\
½ Würfel & frische Hefe (ca. 21 g) \\
50 g & weiche Butter (Zimmertemperatur) \\
1 Prise & Salz \\
1 & Ei (Gr. M) \\
& etwas Milch zum Bestreichen \\
& etwas Hagelzucker zum Bestreuen \\
& etwas Mehl zur Teigverarbeitung \\
\end{longtable}

~

\textbf{1. Schritt}

\textbf{250 ml} Milch, \textbf{475 g} Weizenmehl (Type 405), \textbf{1
Prise} Zucker, \textbf{½ Würfel} frische Hefe (ca. 21 g)

Milch erwärmen bis sie lauwarm ist. Mehl in eine Schüssel sieben. Eine
Mulde darin bilden und die Hefe in die Mulde bröseln. 3 EL von der
lauwarmen Milch mit 1 Prise Zucker vermischen und über die Hefe in der
Mulde gießen. Mit einem Löffel die Hefe-Milchmischung etwas vermischen
(noch nicht das Mehl einkneten). Die Schüssel mit einem Geschirrhandtuch
abdecken und an einem warmen Ort ca. 15 Min. gehen lassen.

\textbf{2. Schritt}

\textbf{1} Ei (Gr. M), \textbf{60 g} Zucker, \textbf{1 Prise} Salz,
\textbf{50 g} weiche Butter (Zimmertemperatur)

Ei, restliche Milch, restlichen Zucker und Salz in die Schüssel geben
und zusammen mit der Hefemischung und dem Mehl 3 Min. auf niedriger
Stufe, dann ca. 5 Min. auf hoher Stufe mit den Knethaken des Rührgeräts
verkneten. Butter in Stücken nach und nach unterkneten. Damit der Teig
später gut aufgeht, sollte der Teig mindestens 5 Min. kräftig geknetet
werden. Sonst kann der Teig später zusammenfallen oder klebrig sein!

\textbf{3. Schritt}

etwas Mehl zur Teigverarbeitung

Schüssel mit dem Teig nochmals mit einem Geschirrhandtuch abdecken und
weitere 60 Min. an einem warmen Ort gehen lassen. Dann den{[} {]}Teig
auf eine bemehlte Arbeitsfläche geben und in drei Teile teilen. Die
Teigstücke jeweils zu einer langen Wurst mit 40 cm Länge rollen.
Teigsträhnen zu einem Zopf flechten. Die Enden miteinander verdrehen und
unter den Zopf legen, damit sie einen schönen Abschluss bilden. Zopf auf
ein mit Backpapier belegtes Blech legen und mit einem Geschirrhandtuch
abdecken. Nochmals 45 Min. gehen lassen.

\textbf{4. Schritt}

etwas Milch zum Bestreichen, etwas Hagelzucker zum Bestreuen

Währenddessen den Backofen auf \textbf{200 Grad Ober-/ Unterhitze
(Umluft: 180 Grad)} vorheizen. Zopf mit etwas Milch bestreichen und mit
Hagelzucker bestreuen. Zopf schließlich im vorgeheizten Ofen \textbf{ca.
15-20 Minuten} leicht bräunlich backen. Vollständig auskühlen lassen.
Der Zopf kann auch wunderbar eingefroren werden.

\section{Vitamin C bei Meerschweinchen}

In einer Gruppe von 60 Meerschweinchen wurde die Länge der zahnbildenden
Zellen (Odontoblasten) in Micron gemessen (\textbf{len}). Den Tieren
wurde zuvor Vitamin C in Form von Ascorbinsäure (VC) oder Orangensaft
(VC) verabreicht (\textbf{supp}). Die Meerschweinchen erhielten Dosen
von 0.5, 1 oder 2 Milligramm Vitamin C pro Tag (\textbf{dose}).
{[}@Crampton.1947{]}

\textbf{Welche Wirkung hat Vitamin C auf das Zahnwachstum von
Meerschweinchen? Erläutern Sie Ihr Vorgehen mit Hilfe von Pseudocode
oder mit Hilfe eines Flussdiagramms, um den Effekt der Verabreichungsart
und der Dosis zu bestimmen.}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
\# & len & supp & dose \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & 4.2 & VC & 0.5 \\
11 & 16.5 & VC & 1 \\
21 & 23.6 & VC & 2 \\
31 & 15.2 & OJ & 0.5 \\
41 & 19.7 & OJ & 1 \\
51 & 25.5 & OJ & 2 \\
\end{longtable}

~

Wenn Sie sich den vollständigen Datensatz ansehen möchten, können Sie
diesen in R mit \texttt{ToothGrowth} aufrufen oder den Datensatz hier
herunterladen:
\href{https://vincentarelbundock.github.io/Rdatasets/csv/datasets/ToothGrowth.csv}{ToothGrowth.csv}

\section{Mit EVA zum Fokussprint}\label{mit-eva-zum-fokussprint}

\begin{figure}[H]

{\centering \includegraphics[width=0.5\linewidth,height=\textheight,keepaspectratio]{books/w-pseudocode/skript/00-bilder/adam-eve-PCL-de.png}

}

\caption{~}

\end{figure}%

Adam Bible Nature von CCXpistiavos ist lizensiert unter
\href{https://pixabay.com/service/license-summary/}{Pixabay Content
License}. Das Werk ist abrufbar auf
\href{https://pixabay.com/vectors/adam-bible-bible-pics-2061819/}{Pixabay}.
Die Sprechblase wurde ergänzt.

~

Manchmal ist aller Anfang schwer. Der erste Schritt zur
Programmentwicklung besteht in der Ideensammlung: Was soll genau getan
werden, welche Schritte sind dafür erforderlich, was kann bereits
erledigt werden, was muss noch vorbereitet oder recherchiert werden?
\textbf{Wenn Sie bereits eine gute Vorstellung von der Aufgabenlösung
haben, können Sie diesen Schritt überspringen.}

Der \textbf{Fokussprint} (Scheuermann 2016) ist eine schnelle
Schreibdenkübung, um einen Einstieg ins Schreiben zu einem bestimmten
Thema zu finden. Die Übung kann als Kreativitätstechnik für den Einstieg
in ein Thema, aber auch zwischendurch als Denkhilfe eingesetzt werden.
Es geht dabei darum, mit einem hohen Schreibtempo drauflos zu schreiben.
Dadurch schreiben Sie nahe an Ihrer inneren Sprache und Ihre Kreativität
kann freien Lauf nehmen. {[}@Scheuermann2016, 74, 78{]}

Der Fokussprint wird in zwei Schritten durchgeführt: Der erste Schritt
besteht in einer fünfminütigen Schreibphase. Formulieren Sie auf einem
Blatt Papier oder am Computer die Aufgabenstellung oder das Problem, zu
dem Sie Ihre Gedanken sammeln möchten. Hier können Sie sich mit einem
Stichwort kurzfassen oder eine konkrete Frage formulieren. Stellen Sie
sich einen Wecker auf 5 Minuten und beginnen mit dem Schnellschreiben
auf dem vorbereiteten Blatt. Es gibt nur eine Regel: Wenn Sie bemerken,
dass Ihre Gedanken vom Thema der Überschrift abschweifen, besinnen Sie
sich auf das Thema, zum Beispiel, indem Sie die Aufgabenstellung erneut
aufschreiben (einfach dort, wo Sie gerade schreiben).
{[}@Scheuermann2016, 78{]}

\subsection*{Fokussprint}\label{fokussprint}
\addcontentsline{toc}{subsection}{Fokussprint}

\textbf{In diesem Textfeld können Sie Ihren Fokussprint durchführen.
Bitte beachten Sie, dass Ihr Text nicht gespeichert wird.~Also dann: 3,
2, 1 -- schreiben Sie in eigenen Worten los!}

~

Im zweiten Schritt erfolgt die Auswertung. Lesen Sie Ihren Fokussprint
durch und markieren Sie, was Ihnen wichtig erscheint. Können Sie
Zwischenschritte identifizieren? Wenn ja, markieren Sie diese und fügen
Ergänzungen, Kommentare oder Fragen hinzu. {[}vgl. @Scheuermann2016,
78{]}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-Zwischenschritte}: Zwischenschritte identifizieren}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-Zwischenschritte} 

Zwischenschritte teilen eine komplexe Aufgabenstellung in überschaubare
Arbeitspakete auf, die jeweils eine bestimmte Funktion im Programmablauf
erfüllen (z. B. das Sortieren von Daten) oder ein bestimmtes
Arbeitsergebnis erzeugen (z. B. eine Grafik). Ein Zwischenschritt ist
also ein Unterprogramm und bei der Bildung von Zwischenschritten geht es
somit darum, eine Aufgabenstellung in Teilaufgaben aufzuteilen und eine
Vorstellung davon zu gewinnen, welche Arbeitsschritte in einem
Unterprogramm ausgeführt werden müssen, um die Teilaufgabe zu lösen.

Die Bildung von Zwischenschritten dient vor allem der
Komplexitätsreduktion. Ein zur Lösung einer abgegrenzten Teilaufgabe
entwickeltes Unterprogramm hat zum einen den Vorteil, dass es leicht
getestet werden kann, um Fehler zu finden und zu beheben. Zum anderen
kann ein Unterprogramm wiederholt im Programmablauf aufgerufen werden,
z. B. um die Lösung einer anderen, komplexeren Teilaufgabe zu
vereinfachen.

Bei der Abgrenzung von Zwischenschritten können auch andere Kriterien
als die erbrachte Funktion oder das produzierte Arbeitsergebnis sinnvoll
sein, etwa nach dem Ort der Datenverarbeitung (z. B. an der Messstelle,
am Arbeitsrechner, im Rechenzentrum) oder nach den verwendeten
Werkzeugen (z. B. Mikrocontroller, Python, C++, manuelle
Datenverarbeitung).

\phantomsection\label{tip-uxdcbungsaufgaben}
\begin{quote}
\textbf{Tip~5.1: Mögliche Zwischenschritte für die Übungsaufgaben}

Hefezopf backen

\begin{itemize}
\item
  Unterteilung nach Funktion: Vorbereiten der Zutaten, Verarbeiten der
  Zutaten, Backen
\item
  Unterteilung nach Arbeitsergebnissen: Milchmischung zubereiten,
  Hefemischung zubereiten, Rohteig zubereiten, Teigzopf formen, Zopf
  backen
\end{itemize}

Vitamin C bei Meerschweinchen

\begin{itemize}
\item
  Unterteilung nach Funktion: Teildatensätze bilden, Datensatz
  auswerten, Datensatz darstellen, Flussdiagramm erstellen
\item
  Unterteilung nach Arbeitsergebnis: tabellierter Mittelwertvergleich,
  Boxplot für alle Teilgruppen, Mermaid Flussdiagramm
\end{itemize}
\end{quote}

\end{tcolorbox}

Das \textbf{EVA-Prinzip} hilft Ihnen, Zwischenschritte vollständig zu
beschreiben. Das EVA-Prinzip ist ein Grundmuster der computergestützten
Datenverarbeitung und steht für \textbf{E}ingabe, \textbf{V}erarbeitung
und \textbf{A}usgabe. Diese Schritte folgen aufeinander: Zuerst werden
die Daten erfasst, dann erfolgt die Datenverarbeitung, zuletzt werden
die Ergebnisse ausgegeben.

\begin{itemize}
\item
  Eingabe: Welche Daten liegen als Eingabe vor? Welches Format haben die
  Daten?
\item
  Verarbeitung: Welche Arbeitsschritte müssen durchgeführt werden, um
  die beschriebene Ausgabe zu erreichen?
\item
  Ausgabe: Welches Ergebnis soll durch die Datenverarbeitung erzeugt
  werden? Welches Format hat die Ausgabe?
\end{itemize}

Fassen Sie zum Abschluss Ihren Fokussprint in einem Kernsatz zusammen,
der das für Sie Wichtigste hervorhebt. Dies kann eine Feststellung, aber
auch eine offene Frage, die Sie weiter verfolgen möchten, sein.
Markieren Sie diesen Kernsatz zusätzlich. {[}@Scheuermann2016, 79{]}

Damit haben Sie den ersten Schritt zur Formulierung einer vollständigen
Programmbeschreibung geschafft! Wenn Sie möchten, können Sie Ihre
Gedanken zu einer noch offenen Frage oder zu einem Zwischenschritt mit
einem erneuten Fokussprint vertiefen. Andernfalls folgt nun der nächste
Schritt.

\section{Programmbeschreibung in
Pseudocode}\label{programmbeschreibung-in-pseudocode}

Sie haben nun eine Vorstellung von Ihrem Lösungsweg, den
Zwischenschritten, aus denen dieser besteht, und von ihrer Abfolge. Im
zweiten Schritt wird Ihr Programm durch die Beschreibung mit Pseudocode
formalisiert. Dazu werden Programmanweisungen zwar alltagssprachlich,
aber im Stil und mit Begriffen der Programmierung formuliert. Dies
bedeutet,

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  für Programmanweisungen sprechende Namen zu vergeben. In der
  Datenanalyse benutzte Anweisungen sind:

  \begin{itemize}
  \item
    Daten importieren (import), z. B. HoleDatenVonOrt
  \item
    Daten organisieren (tidy), z. B. SortiereAufsteigend
  \item
    Daten transformieren (transform), z. B. BildeDurchschnitt
  \item
    Daten visualisieren (visualise), z. B. ErzeugeHistogramm
  \item
    Daten modellieren (model), z. B. ErzeugeLinearesModell
  \item
    Daten exportieren (export), z. B. SpeicherePlot
  \end{itemize}

  {[}vgl. @R-for-Data-Science, Kapitel Whole game{]}
\item
  den Programmablauf zu dokumentieren, indem

  \begin{itemize}
  \item
    aufeinanderfolgende Programmanweisungen untereinandergeschrieben,
  \item
    Blöcke von Programmanweisungen durch Einrückung und/oder
    Einklammerung kenntlich gemacht und
  \item
    zusammenhängende Programmanweisungen in abgegrenzten
    Zwischenschritten gruppiert werden.
  \end{itemize}
\item
  Programmanweisungen von erläuternden Teilen durch Kommentare zu
  trennen, indem

  \begin{itemize}
  \item
    Kommentare durch Sonderzeichen gekennzeichnet, beispielsweise
    \texttt{//\ Kommentar}, \texttt{\#\ Kommentar},
    \texttt{\%\%\ Kommentar} oder \texttt{/*\ Kommentar\ */}, und
  \item
    einzelnen Arbeitsschritten vorangestellt (z. B. Kurzbeschreibung von
    Zwischenschritten nach EVA) und/oder innerhalb einer Zeile benutzt
    werden.
  \end{itemize}
\item
  Komplexe Programmanweisungen mit informatischen Begriffen
  auszudrücken, ggf. in Anlehnung an die Begriffe und Syntax der von
  Ihnen gewählten Programmiersprache. Dies umfasst:

  \textbf{Fallunterscheidungen:} Fallunterscheidungen machen die
  Ausführung von Programmanweisungen abhängig von einer oder von
  mehreren Bedingungen.

  \begin{itemize}
  \item
    WENN A (kleiner, kleiner gleich, genau gleich, größer als, größer
    gleich, ungleich) B, DANN C, SONST D
  \item
    WENN A B1 UND B2, DANN C
  \item
    WENN A B1 ODER B2, DANN C
  \end{itemize}

  \textbf{Schleifen:} Schleifen wiederholen Programmanweisungen solange
  die Eintrittsbedingung gilt bzw. die Abbruchbedingung eintritt.

  \begin{itemize}
  \item
    SOLANGE A, TUE C
  \item
    VON A BIS B, TUE C
  \end{itemize}

  \textbf{Funktionen:} Funktionen bündeln Programmanweisungen, damit
  Programmteile mehrfach verwendet werden können. Funktionen sind eine
  Form von Unterprogrammen.

  \begin{itemize}
  \tightlist
  \item
    FunktionTueXY(Argument 1, Argument 2, \ldots)\\
    Anweisung1\\
    Anweisung2\\
    \ldots{}
  \end{itemize}
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-beispiel-pseudocode}: Programmbeschreibung in Pseudocode}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-beispiel-pseudocode} 

\begin{verbatim}
# Eingabe: eindimensionaler, ordinaler Datensatz
# Verarbeitung: Prüfung ob Datensatz mindestens zwei Werte enthält
## falls nein: Fehlermeldung
## falls ja: aufsteigende Sortierung mit Bubblesort mit Kontrollstruktur für den äußeren Schleifendurchlauf
# Ausgabe: aufsteigend sortierter Datensatz

  SortiereAufsteigend(Datensatz)
    WENN LängeDatensatz > 1 DANN

      # äußere Schleife
      do_work = WAHR # Kontrollstruktur für die äußere Schleife
      WENN do_work == WAHR DANN

        VON Datensatz[IndexA = 1] BIS Datensatz [IndexA = LängeDatensatz - 1] TUE
          do_work = FALSCH

          # innere Schleife für paarweise Vergleiche
          VON Datensatz[IndexB = 1] BIS Datensatz [IndexB = LängeDatensatz - 1] TUE
            WENN Datensatz[IndexB] > Datensatz[IndexB + 1] DANN
              Vertausche(Datensatz[IndexB], Datensatz[IndexB + 1])
                Schreibe(Datensatz[IndexB], nach = Zwischenlager)
                Schreibe(Datensatz[IndexB + 1], nach = Datensatz[IndexB])
                Schreibe(Zwischenlager, nach = Datensatz[IndexB + 1])
              do_work = WAHR # merke, wenn etwas vertauscht wurde
            WENN IndexB < LängeDatensatz - 1 DANN
              Erhöhe IndexB
          
          WENN IndexA < LängeDatensatz - 1 DANN
            Erhöhe IndexA

      AusgabeDatensatz
    SONST
      Melde("Der Datensatz muss mindenstens zwei Elemente enthalten!")
\end{verbatim}

\emph{Hinweis: Die manuelle Erhöhung der Zählindizes ist bei
Programmiersprachen in der Regel nicht erforderlich und dient nur der
besseren Verständlichkeit}.

\end{tcolorbox}

Mit der Formalisierung Ihres Programms in Pseudocode haben Sie eine
intuitiv verständliche, vollständige Programmbeschreibung entwickelt. Im
nächsten Schritt können Sie Ihr Programm grafisch darstellen.

~

\section{Übungsaufgabe zählen}

\textbf{Beschreiben Sie ein Programm, das von 1-10 und von 15 bis 20
zählt, in Pseudocode.}

In diesem Textfeld können Sie Ihren Pseudocode schreiben. Bitte beachten
Sie, dass Ihr Text nicht gespeichert wird.

\section{Musterlösung Pseudocode}

\begin{verbatim}
i = 0
SOLANGE i kleiner als 10 TUE
  erhöhe i um 1
  Ausgabe i
i = 14
SOLANGE i kleiner als 20 TUE
  erhöhe i um 1
  Ausgabe i
\end{verbatim}

\subsection{Karel The Robot}\label{karel-the-robot}

Wenn Sie die Anwendung informatischer Konzepte wie Fallunterscheidung
oder Schleifen üben möchten, ist
\href{https://github.com/fredoverflow/karel}{Karel The Robot} einen
Blick wert. Das Programm führt mit einer eigenen Pseudocode-Sprache in
die Anwendung informatischer Kontrollstrukturen ein.

Eine Vorstellung des Programms, Hinweise zur Installation und Bedienung
finden Sie auf der im vorherigen Absatz verlinkten GitHub-Seite oder auf
dem YouTube-Kanal der Medienberatung Niedersachsen:

\url{https://www.youtube.com/watch?v=vD8RN_WbvLo}

Programmieren lernen mit Karel von Medienberatung Niedersachsen ist
lizensiert unter
\href{https://creativecommons.org/licenses/by/4.0/}{CC-BY}. Das Werk ist
abrufbar auf
\href{https://www.youtube.com/watch?v=vD8RN_WbvLo}{YouTube}. 2022

\section{Programmablauf
visualisieren}\label{programmablauf-visualisieren}

\begin{figure}[H]

{\centering \includegraphics[width=0.5\linewidth,height=\textheight,keepaspectratio]{books/w-pseudocode/skript/00-bilder/woman-speaker.png}

}

\caption{~}

\end{figure}%

Lead 1 von CocoMaterial ist lizensiert unter
\href{https://creativecommons.org/publicdomain/zero/1.0/}{CC0 1.0}. Das
Werk ist abrufbar auf
\href{https://cocomaterial.com/results?q=megaphone&vectorId=65}{CocoMaterial}.

~

Eine anschauliche grafische Darstellung verhilft Pseudocode zu noch mehr
Klarheit und unterstützt dadurch insbesondere den Austausch mit Dritten.
Die grafische Darstellung eines Programms wird Programmablaufplan oder
Flussdiagramm genannt. Die für einen Programmablaufplan verwendeten
Symbole sind in der {[}@DIN-66001-1983{]} genormt. Die Formen werden
auch als Knoten (nodes) bezeichnet, die Verbindungen als Kanten (edges).

\begin{figure}

\begin{minipage}{0.30\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/w-pseudocode/skript/00-bilder/start-stopp.pdf}}\end{minipage}%
%
\begin{minipage}{0.70\linewidth}

\begin{description}
\tightlist
\item[Rechteck mit gerundeten Seiten (Nummer 6.4.1)]
Grenzstelle zur Umwelt, die Beginn und Ende einer Folge anzeigt und
beispielsweise Herkunft oder Verbleib von Daten signalisiert.
\end{description}

\end{minipage}%
\newline
\begin{minipage}{0.30\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/w-pseudocode/skript/00-bilder/verarbeitung.pdf}}\end{minipage}%
%
\begin{minipage}{0.70\linewidth}

\begin{description}
\tightlist
\item[Rechteck (Nummer 6.1.1)]
Verarbeitung einschließlich Ein-/Ausgabe
\end{description}

\end{minipage}%
\newline
\begin{minipage}{0.30\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/w-pseudocode/skript/00-bilder/entscheidung.pdf}}\end{minipage}%
%
\begin{minipage}{0.70\linewidth}

\begin{description}
\tightlist
\item[Raute (Nummer 6.1.2)]
Verzweigung/Entscheidung
\end{description}

\end{minipage}%
\newline
\begin{minipage}{0.30\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/w-pseudocode/skript/00-bilder/unterprogramm.pdf}}\end{minipage}%
%
\begin{minipage}{0.70\linewidth}

\begin{description}
\tightlist
\item[Rechteck mit doppelten, vertikalen Linien (Nummer 7.2.4)]
Hinweis auf ein an anderer Stelle dokumentiertes Programm
\end{description}

\end{minipage}%
\newline
\begin{minipage}{0.30\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/w-pseudocode/skript/00-bilder/verbindungen.pdf}}\end{minipage}%
%
\begin{minipage}{0.70\linewidth}

\begin{description}
\tightlist
\item[Verbindung (Nummer 6.3.1)]
Prozessketten werden mit Linien oder Pfeilen verbunden. Die Verbindungen
sind von links nach rechts bzw. von oben nach unten orientiert,
Abweichungen davon müssen mit Pfeilspitzen gekenzeichnet werden.

Sind mehrere Ausgänge mit Bedingungen verknüpft, müssen diese durch
Beschriftung an den Verbindungslinien kenntlich gemacht werden.

Mehrere Verbindungen zu einem Sinnbild können zu einer Verbindung
zusammengeführt werden. Sich kreuzende Verbindungslinien sollten aber
vermieden werden. Diese stellen keine Zusammenführung dar.
(\emph{Hinweis: Für die Darstellung zusammengeführter Verbindungen wird
Schemdraw empfohlen.})
\end{description}

\end{minipage}%

\end{figure}%

{[}@DIN-66001-1983{]}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-DIN66001} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-DIN66001}: Darstellung von Daten nach DIN 66001}\vspace{3mm}

Die DIN 66001 definiert auch Sinnbilder zur Darstellung von Daten. Die
Norm regelt aber für Programmablaufpläne: ``Daten werden nicht
dargestellt. Siehe Beispiel in Abschnitt A.2.'' {[}@DIN-66001-1983, S.
2{]}. Gleichwohl sind im Beispiel A.2 spezfische Typen von Daten
dargestellt, beispielsweise manuell oder maschinell zu verarbeitende
Daten {[}@DIN-66001-1983, S. 13-14{]}.

Jedoch sind die in den Nummern 6.2.2 bis 6.2.10 definierten Sinnbilder
für spezifische Datentypen nicht in allen Diagrammwerkzeugen vollständig
verfügbar. Dies betrifft:

\begin{itemize}
\item
  \href{https://graphviz.org/doc/info/shapes.html}{Graphviz} (z. B.
  maschinell zu verarbeitende Daten entsprechend Nummer 6.2.2)
\item
  \href{https://mermaid.js.org/syntax/flowchart.html\#node-shapes}{Mermaid}
  (z. B. maschinell zu verarbeitende Daten entsprechend Nummer 6.2.2)
\item
  Bürosoftwarepaket LibreOffice (z. B. manuell zu verarbeitende Daten
  entsprechend Nummer 6.2.3)
\end{itemize}

In der Darstellung von Programmablaufplänen ist die Verwendung des
Sinnbilds Nr. 6.2.1 Daten allgemein üblich.

\begin{figure}[H]

\begin{minipage}{0.30\linewidth}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/w-pseudocode/skript/00-bilder/din-daten-allgemein.pdf}}

}

\subcaption{~}

\end{figure}%

\end{minipage}%
%
\begin{minipage}{0.70\linewidth}

\begin{description}
\tightlist
\item[Daten (Nummer 6.2.1)]
Darstellung für Daten oder Datenträger allgemein
\end{description}

\end{minipage}%

\end{figure}%

\end{minipage}%
\end{tcolorbox}

\subsection*{Werkzeuge zur Erstellung von
Flussdiagrammen}\label{werkzeuge-zur-erstellung-von-flussdiagrammen}
\addcontentsline{toc}{subsection}{Werkzeuge zur Erstellung von
Flussdiagrammen}

Flussdiagramme können auf unterschiedliche Weise erstellt werden:

\begin{itemize}
\item
  mit Stift und Papier,
\item
  mit Bürosoftwarepaketen wie LibreOffice,
\item
  Visualisierungsprogrammen wie \href{https://graphviz.org/}{Graphviz}
  oder \href{https://mermaid.js.org/}{Mermaid},
\item
  mit spezialisierten Paketen wie
  \href{https://cran.r-project.org/web/packages/DiagrammeR/index.html}{DiagrammeR}
  oder
  \href{https://schemdraw.readthedocs.io/en/latest/elements/flow.html}{Schemdraw}.
\end{itemize}

Der Funktionsumfang und die Syntax unterscheiden sich und jedes Werkzeug
hat eigene Stärken. Mermaid, Graphviz und Schemdraw sind deklarative
Zeichenwerkzeuge, mit denen Flussdiagramme (und andere Grafiken)
geschrieben und graphisch umgesetzt werden können. Mermaid hat eine
einfache, intuitive Syntax. Graphviz erlaubt mehr
Gestaltungsmöglichkeiten (benötigt in Python aber eine lokale
Systeminstallation). Das Python-Modul Schemdraw unterstützt eine an
Pythoncode angelehnte Syntax und bietet einen einfachen Zugriff auf
DIN-konforme Knoten und Kanten.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-flowcharts}: Flussdiagramme in Python und R erstellen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-flowcharts} 

\section{Codebeispiel Python}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Flussdiagramm mit Schemdraw und Graphviz in Python}

\CommentTok{\#\# Schemdraw}
\ImportTok{import}\NormalTok{ subprocess}
\NormalTok{subprocess.call([}\StringTok{\textquotesingle{}pip\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}install\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}schemdraw\textquotesingle{}}\NormalTok{])}
\ImportTok{import}\NormalTok{ schemdraw}

\ImportTok{from}\NormalTok{ schemdraw.flow }\ImportTok{import} \OperatorTok{*}

\ControlFlowTok{with}\NormalTok{ schemdraw.Drawing() }\ImportTok{as}\NormalTok{ d:}
    \CommentTok{\# durchgehender Prozess in korrekter Reihenfolge von Start bis Ende}
\NormalTok{    d}\OperatorTok{+=}\NormalTok{ Start().label(}\StringTok{"Mittagspause"}\NormalTok{)}
\NormalTok{    d}\OperatorTok{+=}\NormalTok{ Line().down()}
\NormalTok{    d}\OperatorTok{+=}\NormalTok{ Box().label(}\StringTok{"Kartoffeln abzählen"}\NormalTok{)}
\NormalTok{    d}\OperatorTok{+=}\NormalTok{ Line().down()}
\NormalTok{    d}\OperatorTok{+=}\NormalTok{ (mit\_Schale }\OperatorTok{:=}\NormalTok{ Decision(S }\OperatorTok{=} \StringTok{"Ja"}\NormalTok{, E }\OperatorTok{=} \StringTok{"Nein"}\NormalTok{).label(}\StringTok{"Mit Schale?"}\NormalTok{))}
\NormalTok{    d}\OperatorTok{+=}\NormalTok{ Arrow().at(mit\_Schale.S)}
\NormalTok{    d}\OperatorTok{+=}\NormalTok{ (kochen }\OperatorTok{:=}\NormalTok{ Box().label(}\StringTok{"Kartoffeln kochen"}\NormalTok{))}
\NormalTok{    d}\OperatorTok{+=}\NormalTok{ Line().down()}
\NormalTok{    d}\OperatorTok{+=}\NormalTok{ Box().label(}\StringTok{"Kartoffeln essen"}\NormalTok{)}
\NormalTok{    d}\OperatorTok{+=}\NormalTok{ Line().down()}
\NormalTok{    d}\OperatorTok{+=}\NormalTok{ Start().label(}\StringTok{"Pause Ende"}\NormalTok{)}

    \CommentTok{\# alternativer Ast der Verzweigung}
\NormalTok{    d}\OperatorTok{+=}\NormalTok{ Arrow().right().at(mit\_Schale.E)}
\NormalTok{    d}\OperatorTok{+=}\NormalTok{ (schälen }\OperatorTok{:=}\NormalTok{ Box().label(}\StringTok{"Kartoffeln schälen"}\NormalTok{))}
\NormalTok{    d}\OperatorTok{+=}\NormalTok{ Wire(}\StringTok{"|{-}"}\NormalTok{, arrow }\OperatorTok{=} \StringTok{"{-}\textgreater{}"}\NormalTok{).at(schälen.S).to(kochen.E) }\CommentTok{\# .S + .E (oder andere Richtungsangaben) müssen gesetzt werden, |{-} definiert zunächst vertikale, rechtwinkelige Kante}
    
\NormalTok{    d.draw()}
    \CommentTok{\# d.save("Kartoffeln.svg")}

\CommentTok{\#\# Graphviz}
\CommentTok{\#\# benötigt eine lokale Installation von Graphviz https://graphviz.org/download/}

\ImportTok{import}\NormalTok{ subprocess}
\NormalTok{subprocess.call([}\StringTok{\textquotesingle{}pip\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}install\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}graphviz\textquotesingle{}}\NormalTok{]) }\CommentTok{\# installiert das Modul graphviz}
\ImportTok{import}\NormalTok{ graphviz}

\NormalTok{dot }\OperatorTok{=}\NormalTok{ graphviz.Digraph(name }\OperatorTok{=} \StringTok{"Kartoffeln"}\NormalTok{)}

\CommentTok{\#\#\# Start / Ende}
\NormalTok{dot.node(name }\OperatorTok{=} \StringTok{"Mittagspause"}\NormalTok{, shape }\OperatorTok{=} \StringTok{"Mrecord"}\NormalTok{) }\CommentTok{\# optional label}
\NormalTok{dot.node(name }\OperatorTok{=} \StringTok{"Pause Ende"}\NormalTok{, shape }\OperatorTok{=} \StringTok{"Mrecord"}\NormalTok{)}

\CommentTok{\#\#\# Anweisungen}
\NormalTok{dot.node(name }\OperatorTok{=} \StringTok{"Kartoffeln abzählen"}\NormalTok{, shape }\OperatorTok{=} \StringTok{"box"}\NormalTok{)}
\NormalTok{dot.node(name }\OperatorTok{=} \StringTok{"Kartoffeln schälen"}\NormalTok{, shape }\OperatorTok{=} \StringTok{"box"}\NormalTok{)}
\NormalTok{dot.node(name }\OperatorTok{=} \StringTok{"Kartoffeln kochen"}\NormalTok{, shape }\OperatorTok{=} \StringTok{"box"}\NormalTok{)}
\NormalTok{dot.node(name }\OperatorTok{=} \StringTok{"Kartoffeln essen"}\NormalTok{, shape }\OperatorTok{=} \StringTok{"box"}\NormalTok{)}

\CommentTok{\#\#\# Entscheidung}
\NormalTok{dot.node(name }\OperatorTok{=} \StringTok{"mit Schale"}\NormalTok{, shape }\OperatorTok{=} \StringTok{"diamond"}\NormalTok{)}
    
\CommentTok{\#\#\# Kanten}
\NormalTok{dot.edge(}\StringTok{"Mittagspause"}\NormalTok{, }\StringTok{"Kartoffeln abzählen"}\NormalTok{, arrowhead }\OperatorTok{=} \StringTok{"none"}\NormalTok{)}
\NormalTok{dot.edge(}\StringTok{"Kartoffeln abzählen"}\NormalTok{, }\StringTok{"mit Schale"}\NormalTok{, arrowhead }\OperatorTok{=} \StringTok{"none"}\NormalTok{)}
\NormalTok{dot.edge(}\StringTok{"mit Schale"}\NormalTok{, }\StringTok{"Kartoffeln kochen"}\NormalTok{, label }\OperatorTok{=} \StringTok{"Ja"}\NormalTok{)}
\NormalTok{dot.edge(}\StringTok{"mit Schale"}\NormalTok{, }\StringTok{"Kartoffeln schälen"}\NormalTok{, label }\OperatorTok{=} \StringTok{"nein"}\NormalTok{)}
\NormalTok{dot.edge(}\StringTok{"Kartoffeln schälen"}\NormalTok{, }\StringTok{"Kartoffeln kochen"}\NormalTok{, arrowhead }\OperatorTok{=} \StringTok{"none"}\NormalTok{)}
\NormalTok{dot.edge(}\StringTok{"Kartoffeln kochen"}\NormalTok{, }\StringTok{"Kartoffeln essen"}\NormalTok{, arrowhead }\OperatorTok{=} \StringTok{"none"}\NormalTok{)}
\NormalTok{dot.edge(}\StringTok{"Kartoffeln essen"}\NormalTok{, }\StringTok{"Pause Ende"}\NormalTok{, arrowhead }\OperatorTok{=} \StringTok{"none"}\NormalTok{)}

\NormalTok{dot.render(}\StringTok{"Kartoffeln.gv"}\NormalTok{, cleanup }\OperatorTok{=} \VariableTok{True}\NormalTok{, view }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\section{Schemdraw in Python}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/w-pseudocode/skript/00-bilder/Kartoffeln.pdf}}

}

\caption{Flussdiagramm mit Schemdraw}

\end{figure}%

\emph{Hinweis: Aus technischen Gründen wurde die Grafik als Bild
eingebunden.}

\section{Codebeispiel R}

\begin{verbatim}
# Flussdiagramm mit DiagrammeR in R

install.packages("DiagrammeR")
library("DiagrammeR")

## Mermaid
DiagrammeR::mermaid("
  graph TD
    0(Mittagspause)
    A[Kartoffeln abzählen]
    B{mit Schale}
    D[Kartoffeln kochen]
    E[Kartoffeln essen]
    S[Kartoffeln schälen]
    Z(Pause Ende)
    
    0---A
    A---B
    B-->|ja|D
    B-->|nein|S
    S---D
    D---E
    E---Z
")

## Graphviz
DiagrammeR::grViz("

  graph Kartoffeln {
  
  # defining nodes
  node [shape = Mrecord]
  
    Mittagspause; Pause_Ende
  
  node [shape = box]
  
    Kartoffeln_abzählen
    Kartoffeln_schälen
    Kartoffeln_kochen
    Kartoffeln_essen
    
  node[shape = diamond]
  
    mit_Schale
    
  # defining edges
    Mittagspause -- Kartoffeln_abzählen
    Kartoffeln_abzählen -- mit_Schale
      mit_Schale -- Kartoffeln_kochen[dir = forward label=ja]
      mit_Schale -- Kartoffeln_schälen[dir = forward label=nein]
        Kartoffeln_schälen -- Kartoffeln_kochen
    Kartoffeln_kochen -- Kartoffeln_essen
    Kartoffeln_essen -- Pause_Ende
  }
")
\end{verbatim}

\section{Mermaid in R}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/w-pseudocode/skript/00-bilder/mermaid-in-r.png}}

}

\caption{~}

\end{figure}%

\end{tcolorbox}

~

\section{Übungsaufgabe zählen}

\textbf{Erstellen Sie ein Flussdiagramm für ein Programm, das von 1-10
und von 15 bis 20 zählt.}

\section{Musterlösung Pseudocode}

\begin{verbatim}
i = 0
SOLANGE i kleiner als 10 TUE
  erhöhe i um 1
  Ausgabe i
i = 14
SOLANGE i kleiner als 20 TUE
  erhöhe i um 1
  Ausgabe i
\end{verbatim}

\section{Musterlösung Mermaid}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{{-}{-}{-}}
\NormalTok{title: Zähle von 1{-}10 und von 15{-}20}
\NormalTok{{-}{-}{-}}
\NormalTok{flowchart TD}
\NormalTok{Start([Start])}
\NormalTok{initialisieren1[i = 0]}
\NormalTok{initialisieren2[i = 14]}
\NormalTok{Schleife1\{i kleiner 10\}}
\NormalTok{Schleife2\{i kleiner 20\}}
\NormalTok{Erhöhe1[i = i + 1]}
\NormalTok{Erhöhe2[i = i + 1]}
\NormalTok{Ausgabe1[Gebe i aus]}
\NormalTok{Ausgabe2[Gebe i aus]}
\NormalTok{Ende([Ende])}

\NormalTok{Start {-}{-}{-} initialisieren1}
\NormalTok{initialisieren1 {-}{-}{-} Schleife1}
    
\NormalTok{    Schleife1 {-}{-}\textgreater{}|nein| initialisieren2 {-}{-}{-} Schleife2}
\NormalTok{        Schleife2 {-}{-}\textgreater{}|ja| Erhöhe2 {-}{-}{-} Ausgabe2 {-}{-}\textgreater{} Schleife2}
\NormalTok{        Schleife2 {-}{-}\textgreater{}|nein| Ende}

\NormalTok{    Schleife1 {-}{-}\textgreater{}|ja| Erhöhe1 {-}{-}{-} Ausgabe1 {-}{-}\textgreater{} Schleife1}

\NormalTok{\%\% unsichtbare Verbindungen zur Positionssteuerung}
\NormalTok{    Ausgabe1 \textasciitilde{}\textasciitilde{}\textasciitilde{} Schleife2}
\NormalTok{    Ausgabe2 \textasciitilde{}\textasciitilde{}\textasciitilde{} Ende}
\end{Highlighting}
\end{Shaded}

\section{Musterlösung Flussdiagramm}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/w-pseudocode/aufgaben/00-bilder/musterloesung-flussdiagramm.png}}

}

\caption{Flussdiagramm mit DiagrammeR in R}

\end{figure}%

\chapter{Musterlösungen}\label{musterluxf6sungen}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-Hefezopf}: Hefezopf backen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-Hefezopf} 

Für die Zubereitung des Hefezopfes werden mindestens drei Stunden
benötigt. Der Teig (bzw. die Hefemischung) muss verteilt über mehrere
Schritte insgesamt 120 Minuten gehen und nach dem Backen auskühlen.
Aufgrund der langen Wartezeiten können die Arbeitsschritte von einer
Person durchgeführt werden, eine parallele Bearbeitung durch eine zweite
Person spart nur wenig Zeit ein. Lisa darf natürlich trotzdem eine
Stunde früher vorbei kommen, aber dann ruht der Teig zum letzten Mal,
bäckt im Ofen oder kühlt bereits aus. Zutaten mitbringen muss sie nicht,
die Zutatenliste ist vollständig.

\begin{verbatim}
# Zwischenschritt 1 - ca. 25 Minuten
## Eingabe: 250 ml Milch, 475 g Weizenmehl, 1 Prise Zucker, ½ Würfel Hefe
## Werkzeug: Schüssel, Sieb, Topf, Löffel, Geschirrtuch  
## Verarbeitung: Hefe in gezuckerter Milch lösen
## Ausgabe: Hefemischung, Mehl

BereiteHefemischung
  MehlSieben # benutze Sieb
  MehlHinzufügen        
  MuldeBilden # Mulde im Mehl bilden  
  HefeZerbröseln  
  HefeHinzufügen  
  MilchVorbereiten # benutze Topf
    **Solange** Milch < lauwarm **Tue**  
      MilchErwärmen  
    ZuckerHinzufügen
    Verrühren # Milch und Zucker mit Löffel vermischen  
  MilchHinzufügen  
  Verrühren # Hefe und Milchmischung mit Löffel vermischen  
  TeigGeht(Zeit = 15 Minuten)  
    SchüsselAbdecken # benutze Geschirrtuch  
    WarmStellen

# Zwischenschritt 2 - ca. 75 Minuten
## Eingabe: Hefemischung, Mehl, 1 Ei, 60 g Zucker, 1 Prise Salz, 50 g Butter  
## Werkzeug: Schüssel, Rührgerät, Messer, Geschirrtuch
## Verarbeitung: Ei, Milch, Salz, Butter hinzugeben und verkneten  
## Ausgabe: Rohteig
    
BereiteTeig  
  ButterWürfeln # benutze Messer  
    # Ausgabe: n Butterwürfel
  **SOLANGE** TeigGeht **TUE**
    Warten  
  EiHinzufügen  
  MilchHinzufügen  
  ZuckerHinzufügen  
  SalzHinzufügen  
  Kneten(Zeit = 3 Min, Stufe = niedrig) # benutze Rührhaken  
  Kneten(Zeit = 5 Min, Stufe = hoch) # benutze Rührhaken  
  ButterHinzufügen  
    **SOLANGE** n > 0 **TUE**  
      Kneten(Stufe = hoch)  
      ButterwürfelHinzufügen  
      n = n - 1
    Kneten(Zeit = 5 Min, Stufe = hoch) # benutze Rührhaken
  TeigGeht(Zeit = 60 Minuten)  
    SchüsselAbdecken # benutze Geschirrtuch  
    WarmStellen

# Zwischenschritt 3 - ca. 55 Minuten
## Eingabe: Rohteig, etwas Mehl
## Verarbeitung: Rohteig zu Teigzopf verarbeiten
## Werkzeug: Blech, Backpapier, Geschirrtuch
## Ausgabe: Teigzopf

ZopfFormen  
  BackpapierAufBlechLegen  
  ArbeitsflächeBemehlen  
  TeigAufArbeitsflächeLegen  
  TeigTeilen(Stücke = 3)  
    # Ausgabe = n Teigstücke  
  TeigRollen  
    **SOLANGE** n > 0 **TUE**  
      TeigstückRollen(Länge = 40 cm)  
      n = n - 1  
  ZopfErzeugen  
    RollenFlechten  
    EndenVerdrehen  
  ZopfAufBackpapierLegen  
  TeigGeht(Zeit = 45 Minuten)  
    ZopfAbdecken # benutze Geschirrtuch 
    WarmStellen  

# Zwischenschritt 4 - ca. 40 Minuten
## Eingabe: Teigzopf, etwas Milch, etwas Hagelzucker
## Werkzeug: Pinsel, Ofen
## Verarbeitung: Zopf bestreichen, bestreuen und backen
## Ausgabe: Hefezopf (gebacken)

ZopfBacken  
  OfenVorheizen  
    **WENN** UmluftVerfügbar **DANN**   
      Modus = Umluft  
      Temperatur = 180 Grad  
    **SONST**  
      Modus = Ober- / Unterhitze  
      Temperatur = 200 Grad  
  ZopfMitMilchBestreichen # benutze Pinsel
  ZopfMitHagelzuckerBestreuen
  ZopfBacken
    BlechInOfenStellen
    **SOLANGE** Zopf < leicht bräunlich **TUE**
      BlechImOfenLassen
    BlechHerausholen
  ZopfAuskühlen
    **SOLANGE** Zopf > Zimmertemperatur **TUE**
      Warten
\end{verbatim}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-Meerschweinchen}: Vitamin C bei Meerschweinchen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-Meerschweinchen} 

\begin{verbatim}
# Schritt 1 – Datensatz einlesen
## Eingabe: URL
## Werkzeug: Browser
## Verarbeitung: Speichern der Rohdaten
## Ausgabe: kommaseparierte Datei ToothGrowth.csv

HoleDatensatzVonURL
DatensatzSpeichern

# Schritt 2 – Mittelwertvergleich
## Eingabe: ToothGrowth.csv
## Werkzeug: IDE
## Verarbeitung: Mittelwerte für Teildatensätze bilden
## Ausgabe: Tabelle der Mittelwerte nach Dosis und Verabreichungsmethode

ZeilennummernBestimmen
  Zeilennummern(supp = OJ)
  Zeilennummern(supp = VC)
  Zeilennummern(dose = 0.5)
  Zeilennummern(dose = 1)
  Zeilennummern(dose = 2)
TeildatensätzeBilden # über Kriterium oder über Zeilennummern
    TeildatensatzSupp = OJ
        TeildatensatzDose = 0.5
        TeildatensatzDose = 1
        TeildatensatzDose = 2
    TeildatensatzSupp = VC
        TeildatensatzDose = 0.5
        TeildatensatzDose = 1
        TeildatensatzDose = 2
MittelwerteErmitteln
    MittelwertLen(Datensatz)
    MittelwerteTeildatensätze
        MittelwertLen(TeildatensatzSupp = OJ & Dose = 0.5)
        MittelwertLen(TeildatensatzSupp = OJ & Dose = 1)
        MittelwertLen(TeildatensatzSupp = OJ & Dose = 2)
        MittelwertLen(TeildatensatzSupp = VC & Dose = 0.5)
        MittelwertLen(TeildatensatzSupp = VC & Dose = 1)
        MittelwertLen(TeildatensatzSupp = VC & Dose = 2)
TabelleErstellen
    Spalten = OJ, VC
    Zeilen = Dosis
    Zellen = MittelwerteLen
TabelleAusgeben

# Schritt 3 – graphische Darstellung
## Eingabe: ToothGrowth.csv
## Werkzeug: Funktion für Boxplot
## Verarbeitung: Boxplot nach Dosis und Methode erzeugen
## Ausgabe: Boxplots nach Dosis und Verabreichungsmethode

Boxplot(Len nach Dosis & Methode)
    BoxplotErstellen
    VerabreichungsmethodeFarblichUnterscheiden
    LegendeEintragen
SpeichereBoxplot
\end{verbatim}

\end{tcolorbox}

\chapter{Das Wichtigste}\label{das-wichtigste}

~

In welcher Form und wie detailliert Sie Pseudocode formulieren, hängt
von Ihrem Kenntnisstand und Ihrem Ziel ab. Die Entwicklung von
Pseudocode kann als Kreativitätstechnik ohne formale Vorgaben eingesetzt
werden, in detaillierter Form bei der Ausarbeitung einer algorithmischen
Lösung helfen oder visuell in Form eines Flussdiagramms Ihre
Kommunikation mit Dritten unterstützen.

\chapter{Lernzielkontrolle}\label{lernzielkontrolle}

\section{Kompetenzquiz}\label{kompetenzquiz}

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\tightlist
\item
  Schreiben Sie ein Programm in Pseudocode, das alle geraden Zahlen bis
  10 ausgibt.
\end{enumerate}

~

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\setcounter{enumi}{1}
\tightlist
\item
  Fehler im Pseudocode finden.
\end{enumerate}

Ein:e Freund:in zeigt Ihnen den Pseudocode eines Programms, das prüfen
soll, ob Buchstaben groß oder klein geschrieben sind. Die Ausgabe klappt
aber nur für klein geschriebene Buchstaben. Finden Sie den Fehler?

\begin{verbatim}

text = Eingabe("Bitte geben Sie Ihren Text ein.")
zeichen_liste = TeileZeichenweiseInListeAuf(text)

FÜR JEDES element IN zeichen_liste TUE

  Wenn Dezimalwert(element) >= 97 UND Dezimalwert(element) <= 122 TUE
    Schreibe("Das Zeichen ", element, "ist klein geschrieben.")

    Wenn Dezimalwert(element) >= 65 UND Dezimalwert(element) <= 90 TUE
      Schreibe("Das Zeichen ", element, "ist groß geschrieben.")
\end{verbatim}

~

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\setcounter{enumi}{2}
\tightlist
\item
  Zeichnen Sie ein Flussdiagramm des korrekten Programms.
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-Kompetenzquiz}: Lösungen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-Kompetenzquiz} 

Lösung 1:

\begin{verbatim}
i = 1 
SOLANGE i kleiner gleich 10
  WENN i Modulo 2 gleich 0 TUE
    Ausgabe i
  Erhöhe i um 1
\end{verbatim}

Lösung 2: Die Prüfung der Bedingungen für groß geschriebenen Buchstaben
(Dezimalwert(element) \textgreater= 65 UND Dezimalwert(element)
\textless= 90) erfolgt im Anweisungsblock, wenn ein Buchstabe klein
geschrieben ist (Dezimalwert(element) \textgreater= 97 UND
Dezimalwert(element) \textless= 122 ). Der Wahrheitswert dieser
Bedingung ist falsch, wenn ein Buchstabe groß geschrieben ist. Die
folgenden Anweisungen werden deshalb nicht ausgeführt, wenn element
einen Großbuchstaben enthält. Durch korrektes Einrücken kann das Problem
gelöst werden.

\begin{verbatim}

text = Eingabe("Bitte geben Sie Ihren Text ein.")
zeichen_liste = TeileZeichenweiseInListeAuf(text)

FÜR JEDES element IN zeichen_liste TUE

  Wenn Dezimalwert(element) >= 97 UND Dezimalwert(element) <= 122 TUE
    Schreibe("Das Zeichen ", element, "ist klein geschrieben.")

  # korrigierte Einrückung
  Wenn Dezimalwert(element) >= 65 UND Dezimalwert(element) <= 90 TUE
    Schreibe("Das Zeichen ", element, "ist groß geschrieben.")
\end{verbatim}

Lösung 3:

\phantomsection\label{tip-Kompetenzquiz-flussdiagramm}
\begin{quote}
\textbf{Tip~8.1: Mermaid Diagramm}

\includegraphics[width=0.8\linewidth,height=\textheight,keepaspectratio]{index_files/mediabag/books/w-pseudocode/skript/00-bilder/mermaid-diagram-buchstaben.pdf}
\end{quote}

\end{tcolorbox}

\section{Übungen}\label{uxfcbungen}

\subsection{Börsenstrategie
entwickeln}\label{buxf6rsenstrategie-entwickeln}

Sie möchten den möglichen Ertrag einer Turnaround-Strategie an der Börse
bewerten. Ihre Idee besteht darin, einen Aktienindex zu kaufen, wenn
dieser mindestens 30 Prozent vom Allzeithoch der letzten drei Jahre
gefallen ist. Sie spekulieren mit Ihrer Strategie darauf, dass sich der
Aktienindex wieder erholt und Sie durch den günstigen Einstieg eine
bessere Rendite als bei regelmäßigen, kursunabhängigen Zukäufen
erzielen. Der Vergleichszeitraum beträgt 30 Jahre (Beginn und Ende
können Sie selbst festlegen).

\textbf{Testen Sie Ihre Strategie anhand des S\&P500.}

Parameter: 5.000 Dollar Startkapital, über 30 Jahre monatlich zusätzlich
500 Dollar investierbares Kapital, Dividenden werden im Folgemonat
reinvestiert bzw. bis zum nächsten Kursrückgang angespart, Strategie:
Buy \& Hold (keine Verkäufe), Kurseinbruch: 30 Prozent gegenüber
Allzeithoch der letzten 3 Jahre.

\begin{itemize}
\item
  Optional: In wie vielen 30-Jahresperioden wäre Ihre
  Turnaround-Strategie besser gewesen als stetiges Zukaufen?
\item
  Optional: Wie verändert sich das Verhältnis, wenn der Schwellenwert
  für den Kurseinbruch verändert wird (20 oder 40 Prozent)?
\end{itemize}

Ein Datensatz des S\&P500 mit Monatsdaten von 1871 bis 2024 ist auf der
\href{https://shillerdata.com/}{Webseite} von Robert Shiller verfügbar
(\href{https://img1.wsimg.com/blobby/go/e5e77e0b-59d1-44d9-ab25-4763ac982e53/downloads/ie_data.xls?ver=1712069253887}{Direktlink
zur XLS-Datei}).

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-SP500} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-SP500}: Datensatzbeschreibung S\&P500}\vspace{3mm}

Der Datensatz liegt in monatlicher Auflösung (\textbf{Date}) vor. Neben
dem Kurs (\textbf{Price}) sind die ausgeschütteten Dividenden
(\textbf{Dividend}) festgehalten.\\
\emph{Hinweis: Der Datensatz liegt als Exceldatei vor und wurde aus
Gründen der Übersichtlichkeit leicht bearbeitet (Anpassung der
Spaltennamen, Formatierung Spalte Date, Runden der Spalten Price und
Dividend). Bitte beachten Sie, dass wenn Sie den Datensatz selbst
abrufen, das Erscheinungsbild entsprechend abweicht.}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
\# & Date & Price & Dividend \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & 1871.01 & 4.44 & 0.26 \\
2 & 1871.02 & 4.50 & 0.26 \\
3 & 1871.03 & 4.61 & 0.26 \\
4 & 1871.04 & 4.74 & 0.26 \\
5 & 1871.05 & 4.86 & 0.26 \\
6 & 1871.06 & 4.82 & 0.26 \\
7 & 1871.07 & 4.73 & 0.26 \\
8 & 1871.08 & 4.79 & 0.26 \\
9 & 1871.09 & 4.84 & 0.26 \\
10 & 1871.10 & 4.59 & 0.26 \\
11 & 1871.11 & 4.64 & 0.26 \\
12 & 1871.12 & 4.74 & 0.26 \\
1828 & 2023.04 & 4121.47 & 68.38 \\
1829 & 2023.05 & 4146.17 & 68.54 \\
1830 & 2023.06 & 4345.37 & 68.71 \\
1831 & 2023.07 & 4508.08 & 68.91 \\
1832 & 2023.08 & 4457.36 & 69.11 \\
1833 & 2023.09 & 4409.09 & 69.31 \\
1834 & 2023.10 & 4269.40 & 69.64 \\
1835 & 2023.11 & 4460.06 & 69.97 \\
1836 & 2023.12 & 4685.05 & 70.30 \\
1837 & 2024.01 & 4815.61 & 70.48 \\
1838 & 2024.02 & 5011.96 & 70.65 \\
1839 & 2024.03 & 5170.57 & 70.82 \\
\end{longtable}

\end{minipage}%
\end{tcolorbox}

\part{w-python-minimal}

\chapter*{Werkzeugbaustein Python}\label{werkzeugbaustein-python}
\addcontentsline{toc}{chapter}{Werkzeugbaustein Python}

\markboth{Werkzeugbaustein Python}{Werkzeugbaustein Python}

\phantomsection\label{Lizenz}
\begin{figure}

\begin{minipage}{0.20\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/w-python-minimal/skript/00-bilder/CC-BY.pdf}}\end{minipage}%
%
\begin{minipage}{0.80\linewidth}
Bausteine Computergestützter Datenanalyse von Lukas Arnold, Simone
Arnold, Florian Bagemihl, Matthias Baitsch, Marc Fehr, Franca Hollmann,
Maik Poetzsch und Sebastian Seipel. Werkzeugbaustein Python von Marc
Fehr und Maik Poetzsch ist lizensiert unter
\href{https://creativecommons.org/licenses/by/4.0/deed.de}{CC BY 4.0}.
Das Werk ist abrufbar auf
\href{https://github.com/bausteine-der-datenanalyse/w-python}{GitHub}.
Ausgenommen von der Lizenz sind alle Logos Dritter und anders
gekennzeichneten Inhalte. 2025\end{minipage}%

\end{figure}%

Zitiervorschlag

Arnold, Lukas, Simone Arnold, Matthias Baitsch, Marc Fehr, Franca
Hollmann, Maik Poetzsch, und Sebastian Seipel. 2025. ``Bausteine
Computergestützter Datenanalyse. Werkzeugbaustein Python''.
\url{https://github.com/bausteine-der-datenanalyse/w-python}.

BibTeX-Vorlage

\begin{verbatim}
@misc{BCD-w-python-2025,
 title={Bausteine Computergestützter Datenanalyse. Werkzeugbaustein Python},
 author={Arnold, Lukas and Arnold, Simone and Baitsch, Matthias and Fehr, Marc and Hollmann, Franca and Poetzsch, Maik and Seipel, Sebastian},
 year={2025},
 url={https://github.com/bausteine-der-datenanalyse/w-python}} 
\end{verbatim}

\section*{Voraussetzungen}\label{voraussetzungen-1}
\addcontentsline{toc}{section}{Voraussetzungen}

\markright{Voraussetzungen}

Keine Voraussetzungen

\section*{Lernziele}\label{lernziele-1}
\addcontentsline{toc}{section}{Lernziele}

\markright{Lernziele}

In diesem Bausteine werden die Grundzüge der Programmierung mit Python
vermittelt. In diesem Baustein lernen Sie \ldots{}

\begin{itemize}
\item
  Grundlagen des Programmierens
\item
  Ausgaben in Python, Grundlegende Datentypen, FLusskontrolle
\item
  die Dokumentation zu lesen und zu verwenden
\item
  Module und Pakete laden
\end{itemize}

\chapter{Einführung}\label{einfuxfchrung}

\chapter{Willkommen bei Python!}\label{willkommen-bei-python}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/w-python-minimal/skript/00-bilder/python-logo-and-wordmark-cc0-tm.png}}

}

\caption{Logo der Programmiersprache Python}

\end{figure}%

Python Logo von Python Software Foundation steht unter der
\href{https://www.gnu.org/licenses/gpl-3.0.html}{GPLv3}. Die
Wort-Bild-Marke ist markenrechtlich geschützt:
\url{https://www.python.org/psf/trademarks/}. Das Werk ist abrufbar auf
\href{https://de.m.wikipedia.org/wiki/Datei:Python_logo_and_wordmark.svg}{wikimedia}.
2008

Python ist eine moderne Programmiersprache, die sich besonders gut für
Einsteigerinnen und Einsteiger eignet. Sie ist leicht verständlich und
wird in vielen Bereichen eingesetzt -- von der Datenanalyse bis hin zur
Webentwicklung.

\begin{quote}
In diesem Kurs lernen Sie Python Schritt für Schritt anhand praktischer
Beispiele.
\end{quote}

\section{Lernziele dieses Kapitels}\label{lernziele-dieses-kapitels}

Am Ende dieses Kapitels können Sie:

\begin{itemize}
\tightlist
\item
  einfache Python-Programme schreiben,
\item
  Text auf dem Bildschirm ausgeben,
\item
  erste Variablen definieren und verwenden.
\end{itemize}

\section{Ihr erstes Programm}\label{ihr-erstes-programm}

Die ersten Schritte in einer neuen Programmiersprache sind immer die
gleichen. WIr lassen uns die Worte `Hello World' ausgeben. Dazu nutzen
wir den print-Befehl \texttt{print()}:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hallo Welt!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hallo Welt!
\end{verbatim}

\textbf{Was passiert hier?} - \texttt{print()} ist eine sogenannte
\textbf{Funktion}, die etwas auf dem Bildschirm ausgibt. - Der Text
\texttt{"Hello\ World!"} wird angezeigt. - Texte (auch „Strings``
genannt) stehen immer in Anführungszeichen.

\section{Variablen -- Namen für
Werte}\label{variablen-namen-fuxfcr-werte}

Variablen sind wie beschriftete Schubladen: Sie speichern Informationen
unter einem Namen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{name }\OperatorTok{=} \StringTok{"Frau Müller"}
\NormalTok{alter }\OperatorTok{=} \DecValTok{32}
\end{Highlighting}
\end{Shaded}

Sie können diese Variablen verwenden, um dynamische Ausgaben zu
erzeugen:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(name }\OperatorTok{+} \StringTok{" ist "} \OperatorTok{+} \BuiltInTok{str}\NormalTok{(alter) }\OperatorTok{+} \StringTok{" Jahre alt."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Frau Müller ist 32 Jahre alt.
\end{verbatim}

Zu beachten ist hier, dass sie versuchen sowohl eine Zahl, als auch Text
auszugeben. Daher müssen wir mit der Funktion `str()' die Zahl in Text
umwandeln.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{✏️ Aufgabe: Begrüßung mit Alter}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Schreiben Sie ein Programm, das Sie mit Ihrem Namen begrüßt:

\begin{verbatim}
Hallo Frau Müller!
\end{verbatim}

Tipp: In Python können Sie Texte mit \texttt{+} zusammenfügen. Denken
Sie daran, dass Strings in Anführungszeichen stehen müssen.

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mein\_name }\OperatorTok{=} \StringTok{"Ihr Name hier"}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Hallo "} \OperatorTok{+}\NormalTok{ mein\_name }\OperatorTok{+} \StringTok{"!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hallo Ihr Name hier!
\end{verbatim}
\end{quote}

Erweitern Sie Ihr Programm so, dass es eine Begrüßung inklusive Alter
ausgibt:

\begin{verbatim}
Hallo Frau Müller!
Sie sind 32 Jahre alt.
\end{verbatim}

Tipp: Verwenden Sie \texttt{print()} mehrmals oder fügen Sie Texte
zusammen.

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{name }\OperatorTok{=} \StringTok{"Frau Müller"}
\NormalTok{alter }\OperatorTok{=} \DecValTok{32}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Hallo "} \OperatorTok{+}\NormalTok{ name }\OperatorTok{+} \StringTok{"!"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Sie sind "} \OperatorTok{+} \BuiltInTok{str}\NormalTok{(alter) }\OperatorTok{+} \StringTok{" Jahre alt."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hallo Frau Müller!
Sie sind 32 Jahre alt.
\end{verbatim}
\end{quote}

\end{tcolorbox}

\chapter{Datentypen verstehen}\label{datentypen-verstehen}

\section{Lernziele dieses Kapitels}\label{lernziele-dieses-kapitels-1}

Am Ende dieses Kapitels können Sie:

\begin{itemize}
\tightlist
\item
  die wichtigsten Datentypen unterscheiden,
\item
  mit Zahlen und Texten rechnen bzw. arbeiten,
\item
  einfache Berechnungen und Ausgaben erstellen.
\end{itemize}

\section{Einleitung}\label{einleitung}

In Python gibt es verschiedene \textbf{Datentypen}. Diese beschreiben,
\textbf{welche Art von Daten} Sie in Variablen speichern. Das ist
wichtig, weil viele Operationen -- wie zum Beispiel \texttt{+} -- je
nach Datentyp etwas anderes bedeuten:

\begin{itemize}
\tightlist
\item
  \texttt{+} bei Zahlen bedeutet \textbf{Addition},
\item
  \texttt{+} bei Text bedeutet \textbf{Zusammenfügen} (Konkatenation).
\end{itemize}

Bevor wir also mit komplexeren Programmen arbeiten, sollten wir
verstehen, welche Datentypen es gibt und wie man mit ihnen umgeht.

\section{Die wichtigsten Datentypen}\label{die-wichtigsten-datentypen}

Hier sind die grundlegenden Datentypen in Python:

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Typ & Beispiel & Bedeutung \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{int} & \texttt{10} & Ganze Zahl \\
\texttt{float} & \texttt{3.14} & Kommazahl \\
\texttt{str} & \texttt{"Hallo"} & Text (String) \\
\texttt{bool} & \texttt{True}, \texttt{False} & Wahrheitswert
(Ja/Nein) \\
\end{longtable}

Sie können den Typ einer Variable mit der Funktion \texttt{type()}
herausfinden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{wert }\OperatorTok{=} \DecValTok{42}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(wert))  }\CommentTok{\# Ausgabe: \textless{}class \textquotesingle{}int\textquotesingle{}\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'int'>
\end{verbatim}

\section{\texorpdfstring{Unterschiede zwischen \texttt{int} und
\texttt{float}}{Unterschiede zwischen int und float}}\label{unterschiede-zwischen-int-und-float}

In Python unterscheidet man zwischen \textbf{ganzen Zahlen}
(\texttt{int}) und \textbf{Kommazahlen} (\texttt{float}):

\begin{itemize}
\tightlist
\item
  \texttt{int} steht für „integer`` -- also ganze Zahlen wie \texttt{1},
  \texttt{0}, \texttt{-10}
\item
  \texttt{float} steht für „floating point number`` -- also Zahlen mit
  Dezimalstellen wie \texttt{3.14}, \texttt{0.5}, \texttt{-2.0}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \DecValTok{10}       \CommentTok{\# int}
\NormalTok{b }\OperatorTok{=} \FloatTok{2.5}      \CommentTok{\# float}

\BuiltInTok{print}\NormalTok{(}\StringTok{"a:"}\NormalTok{, a, }\StringTok{"| Typ:"}\NormalTok{, }\BuiltInTok{type}\NormalTok{(a))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"b:"}\NormalTok{, b, }\StringTok{"| Typ:"}\NormalTok{, }\BuiltInTok{type}\NormalTok{(b))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
a: 10 | Typ: <class 'int'>
b: 2.5 | Typ: <class 'float'>
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title={Important}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Die Unterscheidung ist wichtig: Manche Rechenoperationen verhalten sich
je nach Datentyp leicht unterschiedlich.

\end{tcolorbox}

\section{\texorpdfstring{Was sind Booleans
(\texttt{bool})?}{Was sind Booleans (bool)?}}\label{was-sind-booleans-bool}

Ein \textbf{Boolean} ist ein Wahrheitswert: Er kann nur zwei Zustände
annehmen:

\begin{itemize}
\tightlist
\item
  \texttt{True} (wahr)
\item
  \texttt{False} (falsch)
\end{itemize}

Solche Werte begegnen uns zum Beispiel bei Fragen wie:

\begin{itemize}
\tightlist
\item
  Ist die Temperatur über 30\,°C?
\item
  Hat die Datei einen bestimmten Namen?
\item
  Ist die Liste leer?
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ist\_sonnig }\OperatorTok{=} \VariableTok{True}
\NormalTok{hat\_regenschirm }\OperatorTok{=} \VariableTok{False}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Sonnig:"}\NormalTok{, ist\_sonnig)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Regenschirm dabei?"}\NormalTok{, hat\_regenschirm)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Typ von \textquotesingle{}ist\_sonnig\textquotesingle{}:"}\NormalTok{, }\BuiltInTok{type}\NormalTok{(ist\_sonnig))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Sonnig: True
Regenschirm dabei? False
Typ von 'ist_sonnig': <class 'bool'>
\end{verbatim}

Booleans werden besonders in \textbf{Bedingungen} und
\textbf{Vergleichen} verwendet, was Sie in Kapitel 4 genauer
kennenlernen.

\section{Rechnen mit Zahlen}\label{rechnen-mit-zahlen}

Python kann wie ein Taschenrechner verwendet werden:

\begin{longtable}[]{@{}cc@{}}
\toprule\noalign{}
Operator & Beschreibung \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{+}, \texttt{-} & Addition / Subtraktion \\
\texttt{*}, \texttt{/} & Multiplikation / Division \\
\texttt{//}, \texttt{\%} & Ganzzahlige Division / Rest \\
\texttt{**} & Potenzieren \\
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \DecValTok{10}
\NormalTok{b }\OperatorTok{=} \DecValTok{3}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Addition:"}\NormalTok{, a }\OperatorTok{+}\NormalTok{ b)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Subtraktion:"}\NormalTok{, a }\OperatorTok{{-}}\NormalTok{ b)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Multiplikation:"}\NormalTok{, a }\OperatorTok{*}\NormalTok{ b)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Potenzieren"}\NormalTok{, a}\OperatorTok{**}\NormalTok{b)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Division:"}\NormalTok{, a }\OperatorTok{/}\NormalTok{ b)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Ganzzahlige Division:"}\NormalTok{, a }\OperatorTok{//}\NormalTok{ b)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Division mit Rest:"}\NormalTok{, a }\OperatorTok{\%}\NormalTok{ b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Addition: 13
Subtraktion: 7
Multiplikation: 30
Potenzieren 1000
Division: 3.3333333333333335
Ganzzahlige Division: 3
Division mit Rest: 1
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\texttt{//} bedeutet: Ganzzahldivision, das Ergebnis wird abgerundet.
Alternativ gibt es auch \texttt{\%}. Hier wird eine Ganzzahldivision
durchgeführt und der Rest ausgegeben.

\end{tcolorbox}

\section{Arbeiten mit Text}\label{arbeiten-mit-text}

Texte (Strings) können miteinander kombiniert werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vorname }\OperatorTok{=} \StringTok{"Anna"}
\NormalTok{nachname }\OperatorTok{=} \StringTok{"Beispiel"}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Willkommen, "} \OperatorTok{+}\NormalTok{ vorname }\OperatorTok{+} \StringTok{" "} \OperatorTok{+}\NormalTok{ nachname }\OperatorTok{+} \StringTok{"!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Willkommen, Anna Beispiel!
\end{verbatim}

Wenn Sie Text und Zahlen kombinieren wollen, müssen Sie die Zahl in
einen String umwandeln:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{punkte }\OperatorTok{=} \DecValTok{95}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Sie haben "} \OperatorTok{+} \BuiltInTok{str}\NormalTok{(punkte) }\OperatorTok{+} \StringTok{" Punkte erreicht."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Sie haben 95 Punkte erreicht.
\end{verbatim}

\section{Umwandlung von Datentypen
(Typecasting)}\label{umwandlung-von-datentypen-typecasting}

Manchmal müssen Sie einen Wert von einem Datentyp in einen anderen
umwandeln -- z.\,B. eine Zahl in einen Text (String), damit sie
ausgegeben werden kann.

Das nennt man \textbf{Typecasting}. Hier sind die wichtigsten Funktionen
dafür:

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Funktion & Beschreibung & Beispiel \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{str())} & Zahl → Text & \texttt{str(42)} → \texttt{"42"} \\
\texttt{int()} & Text/Zahl → ganze Zahl & \texttt{int("10")} →
\texttt{10} \\
\texttt{float()} & Text/Zahl → Kommazahl & \texttt{float("3.14")} →
\texttt{3.14} \\
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beispiel: Zahl als Text anzeigen}
\NormalTok{punkte }\OperatorTok{=} \DecValTok{100}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Sie haben "} \OperatorTok{+} \BuiltInTok{str}\NormalTok{(punkte) }\OperatorTok{+} \StringTok{" Punkte."}\NormalTok{)}

\CommentTok{\# Beispiel: String in Zahl umwandeln und berechnen}
\NormalTok{eingabe }\OperatorTok{=} \StringTok{"3.5"}
\NormalTok{wert }\OperatorTok{=} \BuiltInTok{float}\NormalTok{(eingabe) }\OperatorTok{*} \DecValTok{2}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Doppelt so viel:"}\NormalTok{, wert)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Sie haben 100 Punkte.
Doppelt so viel: 7.0
\end{verbatim}

Achten Sie beim Umwandeln darauf, dass der Inhalt auch wirklich passt --
\texttt{int("abc")} führt zu einem Fehler.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Aufgabe: Alter in Tagen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Berechnen Sie, wie alt eine Person in Tagen ist.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{alter\_jahre }\OperatorTok{=} \DecValTok{32}
\NormalTok{tage }\OperatorTok{=}\NormalTok{ alter\_jahre }\OperatorTok{*} \DecValTok{365}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Sie sind ungefähr "} \OperatorTok{+} \BuiltInTok{str}\NormalTok{(tage) }\OperatorTok{+} \StringTok{" Tage alt."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Sie sind ungefähr 11680 Tage alt.
\end{verbatim}

Tipp: Denken Sie an die Umwandlung in einen String, wenn Sie die Zahl
ausgeben möchten.

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{alter }\OperatorTok{=} \DecValTok{32}
\NormalTok{tage }\OperatorTok{=}\NormalTok{ alter }\OperatorTok{*} \DecValTok{365}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Sie sind ungefähr "} \OperatorTok{+} \BuiltInTok{str}\NormalTok{(tage) }\OperatorTok{+} \StringTok{" Tage alt."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Sie sind ungefähr 11680 Tage alt.
\end{verbatim}
\end{quote}

\end{tcolorbox}

\chapter{Entscheidungen und
Wiederholungen}\label{entscheidungen-und-wiederholungen}

Programme müssen oft Entscheidungen treffen -- zum Beispiel abhängig von
einer Benutzereingabe oder einem bestimmten Wert. Ebenso müssen
bestimmte Aktionen mehrfach durchgeführt werden.

Dafür gibt es zwei zentrale Elemente in Python:

\begin{itemize}
\tightlist
\item
  \textbf{Kontrollstrukturen}: \texttt{if}, \texttt{elif}, \texttt{else}
\item
  \textbf{Schleifen}: \texttt{while} und \texttt{for}
\end{itemize}

\section{Lernziele dieses Kapitels}\label{lernziele-dieses-kapitels-2}

Am Ende dieses Kapitels können Sie:

\begin{itemize}
\tightlist
\item
  Bedingungen formulieren und mit \texttt{if}, \texttt{elif},
  \texttt{else} nutzen,
\item
  Vergleichsoperatoren verwenden (\texttt{==}, \texttt{\textless{}},
  \texttt{!=}, \ldots),
\item
  Wiederholungen mit \texttt{while} und \texttt{for} umsetzen.
\end{itemize}

\section{\texorpdfstring{Bedingungen mit \texttt{if}, \texttt{elif},
\texttt{else}}{Bedingungen mit if, elif, else}}\label{bedingungen-mit-if-elif-else}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{alter }\OperatorTok{=} \DecValTok{17}

\ControlFlowTok{if}\NormalTok{ alter }\OperatorTok{\textgreater{}=} \DecValTok{18}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Sie sind volljährig."}\NormalTok{)}
\ControlFlowTok{else}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Sie sind minderjährig."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Sie sind minderjährig.
\end{verbatim}

Mehrere Fälle unterscheiden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{note }\OperatorTok{=} \FloatTok{2.3}

\ControlFlowTok{if}\NormalTok{ note }\OperatorTok{\textless{}=} \FloatTok{1.5}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Sehr gut"}\NormalTok{)}
\ControlFlowTok{elif}\NormalTok{ note }\OperatorTok{\textless{}=} \FloatTok{2.5}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Gut"}\NormalTok{)}
\ControlFlowTok{elif}\NormalTok{ note }\OperatorTok{\textless{}=} \FloatTok{3.5}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Befriedigend"}\NormalTok{)}
\ControlFlowTok{else}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Ausreichend oder schlechter"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Gut
\end{verbatim}

\section{Vergleichsoperatoren}\label{vergleichsoperatoren}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Ausdruck & Bedeutung \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{a\ ==\ b} & gleich \\
\texttt{a\ !=\ b} & ungleich \\
\texttt{a\ \textless{}\ b} & kleiner als \\
\texttt{a\ \textgreater{}\ b} & größer als \\
\texttt{a\ \textless{}=\ b} & kleiner oder gleich \\
\texttt{a\ \textgreater{}=\ b} & größer oder gleich \\
\end{longtable}

\section{\texorpdfstring{Wiederholungen mit
\texttt{while}}{Wiederholungen mit while}}\label{wiederholungen-mit-while}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zähler }\OperatorTok{=} \DecValTok{0}

\ControlFlowTok{while}\NormalTok{ zähler }\OperatorTok{\textless{}} \DecValTok{5}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Zähler ist:"}\NormalTok{, zähler)}
\NormalTok{    zähler }\OperatorTok{+=} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Zähler ist: 0
Zähler ist: 1
Zähler ist: 2
Zähler ist: 3
Zähler ist: 4
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title={Important}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Achten Sie auf eine Abbruchbedingung -- sonst läuft die Schleife endlos!

Wird die Variable `zähler' nicht erhöht, wird die Abbruchbedingung nie
erreicht.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zähler }\OperatorTok{=} \DecValTok{0}

\ControlFlowTok{while}\NormalTok{ zähler }\OperatorTok{\textless{}} \DecValTok{5}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Zähler ist:"}\NormalTok{, zähler)}
\end{Highlighting}
\end{Shaded}

In Python können Sie die Programmausführung durch gemeinsames Drücken
der Tasten Strg und C beenden. Je nach verwendeter Entwicklungsumgebung
kann eine andere Tastenkombination gelten.

\end{tcolorbox}

\section{\texorpdfstring{Schleifen mit \texttt{for} und
\texttt{range()}}{Schleifen mit for und range()}}\label{schleifen-mit-for-und-range}

Wenn Sie eine Schleife \textbf{genau eine bestimmte Anzahl von Malen}
durchlaufen möchten, nutzen Sie \texttt{for} mit \texttt{range()}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{5}\NormalTok{):}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Durchlauf:"}\NormalTok{, i)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Durchlauf: 0
Durchlauf: 1
Durchlauf: 2
Durchlauf: 3
Durchlauf: 4
\end{verbatim}

Start- und Endwert festlegen:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{):}
    \BuiltInTok{print}\NormalTok{(i)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
2
3
4
5
\end{verbatim}

\section{\texorpdfstring{Was macht \texttt{range()}
genau?}{Was macht range() genau?}}\label{was-macht-range-genau}

Die Funktion \texttt{range()} erzeugt eine Abfolge von Zahlen, über die
Sie mit einer \texttt{for}-Schleife iterieren können.

\subsection{Varianten:}\label{varianten}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{range}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

➡️ ergibt: \texttt{0,\ 1,\ 2,\ 3,\ 4} (startet bei 0, endet \textbf{vor}
5)

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{range}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

➡️ ergibt: \texttt{2,\ 3,\ 4,\ 5} (startet bei 2, endet \textbf{vor} 6)

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

➡️ ergibt: \texttt{1,\ 3,\ 5,\ 7,\ 9} (Schrittweite = 2)

\texttt{range()} erzeugt keine echte Liste, sondern ein sogenanntes
„range-Objekt``, das wie eine Liste verwendet werden kann.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{✏️ Aufgabe: Zähle von 1 bis 10}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Nutzen Sie eine \texttt{for}-Schleife, um die Zahlen von 1 bis 10
auszugeben.

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{):}
    \BuiltInTok{print}\NormalTok{(i)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
2
3
4
5
6
7
8
9
10
\end{verbatim}
\end{quote}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Aufgabe: Gerade Zahlen ausgeben}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Geben Sie alle geraden Zahlen von 0 bis 20 aus. Tipp: Eine Zahl ist
gerade, wenn \texttt{zahl\ \%\ 2\ ==\ 0}.

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ zahl }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{21}\NormalTok{):}
    \ControlFlowTok{if}\NormalTok{ zahl }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(zahl)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0
2
4
6
8
10
12
14
16
18
20
\end{verbatim}
\end{quote}

\end{tcolorbox}

\chapter{Mehrere Werte speichern}\label{mehrere-werte-speichern}

Bisher haben Sie einzelne Werte in Variablen gespeichert. Doch was, wenn
Sie eine ganze Reihe von Zahlen, Namen oder Werten auf einmal speichern
möchten?

Dafür gibt es in Python \textbf{Listen}. In diesem Kapitel lernen Sie
außerdem, wie man mit \texttt{for}-Schleifen über Listen iteriert.

\section{Was ist eine Liste?}\label{was-ist-eine-liste}

Eine Liste ist eine geordnete Sammlung von Werten eines Datentyps.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{namen }\OperatorTok{=}\NormalTok{ [}\StringTok{"Ali"}\NormalTok{, }\StringTok{"Bente"}\NormalTok{, }\StringTok{"Carlos"}\NormalTok{]}
\NormalTok{noten }\OperatorTok{=}\NormalTok{ [}\FloatTok{1.7}\NormalTok{, }\FloatTok{2.3}\NormalTok{, }\FloatTok{1.3}\NormalTok{, }\FloatTok{2.0}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Auf Elemente greifen Sie mit eckigen Klammern zu:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(namen[}\DecValTok{0}\NormalTok{])  }\CommentTok{\# erstes Element}
\BuiltInTok{print}\NormalTok{(noten[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]) }\CommentTok{\# letztes Element}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Ali
2.0
\end{verbatim}

\section{Teile aus Listen ausschneiden --
Slicing}\label{teile-aus-listen-ausschneiden-slicing}

Mit dem sogenannten \textbf{Slicing} können Sie gezielt Ausschnitte aus
einer Liste entnehmen. Dabei geben Sie an, \textbf{wo der Ausschnitt
beginnt und wo er endet} (der Endwert wird \textbf{nicht} mehr
mitgenommen):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zahlen }\OperatorTok{=}\NormalTok{ [}\DecValTok{10}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{60}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(zahlen[}\DecValTok{1}\NormalTok{:}\DecValTok{4}\NormalTok{])  }\CommentTok{\# Ausgabe: [20, 30, 40]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[20, 30, 40]
\end{verbatim}

\subsection{\texorpdfstring{Syntax:
\texttt{liste{[}start:stop{]}}}{Syntax: liste{[}start:stop{]}}}\label{syntax-listestartstop}

\begin{itemize}
\tightlist
\item
  \textbf{start}: Index, bei dem das Slicing beginnt (inklusive)
\item
  \textbf{stop}: Index, an dem es endet (exklusive)
\item
  Der Startwert kann auch weggelassen werden: \texttt{{[}:3{]}} → erstes
  bis drittes Element
\item
  Ebenso der Endwert: \texttt{{[}3:{]}} → ab dem vierten Element bis zum
  Ende
\item
  Ganze Kopie: \texttt{{[}:{]}}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(zahlen[:}\DecValTok{3}\NormalTok{])   }\CommentTok{\# [10, 20, 30]}
\BuiltInTok{print}\NormalTok{(zahlen[}\DecValTok{3}\NormalTok{:])   }\CommentTok{\# [40, 50, 60]}
\BuiltInTok{print}\NormalTok{(zahlen[:])    }\CommentTok{\# vollständige Kopie}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[10, 20, 30]
[40, 50, 60]
[10, 20, 30, 40, 50, 60]
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title={Note}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Sie können auch mit negativen Indizes arbeiten (\texttt{-1} ist das
letzte Element):

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(zahlen[}\OperatorTok{{-}}\DecValTok{3}\NormalTok{:])  }\CommentTok{\# [40, 50, 60]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[40, 50, 60]
\end{verbatim}

\end{tcolorbox}

\section{Über Listen iterieren}\label{uxfcber-listen-iterieren}

Mit einer \texttt{for}-Schleife können Sie über jedes Element in einer
Liste iterieren:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{namen }\OperatorTok{=}\NormalTok{ [}\StringTok{"Ali"}\NormalTok{, }\StringTok{"Bente"}\NormalTok{, }\StringTok{"Carlos"}\NormalTok{]}

\ControlFlowTok{for}\NormalTok{ name }\KeywordTok{in}\NormalTok{ namen:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Hallo"}\NormalTok{, name }\OperatorTok{+} \StringTok{"!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hallo Ali!
Hallo Bente!
Hallo Carlos!
\end{verbatim}

\section{Erweiterung: Bedingte
Ausgaben}\label{erweiterung-bedingte-ausgaben}

Sie können in der Schleife mit \texttt{if} filtern:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{temperaturen }\OperatorTok{=}\NormalTok{ [}\FloatTok{14.2}\NormalTok{, }\FloatTok{17.5}\NormalTok{, }\FloatTok{19.0}\NormalTok{, }\FloatTok{21.3}\NormalTok{, }\FloatTok{18.4}\NormalTok{]}

\ControlFlowTok{for}\NormalTok{ t }\KeywordTok{in}\NormalTok{ temperaturen:}
    \ControlFlowTok{if}\NormalTok{ t }\OperatorTok{\textgreater{}} \DecValTok{18}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(t, }\StringTok{"ist ein warmer Tag"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
19.0 ist ein warmer Tag
21.3 ist ein warmer Tag
18.4 ist ein warmer Tag
\end{verbatim}

\section{Durchschnitt berechnen}\label{durchschnitt-berechnen}

Python stellt nützliche Funktionen bereit, z.\,B. \texttt{sum()} und
\texttt{len()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{noten }\OperatorTok{=}\NormalTok{ [}\FloatTok{1.7}\NormalTok{, }\FloatTok{2.3}\NormalTok{, }\FloatTok{1.3}\NormalTok{, }\FloatTok{2.0}\NormalTok{]}

\NormalTok{durchschnitt }\OperatorTok{=} \BuiltInTok{sum}\NormalTok{(noten) }\OperatorTok{/} \BuiltInTok{len}\NormalTok{(noten)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Durchschnittsnote:"}\NormalTok{, }\BuiltInTok{round}\NormalTok{(durchschnitt, }\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Durchschnittsnote: 1.82
\end{verbatim}

\section{\texorpdfstring{Listen erweitern:
\texttt{.append()}}{Listen erweitern: .append()}}\label{listen-erweitern-.append}

Manchmal kennen Sie die Listenelemente nicht vorher -- dann können Sie
neue Werte \textbf{nachträglich hinzufügen}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{namen }\OperatorTok{=}\NormalTok{ []}

\NormalTok{namen.append(}\StringTok{"Ali"}\NormalTok{)}
\NormalTok{namen.append(}\StringTok{"Bente"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(namen)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['Ali', 'Bente']
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title={Note}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Die Methode \texttt{.append())} hängt einen neuen Wert an das Ende der
Liste.

\end{tcolorbox}

\section{Verschachtelte Schleifen}\label{verschachtelte-schleifen}

Wenn Sie mit \textbf{mehrdimensionalen Daten} arbeiten -- z.\,B. eine
Tabelle mit mehreren Zeilen -- können Sie Schleifen \textbf{ineinander
verschachteln}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{wochentage }\OperatorTok{=}\NormalTok{ [}\StringTok{"Mo"}\NormalTok{, }\StringTok{"Di"}\NormalTok{, }\StringTok{"Mi"}\NormalTok{]}
\NormalTok{stunden }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}

\ControlFlowTok{for}\NormalTok{ tag }\KeywordTok{in}\NormalTok{ wochentage:}
    \ControlFlowTok{for}\NormalTok{ stunde }\KeywordTok{in}\NormalTok{ stunden:}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{tag}\SpecialCharTok{\}}\SpecialStringTok{, Stunde }\SpecialCharTok{\{}\NormalTok{stunde}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Mo, Stunde 1
Mo, Stunde 2
Mo, Stunde 3
Di, Stunde 1
Di, Stunde 2
Di, Stunde 3
Mi, Stunde 1
Mi, Stunde 2
Mi, Stunde 3
\end{verbatim}

Das ergibt:

\begin{verbatim}
Mo, Stunde 1
Mo, Stunde 2
Mo, Stunde 3
Di, Stunde 1
...
\end{verbatim}

\section{Listen sortieren}\label{listen-sortieren}

Mit \texttt{sorted()} können Sie Listen \textbf{alphabetisch oder
numerisch sortieren}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{namen }\OperatorTok{=}\NormalTok{ [}\StringTok{"Zoe"}\NormalTok{, }\StringTok{"Anna"}\NormalTok{, }\StringTok{"Ben"}\NormalTok{]}
\NormalTok{sortiert }\OperatorTok{=} \BuiltInTok{sorted}\NormalTok{(namen)}

\BuiltInTok{print}\NormalTok{(sortiert)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['Anna', 'Ben', 'Zoe']
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title={Important}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Die Original-Liste bleibt \textbf{unverändert}.\\
Wenn Sie die Liste direkt verändern möchten, geht das mit:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{namen.sort()}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

\chapter{Wiederverwendbarer Code mit
Funktionen}\label{wiederverwendbarer-code-mit-funktionen}

Stellen Sie sich vor, Sie müssen eine bestimmte Berechnung mehrfach im
Programm durchführen. Anstatt den Code jedes Mal neu zu schreiben,
können Sie ihn in einer \textbf{Funktion} bündeln.

Funktionen sind ein zentrales Werkzeug, um Code:

\begin{itemize}
\tightlist
\item
  übersichtlich,
\item
  wiederverwendbar und
\item
  testbar zu machen.
\end{itemize}

\section{Lernziele dieses Kapitels}\label{lernziele-dieses-kapitels-3}

Am Ende dieses Kapitels können Sie:

\begin{itemize}
\tightlist
\item
  eigene Funktionen mit \texttt{def} erstellen,
\item
  Parameter übergeben und Rückgabewerte nutzen,
\item
  Funktionen sinnvoll in Programmen einsetzen.
\end{itemize}

\section{Eine Funktion definieren}\label{eine-funktion-definieren}

Eine Funktion besteht aus folgenden Teilen:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Definition} mit \texttt{def}
\item
  \textbf{Funktionsname}
\item
  \textbf{Parameter in Klammern (optional)}
\item
  \textbf{Einrückung} für den Funktionskörper
\item
  (optional) \textbf{\texttt{return}-Anweisung}
\end{enumerate}

Beispiel:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ hallo(name}\OperatorTok{=}\StringTok{"Gast"}\NormalTok{):}
\NormalTok{    begruessung }\OperatorTok{=} \StringTok{"Hallo "} \OperatorTok{+}\NormalTok{ name }\OperatorTok{+} \StringTok{"!"}
    \ControlFlowTok{return}\NormalTok{ begruessung}
\end{Highlighting}
\end{Shaded}

Fangen wir mit dem ersten Stichwort an. Funktionen werden mit
\texttt{def} definiert und können beliebig oft aufgerufen werden:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ begruessung():}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Hallo und willkommen!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Sie wird erst ausgeführt, wenn Sie sie aufrufen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{begruessung()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hallo und willkommen!
\end{verbatim}

\section{Parameter übergeben}\label{parameter-uxfcbergeben}

Funktionen können Eingabewerte (Parameter) erhalten:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ begruessung(name):}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Hallo"}\NormalTok{, name }\OperatorTok{+} \StringTok{"!"}\NormalTok{)}

\NormalTok{begruessung(}\StringTok{"Alex"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hallo Alex!
\end{verbatim}

\section{\texorpdfstring{Rückgabewerte mit
\texttt{return}}{Rückgabewerte mit return}}\label{ruxfcckgabewerte-mit-return}

Eine Funktion kann auch einen Wert \textbf{zurückgeben}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ quadrat(zahl):}
    \ControlFlowTok{return}\NormalTok{ zahl }\OperatorTok{*}\NormalTok{ zahl}

\NormalTok{ergebnis }\OperatorTok{=}\NormalTok{ quadrat(}\DecValTok{5}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(ergebnis)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
25
\end{verbatim}

\section{Beispiel: Umrechnungen}\label{beispiel-umrechnungen}

\subsection{Euro zu US-Dollar}\label{euro-zu-us-dollar}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ euro\_zu\_usd(betrag\_euro):}
\NormalTok{    wechselkurs }\OperatorTok{=} \FloatTok{1.09}
    \ControlFlowTok{return}\NormalTok{ betrag\_euro }\OperatorTok{*}\NormalTok{ wechselkurs}

\BuiltInTok{print}\NormalTok{(}\StringTok{"20 € sind"}\NormalTok{, euro\_zu\_usd(}\DecValTok{20}\NormalTok{), }\StringTok{"US{-}Dollar."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
20 € sind 21.8 US-Dollar.
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Aufgabe: Begrüßung mit Name}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Erstellen Sie eine Funktion \texttt{begruesse(name)}, die den Namen in
einem Begrüßungstext verwendet:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Hallo Fatima, schön dich zu sehen!}
\end{Highlighting}
\end{Shaded}

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ begruesse(name):}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Hallo"}\NormalTok{, name }\OperatorTok{+} \StringTok{", schön dich zu sehen!"}\NormalTok{)}

\NormalTok{begruesse(}\StringTok{"Fatima"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hallo Fatima, schön dich zu sehen!
\end{verbatim}
\end{quote}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Aufgabe: Temperaturumrechnung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Schreiben Sie eine Funktion, die Celsius in Fahrenheit umrechnet:

Formel: {[} F = C \times 1.8 + 32 {]}

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ celsius\_zu\_fahrenheit(c):}
    \ControlFlowTok{return}\NormalTok{ c }\OperatorTok{*} \FloatTok{1.8} \OperatorTok{+} \DecValTok{32}

\BuiltInTok{print}\NormalTok{(celsius\_zu\_fahrenheit(}\DecValTok{20}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
68.0
\end{verbatim}
\end{quote}

\end{tcolorbox}

\section{Parameter mit
Standardwerten}\label{parameter-mit-standardwerten}

Sie können Parametern \textbf{Standardwerte} zuweisen. So kann die
Funktion auch ohne Angabe eines Werts aufgerufen werden:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ begruessung(name}\OperatorTok{=}\StringTok{"Gast"}\NormalTok{):}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Hallo"}\NormalTok{, name }\OperatorTok{+} \StringTok{"!"}\NormalTok{)}

\NormalTok{begruessung()         }\CommentTok{\# Hallo Gast!}
\NormalTok{begruessung(}\StringTok{"Maria"}\NormalTok{)  }\CommentTok{\# Hallo Maria!}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hallo Gast!
Hallo Maria!
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{\texttt{print()} vs.~\texttt{return}}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Diese beiden Begriffe werden oft verwechselt:

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Ausdruck & Bedeutung \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{print()} & zeigt einen Text auf dem Bildschirm \\
\texttt{return} & gibt einen Wert an den Aufrufer zurück \\
\end{longtable}

Beispiel:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ verdoppeln(x):}
    \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{*} \DecValTok{2}

\CommentTok{\# Ausgabe sichtbar machen}
\BuiltInTok{print}\NormalTok{(verdoppeln(}\DecValTok{5}\NormalTok{))  }\CommentTok{\# Ausgabe: 10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
10
\end{verbatim}

\end{tcolorbox}

\chapter{Arbeiten mit Dateien}\label{arbeiten-mit-dateien}

Programme arbeiten oft nicht nur mit Benutzereingaben, sondern auch mit
\textbf{Textdateien} -- zum Beispiel um Daten zu speichern oder zu
laden.

Python bietet einfache Funktionen, um:

\begin{itemize}
\tightlist
\item
  Dateien \textbf{zu öffnen},
\item
  ihren \textbf{Inhalt zu lesen} oder \textbf{hineinzuschreiben},
\item
  und die Datei \textbf{wieder zu schließen}.
\end{itemize}

\section{Lernziele dieses Kapitels}\label{lernziele-dieses-kapitels-4}

Am Ende dieses Kapitels können Sie:

\begin{itemize}
\tightlist
\item
  Dateien mit \texttt{open()} öffnen,
\item
  Inhalte aus Textdateien einlesen,
\item
  Texte in Dateien schreiben,
\item
  mit \texttt{with}-Blöcken sicher und einfach arbeiten.
\end{itemize}

\section{Eine Datei einlesen}\label{eine-datei-einlesen}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beispiel: Datei lesen}
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{"01{-}daten/beispiel.txt"}\NormalTok{, }\StringTok{"r"}\NormalTok{) }\ImportTok{as}\NormalTok{ datei:}
\NormalTok{    inhalt }\OperatorTok{=}\NormalTok{ datei.read()}
    \BuiltInTok{print}\NormalTok{(inhalt)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Dies ist ein Test.
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \texttt{"r"} steht für \textbf{read} (lesen).
\item
  \texttt{with} sorgt dafür, dass die Datei nach dem Lesen automatisch
  geschlossen wird.
\item
  \texttt{read()} liest den \textbf{gesamten Inhalt} der Datei als
  String.
\end{itemize}

\section{Zeilenweise lesen}\label{zeilenweise-lesen}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{"01{-}daten/beispiel.txt"}\NormalTok{, }\StringTok{"r"}\NormalTok{) }\ImportTok{as}\NormalTok{ datei:}
    \ControlFlowTok{for}\NormalTok{ zeile }\KeywordTok{in}\NormalTok{ datei:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Zeile:"}\NormalTok{, zeile.strip())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Zeile: Dies ist ein Test.
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\texttt{.strip()} entfernt Leerzeichen und Zeilenumbrüche am Anfang und
Ende.

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Aufgabe: Datei lesen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Angenommen, es gibt eine Datei \texttt{gruesse.txt} mit folgendem
Inhalt:

\begin{verbatim}
Hallo Anna
Guten Morgen Ben
Willkommen Carla
\end{verbatim}

Schreiben Sie ein Programm, das jede Zeile einzeln einliest und mit
\texttt{print(...)} wiedergibt.

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{"01{-}daten/gruesse.txt"}\NormalTok{, }\StringTok{"r"}\NormalTok{) }\ImportTok{as}\NormalTok{ f:}
    \ControlFlowTok{for}\NormalTok{ zeile }\KeywordTok{in}\NormalTok{ f:}
        \BuiltInTok{print}\NormalTok{(zeile.strip())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hallo Anna
Guten Morgen Ben
Willkommen Carla
\end{verbatim}
\end{quote}

\end{tcolorbox}

\section{In eine Datei schreiben}\label{in-eine-datei-schreiben}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{"ausgabe.txt"}\NormalTok{, }\StringTok{"w"}\NormalTok{) }\ImportTok{as}\NormalTok{ datei:}
\NormalTok{    datei.write(}\StringTok{"Das ist eine neue Zeile.}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{    datei.write(}\StringTok{"Und noch eine."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{"w"} steht für \textbf{write} (schreiben).
\item
  Achtung: Eine vorhandene Datei wird \textbf{überschrieben}!
\end{itemize}

\section{Zeilenweise schreiben mit
Schleife}\label{zeilenweise-schreiben-mit-schleife}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{daten }\OperatorTok{=}\NormalTok{ [}\StringTok{"Apfel"}\NormalTok{, }\StringTok{"Banane"}\NormalTok{, }\StringTok{"Kirsche"}\NormalTok{]}

\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{"obst.txt"}\NormalTok{, }\StringTok{"w"}\NormalTok{) }\ImportTok{as}\NormalTok{ f:}
    \ControlFlowTok{for}\NormalTok{ eintrag }\KeywordTok{in}\NormalTok{ daten:}
\NormalTok{        f.write(eintrag }\OperatorTok{+} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Jede Zeile endet mit \texttt{\textbackslash{}n} für einen Zeilenumbruch.

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Aufgabe: Liste in Datei schreiben}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Gegeben ist eine Liste von Städten:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{staedte }\OperatorTok{=}\NormalTok{ [}\StringTok{"Berlin"}\NormalTok{, }\StringTok{"Hamburg"}\NormalTok{, }\StringTok{"München"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Schreiben Sie ein Programm, das jede Stadt in eine neue Zeile einer
  Datei \texttt{staedte.txt} schreibt.
\end{itemize}

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{staedte }\OperatorTok{=}\NormalTok{ [}\StringTok{"Berlin"}\NormalTok{, }\StringTok{"Hamburg"}\NormalTok{, }\StringTok{"München"}\NormalTok{]}

\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{"staedte.txt"}\NormalTok{, }\StringTok{"w"}\NormalTok{) }\ImportTok{as}\NormalTok{ f:}
    \ControlFlowTok{for}\NormalTok{ stadt }\KeywordTok{in}\NormalTok{ staedte:}
\NormalTok{        f.write(stadt }\OperatorTok{+} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\end{quote}

\end{tcolorbox}

\section{\texorpdfstring{Alle Zeilen auf einmal lesen mit
\texttt{readlines()}}{Alle Zeilen auf einmal lesen mit readlines()}}\label{alle-zeilen-auf-einmal-lesen-mit-readlines}

Statt über eine Datei zu iterieren, können Sie alle Zeilen auf einmal
als Liste einlesen:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{"01{-}daten/beispiel.txt"}\NormalTok{, }\StringTok{"r"}\NormalTok{) }\ImportTok{as}\NormalTok{ f:}
\NormalTok{    zeilen }\OperatorTok{=}\NormalTok{ f.readlines()}
    \BuiltInTok{print}\NormalTok{(zeilen)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['Dies ist ein Test.']
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Jede Zeile endet mit \texttt{\textbackslash{}n}, deshalb kann eine
Nachbearbeitung mit \texttt{.strip()} sinnvoll sein:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ zeile }\KeywordTok{in}\NormalTok{ zeilen:}
    \BuiltInTok{print}\NormalTok{(zeile.strip())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Dies ist ein Test.
\end{verbatim}

\end{tcolorbox}

\section{\texorpdfstring{Dateien manuell schließen mit
\texttt{close()}}{Dateien manuell schließen mit close()}}\label{dateien-manuell-schlieuxdfen-mit-close}

Wenn Sie \textbf{keinen \texttt{with}-Block} verwenden, müssen Sie die
Datei selbst schließen -- sonst bleibt sie geöffnet:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datei }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(}\StringTok{"01{-}daten/beispiel.txt"}\NormalTok{, }\StringTok{"w"}\NormalTok{)}
\NormalTok{datei.write(}\StringTok{"Dies ist ein Test."}\NormalTok{)}
\NormalTok{datei.close()}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\texttt{close()} ist wichtig, damit Änderungen gespeichert werden und
die Datei nicht gesperrt bleibt.

\textbf{Empfehlung}: Nutzen Sie immer \texttt{with\ open(...)}, da
Python die Datei dann automatisch schließt -- auch bei Fehlern.

\end{tcolorbox}

\chapter{Das Wichtigste}\label{das-wichtigste-1}

Python ist eine sehr vielseitige und deshalb auch eine der am häufigsten
genutzen Programmiersprachen. Die Pythonbasis bringt das Grundgerüst für
die statistische Programmierung mit. Durch spezialisierte Module wird
der Funktionsumfang noch erheblich erweitert. Mehr dazu erfahren Sie in
dem Video.

\part{w-python}

\chapter*{Werkzeugbaustein Python}\label{werkzeugbaustein-python-1}
\addcontentsline{toc}{chapter}{Werkzeugbaustein Python}

\markboth{Werkzeugbaustein Python}{Werkzeugbaustein Python}

\phantomsection\label{Lizenz}
\begin{figure}

\begin{minipage}{0.20\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/w-python/skript/00-bilder/CC-BY.pdf}}\end{minipage}%
%
\begin{minipage}{0.80\linewidth}
Bausteine Computergestützter Datenanalyse von Lukas Arnold, Simone
Arnold, Florian Bagemihl, Matthias Baitsch, Marc Fehr, Franca Hollmann,
Maik Poetzsch und Sebastian Seipel. Werkzeugbaustein Python von Marc
Fehr und Maik Poetzsch ist lizensiert unter
\href{https://creativecommons.org/licenses/by/4.0/deed.de}{CC BY 4.0}.
Das Werk ist abrufbar auf
\href{https://github.com/bausteine-der-datenanalyse/w-python}{GitHub}.
Ausgenommen von der Lizenz sind alle Logos Dritter und anders
gekennzeichneten Inhalte. 2025\end{minipage}%

\end{figure}%

Zitiervorschlag

Arnold, Lukas, Simone Arnold, Matthias Baitsch, Marc Fehr, Franca
Hollmann, Maik Poetzsch, und Sebastian Seipel. 2025. „Bausteine
Computergestützter Datenanalyse. Werkzeugbaustein Python``.
\url{https://github.com/bausteine-der-datenanalyse/w-python}.

BibTeX-Vorlage

\begin{verbatim}
@misc{BCD-w-python-2025,
 title={Bausteine Computergestützter Datenanalyse. Werkzeugbaustein Python},
 author={Arnold, Lukas and Arnold, Simone and Baitsch, Matthias and Fehr, Marc and Hollmann, Franca and Poetzsch, Maik and Seipel, Sebastian},
 year={2025},
 url={https://github.com/bausteine-der-datenanalyse/w-python}} 
\end{verbatim}

\section*{Voraussetzungen}\label{voraussetzungen-2}
\addcontentsline{toc}{section}{Voraussetzungen}

\markright{Voraussetzungen}

Keine Voraussetzungen, hilfreich ist der
\href{https://bausteine-der-datenanalyse.github.io/w-pseudocode/Pseudocode.html}{Werkzeugbaustein
Pseudocode}

Die Bearbeitungszeit dieses Bausteins beträgt circa 30 Stunden.

\section*{Lernziele}\label{lernziele-2}
\addcontentsline{toc}{section}{Lernziele}

\markright{Lernziele}

In diesem Bausteine werden die Grundzüge der Programmierung mit Python
vermittelt. In diesem Baustein lernen Sie \ldots{}

\begin{itemize}
\item
  Grundbegriffe der objektorientierten Programmierung kennen.
\item
  Python-Code zu schreiben, Variablen zu erstellen, Operationen
  durchzuführen und die Ausgabe zu formatieren.
\item
  die Dokumentation zu lesen und zu verwenden
\item
  die exklusive Zählweise von Python kennen.
\item
  den Unterschied zwischen Funktionen und Methoden kennen und wie eigene
  Funktionen geschrieben werden.
\item
  Module und Pakete laden
\end{itemize}

\chapter{Einleitung: Datenanalyse mit
Python}\label{einleitung-datenanalyse-mit-python}

Die Erzeugung und Auswertung von Daten ist ein zentraler Bestandteil
wissenschaftlicher Forschung. Die computergestützte Datenanalyse
ermöglicht es, große Datenmengen (teil-)automatisiert auszuwerten. Gut
lesbare Skriptsprachen wie Python sorgen für eine nachvollziehbare
Datenverarbeitung und ermöglichen es, Analysen ``auf Knopfdruck'' zu
wiederholen oder anzupassen.

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/w-python/skript/00-bilder/python-logo-and-wordmark-cc0-tm.png}}

}

\caption{Logo der Programmiersprache Python}

\end{figure}%

Python Logo von Python Software Foundation steht unter der
\href{https://www.gnu.org/licenses/gpl-3.0.html}{GPLv3}. Die
Wort-Bild-Marke ist markenrechtlich geschützt:
\url{https://www.python.org/psf/trademarks/}. Das Werk ist abrufbar auf
\href{https://de.m.wikipedia.org/wiki/Datei:Python_logo_and_wordmark.svg}{wikimedia}.
2008

~

Python kommt als schlichte Konsole daher. Python-Code wird in die
Konsole eingegeben oder in einer reinen Textdatei, dem Skript,
gespeichert. Der Programmcode wird von einem sogenannten Interpreter
ausgeführt. Der Interpreter übersetzt die Programmanweisungen des
Skripts in Maschinencode für das jeweilige Computersystem. Dadurch kann
das Skript auf verschiedenen Computersystemen ausgeführt werden. Moderne
Python-Interpreter sind nicht auf durch ASCII darstellbare Zeichen
limitiert und können auch mit Zeichen aus dem Format
\href{https://de.wikipedia.org/wiki/UTF-8}{UTF-8} umgehen, das das
ASCII-Format z. B. um deutsche Sonderzeichen erweitert.

Zahlreiche Funktionen wie Codeformatierung, Codevervollständigung und
Fehleranalyse werden durch eine sogenannte integrierte
Entwicklungsumgebung (Integrated Development Environment, IDE)
bereitgestellt.

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/w-python/skript/einleitung_files/figure-pdf/cell-2-output-1.pdf}}

}

\caption{Programmentwicklung mit Python}

\end{figure}%

\section{Grundbegriffe der objektorientierten
Programmierung}\label{grundbegriffe-der-objektorientierten-programmierung}

Python ist eine objektorientierte Programmiersprache. Die
objektorientierte Programmierung ist ein System, um Ordnung in komplexe
Computerprogramme zu bringen. In diesem Abschnitt werden die
Grundbegriffe der objektorientierten Programmierung mit Python
vermittelt. Sie erfahren, was der Unterschied zwischen einem Objekt,
einer Klasse und dem Datentyp ist.

\subsection{Klassen, Typen, Objekte,
Attribute}\label{klassen-typen-objekte-attribute}

Ein Pythonprogramm besteht aus verschiedenen Elementen: Operatoren und
Operanden, Funktionen und Methoden, Werten und Variablen und vielem
mehr. Alles in Python ist ein Objekt.

Jedes Objekt gehört zu einer Klasse, beispielsweise zur Klasse der
Ganzzahlen. Die Klasse bestimmt als Blaupause die \emph{Eigenschaften}
und das \emph{Verhalten} des Objekts - etwa welche Daten gespeichert und
welche Operationen ausgeführt werden können. Ein kurzes Beispiel:
Abhängig von ihrer Klasse, verhalten sich Objekte anders mit dem
Operator \texttt{+}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(}\DecValTok{2}\NormalTok{), }\DecValTok{2} \OperatorTok{+} \DecValTok{2}\NormalTok{, }\StringTok{"Ganzzahlen werden addiert."}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(}\StringTok{\textquotesingle{}a\textquotesingle{}} \KeywordTok{and} \StringTok{\textquotesingle{}2\textquotesingle{}}\NormalTok{), }\StringTok{\textquotesingle{}a\textquotesingle{}} \OperatorTok{+} \StringTok{\textquotesingle{}2\textquotesingle{}}\NormalTok{, }\StringTok{"Zeichen werden verkettet."}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(}\VariableTok{True}\NormalTok{), }\VariableTok{True} \OperatorTok{+} \VariableTok{True}\NormalTok{, }\StringTok{"Wahrheitswerte werden addiert."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'int'> 4 Ganzzahlen werden addiert.
<class 'str'> a2 Zeichen werden verkettet.
<class 'bool'> 2 Wahrheitswerte werden addiert.
\end{verbatim}

Das liegt daran, dass das Verhalten des Operators \texttt{+} für die
Klassen Ganzzahlen (`int'), Zeichenfolgen (`str') und Boolesche Werte
(`bool') definiert ist. Anders verhält es sich mit \texttt{None}, einer
Klasse, mit der nicht existente Werte verarbeitet werden:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\VariableTok{None} \OperatorTok{+} \VariableTok{None}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
unsupported operand type(s) for +: 'NoneType' and 'NoneType'
\end{verbatim}

Python kennt sehr viele Klassen. In Python werden Klassen (class) auch
Typen (type) genannt. In früheren Versionen von Python waren Klassen und
Typen noch verschieden. Inzwischen gibt es diesen Unterschied nicht
mehr, beide Begriffe kommen aber noch in der Sprache vor.

\begin{figure}[H]

{\centering \includegraphics[width=0.6\linewidth,height=\textheight,keepaspectratio]{books/w-python/skript/00-bilder/python3-standard-type-hierarchy.png}

}

\caption{Datentypen in Python}

\end{figure}%

Python 3. The standard type hierarchy. von Максим Пе ist lizensiert
unter \href{https://creativecommons.org/licenses/by-sa/4.0/deed.de}{CC
BY SA 4.0} und abrufbar auf
\href{https://commons.wikimedia.org/wiki/File:Python_3._The_standard_type_hierarchy.png}{wikimedia}.
2018

~

Zu welcher Klasse bzw. zu welchem Typ ein Objekt gehört, kann mit der
Funktion \texttt{type()} ermittelt werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(}\BuiltInTok{print}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'builtin_function_or_method'>
\end{verbatim}

Attribute speichern Eigenschaften eines Objekts. Sie treten in der Form
\texttt{objekt.attribut} auf und werden ohne nachfolgende Klammern
aufgerufen. Attribute haben an dieser Stelle der Einführung keine
praktische Bedeutung, werden uns aber später wieder begegnen. Eine
zweite Form der Attribute ist die Methode. Methoden sind Funktionen, die
zu einer bestimmten Klasse gehören. Methoden haben die Form
\texttt{objekt.methode()}, werden also mit nachfolgenden Klammern
aufgerufen. Die Benutzung von Funktionen und Methoden lernen wir in den
kommenden Kapiteln kennen. Wie Sie die verfügbaren Attribute und
Methoden eines Objekts bestimmen, erfahren Sie in
Note~\ref{nte-attribute} und Note~\ref{nte-methods}.

\section{Programmcode formatieren}\label{programmcode-formatieren}

Bei der Formatierung von Python-Code müssen nur wenige Punkte beachtet
werden. Um mit Python eine Ausgabe zu erzeugen, wird die Funktion
\texttt{print(eingabe)} verwendet. Diese Funktion gibt das Argument
eingabe aus.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Zahlen und Operatoren können direkt eingegeben werden. Text, genauer
  eine Zeichenfolge, muss in einfache oder doppelte Anführungszeichen
  gesetzt werden, andernfalls interpretiert Python diesen als Namen
  eines Objekts. Zeichenfolgen können neben Buchstaben, Sonderzeichen
  und Zahlen enthalten.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{1} \OperatorTok{+} \DecValTok{2}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}123: Hallo Welt!\textquotesingle{}}\NormalTok{)}
\NormalTok{text\_variable }\OperatorTok{=} \StringTok{\textquotesingle{}Hallo Python!\textquotesingle{}}
\BuiltInTok{print}\NormalTok{(text\_variable)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
123: Hallo Welt!
Hallo Python!
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Kommentare werden mit einer vorangestellten Raute \texttt{\#}
  gekennzeichnet. Kommentare markieren Code, der nicht ausgeführt werden
  soll, oder Erläuterungen.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ein reiner Kommentar}
\CommentTok{\# print("Python ist großartig!") \# auskommentierter Code, gefolgt von einem Kommentar}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Python ist ziemlich gut."}\NormalTok{) }\CommentTok{\# auszuführender Code, gefolgt von einem Kommentar}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Python ist ziemlich gut.
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Ausdrücke müssen in einer Zeile stehen. Längere Ausdrücke können mit
  dem Backslash \texttt{\textbackslash{}} über mehrere Zeilen
  fortgesetzt werden (hinter \texttt{\textbackslash{}} darf keine
  \texttt{\#} stehen). Innerhalb von Funktionen wie zum Beispiel
  \texttt{print()} können Zeilen nach jedem Komma fortgesetzt werden.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{variable1 }\OperatorTok{=} \DecValTok{15}
\NormalTok{variable2 }\OperatorTok{=} \DecValTok{25}

\CommentTok{\# Zeilenfortsetzung mit \textbackslash{}}
\NormalTok{summe }\OperatorTok{=}\NormalTok{ variable1 }\OperatorTok{+} \OperatorTok{\textbackslash{}}
\NormalTok{    variable2}

\CommentTok{\# Zeilenfortsetzung innerhalb einer Funktion}
\BuiltInTok{print}\NormalTok{(variable1,}
\NormalTok{ variable2,}
\NormalTok{  summe)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
15 25 40
\end{verbatim}

\emph{In dem obenstehenden Beispiel werden Variablen angelegt. Mit
Variablen beschäftigten wir uns im nächsten Kapitel. Trotzdem möchte ich
Sie bitten, sich variable1 und variable2 nocheinmal kurz anzusehen. Wir
kommen später darauf zurück.}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Die Anzahl der Leerzeichen zwischen Operanden und Operatoren kann
  beliebig sein.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{1}\OperatorTok{+}\DecValTok{0}\NormalTok{, }\DecValTok{1} \OperatorTok{+} \DecValTok{1}\NormalTok{, }\DecValTok{1} \OperatorTok{+}                  \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1 2 3
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Die Einrückung mit Leerzeichen kennzeichnet einen zusammengehörigen
  Code-Block. Innerhalb eines Code-Blocks muss immer die gleiche Anzahl
  Leerzeichen verwendet werden. Es muss mindestens ein Leerzeichen
  gesetzt werden, ansonsten ist die Anzahl der Leerzeichen beliebig.
  Üblich sind 2 oder 4 Leerzeichen.\\
  Die folgende for-Schleife führt alle Anweisungen im eingerückten
  Ausführungsblock aus. Die anschließende, nicht eingerückte Zeile
  markiert den Beginn einer neuen, nicht zur Schleife gehörigen
  Anweisung.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{2}\NormalTok{):}
    \BuiltInTok{print}\NormalTok{(variable1)}
    \BuiltInTok{print}\NormalTok{(variable2)}
\BuiltInTok{print}\NormalTok{(summe)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
15
25
15
25
40
\end{verbatim}

\section{Ausgabe formatieren}\label{ausgabe-formatieren}

Mit sogenannten \texttt{f-Strings} können formatierte Zeichenfolgen
erstellt werden. Formatierte Zeichenfolgen werden mit einem den
Anführungsstrichen vorangestellten \texttt{f} erstellt. Werte und
Variablen können durch Platzhalter eingesetzt werden, die mit
geschweiften Klammern \texttt{\{\}} angegeben und mit
Formattierungsinformationen versehen werden. Das Formatierungsformat
innerhalb der geschweiften Klammer ist vereinfacht dargestellt:

\begin{verbatim}
{Variablenname:PlatzbedarfAusgabetyp}
\end{verbatim}

Ein f-String mit Platzhaltern ohne Formatierungsinformationen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zahl1 }\OperatorTok{=} \DecValTok{5}
\NormalTok{zahl2 }\OperatorTok{=} \DecValTok{7}
\NormalTok{verhältnis }\OperatorTok{=}\NormalTok{ zahl1 }\OperatorTok{/}\NormalTok{ zahl2}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Das Verhältnis von }\SpecialCharTok{\{}\NormalTok{zahl1}\SpecialCharTok{\}}\SpecialStringTok{ zu }\SpecialCharTok{\{}\NormalTok{zahl2}\SpecialCharTok{\}}\SpecialStringTok{ ist }\SpecialCharTok{\{}\NormalTok{verh}\SpecialCharTok{ä}\NormalTok{ltnis}\SpecialCharTok{\}}\SpecialStringTok{."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Das Verhältnis von 5 zu 7 ist 0.7142857142857143.
\end{verbatim}

Die Anzahl der darzustellenden Nachkommastellen kann wie folgt
festgelegt werden: \texttt{\{verhältnis:.2f\}}.

\begin{itemize}
\item
  \texttt{:} leitet die Formatierungsbefehle ein.
\item
  \texttt{.} gibt an, dass Formatierungsinformationen für die
  Darstellung hinter dem Dezimaltrennzeichen folgen.
\item
  \texttt{2} ist der Wert für die darzustellenden Nachkommastellen.
\item
  \texttt{f} spezifiziert die Darstellung einer Gleitkommazahl `float'.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Das Verhältnis von }\SpecialCharTok{\{}\NormalTok{zahl1}\SpecialCharTok{\}}\SpecialStringTok{ zu }\SpecialCharTok{\{}\NormalTok{zahl2}\SpecialCharTok{\}}\SpecialStringTok{ ist }\SpecialCharTok{\{}\NormalTok{verh}\SpecialCharTok{ä}\NormalTok{ltnis}\SpecialCharTok{:.2f\}}\SpecialStringTok{."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Das Verhältnis von 5 zu 7 ist 0.71.
\end{verbatim}

Das Gleiche ist mit einem Wert möglich:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Das Verhältnis ist genauer }\SpecialCharTok{\{}\FloatTok{0.7142857142857143}\SpecialCharTok{:.3f\}}\SpecialStringTok{."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Das Verhältnis ist genauer 0.714.
\end{verbatim}

Ein Wert für die insgesamt darzustellenden Stellen wird vor dem
Dezimaltrennzeichen übergeben \texttt{\{verhältnis:7.2f\}} bzw.
inklusive führender Nullen \texttt{\{verhältnis:07.2f\}}:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Das Verhältnis von }\SpecialCharTok{\{}\NormalTok{zahl1}\SpecialCharTok{\}}\SpecialStringTok{ zu }\SpecialCharTok{\{}\NormalTok{zahl2}\SpecialCharTok{\}}\SpecialStringTok{ ist }\SpecialCharTok{\{}\NormalTok{verh}\SpecialCharTok{ä}\NormalTok{ltnis}\SpecialCharTok{:7.2f\}}\SpecialStringTok{."}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Das Verhältnis ist genauer }\SpecialCharTok{\{}\FloatTok{0.7142857142857143}\SpecialCharTok{:07.3f\}}\SpecialStringTok{."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Das Verhältnis von 5 zu 7 ist    0.71.
Das Verhältnis ist genauer 000.714.
\end{verbatim}

Das Dezimaltrennzeichen zählt als eine Stelle.

Häufig verwendete Formatierungen sind:

\section{Ganze Zahlen}

Ganze Zahlen haben den Ausgabetyp \texttt{d}.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.2727}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.7273}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Formatierung
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Ausgabe
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{nd} & n-Stellen werden für die Ausgabe verwendet \\
\texttt{0nd} & Ausgabe von n-Stellen, wobei die Leerstellen mit Nullen
aufgefüllt werden. \\
\texttt{+d} & Ausgabe des Vorzeichens auch bei positiven Zahlen \\
\end{longtable}

\section{Gleitkommazahlen}

Gleitkommazahlen haben die Ausgabetypen \texttt{f} und \texttt{e}.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.2727}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.7273}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Formatierung
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Ausgabe
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{.mf} & m-Stellen werden für die Nachkommastellen genutzt. \\
\texttt{n.mf} & Insgesamt werden n-Stellen verwendet, wobei m-Stellen
für die Nachkommastellen genutzt werden. \\
\texttt{n.me} & Genauso, aber die Ausgabe erfolgt in exponentieller
Schreibweise. \\
\end{longtable}

\section{Zeichenfolgen}

Zeichenfolgen haben den Ausgabetyp \texttt{s}.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.2727}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.7273}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Formatierung
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Ausgabe
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{ns} & Insgesamt werden n-Stellen verwendet. \\
\texttt{\textless{}ns}, \texttt{\textgreater{}ns}, \texttt{\^{}ns} &
Genauso, jedoch wird die Zeichenfolge linksbündig, rechtsbündig bzw.
zentriert platziert. \\
\end{longtable}

Eine Auflistung aller verfügbaren Ausgabetypen findet sich in der
\href{https://docs.python.org/3/library/stdtypes.html\#printf-style-string-formatting}{Python
Dokumentation}.

\section{Aufgaben}\label{aufgaben}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Gleitkommazahlen können natürlich, z. B. \{1015.39:12.4f\}, oder
  wissenschaftlich, \{1015.39:e\}, dargestellt werden.

  \begin{itemize}
  \item
    Verändern Sie die natürliche Schreibweise so, dass nur noch eine
    Stelle nach dem Komma angezeigt wird. Was fällt auf?
  \item
    Verändern Sie die wissenschaftliche Schreibweise so, dass anstelle
    von \texttt{e} die Zehnerbasis als \texttt{E} geschrieben wird.
  \end{itemize}
\item
  Wandeln Sie die Zahl 1015.39 in eine Zeichenfolge um und stellen Sie
  diese mit 12 Stellen rechtsbündig dar.
\item
  Geben Sie mit Hilfe der formatierten Zeichenfolge eine Tabelle aus,
  welche die Spalten \(x\), \(x^2\) und \(x^3\) für ganze Zahlen
  zwischen -2 und 2 auflistet.
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-lösungausgabe}: Musterlösung Ausgabe}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-lösungausgabe} 

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Verändern Sie die natürliche Schreibweise so, dass nur noch eine Stelle nach dem Komma angezeigt wird.}
\CommentTok{\# Was fällt auf?}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"natürliche Schreibweise: }\SpecialCharTok{\{}\FloatTok{1015.39}\SpecialCharTok{:12.4f\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"wissenschaftliche Schreibweise: }\SpecialCharTok{\{}\FloatTok{1015.39}\SpecialCharTok{:e\}}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Schreibweise mit einer Kommastelle: }\SpecialCharTok{\{}\FloatTok{1015.39}\SpecialCharTok{:12.1f\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# Verändern Sie die wissenschaftliche Schreibweise so, dass anstelle von e die Zehnerbasis als E geschrieben wird.}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Zehnerbasis verändern: }\SpecialCharTok{\{}\FloatTok{1015.39}\SpecialCharTok{:E\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
natürliche Schreibweise:    1015.3900
wissenschaftliche Schreibweise: 1.015390e+03
Schreibweise mit einer Kommastelle:       1015.4
Zehnerbasis verändern: 1.015390E+03
\end{verbatim}

Es fällt auf, dass die Nachkommastelle der natürlichen Zahl automatisch
gerundet wird. Beim Ändern der Zehnerbasis zu einem großen \textbf{E}
wird dieses auch in der \texttt{print}-Ausgabe groß geschrieben.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 2.}
\CommentTok{\# Wandeln Sie die Zahl 1015.39 in eine Zeichenfolge um und stellen Sie diese mit 12 Stellen rechtsbündig dar.}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\StringTok{"1015.39"}\SpecialCharTok{:\textgreater{}12s\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     1015.39
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 3.}
\CommentTok{\# Geben Sie mit Hilfe der formatierten Zeichenfolge eine Tabelle aus, welche}
\CommentTok{\# die Spalten x, x² und x³ und für ganze Zahlen zwischen {-}2 und 2 auflistet.}

\NormalTok{x }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{2}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{x}\SpecialCharTok{:\textgreater{}10d\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{x}\OperatorTok{**}\DecValTok{2}\SpecialCharTok{:\textgreater{}10d\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{x}\OperatorTok{**}\DecValTok{3}\SpecialCharTok{:\textgreater{}10d\}}\SpecialStringTok{"}\NormalTok{)}
\NormalTok{x }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{1}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{x}\SpecialCharTok{:\textgreater{}10d\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{x}\OperatorTok{**}\DecValTok{2}\SpecialCharTok{:\textgreater{}10d\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{x}\OperatorTok{**}\DecValTok{3}\SpecialCharTok{:\textgreater{}10d\}}\SpecialStringTok{"}\NormalTok{)}
\NormalTok{x }\OperatorTok{=} \DecValTok{0}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{x}\SpecialCharTok{:\textgreater{}10d\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{x}\OperatorTok{**}\DecValTok{2}\SpecialCharTok{:\textgreater{}10d\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{x}\OperatorTok{**}\DecValTok{3}\SpecialCharTok{:\textgreater{}10d\}}\SpecialStringTok{"}\NormalTok{)}
\NormalTok{x }\OperatorTok{=} \DecValTok{1}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{x}\SpecialCharTok{:\textgreater{}10d\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{x}\OperatorTok{**}\DecValTok{2}\SpecialCharTok{:\textgreater{}10d\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{x}\OperatorTok{**}\DecValTok{3}\SpecialCharTok{:\textgreater{}10d\}}\SpecialStringTok{"}\NormalTok{)}
\NormalTok{x }\OperatorTok{=} \DecValTok{2}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{x}\SpecialCharTok{:\textgreater{}10d\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{x}\OperatorTok{**}\DecValTok{2}\SpecialCharTok{:\textgreater{}10d\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{x}\OperatorTok{**}\DecValTok{3}\SpecialCharTok{:\textgreater{}10d\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
        -2          4         -8
        -1          1         -1
         0          0          0
         1          1          1
         2          4          8
\end{verbatim}

Alternativ ist auch eine (elegantere) Lösung mit einer
\texttt{for}-Schleife möglich:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ x }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\OperatorTok{{-}}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{):}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{x}\SpecialCharTok{:\textgreater{}12d\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{x}\OperatorTok{**}\DecValTok{2}\SpecialCharTok{:\textgreater{}12d\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{x}\OperatorTok{**}\DecValTok{3}\SpecialCharTok{:\textgreater{}12d\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
          -2            4           -8
          -1            1           -1
           0            0            0
           1            1            1
           2            4            8
\end{verbatim}

Musterlösung von Marc Sönnecken.

\end{tcolorbox}

~

{[}@Arnold-2023-datentypen-und-grundlagen;
@Arnold-2023-funktionen-module-dateien;
@Arnold-2023-datenanalyse-python{]}

\chapter{Datentypen}\label{datentypen}

Objekte, die Daten speichern, haben einen Datentyp. Der Datentyp gibt
an, wie die gespeicherten Werte von Python interpretiert werden sollen.
Beispielsweise kann der Wert ``1'' in Python ein Zeichen, eine Ganzzahl,
einen Wahrheitswert, den Monat Januar, den Wochentag Dienstag oder die
Ausprägung einer kategorialen Variablen repräsentieren.

In diesem Abschnitt werden die für die Datenanalyse wichtigsten
Datentypen vorgestellt.

\section{Zahlen}\label{zahlen}

Zu den Zahlen gehören Ganzzahlen, boolsche Werte (Wahrheitswerte),
Gleitkommazahlen sowie komplexe Zahlen (die hier nicht näher vorgestellt
werden).

\subsection{Ganzzahlen}\label{ganzzahlen}

Ganzzahlen werden standardmäßig im Dezimalsystem eingegeben und können
positiv oder negativ sein.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{12}\NormalTok{, }\OperatorTok{{-}}\DecValTok{8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
12 -8
\end{verbatim}

Darüber hinaus können Ganzzahlen auch in anderen Basen angegeben werden:

\begin{itemize}
\tightlist
\item
  Dualsystem: Ziffern \texttt{0} und \texttt{1} mit dem Präfix
  \texttt{0b}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BaseNTok{0b1000}\NormalTok{, }\StringTok{"plus"}\NormalTok{, }\BaseNTok{0b0000}\NormalTok{, }\StringTok{"plus"}\NormalTok{, }\BaseNTok{0b0010}\NormalTok{, }\OperatorTok{\textbackslash{}}
      \StringTok{"plus"}\NormalTok{, }\BaseNTok{0b0001}\NormalTok{, }\StringTok{"ist"}\NormalTok{, }\BaseNTok{0b1011}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
8 plus 0 plus 2 plus 1 ist 11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Oktalsystem: Ziffern \texttt{0} bis \texttt{7} mit dem Präfix
  \texttt{0o}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BaseNTok{0o7000}\NormalTok{, }\StringTok{"plus"}\NormalTok{, }\BaseNTok{0o0700}\NormalTok{, }\StringTok{"plus"}\NormalTok{, }\BaseNTok{0o0020}\NormalTok{, }\OperatorTok{\textbackslash{}}
      \StringTok{"plus"}\NormalTok{, }\BaseNTok{0o0000}\NormalTok{, }\StringTok{"ist"}\NormalTok{, }\BaseNTok{0o7720}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3584 plus 448 plus 16 plus 0 ist 4048
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Hexadezimalsystem: Ziffern \texttt{0} bis \texttt{F} mit dem Präfix
  \texttt{0x}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BaseNTok{0xF000}\NormalTok{, }\StringTok{"plus"}\NormalTok{, }\BaseNTok{0x0200}\NormalTok{, }\StringTok{"plus"}\NormalTok{, }\BaseNTok{0x00A0}\NormalTok{, }\OperatorTok{\textbackslash{}}
      \StringTok{"plus"}\NormalTok{, }\BaseNTok{0x0001}\NormalTok{, }\StringTok{"ist"}\NormalTok{, }\BaseNTok{0xF2A1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
61440 plus 512 plus 160 plus 1 ist 62113
\end{verbatim}

\subsection{Gleitkommazahlen}\label{gleitkommazahlen-1}

Gleitkommazahlen werden entweder mit dem Dezimaltrennzeichen \texttt{.}
oder in Exponentialschreibweise angegeben. Gleitkommazahlen haben den
Typ \texttt{float}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\FloatTok{120.6}\NormalTok{, }\FloatTok{1206e{-}1}\NormalTok{, }\FloatTok{12060e{-}2}\NormalTok{, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Beim Lottogewinn in Exponentialschreibeweise zählt das Vorzeichen."}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\FloatTok{1e{-}3}\NormalTok{, }\StringTok{"oder"}\NormalTok{, }\FloatTok{1e+3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
120.6 120.6 120.6 

Beim Lottogewinn in Exponentialschreibeweise zählt das Vorzeichen.
0.001 oder 1000.0
\end{verbatim}

Da Computer im Binärsystem arbeiten, können Dezimalzahlen nicht exakt
gespeichert werden. Beispielsweise ist die Division von 1 durch 10
dezimal gleich 0,1. Binär ist 1\textsubscript{2} durch
1010\textsubscript{2} aber ein periodischer Bruch:
\[ \frac{1_2}{1010_2} ~ {=} ~ 0,000\overline{1100}_2 \]

Dezimalzahlen müssen deshalb als Bruch zweier Ganzzahlen approximiert
werden (Der Binärbruch, der 0.1 annähert, ist in Dezimalschreibweise
3602879701896397 / 2\textsuperscript{55}). Dadurch kommt es vor, dass
mehrere Gleitkommazahlen durch die selbe Binärapproximation
repräsentiert werden. Python gibt zwar die jeweils kürzeste Dezimalzahl
aus, da Berechnungen aber binär durchgeführt werden, kann sich bei
Berechnungen die nächste Binärapproximation und damit die zugehörige
kürzeste Dezimalzahl ändern (weitere Informationen in der
\href{https://docs.python.org/3/tutorial/floatingpoint.html}{Python
Dokumentation}).

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\FloatTok{0.1}\NormalTok{) }\CommentTok{\# Die kürzeste Dezimalzahl zur Binärapproximation}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{format}\NormalTok{(}\FloatTok{0.1}\NormalTok{, }\StringTok{\textquotesingle{}.17g\textquotesingle{}}\NormalTok{)) }\CommentTok{\# Die nächstlängere Dezimalzahl zur selben Binärapproximation}
\BuiltInTok{print}\NormalTok{(}\FloatTok{0.3} \OperatorTok{{-}} \FloatTok{0.2}\NormalTok{) }\CommentTok{\# binär gerechnet, ändert sich die Binärapproximation}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.1
0.10000000000000001
0.09999999999999998
\end{verbatim}

In der praktischen Arbeit mit Python kommen deshalb gelegentlich auf den
ersten Blick ungewöhnlich wirkende Ergebnisse vor.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\FloatTok{0.1} \OperatorTok{+} \FloatTok{0.2}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\FloatTok{0.01} \OperatorTok{+} \FloatTok{0.02}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\FloatTok{0.001} \OperatorTok{+} \FloatTok{0.002}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\FloatTok{0.0001} \OperatorTok{+} \FloatTok{0.0002}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\FloatTok{0.00001} \OperatorTok{+} \FloatTok{0.00002}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.30000000000000004
0.03
0.003
0.00030000000000000003
3.0000000000000004e-05
\end{verbatim}

\section{Arithmetische Operatoren}\label{arithmetische-operatoren}

Mit arithmetischen Operatoren können die Grundrechenarten verwendet
werden. Das Ergebnis ist meist vom Typ \texttt{float}, außer, wenn beide
Operanden vom Typ \texttt{int} sind und das Ergebnis als ganze Zahl
darstellbar ist.

\begin{longtable}[]{@{}cc@{}}
\toprule\noalign{}
Operator & Beschreibung \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{+}, \texttt{-} & Addition / Subtraktion \\
\texttt{*}, \texttt{/} & Multiplikation / Division \\
\texttt{//}, \texttt{\%} & Ganzzahlige Division / Rest \\
\texttt{**} & Potenzieren \\
\end{longtable}

~

Werden mehrere Operatoren kombiniert, so muss deren Reihenfolge beachtet
bzw. durch die Verwendung von Klammern \texttt{(1\ +\ 2)\ *\ 3}
hergestellt werden. Es gelten die gleichen Regeln wie beim schriftlichen
Rechen. Die vollständige Übersicht der Reihenfolge der Ausführung ist in
der
\href{https://docs.python.org/3/reference/expressions.html\#operator-precedence}{Pythondokumentation}
aufgeführt. Für die arithmethischen Operatoren gilt folgende,
absteigende Reihenfolge.

\begin{longtable}[]{@{}c@{}}
\toprule\noalign{}
Operator \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{**} \\
\texttt{*} , \texttt{/} , \texttt{//} , \texttt{\%} \\
\texttt{+} , \texttt{-} \\
\end{longtable}

Bei gleichrangigen Operationen werden diese von links nach rechts
ausgeführt.

\section{Aufgaben Zahlen}\label{aufgaben-zahlen}

\textbf{Lösen Sie die folgenden Aufgaben mit Python.}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  4 + 2 * 4 = ?
\item
  2 hoch 12 = ?
\item
  Was ist der Rest aus 315 geteilt durch 4?
\item
  𝟣 + 𝟤6 / 𝟧 = ?
\item
  Welche Dezimalzahl ist 11111101001\textsubscript{2} ?
\item
  11111101001\textsubscript{2} / 101\textsubscript{2} = ?
\item
  Welcher Kapitalertrag ist größer, wenn 1000 Euro angelegt werden?

  \begin{enumerate}
  \def\labelenumii{\alph{enumii})}
  \item
    20 Jahre Anlagedauer mit 3 Prozent jährlicher Rendite
  \item
    30 Jahre Anlagedauer mit 2 Prozent jährlicher Rendite
  \end{enumerate}
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-lösungzahlen}: Musterlösung Zahlen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-lösungzahlen} 

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 1.}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}4 + 2 * 4 =\textquotesingle{}}\NormalTok{, }\DecValTok{4}\OperatorTok{+}\DecValTok{2}\OperatorTok{*}\DecValTok{4}\NormalTok{, }\StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
\CommentTok{\# 2.}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}2 hoch 12 =\textquotesingle{}}\NormalTok{, }\DecValTok{2}\OperatorTok{**}\DecValTok{12}\NormalTok{, }\StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
\CommentTok{\# 3.}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Rest aus 315 geteilt durch 4 =\textquotesingle{}}\NormalTok{, }\DecValTok{315}\OperatorTok{\%}\DecValTok{4}\NormalTok{, }\StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
\CommentTok{\# 4.}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}1 + 2\^{}6 / 5 = \textquotesingle{}}\NormalTok{, }\DecValTok{1}\OperatorTok{+}\NormalTok{(}\DecValTok{2}\OperatorTok{**}\DecValTok{6}\NormalTok{)}\OperatorTok{/}\DecValTok{5}\NormalTok{ , }\StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
\CommentTok{\# 5.}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}binär 11111101001 ist dezimal =\textquotesingle{}}\NormalTok{, }\BaseNTok{0b11111101001}\NormalTok{, }\StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
\CommentTok{\# 6.}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}binär 11111101001 / 101 ist dezimal =\textquotesingle{}}\NormalTok{, }\BaseNTok{0b11111101001}\OperatorTok{/}\BaseNTok{0b101}\NormalTok{, }\StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
\CommentTok{\# 7.}
\NormalTok{variante\_a }\OperatorTok{=} \DecValTok{1000}\OperatorTok{*}\FloatTok{1.03}\OperatorTok{**}\DecValTok{20}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f\textquotesingle{}nach 20 Jahren mit 3 Prozent = }\SpecialCharTok{\{}\NormalTok{variante\_a}\SpecialCharTok{:.2f\}}\SpecialStringTok{\textquotesingle{}}\NormalTok{)}
\NormalTok{variante\_b }\OperatorTok{=} \DecValTok{1000}\OperatorTok{*}\FloatTok{1.02}\OperatorTok{**}\DecValTok{30}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f\textquotesingle{}nach 30 Jahren mit 2 Prozent = }\SpecialCharTok{\{}\NormalTok{variante\_b}\SpecialCharTok{:.2f\}}\SpecialStringTok{\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4 + 2 * 4 = 12 

2 hoch 12 = 4096 

Rest aus 315 geteilt durch 4 = 3 

1 + 2^6 / 5 =  13.8 

binär 11111101001 ist dezimal = 2025 

binär 11111101001 / 101 ist dezimal = 405.0 

nach 20 Jahren mit 3 Prozent = 1806.11
nach 30 Jahren mit 2 Prozent = 1811.36
\end{verbatim}

Musterlösung von Marc Sönnecken

\end{tcolorbox}

\section{Boolsche Werte}\label{boolsche-werte}

Die boolschen Werte \texttt{True} und \texttt{False} sind das Ergebnis
logischer Abfragen, die wir später genauer kennenlernen. Sie nehmen auch
die Werte \texttt{1} und \texttt{0} an und gehören in Python deshalb zu
den Zahlen.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Ist 10 größer als 9?"}\NormalTok{, }\DecValTok{10} \OperatorTok{\textgreater{}} \DecValTok{9}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Ist 11 kleiner als 10?"}\NormalTok{, }\DecValTok{11} \OperatorTok{\textless{}} \DecValTok{10}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Ist 10 genau 10.0?"}\NormalTok{, }\DecValTok{10} \OperatorTok{==} \FloatTok{10.0}\NormalTok{, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"True und False können mit + addiert werden:"}\NormalTok{, }\VariableTok{True} \OperatorTok{+} \VariableTok{False}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"... und mit * multipliziert werden:"}\NormalTok{, }\VariableTok{True} \OperatorTok{*} \VariableTok{False}\NormalTok{, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Ist 10 größer als 9? True
Ist 11 kleiner als 10? False
Ist 10 genau 10.0? True 

True und False können mit + addiert werden: 1
... und mit * multipliziert werden: 0 
\end{verbatim}

Die Multiplikation von Wahrheitswerten ist nützlich, um mehrere logische
Abfragen zu einem logischen UND zu kombinieren:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Ist 10 \textgreater{} 9 UND 10 \textgreater{} 8?"}\NormalTok{, (}\DecValTok{10} \OperatorTok{\textgreater{}} \DecValTok{9}\NormalTok{) }\OperatorTok{*}\NormalTok{ (}\DecValTok{10} \OperatorTok{\textgreater{}} \DecValTok{8}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Ist 10 > 9 UND 10 > 8? 1
\end{verbatim}

Die Funktion \texttt{bool()} gibt den Wahrheitswert eines Werts zurück.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Ist 10 \textgreater{} 9 UND \textgreater{} 8?"}\NormalTok{, }\BuiltInTok{bool}\NormalTok{((}\DecValTok{10} \OperatorTok{\textgreater{}} \DecValTok{9}\NormalTok{) }\OperatorTok{*}\NormalTok{ (}\DecValTok{10} \OperatorTok{\textgreater{}} \DecValTok{8}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Ist 10 > 9 UND > 8? True
\end{verbatim}

Die meisten Werte in Python haben den Wahrheitswert \texttt{True}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{bool}\NormalTok{(}\DecValTok{1}\NormalTok{), }\BuiltInTok{bool}\NormalTok{(}\DecValTok{2}\NormalTok{), }\BuiltInTok{bool}\NormalTok{(}\FloatTok{2.4}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{bool}\NormalTok{(}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{), }\BuiltInTok{bool}\NormalTok{(}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{), }\BuiltInTok{bool}\NormalTok{(}\StringTok{\textquotesingle{}ab\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True True True
True True True
\end{verbatim}

Neben \texttt{False} und \texttt{0} haben leere und nicht existierende
Werte oder Objekte den Wahrheitswert \texttt{False}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{bool}\NormalTok{(}\VariableTok{False}\NormalTok{), }\BuiltInTok{bool}\NormalTok{(}\DecValTok{0}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{bool}\NormalTok{(}\StringTok{""}\NormalTok{)) }\CommentTok{\# eine leere Zeichenfolge}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{bool}\NormalTok{([])) }\CommentTok{\# eine leere Liste}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{bool}\NormalTok{(())) }\CommentTok{\# eine leeres Tupel}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{bool}\NormalTok{(\{\})) }\CommentTok{\# ein leeres Dictionary}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{bool}\NormalTok{(}\VariableTok{None}\NormalTok{)) }\CommentTok{\# None deklariert einen nicht existenten Wert}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
False False
False
False
False
False
False
\end{verbatim}

Die Sammeltypen Liste, Tupel und Dictionary lernen wir in den folgenden
Kapiteln kennen. Boolsche Werte können die Ausführung von Programmcode
steuern, indem sie wie \texttt{an} und \texttt{aus} wirken. So kann
Programmcode mit einer \texttt{if}-Anweisung nur dann ausgeführt werden,
wenn ein Sammeltyp auch Werte enthält.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{meine\_Liste }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Äpfel\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Butter\textquotesingle{}}\NormalTok{]}
\ControlFlowTok{if}\NormalTok{ meine\_Liste:}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Wir müssen }\SpecialCharTok{\{}\NormalTok{meine\_Liste}\SpecialCharTok{\}}\SpecialStringTok{ einkaufen."}\NormalTok{)}

\NormalTok{meine\_Liste }\OperatorTok{=}\NormalTok{ [] }\CommentTok{\# eine leere Liste}
\ControlFlowTok{if}\NormalTok{ meine\_Liste:}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Wir müssen }\SpecialCharTok{\{}\NormalTok{meine\_Liste}\SpecialCharTok{\}}\SpecialStringTok{ einkaufen."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Wir müssen ['Äpfel', 'Butter'] einkaufen.
\end{verbatim}

\section{Logische Operatoren}\label{logische-operatoren}

Zu den logischen Operatoren gehören die logischen Verknüpfungen
\texttt{and}, \texttt{or} und \texttt{not}. Darüber hinaus können auch
vergleichende Operatoren wie \texttt{\textgreater{}},
\texttt{\textgreater{}=} oder \texttt{==} verwendet werden. Das Ergebnis
dieser Operationen ist vom Typ \texttt{bool}. Die Operatoren werden in
folgender Reihenfolge ausgeführt. Gleichrangige Operatoren werden von
links nach rechts ausgeführt.

\begin{longtable}[]{@{}
  >{\centering\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\centering\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\centering
Operator
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Beschreibung
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{\&} & bitweises UND \\
\texttt{\^{}} & bitweises XOR \\
\texttt{\textbar{}} & bitweises ODER \\
\texttt{\textless{}}, \texttt{\textless{}=}, \texttt{\textgreater{}},
\texttt{\textgreater{}=}, \texttt{!=}, \texttt{==} & kleiner / kleiner
gleich / größer als / größer gleich / ungleich / gleich \\
\texttt{not} & logisches NICHT \\
\texttt{and} & logisches UND \\
\texttt{or} & logisches ODER \\
\end{longtable}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-bitwise} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-bitwise}: Bitweise Operatoren}\vspace{3mm}

Besondere Vorsicht ist mit den
\href{https://wiki.python.org/moin/BitwiseOperators}{bitweisen
Operatoren} geboten. Diese vergleichen Zahlen nicht als Ganzes, sondern
stellenweise (im Binärsystem). Zu beachten ist, dass die bitweisen
Operatoren Ausführungspriorität vor Vergleichsoperationen haben.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{10} \OperatorTok{\textgreater{}} \DecValTok{5} \KeywordTok{and} \DecValTok{10} \OperatorTok{\textgreater{}} \DecValTok{6}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\DecValTok{10} \OperatorTok{\textgreater{}} \DecValTok{5} \OperatorTok{\&} \DecValTok{10} \OperatorTok{\textgreater{}} \DecValTok{6}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\DecValTok{5} \OperatorTok{\&} \DecValTok{10}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\DecValTok{10} \OperatorTok{\textgreater{}} \VariableTok{False} \OperatorTok{\textgreater{}} \DecValTok{6}\NormalTok{)}
\BuiltInTok{print}\NormalTok{((}\DecValTok{10} \OperatorTok{\textgreater{}} \DecValTok{5}\NormalTok{) }\OperatorTok{\&}\NormalTok{ (}\DecValTok{10} \OperatorTok{\textgreater{}} \DecValTok{6}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
False
0
False
True
\end{verbatim}

\begin{quote}
\textbf{Tip}

Im Allgemeinen werden die bitweisen Operatoren für die Datenanalyse
nicht benötigt. Vermeiden Sie unnötige Fehler: Vermeiden Sie die
bitweisen Operatoren \texttt{\&}, \texttt{\^{}} und \texttt{\textbar{}}.

Die Operatoren \texttt{\&}, \texttt{\^{}} und \texttt{\textbar{}} haben
jedoch für Mengen (die wir später kennenlernen werden) eine andere
Bedeutung. Auch in anderen Modulen kommt den Operatoren syntaktisch eine
andere Bedeutung zu, bspw. im Paket Pandas bei der Übergabe mehrerer
Slicing-Bedingungen
\texttt{df\ =\ df{[}(Bedingung1)\ \&\ (Bedingung2)\ \textbar{}\ (Bedingung3){]}}.
\end{quote}

\end{minipage}%
\end{tcolorbox}

\section{Aufgaben boolsche Werte}\label{aufgaben-boolsche-werte}

\textbf{Lösen Sie die Aufgaben mit Python.}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Ist das Verhältnis aus 44 zu 4,5 größer als 10?
\item
  Ist es wahr, dass 4,5 größer als 4 aber kleiner als 5 ist?
\item
  Ist 2 hoch 10 gleich 1024?
\item
  Sind die Zahlen 3, 4 und 5 ganzzahlig durch 2 teilbar ODER ungleich
  10?
\item
  Prüfen Sie, ob eine Person den Vollpreis bezahlen muss, wenn Sie Ihr
  Alter angibt.\\
  Erwachsene zahlen den Vollpreis. Kinder unter 14 Jahren fahren
  kostenlos. Jugendliche ab 14 und bis zum Erreichen des 18. Lebensjahrs
  sowie Senior:innen ab 65 Jahren erhalten einen Rabatt.
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-musterlösung-bool}: Musterlösung boolsche Werte}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-musterlösung-bool} 

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 1.}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Ist 44/4,5 größer als 10?\textquotesingle{}}\NormalTok{, }\DecValTok{44}\OperatorTok{/}\FloatTok{4.5} \OperatorTok{\textgreater{}} \DecValTok{10}\NormalTok{)}
\CommentTok{\# 2.}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Ist 4,5 größer als 4 aber kleiner als 5?\textquotesingle{}}\NormalTok{, }\DecValTok{4}\OperatorTok{\textless{}}\FloatTok{4.5} \KeywordTok{and} \FloatTok{4.5}\OperatorTok{\textless{}}\DecValTok{5}\NormalTok{)}
\CommentTok{\# 3.}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Ist 2 hoch 10 gleich 1024?\textquotesingle{}}\NormalTok{, }\DecValTok{2}\OperatorTok{**}\DecValTok{10} \OperatorTok{==} \DecValTok{1024}\NormalTok{)}
\CommentTok{\# 4.}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Sind die Zahlen 3, 4 und 5 ganzzahlig durch 2 teilbar ODER ungleich 10?\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}3:\textquotesingle{}}\NormalTok{, }\DecValTok{3}\OperatorTok{\%}\DecValTok{2} \OperatorTok{==} \DecValTok{0} \KeywordTok{or} \DecValTok{3} \OperatorTok{!=} \DecValTok{10}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}4:\textquotesingle{}}\NormalTok{, }\DecValTok{4}\OperatorTok{\%}\DecValTok{2} \OperatorTok{==} \DecValTok{0} \KeywordTok{or} \DecValTok{4} \OperatorTok{!=} \DecValTok{10}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}5:\textquotesingle{}}\NormalTok{, }\DecValTok{5}\OperatorTok{\%}\DecValTok{2} \OperatorTok{==} \DecValTok{0} \KeywordTok{or} \DecValTok{5} \OperatorTok{!=} \DecValTok{10}\NormalTok{)}
\CommentTok{\# 5. Alter prüfen}

\CommentTok{\# Variable für das zu prüfende Alter}
\NormalTok{age }\OperatorTok{=} \DecValTok{17}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Alter =\textquotesingle{}}\NormalTok{, age)}

\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Die Person muss den Vollpreis zahlen:\textquotesingle{}}\NormalTok{, age }\OperatorTok{\textgreater{}=} \DecValTok{18} \KeywordTok{and}\NormalTok{ age }\OperatorTok{\textless{}} \DecValTok{65}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Die Person fährt mit Rabatt:\textquotesingle{}}\NormalTok{, age }\OperatorTok{\textgreater{}=} \DecValTok{14} \KeywordTok{and}\NormalTok{ age }\OperatorTok{\textless{}} \DecValTok{18} \KeywordTok{or}\NormalTok{ age }\OperatorTok{\textgreater{}=} \DecValTok{65}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Die Person fährt kostenlos:\textquotesingle{}}\NormalTok{, age }\OperatorTok{\textless{}} \DecValTok{14}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Ist 44/4,5 größer als 10? False
Ist 4,5 größer als 4 aber kleiner als 5? True
Ist 2 hoch 10 gleich 1024? True
Sind die Zahlen 3, 4 und 5 ganzzahlig durch 2 teilbar ODER ungleich 10?
3: True
4: True
5: True
Alter = 17
Die Person muss den Vollpreis zahlen: False
Die Person fährt mit Rabatt: True
Die Person fährt kostenlos: False
\end{verbatim}

Musterlösung von Marc Sönnecken und Maik Poetzsch

\end{tcolorbox}

\section{Zeichenfolgen}\label{zeichenfolgen-1}

Zeichenfolgen (Englisch string) werden in Python in einfache oder
doppelte Anführungszeichen gesetzt.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}eine Zeichenfolge\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"noch eine Zeichenfolge"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
eine Zeichenfolge
noch eine Zeichenfolge
\end{verbatim}

Innerhalb einer Zeichenfolge können einfache oder doppelte
Anführungszeichen verwendet werden, solange diese nicht den die
Zeichenfolge umschließenden Anführungszeichen entsprechen.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}A sophisticated heap beam, which we call a "LASER".\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"I\textquotesingle{}ve turned the moon into what I like to call a \textquotesingle{}Death Star\textquotesingle{}."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
A sophisticated heap beam, which we call a "LASER".
I've turned the moon into what I like to call a 'Death Star'.
\end{verbatim}

Das Steuerzeichen \texttt{\textbackslash{}} (oder Fluchtzeichen, escape
character) erlaubt es, bestimmte Sondernzeichen zu verwenden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Das Steuerzeichen }\CharTok{\textbackslash{}\textbackslash{}}\StringTok{ ermöglicht die gleichen }\CharTok{\textbackslash{}"}\StringTok{Anführungszeichen}\CharTok{\textbackslash{}"}\StringTok{ in der Ausgabe von print."}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Erst ein}\CharTok{\textbackslash{}t}\StringTok{Tabstopp, dann eine}\CharTok{\textbackslash{}n}\StringTok{neue Zeile."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Das Steuerzeichen \ ermöglicht die gleichen "Anführungszeichen" in der Ausgabe von print.
Erst ein    Tabstopp, dann eine
neue Zeile.
\end{verbatim}

Ein vorangestelltes \texttt{r} bewirkt, dass das Steuerzeichen
\texttt{\textbackslash{}} nicht verarbeitet wird (raw string literal).
Dies ist beispielsweise bei der Arbeit mit Dateipfaden praktisch.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Die Daten liegen unter: C:}\CharTok{\textbackslash{}t}\StringTok{olle\_daten}\CharTok{\textbackslash{}n}\StringTok{ordpol}\ErrorTok{\textbackslash{}}\StringTok{weihnachtsmann"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\VerbatimStringTok{r"Die Daten liegen unter: C:}\CharTok{\textbackslash{}t}\VerbatimStringTok{olle\_daten}\CharTok{\textbackslash{}n}\VerbatimStringTok{ordpol}\DecValTok{\textbackslash{}w}\VerbatimStringTok{eihnachtsmann"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Daten liegen unter: C:  olle_daten
ordpol\weihnachtsmann
Die Daten liegen unter: C:\tolle_daten\nordpol\weihnachtsmann
\end{verbatim}

\section{Operationen mit
Zeichenfolgen}\label{operationen-mit-zeichenfolgen}

Einige Operatoren funktionieren auch mit Daten vom Typ string.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# string + string}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}a\textquotesingle{}} \OperatorTok{+} \StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{)}

\CommentTok{\# string + Zahl}
\BuiltInTok{print}\NormalTok{(}\DecValTok{15} \OperatorTok{*} \StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{)}

\CommentTok{\# logische Operatoren}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}a\textquotesingle{}} \OperatorTok{\textless{}} \StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}a\textquotesingle{}} \OperatorTok{\textgreater{}=} \StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}a\textquotesingle{}} \OperatorTok{!=} \StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}a\textquotesingle{}} \KeywordTok{or} \StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}a\textquotesingle{}} \KeywordTok{and} \StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ab
aaaaaaaaaaaaaaa
True False True
a b
\end{verbatim}

\section{Aufgaben Zeichenfolgen}\label{aufgaben-zeichenfolgen}

\textbf{Lösen Sie die Aufgaben mit Python.}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Was passiert, wenn Sie die Zeichenfolge ``Python'' mit '' für
  Anfänger'' addieren?
\item
  Erzeugen Sie eine Zeichenfolge, die 10 mal die Zeichenfolge ``tick
  tack'' enthält.
\item
  Welche Zeichenfolge ist kleiner, ``Aachen'' oder ``Bern''. Warum ist
  das so, wie werden Zeichenfolgen verglichen?
\item
  Geben Sie den Dateipfad aus:
  ``\textasciitilde\textbackslash home\textbackslash tobi\textbackslash neue\_daten''
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-lösungstrings}: Musterlösung Aufgaben Zeichenfolgen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-lösungstrings} 

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 1.}
\BuiltInTok{print}\NormalTok{(}\StringTok{"python"} \OperatorTok{+} \StringTok{"for beginners"}\NormalTok{) }\CommentTok{\# Die beiden Zeichenfolgen werden direkt aneinander gekettet, ohne Leerzeichen dazwischen}
\CommentTok{\# 2.}
\BuiltInTok{print}\NormalTok{(}\DecValTok{10}\OperatorTok{*}\NormalTok{(}\StringTok{"tick tack"}\NormalTok{))}
\CommentTok{\# 3.}
\BuiltInTok{print}\NormalTok{( }\StringTok{"Aachen"}\OperatorTok{\textless{}}\StringTok{"Bern"}\NormalTok{ ) }\CommentTok{\# es werden die Unicode{-}Werte verglichen}
\CommentTok{\# 4.}
\BuiltInTok{print}\NormalTok{(}\VerbatimStringTok{r"\textasciitilde{}}\ErrorTok{\textbackslash{}}\VerbatimStringTok{home}\CharTok{\textbackslash{}t}\VerbatimStringTok{obi}\CharTok{\textbackslash{}n}\VerbatimStringTok{eue\_daten"}\NormalTok{) }\CommentTok{\# Python interpretiert den Backslash "\textbackslash{}" als Escape{-}Zeichen. Um dies bei Dateipfaden zu verhindern, wird der Pfad mittels r" als raw String ausgegeben.}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
pythonfor beginners
tick tacktick tacktick tacktick tacktick tacktick tacktick tacktick tacktick tacktick tack
True
~\home\tobi\neue_daten
\end{verbatim}

Musterlösung von Marc Sönnecken

\end{tcolorbox}

\section{Variablen}\label{variablen}

Variablen sind Platzhalter bzw. Referenzen auf Daten. Die Zuweisung wird
durch den Zuweisungsoperator \texttt{=} dargestellt. Der Name einer
Variablen darf nur aus Buchstaben, Zahlen und Unterstrichen bestehen.
Dabei darf das erste Zeichen keine Zahl sein.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var\_1 }\OperatorTok{=} \StringTok{\textquotesingle{}ABC\textquotesingle{}}
\NormalTok{var\_2 }\OperatorTok{=} \DecValTok{26}
\NormalTok{var\_3 }\OperatorTok{=} \VariableTok{True}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Das"}\NormalTok{, var\_1, }\StringTok{"hat"}\NormalTok{, var\_2, }\StringTok{"Buchstaben. Das ist"}\NormalTok{, var\_3)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Das ABC hat 26 Buchstaben. Das ist True
\end{verbatim}

Variablen müssen in Python nicht initialisiert werden. Der Datentyp der
Variablen wird durch die Zuweisung eines entsprechenden Werts
festgelegt.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Die Variable var\_1 hat den Typ"}\NormalTok{, }\BuiltInTok{type}\NormalTok{(var\_1))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Die Variable var\_2 hat den Typ"}\NormalTok{, }\BuiltInTok{type}\NormalTok{(var\_2))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Die Variable var\_3 hat den Typ"}\NormalTok{, }\BuiltInTok{type}\NormalTok{(var\_3))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Variable var_1 hat den Typ <class 'str'>
Die Variable var_2 hat den Typ <class 'int'>
Die Variable var_3 hat den Typ <class 'bool'>
\end{verbatim}

Der Datentyp einer Variable ändert sich, wenn ihr ein neuer Wert eines
anderen Datentyps zugewiesen wird.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var\_1 }\OperatorTok{=} \DecValTok{100}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Die Variable var\_1 hat den Typ"}\NormalTok{, }\BuiltInTok{type}\NormalTok{(var\_1))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Variable var_1 hat den Typ <class 'int'>
\end{verbatim}

Ebenso kann sich der Datentyp einer Variable ändern, um das Ergebnis
einer Operation aufnehmen zu können. In diesem Beispiel kann das
Ergebnis nicht in Form einer Ganzzahl gespeichert werden. Python weist
dem Objekt var\_1 deshalb den Datentyp `float' zu.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var\_1 }\OperatorTok{=}\NormalTok{ var\_1 }\OperatorTok{/} \DecValTok{11}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Die Variable var\_1 hat den Typ"}\NormalTok{, }\BuiltInTok{type}\NormalTok{(var\_1))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Variable var_1 hat den Typ <class 'float'>
\end{verbatim}

Python enthält Funktionen, um den Datentyp einer Variablen zu bestimmen
und umzuwandeln. Die Funktion \texttt{type()} wurde in den
Code-Beispielen bereits benutzt, um den Datentyp (bzw. die Klasse) von
Objekten zu bestimmen. Die Umwandlung des Datentyps zeigt der folgende
Code-Block.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \DecValTok{67} 
\BuiltInTok{print}\NormalTok{(a, }\BuiltInTok{type}\NormalTok{(a))}

\NormalTok{b }\OperatorTok{=}\NormalTok{ a }\OperatorTok{+} \FloatTok{1.8}
\BuiltInTok{print}\NormalTok{(b, }\BuiltInTok{type}\NormalTok{(b), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Beachten Sie das Abschneiden der Nachkommastelle:}\CharTok{\textbackslash{}n}\SpecialStringTok{Umwandlung in Ganzzahlen mit int(): }\SpecialCharTok{\{}\NormalTok{( a }\OperatorTok{:=} \BuiltInTok{int}\NormalTok{(a) )}\SpecialCharTok{,}\NormalTok{ (b }\OperatorTok{:=} \BuiltInTok{int}\NormalTok{(b) )}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Umwandlung in ASCII{-}Zeichen mit chr(): }\SpecialCharTok{\{}\NormalTok{( a }\OperatorTok{:=} \BuiltInTok{chr}\NormalTok{(a) )}\SpecialCharTok{,}\NormalTok{ ( b }\OperatorTok{:=} \BuiltInTok{chr}\NormalTok{(b) )}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Umwandlung in eine ASCII{-}Zahl mit ord(): }\SpecialCharTok{\{}\NormalTok{( a }\OperatorTok{:=} \BuiltInTok{ord}\NormalTok{(a) )}\SpecialCharTok{,}\NormalTok{ ( b }\OperatorTok{:=} \BuiltInTok{ord}\NormalTok{(b) )}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Umwandlung in Fließkommazahlen mit float(): }\SpecialCharTok{\{}\NormalTok{( a }\OperatorTok{:=} \BuiltInTok{float}\NormalTok{(a) )}\SpecialCharTok{,}\NormalTok{ ( b }\OperatorTok{:=} \BuiltInTok{float}\NormalTok{(b) )}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Umwandlung in Zeichen mit str(): }\SpecialCharTok{\{}\NormalTok{( a }\OperatorTok{:=} \BuiltInTok{str}\NormalTok{(a) )}\SpecialCharTok{,}\NormalTok{ ( b}\OperatorTok{:=} \BuiltInTok{str}\NormalTok{(b) )}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Umwandlung in Wahrheitswerte mit bool(): }\SpecialCharTok{\{}\BuiltInTok{bool}\NormalTok{(a)}\SpecialCharTok{,} \BuiltInTok{bool}\NormalTok{(b)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
67 <class 'int'>
68.8 <class 'float'> 

Beachten Sie das Abschneiden der Nachkommastelle:
Umwandlung in Ganzzahlen mit int(): (67, 68)

Umwandlung in ASCII-Zeichen mit chr(): ('C', 'D')

Umwandlung in eine ASCII-Zahl mit ord(): (67, 68)

Umwandlung in Fließkommazahlen mit float(): (67.0, 68.0)

Umwandlung in Zeichen mit str(): ('67.0', '68.0')

Umwandlung in Wahrheitswerte mit bool(): (True, True)
\end{verbatim}

\subsection{Weitere
Zuweisungsoperatoren}\label{weitere-zuweisungsoperatoren}

In dem obenstehenden Code-Block wurde der sogenannte
\href{https://docs.python.org/3/whatsnew/3.8.html}{Walross-Operator}
\texttt{:=} verwendet. Dieser erlaubt es, Zuweisungen innerhalb eines
Ausdrucks (hier innerhalb der Funktion \texttt{print()}) vorzunehmen.
Python kennt eine ganze Reihe weiterer Zuweisungsoperatoren (weitere
Operatoren siehe
\href{https://docs.python.org/3/reference/simple_stmts.html}{Python-Dokumentation}
oder übersichtlicher
\href{https://www.w3schools.com/python/python_operators.asp}{hier}).

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Operator & entspricht der Zuweisung \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
a += 2 & a = a + 2 \\
a -= 2 & a = a - 2 \\
a *= 2 & a = a * 2 \\
a /= 2 & a = a / 2 \\
a \%= 2 & a = a \% 2 \\
a //= 2 & a = a // 2 \\
a **= 2 & a = a ** 2 \\
\end{longtable}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-zuweisung}: Lesbare Zuweisungen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-zuweisung} 

Die in der Tabelle gezeigten Zuweisungsoperatoren sind für jemanden,
der*die Ihren Code liest, gut zu lesen und nachzuvollziehen, da
Zuweisungen immer am Beginn einer Zeile, also ganz links, stehen.

Dagegen kann der Walross-Operator an einer beliebigen Stelle in Ihrem
Code stehen. Das mag für Sie beim Schreiben ein Vorteil sein, der
Lesbarkeit ist das aber abträglich. Wenn Sie den Walross-Operator
verwenden, achten Sie deshalb auf die Nachvollziehbarkeit Ihres Codes.

\end{tcolorbox}

\subsection{Benennung von Variablen}\label{benennung-von-variablen}

Für die Benennung von Variablen gibt es (meist) nur wenige Vorgaben.
Trotzdem ist es besser, einen langen, aber ausführlichen Variablennamen
zu vergeben, als einen kurzen, der sich schnell schreiben lässt. Denn
Programmcode wird deutlich häufiger gelesen als geschrieben. Können Sie
sich erinnern? Welcher Wert ist in der Variablen \texttt{Var\_3}
gespeichert, und welche Werte sind in \texttt{variable1} und \texttt{a}
gespeichert? Es reicht schon, wenn Sie sich an den richtigen Datentyp
erinnern können.

Falls Sie sich nicht erinnern können, dann ist dieses Beispiel gelungen:
Die Namensgebung dieser Variablen ist alles andere als gut. Die
Auflösung steht im folgenden Aufklapper.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-lösungvariablen}: Auflösung Variablen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-lösungvariablen} 

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(var\_3, }\BuiltInTok{type}\NormalTok{(var\_3))}
\BuiltInTok{print}\NormalTok{(variable1, }\BuiltInTok{type}\NormalTok{(variable1))}
\BuiltInTok{print}\NormalTok{(a, }\BuiltInTok{type}\NormalTok{(a))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True <class 'bool'>
15 <class 'int'>
67.0 <class 'str'>
\end{verbatim}

\end{tcolorbox}

Deshalb empfiehlt es sich ``sprechende'', das heißt selbsterklärende,
Variablennamen zu vergeben. Unter selbsterklärenden Variablennamen
versteht sich, dass der Variablenname den Inhalt der Variable
beschreibt. Wird bspw. in einer Variable der Studienabschluss
gespeichert, so kann diese mit \texttt{academic\_degree} oder
\texttt{studienabschluss} bezeichnet werden. Werden Daten aus
verschiedenen Jahren verarbeitet, kann das Jahr zu besseren
Unterscheidbarkeit in den Variablennamen einfließen, etwa:
\texttt{academic\_degree\_2023} oder \texttt{studienabschluss2024}. Dies
verbessert die Lesbarkeit des Codes und vereinfacht die Benutzung der
Variable. Mehr Informationen finden sich in
\href{https://de.wikipedia.org/wiki/Variable_(Programmierung)\#Namenswahl}{diesem
Wikipedia Abschnitt}.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-warning-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame, coltitle=black, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Warning \ref*{wrn-schlüsselwörter}: Schlüsselwörter und Funktionsnamen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutwrn{wrn-schlüsselwörter} 

In Python reservierte Schlüsselwörter und Funktionsnamen sind
ungeeignete Variablennamen. Während Python die Wertzuweisung zu
Schlüsselwörtern wie \texttt{True} oder \texttt{break} mit einem
Syntaxfehler quittiert, lassen sich Funktionsnamen neue Werte zuweisen,
beispielsweise mit \texttt{print\ =\ 6}. Wenn Sie die Funktion print
dann aufrufen, funktioniert diese natürlich nicht mehr. In diesem Fall
müssen Sie die Zuweisung aus dem Skript entfernen und Python neu
starten.

Folgende Schlüsselwörter gibt es in Python:

\begin{verbatim}
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield
await      else       import     pass       True
break      except     in         raise      class
False      finally    is         return     None
\end{verbatim}

\end{tcolorbox}

\section{Aufgaben Variablen}\label{aufgaben-variablen}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Schreiben Sie ein Skript, welches eine gegebene Zeit 𝗍 in Sekunden in
  die Anzahl Tage, Stunden, Minuten und Sekunden aufteilt und diese
  Aufteilung ausgibt.\\
  Berechnen Sie die Aufteilung für folgende Zeiten:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii})}
  \item
    79222 s
  \item
    90061 s
  \item
    300000 s
  \end{enumerate}
\item
  Die Position eines Fahrzeugs zur Zeit \(t\), welches konstant mit der
  Beschleunigung \(a\) beschleunigt, ist gegeben durch:
\end{enumerate}

\[
x(t) = x_0 + v_0 \cdot t + \frac{1}{2} \cdot a t^2
\]

Dabei ist \(x_0\) die Anfangsposition und \(v_0\) die
Anfangsgeschwindigkeit. Erstellen Sie Variablen für \(x_0\), \(v_0\) und
\(a\) und weisen Sie ihnen Werte zu. Da die Variablen nur Werte, aber
keine Einheiten abbilden, überlegen Sie sich die ggf. notwendigen
Umrechnungen. Folgende Werte können sie als Beispiel verwenden:

\[
x_0 = 10 \, km \,\,\,v_0 = 50 \frac{km}{h} \,\,\,a = 0.1 \frac{m}{s^2}
\]

Erzeugen Sie eine Variable für den Zeitpunkt \(t\), z. B.:
\(t = 10 \, min\). Berechnen Sie mit obiger Gleichung und mit Hilfe der
Variablen die Position \(x(t)\). Geben Sie nicht nur den Wert von
\(x(t)\) in Kilometer aus, sondern betten ihn in einen ganzen
Antwortsatz (einschließlich Einheiten) ein.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-lösungvariablen}: Musterlösung Aufgaben Variablen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-lösungvariablen} 

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 1.}
\KeywordTok{def}\NormalTok{ zeit\_aufteilung(t):}
\NormalTok{    tage }\OperatorTok{=}\NormalTok{ t }\OperatorTok{//}\NormalTok{ (}\DecValTok{24}\OperatorTok{*}\DecValTok{3600}\NormalTok{)}
\NormalTok{    t }\OperatorTok{=}\NormalTok{ t }\OperatorTok{\%}\NormalTok{ (}\DecValTok{24}\OperatorTok{*}\DecValTok{3600}\NormalTok{)}
\NormalTok{    stunden }\OperatorTok{=}\NormalTok{ t}\OperatorTok{//}\DecValTok{3600}
\NormalTok{    t }\OperatorTok{=}\NormalTok{ t}\OperatorTok{\%}\DecValTok{3600}
\NormalTok{    minuten }\OperatorTok{=}\NormalTok{ t}\OperatorTok{//}\DecValTok{60}
\NormalTok{    sekunden }\OperatorTok{=}\NormalTok{ t}\OperatorTok{\%}\DecValTok{60}
    
    \ControlFlowTok{return}\NormalTok{ tage, stunden, minuten, sekunden}

\CommentTok{\# hier die zu prüfenden Werte a, b, c eintragen}
\NormalTok{zeit\_gegeben }\OperatorTok{=} \DecValTok{79222}

\NormalTok{tage, stunden, minuten, sekunden }\OperatorTok{=}\NormalTok{ zeit\_aufteilung(zeit\_gegeben)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{zeit\_gegeben}\SpecialCharTok{\}}\SpecialStringTok{ Sekunden entsprechen }\SpecialCharTok{\{}\NormalTok{tage}\SpecialCharTok{\}}\SpecialStringTok{ Tagen, }\SpecialCharTok{\{}\NormalTok{stunden}\SpecialCharTok{\}}\SpecialStringTok{ Stunden, }\SpecialCharTok{\{}\NormalTok{minuten}\SpecialCharTok{\}}\SpecialStringTok{ Minuten und }\SpecialCharTok{\{}\NormalTok{sekunden}\SpecialCharTok{\}}\SpecialStringTok{ Sekunden"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
79222 Sekunden entsprechen 0 Tagen, 22 Stunden, 0 Minuten und 22 Sekunden
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 2.}
\CommentTok{\# Ausgangswerte inkl. Umrechnungen}
\NormalTok{x0 }\OperatorTok{=} \DecValTok{10}\OperatorTok{*}\DecValTok{1000} \CommentTok{\# Kilometer in Metern}
\NormalTok{v0 }\OperatorTok{=} \DecValTok{50}\OperatorTok{/}\FloatTok{3.6} \CommentTok{\# km/h in m/s}
\NormalTok{a }\OperatorTok{=} \FloatTok{0.1}
\NormalTok{t }\OperatorTok{=} \DecValTok{10}\OperatorTok{*}\DecValTok{60} \CommentTok{\# Minuten in Sekunden}

\NormalTok{x }\OperatorTok{=}\NormalTok{ x0 }\OperatorTok{+}\NormalTok{ v0 }\OperatorTok{*}\NormalTok{ t }\OperatorTok{+} \FloatTok{0.5} \OperatorTok{*}\NormalTok{ a }\OperatorTok{*}\NormalTok{ t }\OperatorTok{**}\DecValTok{2}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die berechnete Position des Fahrzeugs zur Zeit t = }\SpecialCharTok{\{}\NormalTok{(t}\OperatorTok{/}\DecValTok{60}\NormalTok{)}\SpecialCharTok{:.0f\}}\SpecialStringTok{ Minuten beträgt }\SpecialCharTok{\{}\NormalTok{(x}\OperatorTok{/}\DecValTok{1000}\NormalTok{)}\SpecialCharTok{:.2f\}}\SpecialStringTok{ Kilometer."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die berechnete Position des Fahrzeugs zur Zeit t = 10 Minuten beträgt 36.33 Kilometer.
\end{verbatim}

Musterlösung von Marc Sönnecken

\end{tcolorbox}

{[}@Arnold-2023-datentypen-und-grundlagen;
@Arnold-2023-funktionen-module-dateien{]}

\chapter{Funktionen: Grundlagen}\label{funktionen-grundlagen}

Funktionen sind Unterprogramme, die Programmanweisungen bündeln, damit
Programmteile mehrfach verwendet werden können. Auf diese Weise kann ein
Programm schneller geschrieben werden und ist auch leichter lesbar.
Python bringt, wie Sie der
\href{https://docs.python.org/3/library/functions.html}{Dokumentation}
entnehmen können, eine überschaubare Anzahl von grundlegenden Funktionen
mit. In diesem Kapitel wird die allgemeine Verwendung der in Python
enthaltenen Funktionen vermittelt.

Python wird dynamisch weiterentwickelt: Regelmäßig erscheinen neue
Versionen mit neuen Eigenschaften. In diesem Kapitel wird deshalb mit
einer Reihe von Tipps auch vermittelt, wie die Dokumentation von Python
zu lesen ist. Dies erfolgt auch in Hinblick auf die Möglichkeit, Python
umfangreich durch Module zu erweitern. So haben beispielsweise die
Funktionen des Moduls Pandas nicht selten dutzende dokumentierte
Parameter.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-dokumentation}: Dokumentation}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-dokumentation} 

Der wichtigste Tipp zuerst: \textbf{Benutzen Sie die Dokumentation!}
Auch wenn Sie eine Funktion kennen: Vergewissern Sie sich regelmäßig,
dass Sie noch auf dem neuesten Stand sind. Auf diese Weise erhalten Sie
einen vollständigen Überblick über standardmäßig gesetzte und optional
verfügbare Parameter. Außerdem erkennen Sie Änderungen in der
Programmausführung und vermeiden so unerwartete Fehler.

\begin{figure}[H]

\begin{minipage}{0.50\linewidth}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/w-python/skript/00-bilder/added-in-pyhton.png}}

}

\subcaption{Neuerung in Python}

\end{figure}%

\end{minipage}%
%
\begin{minipage}{0.50\linewidth}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/w-python/skript/00-bilder/deprecated-in-python.png}}

}

\subcaption{Abkündigung in Python}

\end{figure}%

\end{minipage}%

\end{figure}%

Achten Sie auf die korrekte Version der Dokumentation.

\begin{figure}[H]

{\centering \includegraphics[width=0.8\linewidth,height=\textheight,keepaspectratio]{books/w-python/skript/00-bilder/python-documentation-version.png}

}

\caption{Versionsauswahl der Dokumentation}

\end{figure}%

\end{tcolorbox}

\section{Funktionen und Methoden}\label{funktionen-und-methoden}

In Python gibt es zwei Arten von Funktionen: Funktionen und Methoden.

\subsection{Funktionen}\label{funktionen}

Funktionen können Objekte unabhängig von ihrem Datentyp übergeben
werden. Funktionen werden über ihren Funktionsnamen gefolgt von runden
Klammern \texttt{()} aufgerufen. Ein Beispiel ist die Funktion
\texttt{print()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var\_str }\OperatorTok{=} \StringTok{\textquotesingle{}ABC\textquotesingle{}}
\NormalTok{var\_int }\OperatorTok{=} \DecValTok{26}
\NormalTok{var\_bool }\OperatorTok{=} \VariableTok{True}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Die Variable var\_1 hat den Typ"}\NormalTok{, }\BuiltInTok{type}\NormalTok{(var\_str))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Die Variable var\_2 hat den Typ"}\NormalTok{, }\BuiltInTok{type}\NormalTok{(var\_int))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Die Variable var\_3 hat den Typ"}\NormalTok{, }\BuiltInTok{type}\NormalTok{(var\_bool))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Variable var_1 hat den Typ <class 'str'>
Die Variable var_2 hat den Typ <class 'int'>
Die Variable var_3 hat den Typ <class 'bool'>
\end{verbatim}

Funktionen müssen immer einen Wert zurückgeben. Wenn Funktionen keinen
Wert zurückgeben können oder sollen, wird der Wert \texttt{None}
zurückgegeben, der nicht existente Werte kennzeichnet.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res }\OperatorTok{=} \BuiltInTok{print}\NormalTok{( }\DecValTok{15}\NormalTok{ )}
\BuiltInTok{print}\NormalTok{(res)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
15
None
\end{verbatim}

Funktionen können verschachtelt und so von innen nach außen nacheinander
ausgeführt werden. In diesem Code-Beispiel wird zunächst die Summe
zweier Zahlen und anschließend der Wahrheitswert des Ergebnisses
gebildet. Dieser wird anschließend mit der Funktion \texttt{print()}
ausgegeben.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{bool}\NormalTok{(}\BuiltInTok{sum}\NormalTok{([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{])))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

\subsection{Methoden}\label{methoden}

Methoden sind eine Besonderheit objektorientierter Programmiersprachen.
Im vorherigen Kapitel wurde erläutert, dass in Python Objekte zu einem
bestimmten Typ bzw. zu einer Klasse gehören und abhängig von den in
ihnen gespeicherten Werte einen passenden Datentyp erhalten. Methoden
sind Funktionen, die zu einer bestimmten Klasse gehören und nur für
Objekte dieser Klasse verfügbar sind. Methoden können auch für mehrere
Klassen definiert sein. Methoden werden getrennt durch einen Punkt
\texttt{.} hinter Objekten mit ihrem Namen aufgerufen:
\texttt{variable.methode} bzw. \texttt{(wert).methode}. Beispielsweise
sind \texttt{.upper()}, \texttt{.lower()} und \texttt{.title()} für
Zeichenfolgen definierte Methoden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{toller\_text }\OperatorTok{=} \StringTok{"Python 3.12 ist großartig."}

\BuiltInTok{print}\NormalTok{(toller\_text.upper())}
\BuiltInTok{print}\NormalTok{(toller\_text.lower())}
\BuiltInTok{print}\NormalTok{(toller\_text.title(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{((}\StringTok{"Mit in Klammern gesetzten Werten klappt es auch."}\NormalTok{).upper())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
PYTHON 3.12 IST GROSSARTIG.
python 3.12 ist großartig.
Python 3.12 Ist Großartig. 

MIT IN KLAMMERN GESETZTEN WERTEN KLAPPT ES AUCH.
\end{verbatim}

Für Objekte mit einem unpassenden Datentyp sind Methoden wie
\texttt{.lower()} nicht verfügbar.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{((}\DecValTok{1}\NormalTok{).upper())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
'int' object has no attribute 'upper'
\end{verbatim}

Methoden können verkettet und so nacheinander ausgeführt werden. In
diesem Beispiel wird die Zeichenfolge `Katze' klein geschrieben, dann
die Häufigkeit des Buchstabens `k' gezählt.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Katze\textquotesingle{}}\NormalTok{.lower().count(}\StringTok{\textquotesingle{}k\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

Welche Methoden für ein Objekt verfügbar sind, kann mit der Funktion
\texttt{dir(objekt)} bestimmt werden. Die Ausgabe der Funktion ist aber
häufig sehr umfangreich. Um die relevanten Einträge auszuwählen, muss
die Ausgabe gefiltert werden. Notwendig ist das aber nicht -
Interessierte schauen in Note~\ref{nte-methods}.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-methods}: Methoden eines Objekts bestimmen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-methods} 

Mit der Funktion \texttt{dir(objekt)} können die verfügbaren Methoden
eines Objekts ausgegeben werden. Dabei werden jedoch auch die Attribute
und die Methoden der Klasse des Objekts ausgegeben, sodass die Ausgabe
oft sehr umfangreich ist. Zum Beispiel für die Ganzzahl 1:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{dir}\NormalTok{(}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__getstate__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_count', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'is_integer', 'numerator', 'real', 'to_bytes']
\end{verbatim}

Um die Ausgabe auf Methoden einzugrenzen, kann folgende Funktion in
Listenschreibweise verwendet werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{objekt }\OperatorTok{=} \DecValTok{1}

\NormalTok{attribute }\OperatorTok{=}\NormalTok{ [attr }\ControlFlowTok{for}\NormalTok{ attr }\KeywordTok{in} \BuiltInTok{dir}\NormalTok{(objekt) }\ControlFlowTok{if} \BuiltInTok{callable}\NormalTok{ (}\BuiltInTok{getattr}\NormalTok{(objekt, attr))]}
\BuiltInTok{print}\NormalTok{(attribute)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__getstate__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_count', 'bit_length', 'conjugate', 'from_bytes', 'is_integer', 'to_bytes']
\end{verbatim}

Mit doppelten Unterstrichen umschlossene Methoden sind für die Klasse
definierte Methoden. Folgende Funktion entfernt Methoden mit doppelten
Unterstrichen aus der Ausgabe:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{objekt }\OperatorTok{=} \DecValTok{1}

\NormalTok{attribute }\OperatorTok{=}\NormalTok{ [attr }\ControlFlowTok{for}\NormalTok{ attr }\KeywordTok{in} \BuiltInTok{dir}\NormalTok{(objekt) }\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{callable}\NormalTok{(}\BuiltInTok{getattr}\NormalTok{(objekt, attr)) }\KeywordTok{and} \KeywordTok{not}\NormalTok{ attr.startswith(}\StringTok{\textquotesingle{}\_\_\textquotesingle{}}\NormalTok{))]}
\BuiltInTok{print}\NormalTok{(attribute)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['as_integer_ratio', 'bit_count', 'bit_length', 'conjugate', 'from_bytes', 'is_integer', 'to_bytes']
\end{verbatim}

Im Fall einer Ganzzahl können Methoden (zur Abgrenzung von
Gleitkommazahlen in umschließenden Klammern) wie folgt aufgerufen
werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\DecValTok{1}\NormalTok{).as\_integer\_ratio()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(1, 1)
\end{verbatim}

Die Methoden des Objekts `toller\_text':

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{objekt }\OperatorTok{=}\NormalTok{ toller\_text}

\NormalTok{attribute }\OperatorTok{=}\NormalTok{ [attr }\ControlFlowTok{for}\NormalTok{ attr }\KeywordTok{in} \BuiltInTok{dir}\NormalTok{(objekt) }\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{callable}\NormalTok{(}\BuiltInTok{getattr}\NormalTok{(objekt, attr)) }\KeywordTok{and} \KeywordTok{not}\NormalTok{ attr.startswith(}\StringTok{\textquotesingle{}\_\_\textquotesingle{}}\NormalTok{))]}
\BuiltInTok{print}\NormalTok{(attribute)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'removeprefix', 'removesuffix', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']
\end{verbatim}

\end{tcolorbox}

\section{Parameter}\label{parameter}

Vielen Funktionen und Methoden können getrennt durch Kommata mehrere
Parameter übergeben werden. Die Werte, die als Parameter übergeben
werden, werden Argumente genannt
(\href{https://docs.python.org/3/faq/programming.html\#faq-argument-vs-parameter}{Python-Dokumentation}).
\href{https://docs.python.org/3/glossary.html\#term-parameter}{Parameter}
steuern die Programmausführung. Die für die Funktion \texttt{print()}
verfügbaren Parameter stehen in der
\href{https://docs.python.org/3/library/functions.html\#print}{Dokumentation
der Funktion}:

\begin{verbatim}
print(*objects, sep=' ', end='\n', file=None, flush=False)
\end{verbatim}

\texttt{*objects}, \texttt{sep}, \texttt{end}, \texttt{file} und
\texttt{flush} sind die Parameter der Funktion \texttt{print()}.

\begin{itemize}
\item
  Parameter ohne Gleichheitszeichen \texttt{=} müssen beim Funktions-
  bzw. Methodenaufruf übergeben werden. Parameter mit Gleichheitszeichen
  \texttt{=} können beim Aufruf übergeben werden, es handelt sich um
  optionale Parameter.
\item
  Die Werte hinter dem Gleichheitszeichen zeigen die Standardwerte
  (default value) der Parameter an. Diese werden verwendet, wenn ein
  Argument nicht explizit beim Aufruf übergeben wird.
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-standardwerte}: Ausnahmen bei Standardwerten}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-standardwerte} 

Bei den in der Funktionsdefinition genannten Werten handelt es sich
nicht immer um die tatsächlichen Standardwerte. Es empfiehlt sich
deshalb, wenn eine Funktion verwendet wird, die Beschreibung der
Parameter zu lesen.

Einige Funktionen verwenden das Schlüsselwort \texttt{None} zur
Kennzeichnung des Standardwerts. Der Wert \texttt{None} dient dabei als
Platzhalter. Ein Beispiel ist die NumPy-Funktion
\href{https://numpy.org/doc/stable/reference/generated/numpy.loadtxt.html}{numpy.loadtxt()}.

\begin{verbatim}
numpy.loadtxt(fname, dtype=<class 'float'>, comments='#', delimiter=None, converters=None, /
              skiprows=0, usecols=None, unpack=False, ndmin=0, encoding=None, max_rows=None, /
              *, quotechar=None, like=None)
\end{verbatim}

\begin{itemize}
\item
  Für den Parameter \texttt{delimiter} ist als Standardwert das
  Schlüsselwort \texttt{None} eingetragen. Wie der Funktionsbeschreibung
  zu entnehmen ist, ist der Standartwert tatsächlich das Leerzeichen:
  ``The default is whitespace.''
\item
  Auch der Parameter \texttt{usecols} hat den Standarwert \texttt{None}:
  ``The default, None, results in all columns being read.''
\end{itemize}

Ein weiteres Beispiel ist die Funktion
\href{https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html\#pandas.read_csv}{pandas.read\_csv()}.
Einige Argumente haben den Standardwert
\texttt{\textless{}no\_default\textgreater{}}. (Im Folgenden werden nur
ausgewählte Parameter gezeigt).

\begin{verbatim}
pandas.read_csv(sep=<no_default>, verbose=<no_default>)
\end{verbatim}

Aus der Beschreibung können die tatsächlichen Standardwerte abgelesen
werden:\\
sep : str, default `,'\\
verbose : bool, default False

\end{tcolorbox}

\begin{itemize}
\tightlist
\item
  Argumente können in Python entweder als positionales Argument
  übergeben werden. Das heißt, Python erwartet Argumente in einer
  feststehenden Reihenfolge entsprechend der Parameter der
  Funktionsdefinition. Alternativ können Argumente als Schlüsselwort
  übergeben werden, die Zuordnung von Eingaben erfolgt über den Namen
  des Parameters. Standardmäßig können Argumente positional oder per
  Schlüsselwort übergeben werden. Abweichungen davon werden durch die
  Symbole \texttt{*} und \texttt{/} gekennzeichnet (siehe folgenden
  Tipp).
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-sonderzeichen}: Positionale und Schlüsselwortargumente, *args und **kwargs}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-sonderzeichen} 

Die Symbole \texttt{*} und \texttt{/} zeigen an, welche Parameter
positional und welche per Schlüsselwort übergeben werden können bzw.
müssen.

\begin{longtable}[]{@{}
  >{\centering\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\centering\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\centering\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\centering
Linke Seite
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Trennzeichen
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Rechte Seite
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
nur positionale Argumente & / & positionale oder
Schlüsselwortargumente \\
positionale oder Schlüsselwortargumente & * & nur
Schlüsselwortargumente \\
\end{longtable}

(\url{https://realpython.com/python-asterisk-and-slash-special-parameters/})

~

Ein Beispiel für das Trennzeichen \texttt{*} ist die Funktion
\texttt{glob} aus dem gleichnamigen Modul. Der Parameter
\texttt{pathname} kann positional (an erster Stelle) oder als
Schlüsselwort übergeben werden. Die übrigen Parameter müssen als
Schlüsselwortargumente übergeben werden.

\begin{verbatim}
glob.glob(pathname, *, root_dir=None, dir_fd=None, recursive=False, include_hidden=False)
\end{verbatim}

Beide Steuerzeichen können innerhalb einer Funktionsdefinition
vorkommen, allerdings nur in der Reihenfolge \texttt{/} und \texttt{*}.
Im umgekehrten Fall wäre es unmöglich, Argumente zu übergeben. Ein
Beispiel ist die Funktion \texttt{sorted}. Der erste Parameter muss
positional übergeben werden, die Parameter \texttt{key} und
\texttt{reverse} müssen als Schlüsselworte übergeben werden.

\begin{verbatim}
sorted(iterable, /, *, key=None, reverse=False)
\end{verbatim}

\begin{quote}
\textbf{Ausnahmen}

Einige Funktionen weichen von der Systematik ab, beispielsweise die
Funktionen \texttt{min()} und \texttt{max()}. Diese sind (u. a.) in der
Form definiert:

\begin{verbatim}
min(iterable, *, key=None)
max(iterable, *, key=None)
\end{verbatim}

Beide Funktionen akzeptieren den Parameter \texttt{iterable} aber nicht
als Schlüsselwort.
\end{quote}

Vielen Funktionen können beliebig viele Argumente positional oder als
Schlüsselwort übergeben werden. Im Allgemeinen wird dies durch die
Schlüsselwörter \texttt{*args} (positionale Argumente) und
\texttt{**kwargs} (key word arguments, Schlüsselwortargumente)
angezeigt. Der Unterschied wird durch das eine bzw. die beiden Sternchen
markiert, die Schlüsselwörter selbst sind austauschbar (wie bei der
Funktion \texttt{print(*objects)}). Das Schlüsselwort \texttt{*args}
entspricht zugleich dem Symbol \texttt{*} in der Funktionsdefinition,
d.~h. rechts davon dürfen nur Schlüsselwortargumente stehen. Weitere
Informationen dazu finden Sie
\href{https://book.pythontips.com/en/latest/args_and_kwargs.html}{hier}.

\end{tcolorbox}

In der Funktionsdefinition von \texttt{print()} ist \texttt{*objects}
also ein positionaler Parameter (dieser steht immer an erster Stelle),
der keinen Standardwert hat und dem beliebig viele Argumente übergeben
werden können (n Eingaben stehen an den ersten n-Stellen). Die weiteren
Parameter der Funktion \texttt{print()} sind optional und müssen als
Schlüsselwort übergeben werden.

\section{Aufgaben Funktionen}\label{aufgaben-funktionen}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Richtig oder falsch: Methoden stehen abhängig vom Datentyp eines Werts
  oder eines Objekts zur Verfügung.
\item
  Geben Sie die drei Werte 1, 2 und 3 mit \texttt{print()} aus.
  Parametrisieren Sie die Funktion so, dass ihre Ausgabe wie folgt
  aussieht:
\end{enumerate}

\begin{verbatim}
1_x_2_x_3
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Schlagen Sie in der Dokumentation die Funktion
  \href{https://docs.python.org/3/library/functions.html\#bool}{bool()}
  nach.
\end{enumerate}

\begin{itemize}
\item
  Welche Parameter nimmt die Funktion entgegen und welche davon sind
  optional?
\item
  Welche Argumente werden positional und welche als Schlüsselübergeben?
  Ist die Art der Übergabe wählbar oder festgelegt?
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Lösungen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Aufgabe 1: richtig

Aufgabe 2

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, sep }\OperatorTok{=} \StringTok{"\_x\_"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Aufgabe 3: Die Funktion bool() hat ein optionales Argument object mit
dem Standardwert False. Das Argument muss positional übergeben werden.

\end{tcolorbox}

\chapter{Flusskontrolle}\label{flusskontrolle}

Die Flusskontrolle ermöglicht es, die Ausführung von Programmteilen zu
steuern. Anweisungen können übersprungen oder mehrfach ausgeführt
werden.

\subsection{Abzweigungen}\label{abzweigungen}

Abzweigungen ermöglichen eine Fallunterscheidung, bei der abhängig von
einer oder mehreren Bedingungen verschiedene Teile des Skripts
ausgeführt werden.

In Python werden Abzweigungen mit dem Schlüsselwort \texttt{if}
eingeleitet. Dieses wird von der Abzweigbedingung gefolgt und mit einem
Doppelpunkt \texttt{:} abgeschlossen. Falls die Abzweigbedingung wahr
ist, wird der eingerückte Anweisungsblock ausgeführt.

\begin{verbatim}
if Bedingung:
    Anweisungsblock
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beispiel: Zahl kleiner als ein Schwellwert}

\NormalTok{a }\OperatorTok{=} \DecValTok{7}
\ControlFlowTok{if}\NormalTok{ a }\OperatorTok{\textless{}} \DecValTok{10}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{( }\StringTok{\textquotesingle{}Die Zahl\textquotesingle{}}\NormalTok{, a, }\StringTok{\textquotesingle{}ist kleiner als 10.\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Zahl 7 ist kleiner als 10.
\end{verbatim}

Es ist auch möglich einen alternativen Anweisungsblock zu definieren,
welcher ausgeführt wird, wenn die Bedingung falsch ist. Dieser wird mit
dem \texttt{else} Schlüsselwort umgesetzt.

\begin{verbatim}
if Bedingung:
    # Bedingung ist wahr
    Anweisungsblock
else:
    # Bedingung ist falsch
    Anweisungsblock
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beispiel: Zahl kleiner als ein Schwellwert mit alternativer Ausgabe}

\NormalTok{a }\OperatorTok{=} \DecValTok{13}
\ControlFlowTok{if}\NormalTok{ a }\OperatorTok{\textless{}} \DecValTok{10}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{( }\StringTok{\textquotesingle{}Die Zahl\textquotesingle{}}\NormalTok{, a, }\StringTok{\textquotesingle{}ist kleiner als 10.\textquotesingle{}}\NormalTok{)}
\ControlFlowTok{else}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{( }\StringTok{\textquotesingle{}Die Zahl\textquotesingle{}}\NormalTok{, a, }\StringTok{\textquotesingle{}ist nicht kleiner als 10.\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Zahl 13 ist nicht kleiner als 10.
\end{verbatim}

Es können auch mehrere Bedingungen übergeben werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beispiel: Zahl im Wertebereich zwischen 10 und 20}

\NormalTok{a }\OperatorTok{=} \DecValTok{1}
\ControlFlowTok{if}\NormalTok{ a }\OperatorTok{\textless{}} \DecValTok{20} \KeywordTok{and}\NormalTok{ a }\OperatorTok{\textgreater{}} \DecValTok{10}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{( }\StringTok{\textquotesingle{}Die Zahl\textquotesingle{}}\NormalTok{, a, }\StringTok{\textquotesingle{}liegt zwischen 10 und 20.\textquotesingle{}}\NormalTok{)}
\ControlFlowTok{else}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{( }\StringTok{\textquotesingle{}Die Zahl\textquotesingle{}}\NormalTok{, a, }\StringTok{\textquotesingle{}liegt nicht zwischen 10 und 20.\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Zahl 1 liegt nicht zwischen 10 und 20.
\end{verbatim}

Schließlich können mehrere alternative Bedingungen geprüft werden. Dies
ist zum einen durch das Verschachteln von Abzweigungen möglich.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beispiel: Zahl im Wertebereich zwischen 10 und 20 mit verschachtelten Abzweigungen}

\NormalTok{a }\OperatorTok{=} \DecValTok{12}
\ControlFlowTok{if}\NormalTok{ a }\OperatorTok{\textgreater{}} \DecValTok{10}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{( }\StringTok{\textquotesingle{}Die Zahl\textquotesingle{}}\NormalTok{, a, }\StringTok{\textquotesingle{}ist größer als 10.\textquotesingle{}}\NormalTok{ )}
    
    \ControlFlowTok{if}\NormalTok{ a }\OperatorTok{\textless{}} \DecValTok{20}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{( }\StringTok{\textquotesingle{}Die Zahl\textquotesingle{}}\NormalTok{, a, }\StringTok{\textquotesingle{}ist kleiner als 20.\textquotesingle{}}\NormalTok{ )}
        \BuiltInTok{print}\NormalTok{( }\StringTok{\textquotesingle{}Damit liegt die Zahl zwischen 10 und 20.\textquotesingle{}}\NormalTok{)}
    \ControlFlowTok{else}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{( }\StringTok{\textquotesingle{}Die Zahl\textquotesingle{}}\NormalTok{, a, }\StringTok{\textquotesingle{}ist größer als 20 und liegt nicht im gesuchten Wertebereich.\textquotesingle{}}\NormalTok{ )}
\ControlFlowTok{else}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{( }\StringTok{\textquotesingle{}Die Zahl\textquotesingle{}}\NormalTok{, a, }\StringTok{\textquotesingle{}ist kleiner als 10 und liegt nicht im gesuchten Wertebereich.\textquotesingle{}}\NormalTok{ )}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Zahl 12 ist größer als 10.
Die Zahl 12 ist kleiner als 20.
Damit liegt die Zahl zwischen 10 und 20.
\end{verbatim}

Zum anderen ist dies mit dem Schlüsselwort \texttt{elif} möglich.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beispiel: Zahl im Wertebereich zwischen 10 und 20 mit elif}

\NormalTok{a }\OperatorTok{=} \DecValTok{112}
\ControlFlowTok{if}\NormalTok{ a }\OperatorTok{\textless{}} \DecValTok{20} \KeywordTok{and}\NormalTok{ a }\OperatorTok{\textgreater{}} \DecValTok{10}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Die Zahl\textquotesingle{}}\NormalTok{, a, }\StringTok{\textquotesingle{}liegt zwischen 10 und 20.\textquotesingle{}}\NormalTok{)}
\ControlFlowTok{elif}\NormalTok{ a }\OperatorTok{\textless{}} \DecValTok{10}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Die Zahl\textquotesingle{}}\NormalTok{, a, }\StringTok{\textquotesingle{}ist kleiner als 10 und liegt nicht im gesuchten Wertebereich.\textquotesingle{}}\NormalTok{ )}
\ControlFlowTok{elif}\NormalTok{ a }\OperatorTok{\textgreater{}} \DecValTok{20} \KeywordTok{and}\NormalTok{ a }\OperatorTok{\textless{}=} \DecValTok{100}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Die Zahl\textquotesingle{}}\NormalTok{, a, }\StringTok{\textquotesingle{}ist größer als 20, aber nicht größer als 100.\textquotesingle{}}\NormalTok{)}
\ControlFlowTok{elif}\NormalTok{ a }\OperatorTok{\textgreater{}} \DecValTok{20} \KeywordTok{and}\NormalTok{ a }\OperatorTok{\textless{}=} \DecValTok{1000}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Die Zahl\textquotesingle{}}\NormalTok{, a, }\StringTok{\textquotesingle{}ist größer als 20, aber nicht größer als 1000.\textquotesingle{}}\NormalTok{)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Die Zahl\textquotesingle{}}\NormalTok{, a, }\StringTok{\textquotesingle{}liegt nicht zwischen 10 und 20 und ist größer als 1000.\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Zahl 112 ist größer als 20, aber nicht größer als 1000.
\end{verbatim}

\subsection{Schleifen}\label{schleifen}

Schleifen ermöglichen es, Anweisungen zu wiederholen. In Python können
\texttt{while}- und \texttt{for}-Schleifen definiert werden. Beide
benötigen:

\begin{itemize}
\item
  einen \textbf{Schleifenkopf}, welcher die Ausführung des
  Anweisungsblocks steuert, und
\item
  einen \textbf{Anweisungsblock}, also eine Gruppe von Anweisungen,
  welche bei jedem Schleifendurchlauf ausgeführt werden.
\end{itemize}

Die \texttt{while}-Schleife kommt mit nur einer Bedingung im
Schleifenkopf aus und ist die allgemeinere von beiden. Jede
\texttt{for}-Schleife kann zu einer \texttt{while}-Schleife
umgeschrieben werden (indem ein Zähler in den Anweisungsblock integriert
wird.) Welcher der beiden Typen verwendet wird, hängt von der jeweiligen
Aufgabe ab.

\subsubsection{while-Schleifen}\label{while-schleifen}

Eine \texttt{while}-Schleife führt den Anweisungsblock immer wieder aus,
solange die Ausführbedingung wahr ist. Die Schleife wird mit dem
Schlüsselwort \texttt{while} eingeleitet, gefolgt von der
Ausführbedingung. Dieser Schleifenkopf wird mit einem Doppelpunkt
\texttt{:} abgeschlossen. Darunter wird der eingerückte Anweisungsblock
definiert.

\begin{verbatim}
while Bedingung:
    Anweisungsblock
\end{verbatim}

Beim Beginn der Schleife und nach jedem Durchlauf wird die Bedingung
geprüft. Ist sie wahr, so wird der Anweisungsblock ausgeführt, wenn
nicht, ist die Schleife beendet und die nächste Anweisung außerhalb der
Schleife wird ausgeführt.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beispiel: Erhöhen eines Variablenwertes}

\CommentTok{\# Setze Startwert}
\NormalTok{a }\OperatorTok{=} \DecValTok{5}

\CommentTok{\# Definiere Schleife, welche solange ausgeführt }
\CommentTok{\# wird, wie a kleiner als oder gleich 10 ist}
\ControlFlowTok{while}\NormalTok{ a }\OperatorTok{\textless{}=} \DecValTok{10}\NormalTok{:}
    \CommentTok{\# Anweisungsblock der Schleife:}
    
    \CommentTok{\# 1. Ausgabe des aktuellen Werts von a }
    \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}aktueller Wert von a\textquotesingle{}}\NormalTok{, a)}
    
    \CommentTok{\# 2. Erhöhung von a um Eins}
\NormalTok{    a }\OperatorTok{+=} \DecValTok{1}

\CommentTok{\# Ausgabe des Wertes nach der Schleife}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Wert von a nach der Schleife\textquotesingle{}}\NormalTok{, a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
aktueller Wert von a 5
aktueller Wert von a 6
aktueller Wert von a 7
aktueller Wert von a 8
aktueller Wert von a 9
aktueller Wert von a 10
Wert von a nach der Schleife 11
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-endlosschleife} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-endlosschleife}: Endlosschleife}\vspace{3mm}

\texttt{while}-Schleifen führen zu einer Endlosschleife, wenn die
Abbruchbedingung nicht erreicht werden kann. Beispielsweise fehlt in der
folgenden Schleife eine Möglichkeit für die Laufvariable x den Wert 5 zu
erreichen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{1}

\ControlFlowTok{while}\NormalTok{ x }\OperatorTok{\textless{}} \DecValTok{5}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

In diesem Fall können Sie die Programmausführung durch Drücken von
\texttt{Strg}+ \texttt{C} beenden.

\end{minipage}%
\end{tcolorbox}

\subsubsection{for-Schleifen}\label{for-schleifen}

Während die \texttt{while}-Schleife ausgeführt wird, solange eine
Bedingung erfüllt ist, wird die \texttt{for}-Schleife über eine
Laufvariable gesteuert, die eine Sequenz durchläuft. Die Syntax sieht
wie folgt aus:

\begin{verbatim}
for Laufvariable in Sequenz:
  Anweisungsblock
\end{verbatim}

Zur Definition des Schleifenkopfs gehören die beiden Schlüsselworte
\texttt{for} und \texttt{in} und der Kopf wird mit einem Doppelpunkt
\texttt{:} abgeschlossen. Auch hier wird der Anweisungsblock eingerückt.

Die Sequenz wird mit einem range-Objekt erstellt, das mit der Funktion
\texttt{range(start\ =\ 0,\ stop,\ step\ =\ 1)} erzeugt wird.
\texttt{range()} nimmt ganzzahlige Werte als \emph{positionale
Argumente} entgegen und erzeugt Ganzzahlen von \texttt{start} bis
\emph{nicht einschließlich} \texttt{stop} mit der Schrittweite
\texttt{step}. Dabei ist wichtig, dass Python \textbf{exklusiv zählt},
das heißt, Python beginnt standarmäßig bei \texttt{0} zu zählen und der
als Argument \texttt{stop} übergebene Wert wird nicht mitgezählt.

Die Funktion \texttt{range()} gibt ein range-Objekt zurück, das mit
\texttt{print()} nicht unmittelbar die erwartete Ausgabe erzeugt.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# range(start = 1, stop = 5) {-} step wird nicht übergeben, es gilt der Standardwert step = 1}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{), }\BuiltInTok{type}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
range(1, 5) <class 'range'>
\end{verbatim}

Dieses Verhalten wird faule Auswertung
(\href{https://de.wikipedia.org/wiki/Lazy_Evaluation}{lazy evaluation})
genannt: Die Werte des range-Objekts werden erst erzeugt, wenn Sie
benötigt werden. Im Folgenden Code wird das range-Objekt mit einer
Schleife durchlaufen und für jeden Durchlauf der Wert der Laufvariable
\texttt{i} ausgegeben.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{):}
  \BuiltInTok{print}\NormalTok{(i)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
2
3
4
\end{verbatim}

Mit dem Parameter \texttt{step} kann die Schrittweite gesteuert werden.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{3}\NormalTok{):}
  \BuiltInTok{print}\NormalTok{(i)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
4
7
10
13
\end{verbatim}

Nützlich ist die Ausgabe des range-Objekts in eine Liste oder in ein
Tupel, Sammeltypen, die im nächsten Kapitel behandelt werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ausgabe der geraden Zahlen 1{-}10 in eine Liste}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Liste:"}\NormalTok{, }\BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{2}\NormalTok{)))}

\CommentTok{\# Ausgabe der ungeraden Zahlen 1{-}10 in ein Tupel}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Tupel:"}\NormalTok{, }\BuiltInTok{tuple}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{2}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Liste: [2, 4, 6, 8, 10]
Tupel: (1, 3, 5, 7, 9)
\end{verbatim}

\texttt{start} und \texttt{stop} können auch negativ sein. Für
aufsteigende Zahlenfolgen muss \texttt{stop} immer größer als
\texttt{start} sein.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\OperatorTok{{-}}\DecValTok{5}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{):}
  \BuiltInTok{print}\NormalTok{(i)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
-5
-4
-3
-2
\end{verbatim}

\texttt{step} kann ebenfalls negativ sein. Dann wird eine absteigende
Zahlenfolge erzeugt. Für absteigende Zahlenfolgen muss \texttt{start}
immer größer als \texttt{stop} sein.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\OperatorTok{{-}}\DecValTok{5}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{):}
  \BuiltInTok{print}\NormalTok{(i)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
-1
-2
-3
-4
\end{verbatim}

Eine absteigende Zahlenfolge kann auch mit der Funktion
\texttt{reversed(sequenz)} verwendet werden. Das Ergebnis unterscheidet
sich je nach Vorgehensweise bzw. muss für das selbe Ergebnis eine andere
Eingabe vorgenommen werden:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Absteigende Folge, aber start ist größer als stop}
\CommentTok{\# Die Ausgabe bleibt leer}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{0}\NormalTok{)))}

\CommentTok{\# Mit der Funktion reversed geht es}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{list}\NormalTok{(}\BuiltInTok{reversed}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{5}\NormalTok{))))}

\CommentTok{\# Für einer negative Schrittweite muss start größer sein als stop}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{5}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{)))}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{0}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[]
[4, 3, 2, 1, 0]
[]
[5, 4, 3, 2, 1]
\end{verbatim}

\paragraph{Listennotation}\label{listennotation}

Die sogenannte Listennotation ist eine Kurzschreibweise für
for-Schleifen. In Listennotation geschriebene Schleifen müssen in einer
Zeile stehen und haben die folgende Syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{quadratzahlen }\OperatorTok{=}\NormalTok{ [wert }\OperatorTok{**} \DecValTok{2} \ControlFlowTok{for}\NormalTok{ wert }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{0}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{)]}
\BuiltInTok{print}\NormalTok{(quadratzahlen)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[100, 81, 64, 49, 36, 25, 16, 9, 4, 1]
\end{verbatim}

(@matthes2017python, S. 71)

\subsubsection{Die Schlüsselwörter break und
continue}\label{die-schluxfcsselwuxf6rter-break-und-continue}

Manchmal kann es notwendig sein, den Anweisungsblock einer Schleife
vorzeitig zu verlassen. Dafür können die Schlüsselwörter \texttt{break}
und \texttt{continue} benutzt werden. Das Schlüsselwort \texttt{break}
bewirkt, dass die Schleife sofort verlassen wird. Dagegen führt das
Schlüsselwort \texttt{continue} dazu, dass der aktuelle
Schleifendurchlauf beendet und der nächste Durchlauf begonnen wird.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{0}
\ControlFlowTok{while}\NormalTok{ x }\OperatorTok{\textless{}} \DecValTok{10}\NormalTok{:}

\NormalTok{  x }\OperatorTok{+=} \DecValTok{1}

  \CommentTok{\# keine geraden Zahlen ausgeben}
  \ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\NormalTok{:}
    \ControlFlowTok{continue}

  \CommentTok{\# Schleife bei x == 7 beenden}
  \ControlFlowTok{if}\NormalTok{ x }\OperatorTok{==} \DecValTok{7}\NormalTok{:}
    \ControlFlowTok{break}

  \BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
3
5
\end{verbatim}

\subsection{Ausnahmebehandlung}\label{ausnahmebehandlung}

Die Ausnahmebehandlung erlaubt es, Python alternative Anweisungen zu
geben, die beim Auftreten eines Fehlers ausgeführt werden sollen. Dies
ist beispielsweise beim Einlesen von Datensätzen nützlich, um sich die
Ursache von Fehlermeldungen ausgeben zu lassen - eine Technik, die im
\href{https://bausteine-der-datenanalyse.github.io/m-einlesen-strukturierter-datensaetze/output/book/}{Methodenbaustein
Einlesen strukturierter Datensätze} vorgestellt wird.

In Python gibt es zwei Arten von Fehlern. Dies sind erstens
Syntaxfehler, die Python mit einer Fehlermeldung ähnlich wie der
folgenden quitiert. Syntaxfehler werden durch das Schreiben von
syntaktisch korrektem Programmcode behoben.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{1}\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
closing parenthesis '}' does not match opening parenthesis
\end{verbatim}

Die zweite Art von Fehlern sind Ausnahmen (exceptions), die auch bei
syntaktisch korrektem Programmcode auftreten können. Ausnahmen führen
auch zu Fehlermeldungen.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beispiel 1: Division durch Null}
\BuiltInTok{print}\NormalTok{(}\DecValTok{1} \OperatorTok{/} \DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
division by zero
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beispiel 2: undefinierte Variable}
\BuiltInTok{print}\NormalTok{(undefinierte\_variable)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
name 'undefinierte_variable' is not defined
\end{verbatim}

Fehlermeldungen wie diese können in Python mit der
\href{https://docs.python.org/3/tutorial/errors.html}{Ausnahmebehandlung}
abgefangen werden. Diese wird mit dem Schlüsselwort \texttt{try}
eingeleitet, das mit dem Doppeltpunkt \texttt{:} abgeschlossen wird. In
der nächsten Zeile folgt eingrückt der Anweisungblock, der auf Ausnahmen
getestet werden soll. \emph{Hinweis: Der Anweisungsblock wird
tatsächlich ausgeführt, Änderungen an Daten oder Dateien sind also
möglich.} Anschließend wird mit dem Schlüsselwort \texttt{except}, das
von einem Doppelpunkt \texttt{:} und in der nächsten Zeile von einem
eingerückten Anweisungsblock gefolgt wird, festgelegt, was beim
Aufkommen einer Ausnahme passieren soll. Optional kann mit dem
Schlüsselwort \texttt{else} nach dem gleichen Schema ein weiterer
Anweisungsblock definiert werden, der bei einer erfolgreichen Ausführung
des Anweisungsblocks unter \texttt{try} \emph{zusätzlich} ausgeführt
wird. Der allgemeiner Aufbau lautet wie folgt:

\begin{verbatim}
try:
  Anweisungsblock_1 
except:
  Anweisungsblock falls Anweisungblock_1 eine Ausnahme erzeugt
else:
  optionaler Anweisungsblock falls Anweisungsblock_1 keine Ausnahme erzeugt
\end{verbatim}

Mithilfe der Ausnahmebehandlungen können die Elemente angezeigt werden,
die zu einer Fehlermeldung führen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \DecValTok{1}
\NormalTok{b }\OperatorTok{=} \DecValTok{2}

\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  differenz }\OperatorTok{=}\NormalTok{ a }\OperatorTok{{-}}\NormalTok{ b}
\ControlFlowTok{except}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Differenz aus }\SpecialCharTok{\{}\NormalTok{a}\SpecialCharTok{\}}\SpecialStringTok{ und }\SpecialCharTok{\{}\NormalTok{b}\SpecialCharTok{\}}\SpecialStringTok{ konnte nicht gebildet werden."}\NormalTok{)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Differenz aus }\SpecialCharTok{\{}\NormalTok{a}\SpecialCharTok{\}}\SpecialStringTok{ und }\SpecialCharTok{\{}\NormalTok{b}\SpecialCharTok{\}}\SpecialStringTok{ ist }\SpecialCharTok{\{}\NormalTok{differenz}\SpecialCharTok{\}}\SpecialStringTok{."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Differenz aus 1 und 2 ist -1.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \DecValTok{1}
\NormalTok{b }\OperatorTok{=} \StringTok{\textquotesingle{}abc\textquotesingle{}}

\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  differenz }\OperatorTok{=}\NormalTok{ a }\OperatorTok{{-}}\NormalTok{ b}
\ControlFlowTok{except}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Differenz aus }\SpecialCharTok{\{}\NormalTok{a}\SpecialCharTok{\}}\SpecialStringTok{ und }\SpecialCharTok{\{}\NormalTok{b}\SpecialCharTok{\}}\SpecialStringTok{ konnte nicht gebildet werden."}\NormalTok{)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Differenz aus }\SpecialCharTok{\{}\NormalTok{a}\SpecialCharTok{\}}\SpecialStringTok{ und }\SpecialCharTok{\{}\NormalTok{b}\SpecialCharTok{\}}\SpecialStringTok{ ist }\SpecialCharTok{\{}\NormalTok{differenz}\SpecialCharTok{\}}\SpecialStringTok{."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Differenz aus 1 und abc konnte nicht gebildet werden.
\end{verbatim}

Auch ist es möglich, die Fehlermeldung abzufangen und auszugeben. Dafür
wird die Zeile \texttt{except:} wie folgt modifiziert
\texttt{except\ Exception\ as\ error:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \DecValTok{1}
\NormalTok{b }\OperatorTok{=} \StringTok{\textquotesingle{}abc\textquotesingle{}}

\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  differenz }\OperatorTok{=}\NormalTok{ a }\OperatorTok{{-}}\NormalTok{ b}
\ControlFlowTok{except} \PreprocessorTok{Exception} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Differenz aus }\SpecialCharTok{\{}\NormalTok{a}\SpecialCharTok{\}}\SpecialStringTok{ und }\SpecialCharTok{\{}\NormalTok{b}\SpecialCharTok{\}}\SpecialStringTok{ konnte nicht gebildet werden."}\NormalTok{)}
  \BuiltInTok{print}\NormalTok{(error)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Differenz aus }\SpecialCharTok{\{}\NormalTok{a}\SpecialCharTok{\}}\SpecialStringTok{ und }\SpecialCharTok{\{}\NormalTok{b}\SpecialCharTok{\}}\SpecialStringTok{ ist }\SpecialCharTok{\{}\NormalTok{differenz}\SpecialCharTok{\}}\SpecialStringTok{."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Differenz aus 1 und abc konnte nicht gebildet werden.
unsupported operand type(s) for -: 'int' and 'str'
\end{verbatim}

\section{Aufgaben Flusskontrolle}\label{aufgaben-flusskontrolle}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Schreiben Sie ein Programm, das von 1 bis 25 und von 38 bis 50 zählt
  und jeden Wert, der ganzzahlig durch 7 teilbar ist, mit
  \texttt{print()} ausgibt.
\item
  Roulette: Schreiben Sie ein Programm, das für eine Zahl prüft, ob
  diese im Wertebereich des Spieltischs liegt. Falls nein, soll eine
  Fehlermeldung ausgegeben werden. Falls ja, soll das Programm ausgeben,
  ob die Zahl
\end{enumerate}

\begin{itemize}
\item
  gerade oder ungerade ist,
\item
  rot, schwarz oder grün ist,
\item
  niedrig (1-18) oder hoch (19-36) ist und
\item
  im 1., 2. oder 3. Dutzend liegt.
\end{itemize}

\begin{figure}[H]

{\centering \includegraphics[width=0.9\linewidth,height=\textheight,keepaspectratio]{books/w-python/skript/00-bilder/European_roulette_cc-by-sa.png}

}

\caption{Roulette Tableau}

\end{figure}%

European roulette von Betzaar.com ist lizensiert unter
\href{https://creativecommons.org/licenses/by-sa/3.0/deed.en}{CC 3.0
BY-SA} und verfügbar auf
\href{https://commons.wikimedia.org/wiki/File:European_roulette.svg}{wikimedia.org}.
2010

~

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Musterlösung Aufgaben Flusskontrolle}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Schreiben Sie ein Programm, das von 1 bis 25 und von 38 bis 50 zählt und jeden Wert, der ganzzahlig durch 7 teilbar ist, mit print() ausgibt.}

\NormalTok{i }\OperatorTok{=} \DecValTok{0}
\ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{50}\NormalTok{:}
\NormalTok{  i }\OperatorTok{+=} \DecValTok{1}
  \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{\textgreater{}} \DecValTok{25} \KeywordTok{and}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{38} \KeywordTok{or}\NormalTok{ i }\OperatorTok{\%} \DecValTok{7} \OperatorTok{!=} \DecValTok{0}\NormalTok{:}
    \ControlFlowTok{continue}
  \ControlFlowTok{else}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(i)}

\CommentTok{\# Alternative mit Listen}
\CommentTok{\# Hinweis: wie im Abschnitt "Schleifen" erwähnt muss der Stop{-}Wert der range{-}Funktionen um eine Zahl höher angesetzt werden, da Python exklusiv zählt}
\NormalTok{numbers }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{26}\NormalTok{))}\OperatorTok{+}\BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{38}\NormalTok{,}\DecValTok{51}\NormalTok{))}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ numbers:}
    \ControlFlowTok{if}\NormalTok{ i}\OperatorTok{\%}\DecValTok{7} \OperatorTok{==} \DecValTok{0}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(i)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
7
14
21
42
49
7
14
21
42
49
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Anlegen der zu prüfenden (ganzen) Zahl als Variable}
\NormalTok{x }\OperatorTok{=} \DecValTok{10}

\CommentTok{\# die roten und schwarzen Zahlen werden jeweils als Listen angelegt (ein Tupel funktioniert hier auch)}
\NormalTok{red\_numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{5}\NormalTok{,}\DecValTok{7}\NormalTok{,}\DecValTok{9}\NormalTok{,}\DecValTok{12}\NormalTok{,}\DecValTok{14}\NormalTok{,}\DecValTok{16}\NormalTok{,}\DecValTok{18}\NormalTok{,}\DecValTok{21}\NormalTok{,}\DecValTok{23}\NormalTok{,}\DecValTok{25}\NormalTok{,}\DecValTok{27}\NormalTok{,}\DecValTok{28}\NormalTok{,}\DecValTok{30}\NormalTok{,}\DecValTok{32}\NormalTok{,}\DecValTok{34}\NormalTok{,}\DecValTok{36}\NormalTok{]}
\NormalTok{black\_numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{8}\NormalTok{,}\DecValTok{10}\NormalTok{,}\DecValTok{11}\NormalTok{,}\DecValTok{13}\NormalTok{,}\DecValTok{15}\NormalTok{,}\DecValTok{17}\NormalTok{,}\DecValTok{19}\NormalTok{,}\DecValTok{20}\NormalTok{,}\DecValTok{22}\NormalTok{,}\DecValTok{24}\NormalTok{,}\DecValTok{26}\NormalTok{,}\DecValTok{29}\NormalTok{,}\DecValTok{31}\NormalTok{,}\DecValTok{33}\NormalTok{,}\DecValTok{35}\NormalTok{]}

\CommentTok{\# die erste if{-}Abfrage prüft, ob die Zahl überhaupt im Wertebereich liegt. Falls nicht, wird direkt unten zum "else"{-}Zweig gesprungen}
\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}=} \DecValTok{0} \KeywordTok{and}\NormalTok{ x }\OperatorTok{\textless{}=} \DecValTok{36}\NormalTok{:}

    \CommentTok{\# innerhalb der if{-}Abfrage befinden sich weitere if{-}Abfragen, die jeweils auf die anderen Merkmale prüfen:}

    \CommentTok{\# Prufung ob die Zahl gerade oder ungerade ist}
    \ControlFlowTok{if}\NormalTok{ x}\OperatorTok{\%}\DecValTok{2} \OperatorTok{==} \DecValTok{0}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Zahl ist gerade"}\NormalTok{)}
    \ControlFlowTok{else}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Zahl ist ungerade"}\NormalTok{)}

    \CommentTok{\# Prüfung ob die Zahl rot, schwarz oder grün ist}
    \ControlFlowTok{if}\NormalTok{ x }\KeywordTok{in}\NormalTok{ red\_numbers:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Zahl ist rot"}\NormalTok{)}
    \ControlFlowTok{elif}\NormalTok{ x }\KeywordTok{in}\NormalTok{ black\_numbers:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Zahl ist schwarz"}\NormalTok{)}
    \ControlFlowTok{elif}\NormalTok{ x }\OperatorTok{==} \DecValTok{0}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Zahl ist grün"}\NormalTok{)}

    \CommentTok{\# Prüfung ob die Zahl hoch oder niedrig ist}
    \ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}=} \DecValTok{1} \KeywordTok{and}\NormalTok{ x }\OperatorTok{\textless{}=} \DecValTok{18}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Zahl ist niedrig"}\NormalTok{)}
    \ControlFlowTok{elif}\NormalTok{ x }\OperatorTok{\textgreater{}=} \DecValTok{19} \KeywordTok{and}\NormalTok{ x }\OperatorTok{\textless{}=} \DecValTok{36}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Zahl ist hoch"}\NormalTok{)}
    
    \CommentTok{\# Prüfung in welchem Dutzend die Zahl liegt}
    \ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}=} \DecValTok{1} \KeywordTok{and}\NormalTok{ x }\OperatorTok{\textless{}=} \DecValTok{12}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Zahl liegt im 1. Dutzend"}\NormalTok{)}
    \ControlFlowTok{elif}\NormalTok{ x }\OperatorTok{\textgreater{}=} \DecValTok{13} \KeywordTok{and}\NormalTok{ x }\OperatorTok{\textless{}=} \DecValTok{24}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Zahl ist im 2. Dutzend"}\NormalTok{)}
    \ControlFlowTok{elif}\NormalTok{ x }\OperatorTok{\textgreater{}=} \DecValTok{25} \KeywordTok{and}\NormalTok{ x }\OperatorTok{\textless{}=} \DecValTok{36}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Zahl ist im 3. Dutzend"}\NormalTok{)}
    \ControlFlowTok{else}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Zahl liegt in keinem Dutzend"}\NormalTok{)}
    
\ControlFlowTok{else}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Zahl ist nicht im Wertebereich vorhanden."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Zahl ist gerade
Zahl ist schwarz
Zahl ist niedrig
Zahl liegt im 1. Dutzend
\end{verbatim}

Musterlösung von Marc Sönnecken und Maik Poetzsch

\end{tcolorbox}

~\\
(@Arnold-2023-schleifen-abzweigungen)

\chapter{Sammeltypen}\label{sammeltypen}

Sammeltypen werden benutzt, um mehrere Werte in einer Variablen zu
speichern und zu verarbeiten. In Python gibt es vier Sammeltypen, die
jeweils eine eigene Klasse sind:

\begin{itemize}
\item
  \href{https://de.wikipedia.org/wiki/Liste_(Datenstruktur)}{Listen}
  enthalten eine flexible Anzahl von Elementen beliebigen Typs.
\item
  \href{https://de.wikipedia.org/wiki/Tupel_\%28Informatik\%29}{Tupel}
  können wie Listen Elemente beliebigen Typs enthalten, sind aber
  unveränderlich.
\item
  \href{https://de.wikipedia.org/wiki/Menge_\%28Datenstruktur\%29}{Mengen}
  sind ungeordnete Sammlungen, die jedes Element nur einmal enthalten
  können.
\item
  \href{https://de.wikipedia.org/wiki/Zuordnungstabelle_\%28Datenstruktur\%29}{Assoziative
  Arrays} oder Dictionaries sind Zuordnungstabellen, d.~h. sie bestehen
  aus Schlüssel-Wert-Paaren.
\end{itemize}

In diesem Kapitel werden die vier Sammeltypen zunächst kurz vorgestellt.
Anschließend wird die Arbeitsweise insbesondere mit Listen erläutert.

\section{Listen}\label{listen}

Wie alle Typen in Python werden Listen durch Zuweisung erstellt. Bei der
Definition einer Liste werden die Elemente durch eckige Klammern
\texttt{{[}{]}} eingeklammert und mit Kommata \texttt{,} getrennt.
Listen können mit dem \texttt{+}-Operator verkettet werden. \texttt{*}
verkettet eine Liste n-mal.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{text\_variable }\OperatorTok{=} \StringTok{\textquotesingle{}abc\textquotesingle{}}

\NormalTok{liste1 }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}xy\textquotesingle{}}\NormalTok{, }\VariableTok{True}\NormalTok{, text\_variable]}
\BuiltInTok{print}\NormalTok{(liste1)}

\CommentTok{\# Listen können auch Listen enthalten}
\NormalTok{liste2 }\OperatorTok{=}\NormalTok{ [}\VariableTok{None}\NormalTok{, liste1]}
\BuiltInTok{print}\NormalTok{(liste2)}

\CommentTok{\# Listen können mit + und * verkettet werden}
\BuiltInTok{print}\NormalTok{(liste1 }\OperatorTok{+}\NormalTok{ liste2)}
\BuiltInTok{print}\NormalTok{(liste1 }\OperatorTok{*} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 'xy', True, 'abc']
[None, [1, 'xy', True, 'abc']]
[1, 'xy', True, 'abc', None, [1, 'xy', True, 'abc']]
[1, 'xy', True, 'abc', 1, 'xy', True, 'abc']
\end{verbatim}

Eine leere Liste kann durch Zuweisung von \texttt{{[}{]}} erstellt
werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{leere\_liste }\OperatorTok{=}\NormalTok{ []}
\BuiltInTok{print}\NormalTok{(leere\_liste)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[]
\end{verbatim}

\subsection{Slicing: der Zugriffsoperator
{[}{]}}\label{slicing-der-zugriffsoperator}

Der Zugriff auf einzelne oder mehrere Elemente einer Liste (und andere
Sammeltypen) erfolgt über den Zugriffsoperator \texttt{{[}{]}}. Ein
Ausschnitt aus einem Objekt wird Slice genannt, der Operator heißt
deshalb auch Slice Operator.

\subsubsection{Zugriff auf einzelne
Elemente}\label{zugriff-auf-einzelne-elemente}

Elemente werden über ihren Index, bei 0 beginnend, angesprochen.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(liste1)}
\BuiltInTok{print}\NormalTok{(liste1[}\DecValTok{0}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(liste1[}\DecValTok{3}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 'xy', True, 'abc']
1
abc
\end{verbatim}

Auf verschachtelte Listen kann mit zwei aufeinanderfolgenden
Zugriffsoperatoren zugegriffen werden. Die Liste \texttt{liste2} enthält
an Indexposition 1 eine Liste mit 4 Elementen.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(liste2)}
\BuiltInTok{print}\NormalTok{(liste2[}\DecValTok{1}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(liste2[}\DecValTok{1}\NormalTok{][}\DecValTok{0}\NormalTok{], liste2[}\DecValTok{1}\NormalTok{][}\DecValTok{1}\NormalTok{], liste2[}\DecValTok{1}\NormalTok{][}\DecValTok{2}\NormalTok{], liste2[}\DecValTok{1}\NormalTok{][}\DecValTok{3}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[None, [1, 'xy', True, 'abc']]
[1, 'xy', True, 'abc']
1 xy True abc
\end{verbatim}

Mit negativen Indizes können Elemente vom Ende aus angesprochen werden.
So entspricht z. B. die -1 dem letzten Element.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(liste1)}
\BuiltInTok{print}\NormalTok{(liste1[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{], liste1[}\OperatorTok{{-}}\DecValTok{3}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 'xy', True, 'abc']
abc xy
\end{verbatim}

\subsubsection{Zugriff auf mehrere
Elemente}\label{zugriff-auf-mehrere-elemente}

Indexbereiche können in der Form \texttt{{[}start:stop:step{]}}
angesprochen werden. \texttt{start} ist das erste adressierte Element,
\texttt{stop} \emph{das erste nicht mehr adressierte Element} und
\texttt{step} die Schrittweite.

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Zugriffsoperator & Ausschnitt \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
liste{[}start:stop{]} & Elemente von start bis stop - 1 \\
liste{[}:{]} & Alle Elemente der Liste \\
liste{[}start:{]} & Elemente von start bis zum Ende der Liste \\
liste{[}:stop{]} & Elemente vom Anfang der Liste bis stop - 1 \\
liste{[}::3{]} & Auswahl jedes dritten Elements \\
\end{longtable}

~

Negative Werte für \texttt{start}, \texttt{stop} oder \texttt{step}
bewirken eine Rückwärtsauswahl von Elementen.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Zugriffsoperator
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Ausschnitt
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
liste{[}-1{]} & das letzte Element der Liste \\
liste{[}-2:{]} & die letzten beiden Elemente der Liste \\
liste{[}:-2{]} & alle bis auf die beiden letzten Elemente \\
liste{[}::-1{]} & alle Elemente in umgekehrter Reihenfolge \\
liste{[}1::-1{]} & die ersten beiden Elemente in umgekehrter
Reihenfolge \\
liste{[}:-3:-1{]} & die letzten beiden Elemente in umgekehrter
Reihenfolge \\
liste{[}-3::-1{]} & alle außer die letzten beiden Elemente in
umgekehrter Reihenfolge \\
\end{longtable}

~

(Beispiele von Greg Hewgill unter der Lizenz
\href{https://creativecommons.org/licenses/by-sa/4.0/deed.de}{CC BY-SA
4.0} verfügbar auf
\href{https://stackoverflow.com/a/509295}{stackoverflow}. 2009)

\subsubsection{Zeichenfolgen}\label{zeichenfolgen-2}

Auch aus Zeichenfolgen können mit dem Slice Operator Ausschnitte
ausgewählt werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Ich bin ein string\textquotesingle{}}\NormalTok{[::}\DecValTok{2}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Hallo Welt\textquotesingle{}}\NormalTok{[}\DecValTok{0}\NormalTok{:}\DecValTok{6}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}abc\textquotesingle{}}\NormalTok{[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Ihbnensrn
Hallo 
cba
\end{verbatim}

\subsection{Listenmethoden}\label{listenmethoden}

Für den Listentyp sind verschiedene Methoden definiert.

\subsubsection{Elemente bestimmen}\label{elemente-bestimmen}

\begin{itemize}
\item
  \texttt{list.index(x,\ start,\ stop)} gibt die Indexposition des
  ersten Elements x aus. Die optionalen Argumente \texttt{start} und
  \texttt{stop} erlauben es, den Suchbereich einzuschränken.
\item
  \texttt{list.count(x)} gibt die Häufigkeit von x in der Liste aus.
\item
  \texttt{list.reverse()} kehrt die Reihenfolge der Listenelemente um
  (die Liste wird dadurch verändert!).
\item
  \texttt{list.sort(reverse\ =\ False)} sortiert die Liste, mit dem
  optionalen Argument \texttt{reverse\ =\ True} absteigend (die Liste
  wird dadurch verändert!). Die Datentypen innerhalb der Liste müssen
  sortierbar sein (d.~h. alle Elemente sind numerisch oder Zeichen).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(liste1)}

\NormalTok{liste1.reverse()}
\BuiltInTok{print}\NormalTok{(liste1)}

\CommentTok{\# True wird als 1 gezählt}
\BuiltInTok{print}\NormalTok{(}\StringTok{"True wird als 1 gezählt:"}\NormalTok{, liste1.index(}\DecValTok{1}\NormalTok{), liste1.count(}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 'xy', True, 'abc']
['abc', True, 'xy', 1]
True wird als 1 gezählt: 1 2
\end{verbatim}

\subsubsection{Elemente einfügen}\label{elemente-einfuxfcgen}

\begin{itemize}
\item
  \texttt{list.append(x)} hängt ein einzelnes Element an das Ende der
  Liste an.
\item
  \texttt{list.extend(sammeltyp)} hängt alle mit \texttt{sammeltyp}
  übergebenen Elemente an das Ende der Liste an. Der Sammeltyp kann eine
  Liste, ein Tupel, eine Menge oder ein Dictionary sein.
\item
  \texttt{list.insert(i,\ x)} fügt an der Position i Element x ein.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(liste1, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{liste1.append(}\StringTok{\textquotesingle{}Hallo\textquotesingle{}}\NormalTok{)}
\NormalTok{liste1.extend([}\StringTok{\textquotesingle{}Hallo\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Welt!\textquotesingle{}}\NormalTok{])}
\NormalTok{liste1.insert(}\DecValTok{2}\NormalTok{, }\StringTok{\textquotesingle{}12345\textquotesingle{}}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(liste1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['abc', True, 'xy', 1] 

['abc', True, '12345', 'xy', 1, 'Hallo', 'Hallo', 'Welt!']
\end{verbatim}

\subsubsection{Elemente entfernen}\label{elemente-entfernen}

\begin{itemize}
\item
  \texttt{list.remove(x)} entfernt \emph{das erste} Element x in der
  Liste und gibt einen ValueError zurück, wenn x nicht in der Liste
  enthalten ist.
\item
  \texttt{liste.pop(i)} entfernt das Element an der Indexposition i.
  Wird kein Index angegeben, wird das letzte Element entfernt. Die
  Methode \texttt{liste.pop(i)} gibt die entfernten Elemente zurück.
\item
  \texttt{liste.clear()} entfernt alle Elemente einer Liste.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{liste1.remove(}\StringTok{\textquotesingle{}Hallo\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(liste1)}

\NormalTok{liste1.pop(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['abc', True, '12345', 'xy', 1, 'Hallo', 'Welt!']
\end{verbatim}

\begin{verbatim}
'12345'
\end{verbatim}

\subsubsection{Listen und Listenelemente
kopieren}\label{listen-und-listenelemente-kopieren}

In Python enthalten Listen Daten nicht direkt, sondern bestehen aus
Zeigern auf die Speicherorte der enthaltenen Elemente. Wird eine Liste
durch Zuweisung einer anderen Liste angelegt, dann werden nicht die
Elemente der Liste kopiert, sondern beide Listen greifen dann auf den
selben Speicherort zu.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Kopieren durch Zuweisung}
\NormalTok{liste1 }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}xy\textquotesingle{}}\NormalTok{, }\VariableTok{True}\NormalTok{, text\_variable]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"liste1:"}\NormalTok{, liste1, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{liste2 }\OperatorTok{=}\NormalTok{ liste1}

\CommentTok{\#\# Ändern eines Elements in liste2}
\NormalTok{liste2[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \StringTok{\textquotesingle{}ABC\textquotesingle{}}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Auch liste1 hat sich durch die Zuweisung in liste2 verändert:"}\NormalTok{, liste1, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
liste1: [1, 'xy', True, 'abc'] 

Auch liste1 hat sich durch die Zuweisung in liste2 verändert: ['ABC', 'xy', True, 'abc'] 
\end{verbatim}

Um eine Liste zu kopieren und ein neues Objekt im Speicher anzulegen,
kann die Methode \texttt{liste.copy()} verwendet werden. Auch durch die
Verwendung des Zugriffsoperators \texttt{{[}:{]}} wird eine neue Liste
im Speicher angelegt.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Verwendung der Methode liste.copy()}
\NormalTok{liste1 }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}xy\textquotesingle{}}\NormalTok{, }\VariableTok{True}\NormalTok{, text\_variable]}
\NormalTok{liste2 }\OperatorTok{=}\NormalTok{ liste1.copy()}

\CommentTok{\#\# Ändern eines Elements in liste2}
\NormalTok{liste2[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \StringTok{\textquotesingle{}ABC\textquotesingle{}}
\BuiltInTok{print}\NormalTok{(}\StringTok{"liste1 bleibt durch die Zuweisung in liste2 unverändert:"}\NormalTok{, liste1, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# Verwendung des Slice Operators}
\NormalTok{liste1 }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}xy\textquotesingle{}}\NormalTok{, }\VariableTok{True}\NormalTok{, text\_variable]}
\NormalTok{liste2 }\OperatorTok{=}\NormalTok{ liste1[:]}

\CommentTok{\#\# Ändern eines Elements in liste2}
\NormalTok{liste2[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \StringTok{\textquotesingle{}ABC\textquotesingle{}}
\BuiltInTok{print}\NormalTok{(}\StringTok{"liste1 bleibt durch die Zuweisung in liste2 unverändert:"}\NormalTok{, liste1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
liste1 bleibt durch die Zuweisung in liste2 unverändert: [1, 'xy', True, 'abc'] 

liste1 bleibt durch die Zuweisung in liste2 unverändert: [1, 'xy', True, 'abc']
\end{verbatim}

Die Kopie von Listenelementen ist in dieser Hinsicht unproblematisch.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Verwendung des Slice Operators}
\NormalTok{liste1 }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}xy\textquotesingle{}}\NormalTok{, }\VariableTok{True}\NormalTok{, text\_variable]}
\NormalTok{liste2 }\OperatorTok{=}\NormalTok{ liste1[}\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{]}

\CommentTok{\# Ändern eines Elements in liste2}
\NormalTok{liste2[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \StringTok{\textquotesingle{}ABC\textquotesingle{}}
\BuiltInTok{print}\NormalTok{(}\StringTok{"liste1 bleibt durch die Zuweisung in liste2 unverändert:"}\NormalTok{, liste1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
liste1 bleibt durch die Zuweisung in liste2 unverändert: [1, 'xy', True, 'abc']
\end{verbatim}

Um zu überprüfen, ob sich zwei Objekte den Speicherbereich teilen, kann
die Objekt-ID mit der Funktion \texttt{id()} verglichen oder die
Operatoren \texttt{is} bzw. \texttt{is\ not} verwendet werden, die die
Funktion \texttt{id()} aufrufen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{liste1 }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}xy\textquotesingle{}}\NormalTok{, }\VariableTok{True}\NormalTok{, text\_variable]}
\NormalTok{liste2 }\OperatorTok{=}\NormalTok{ liste1}

\BuiltInTok{print}\NormalTok{(}\StringTok{"ID liste1:"}\NormalTok{, }\BuiltInTok{id}\NormalTok{(liste1))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"ID liste2:"}\NormalTok{, }\BuiltInTok{id}\NormalTok{(liste2))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"ID liste1 gleich ID list2:"}\NormalTok{, liste1 }\KeywordTok{is}\NormalTok{ liste2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ID liste1: 4391900288
ID liste2: 4391900288
ID liste1 gleich ID list2: True
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-wertgleichheit} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-wertgleichheit}: Identität vs.~Wertgleichheit}\vspace{3mm}

Der Operator \texttt{is} prüft die Identität zweier Objekte und
unterscheidet sich dadurch vom logischen Operator \texttt{==}, der auf
Wertgleichheit prüft. Da liste1 und liste2 die gleichen Elemente
enthalten, liegen sowohl Identität und Wertgleichheit vor. Der
Unterschied von Identität und Wertgleichheit kann anhand eines Werts
verdeutlicht werden (Im Code-Beispiel wird eine Syntax-Warnung
unterdrückt.).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Wertgleichheit}
\BuiltInTok{print}\NormalTok{(}\DecValTok{1} \OperatorTok{==} \FloatTok{1.0}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(liste1 }\OperatorTok{==}\NormalTok{ liste2, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# Identität}
\BuiltInTok{print}\NormalTok{(}\DecValTok{1} \KeywordTok{is} \FloatTok{1.0}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(liste1 }\KeywordTok{is}\NormalTok{ liste2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
True 

False
True
\end{verbatim}

\end{minipage}%
\end{tcolorbox}

\subsection{Aufgaben Listen}\label{aufgaben-listen}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Bestimmen Sie in der Liste
  \texttt{zahlen\ =\ {[}34,\ 12,\ 0,\ 67,\ 23{]}} die Position des Werts
  0. Entfernen Sie den Wert aus der Liste und geben Sie die Liste
  aufsteigend sortiert aus.
\item
  Geben Sie nun mit Hilfe des Zugriffsoperators \texttt{{[}{]}} die
  Indexpositionen 1 und 3 der sortierten Liste `zahlen' aus.
\item
  Legen Sie eine Liste mit den Zahlen 1 bis 10 an.
\end{enumerate}

\begin{itemize}
\tightlist
\item
  Geben Sie mit dem Slice-Operator alle geraden Zahlen aus.
\item
  Geben Sie mit dem Slice-Operator die ungeraden Zahlen absteigend aus.
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Erstellen Sie eine Liste `wochentage', die die sieben Tage der Woche
  enthält. Verwenden Sie den Slice-Operator, um eine neue Liste
  `wochenende' mit den Tagen des Wochenendes zu erstellen. Entfernen Sie
  die Tage des Wochenendes aus der Liste `wochentage'.
\item
  4-Tage-Woche: Verwenden Sie Listenmethoden, um den Freitag aus der
  Liste `wochentage' zu entfernen und der Liste `wochenende' vor dem
  Samstag hinzuzufügen.
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-listen}: Musterlösung Listen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-listen} 

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 1.}
\NormalTok{zahlen }\OperatorTok{=}\NormalTok{ [}\DecValTok{34}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{67}\NormalTok{, }\DecValTok{23}\NormalTok{]}
\NormalTok{gesuchter\_index }\OperatorTok{=}\NormalTok{ zahlen.index(}\DecValTok{0}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(gesuchter\_index)}

\NormalTok{zahlen.remove(}\DecValTok{0}\NormalTok{)}
\NormalTok{zahlen.sort()}
\BuiltInTok{print}\NormalTok{(zahlen)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
[12, 23, 34, 67]
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 2.}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Wert der Zahl an Indexposition 1: }\SpecialCharTok{\{}\NormalTok{zahlen[}\DecValTok{1}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Wert der Zahl an Indexposition 3: }\SpecialCharTok{\{}\NormalTok{zahlen[}\DecValTok{3}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Wert der Zahl an Indexposition 1: 23
Wert der Zahl an Indexposition 3: 67
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 3.}
\NormalTok{liste }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(liste[}\DecValTok{1}\NormalTok{::}\DecValTok{2}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(liste[}\OperatorTok{{-}}\DecValTok{2}\NormalTok{::}\OperatorTok{{-}}\DecValTok{2}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[2, 4, 6, 8, 10]
[9, 7, 5, 3, 1]
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 4.}
\CommentTok{\# Aufgabe Wochentage}
\NormalTok{wochentage }\OperatorTok{=}\NormalTok{ [}\StringTok{"Montag"}\NormalTok{, }\StringTok{"Dienstag"}\NormalTok{, }\StringTok{"Mittwoch"}\NormalTok{, }\StringTok{"Donnerstag"}\NormalTok{, }\StringTok{"Freitag"}\NormalTok{, }\StringTok{"Samstag"}\NormalTok{, }\StringTok{"Sonntag"}\NormalTok{]}
\NormalTok{wochenende }\OperatorTok{=}\NormalTok{ wochentage[}\DecValTok{5}\NormalTok{:}\DecValTok{7}\NormalTok{] }\CommentTok{\# hier ist es auch möglich wochentage[{-}2:] zu benutzen}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Wochenende:"}\NormalTok{, wochenende)}

\NormalTok{wochentage.pop(}\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}
\NormalTok{wochentage.pop(}\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(wochentage)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Wochenende: ['Samstag', 'Sonntag']
['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag']
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 5.}
\NormalTok{wochenende.insert(}\DecValTok{0}\NormalTok{, wochentage.pop(}\DecValTok{4}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(wochentage)}
\BuiltInTok{print}\NormalTok{(wochenende)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag']
['Freitag', 'Samstag', 'Sonntag']
\end{verbatim}

Musterlösung von Marc Sönnecken

\end{tcolorbox}

\section{Tupel}\label{tupel}

Tupel sind Listen sehr ähnlich, jedoch sind Tupel unveränderbare
Datenobjekte. Das heißt, die Elemente eines angelegten Tupels können
weder geändert, noch entfernt werden. Auch können keine neuen Elemente
zum Tupel hinzugefügt werden.

Tupel werdem mit runden Klammern \texttt{()} erzeugt, die Elemente
werden mit einem Komma \texttt{,} getrennt. Ein Tupel mit einem Wert
wird mit einem Komma in der Form \texttt{(wert,\ )} angelegt. Der
Zugriff auf die Elemente eines Tupels ist mit dem Slice-Operator
\texttt{{[}start:stop:step{]}} möglich. Tupel können mit den Operatoren
\texttt{+} und \texttt{*} verkettet werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tupel1 }\OperatorTok{=}\NormalTok{ (}\DecValTok{2}\NormalTok{, }\FloatTok{7.8}\NormalTok{, }\StringTok{\textquotesingle{}Feuer\textquotesingle{}}\NormalTok{, }\VariableTok{True}\NormalTok{, text\_variable)}
\NormalTok{tupel2 }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, )}

\BuiltInTok{print}\NormalTok{(tupel1)}
\BuiltInTok{print}\NormalTok{(tupel1[}\DecValTok{2}\NormalTok{:}\DecValTok{4}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(tupel1[::}\DecValTok{2}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(tupel1[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(tupel1[}\DecValTok{2}\NormalTok{:}\DecValTok{4}\NormalTok{] }\OperatorTok{+}\NormalTok{ tupel2)}
\BuiltInTok{print}\NormalTok{(}\DecValTok{3} \OperatorTok{*}\NormalTok{ tupel2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(2, 7.8, 'Feuer', True, 'abc')
('Feuer', True)
(2, 'Feuer', 'abc')
abc
('Feuer', True, 1)
(1, 1, 1)
\end{verbatim}

\subsection{Tupel kopieren}\label{tupel-kopieren}

Tupel verhalten sich beim Kopieren gegensätzlich zu Listen. Für Tupel
ist die Methode \texttt{.copy()} nicht definiert. Dagegen bewirkt die
Kopie mittels dem Zugriffsoperator \texttt{{[}:{]}} zwar, dass zwei
Tupel auf den selben Speicherplatz zugreifen. Bei der Neuzuweisung eines
Tupels legt Python, wie für jedes Objekt, ein neues Objekt im Speicher
an.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Kopieren durch Zuweisung}
\NormalTok{tupel1 }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{tupel2 }\OperatorTok{=}\NormalTok{ tupel1}

\CommentTok{\#\# Neuzuweisung der Werte von tupel1}
\NormalTok{tupel1 }\OperatorTok{=}\NormalTok{ (}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die in tupel2 gespeicherten Werte sind unverändert:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{tupel1}\SpecialCharTok{\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{tupel2}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# Kopieren mit Slice Operator}
\NormalTok{tupel1 }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{tupel2 }\OperatorTok{=}\NormalTok{ tupel1[:]}
\BuiltInTok{print}\NormalTok{(tupel2 }\KeywordTok{is}\NormalTok{ tupel1)}

\CommentTok{\#\# Neuzuweisung der Werte von tupel1}
\NormalTok{tupel1 }\OperatorTok{=}\NormalTok{ (}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(tupel1, tupel2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die in tupel2 gespeicherten Werte sind unverändert:
(4, 5, 6) (1, 2, 3)

True
(4, 5, 6) (1, 2, 3)
\end{verbatim}

\section{Mengen}\label{mengen}

In Python können Mengen mit der \texttt{set()} Funktion z. B. aus einer
Liste oder aus einem Tupel erzeugt oder durch geschweiften Klammern
\texttt{\{\}} erstellt werden (eine leere Menge kann nur mit
\texttt{set()} erzeugt werden, da \texttt{\{\}} ein leeres Dictionary
anlegt). Mengen sind ungeordnete Sammelungen, dementsprechend haben die
Elemente keine Reihenfolge.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{liste }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{2}\NormalTok{, }\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\DecValTok{123}\NormalTok{, }\DecValTok{1000}\NormalTok{, (}\StringTok{\textquotesingle{}tupel\textquotesingle{}}\NormalTok{, }\DecValTok{5}\NormalTok{)]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Das Objekt liste als Menge:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\BuiltInTok{set}\NormalTok{(liste))}

\NormalTok{menge }\OperatorTok{=}\NormalTok{ \{}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{1000}\NormalTok{, (}\StringTok{\textquotesingle{}tupel\textquotesingle{}}\NormalTok{, }\DecValTok{5}\NormalTok{), }\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\DecValTok{123}\NormalTok{\}}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Die Menge kann auch mit geschweiften Klammern erzeugt werden:"}\NormalTok{, menge, sep }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Das Objekt liste als Menge:
 {1, 2, 3, 4, 5, 'a', 1000, ('tupel', 5), 123}
Die Menge kann auch mit geschweiften Klammern erzeugt werden:
{1, 2, 3, 4, 5, 'a', 1000, ('tupel', 5), 123}
\end{verbatim}

Mengen können beispielsweise für Vergleichsoperationen verwendet werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{menge\_a }\OperatorTok{=} \BuiltInTok{set}\NormalTok{(}\StringTok{\textquotesingle{}Python\textquotesingle{}}\NormalTok{)}
\NormalTok{menge\_b }\OperatorTok{=} \BuiltInTok{set}\NormalTok{(}\StringTok{\textquotesingle{}ist super\textquotesingle{}}\NormalTok{)}

\CommentTok{\# einzigartige Zeichen in a}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Menge a:"}\NormalTok{, menge\_a)}

\CommentTok{\# Zeichen in a, aber nicht in b}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Menge a {-} b:"}\NormalTok{, menge\_a }\OperatorTok{{-}}\NormalTok{ menge\_b)}

\CommentTok{\# Zeichen in a oder b}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Menge a | b:"}\NormalTok{, menge\_a }\OperatorTok{|}\NormalTok{ menge\_b)}

\CommentTok{\# Zeichen in a und b}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Menge a \& b:"}\NormalTok{, menge\_a }\OperatorTok{\&}\NormalTok{ menge\_b)}

\CommentTok{\# Zeichen in a oder b, aber nicht in beiden (XOR)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Menge a \^{} b:"}\NormalTok{, menge\_a }\OperatorTok{\^{}}\NormalTok{ menge\_b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Menge a: {'h', 'y', 't', 'n', 'P', 'o'}
Menge a - b: {'h', 'y', 'n', 'P', 'o'}
Menge a | b: {'h', 's', 'u', 'y', 't', ' ', 'n', 'e', 'i', 'P', 'r', 'o', 'p'}
Menge a & b: {'t'}
Menge a ^ b: {'h', 'u', 'p', 'y', ' ', 'n', 'e', 'i', 'r', 'P', 'o', 's'}
\end{verbatim}

\subsection{Mengen kopieren}\label{mengen-kopieren}

Mengen verhalten sich wie Tupel mit dem Unterschied, dass die Methode
\texttt{.copy()} für Mengen definiert ist. Allerdings kann der
Zugriffsoperator \texttt{{[}{]}} nicht auf Mengen angewendet werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Kopieren durch Zuweisung}
\NormalTok{set1 }\OperatorTok{=}\NormalTok{ \{}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{\}}
\NormalTok{set2 }\OperatorTok{=}\NormalTok{ set1}
\BuiltInTok{print}\NormalTok{(set1 }\KeywordTok{is}\NormalTok{ set2)}

\CommentTok{\#\# Neuzuweisen von set1}
\NormalTok{set1 }\OperatorTok{=}\NormalTok{ \{}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{\}}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die in set2 gespeicherten Werte sind unverändert:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{set1}\SpecialCharTok{\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{set2}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# Kopieren durch Methode .copy()}
\NormalTok{set1 }\OperatorTok{=}\NormalTok{ \{}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{\}}
\NormalTok{set2 }\OperatorTok{=}\NormalTok{ set1.copy()}
\BuiltInTok{print}\NormalTok{(set1 }\KeywordTok{is}\NormalTok{ set2)}

\CommentTok{\#\# Neuzuweisen von set1}
\NormalTok{set1 }\OperatorTok{=}\NormalTok{ \{}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{\}}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die in set2 gespeicherten Werte sind unverändert:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{set1}\SpecialCharTok{\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{set2}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
Die in set2 gespeicherten Werte sind unverändert:
{4, 5, 6} {1, 2, 3}
False
Die in set2 gespeicherten Werte sind unverändert:
{4, 5, 6} {1, 2, 3}
\end{verbatim}

\section{Dictionaries}\label{dictionaries}

Dictionaries bestehen aus Schlüssel-Wert-Paaren. Die Schlüssel können
Zahlen oder Zeichenketten sein, jeder Schlüssel darf nur einmal
vorkommen. Dictionaries werden mit geschweiften Klammern \texttt{\{\}}
definiert. Die Schlüssel und deren zugehörigen Werte werden mit einem
Doppelpunkt \texttt{:} getrennt. Der Zugriff auf die Werte erfolgt mit
dem Zugriffsoperator \texttt{{[}{]}}, welcher den oder die Schlüssel
beinhaltet. Ein Zugriff über die Indexposition der Schlüssel ist nicht
möglich, da Zahlen als Schlüssel interpretiert werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dictionary1 }\OperatorTok{=}\NormalTok{ \{}\DecValTok{1}\NormalTok{: }\StringTok{\textquotesingle{}abc\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], }\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{: (}\StringTok{\textquotesingle{}tupel\textquotesingle{}}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{)\}}
\BuiltInTok{print}\NormalTok{(dictionary1, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Werte des Schlüssels 1:"}\NormalTok{, dictionary1[}\DecValTok{1}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Werte des Schlüssels \textquotesingle{}b\textquotesingle{}:"}\NormalTok{,  dictionary1[}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
{1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)} 

Werte des Schlüssels 1: abc
Werte des Schlüssels 'b': [1, 2, 3]
\end{verbatim}

Auf die Schlüssel eines Dictionaries kann über die Methode
\texttt{dictionary.keys()}, auf die Werte mittels der Methode
\texttt{dictionary.values()} zugegriffen werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Schlüssel:"}\NormalTok{, dictionary1.keys(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Werte:"}\NormalTok{, dictionary1.values())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Schlüssel: dict_keys([1, 'b', 'c']) 

Werte: dict_values(['abc', [1, 2, 3], ('tupel', 5, 6)])
\end{verbatim}

\subsection{Dictionaries kopieren}\label{dictionaries-kopieren}

Dictionaries verhalten sich beim Kopieren wie Listen, das heißt beim
Kopieren durch Zuweisung teilen sich Dictionaries den Speicherbereich.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Kopieren durch Zuweisung}
\BuiltInTok{print}\NormalTok{(}\StringTok{"dictionary:"}\NormalTok{, dictionary1, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{dictionary2 }\OperatorTok{=}\NormalTok{ dictionary1}

\CommentTok{\#\# Ändern eines Elements in dictionary2}
\NormalTok{dictionary2[}\DecValTok{1}\NormalTok{] }\OperatorTok{=} \StringTok{\textquotesingle{}ABC\textquotesingle{}}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Auch dictionary1 hat sich durch die Zuweisung in dictionary2 verändert:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{,}
\NormalTok{       dictionary1, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# Verwendung der Methode dictionary.copy()}
\NormalTok{dictionary1 }\OperatorTok{=}\NormalTok{ \{}\DecValTok{1}\NormalTok{: }\StringTok{\textquotesingle{}abc\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], }\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{: (}\StringTok{\textquotesingle{}tupel\textquotesingle{}}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{)\}}
\NormalTok{dictionary2 }\OperatorTok{=}\NormalTok{ dictionary1.copy()}

\CommentTok{\#\# Ändern eines Elements in dictionary2}
\NormalTok{dictionary2[}\DecValTok{1}\NormalTok{] }\OperatorTok{=} \StringTok{\textquotesingle{}ABC\textquotesingle{}}
\BuiltInTok{print}\NormalTok{(}\StringTok{"dictionary1 bleibt durch die Zuweisung in dictionary2 unverändert:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{,}
\NormalTok{       dictionary1, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
dictionary: {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)} 

Auch dictionary1 hat sich durch die Zuweisung in dictionary2 verändert:
 {1: 'ABC', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)} 

dictionary1 bleibt durch die Zuweisung in dictionary2 unverändert:
 {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)} 
\end{verbatim}

\section{Übersicht Sammeltypen}\label{uxfcbersicht-sammeltypen}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.5783}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.0964}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.0843}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.0964}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1446}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Merkmal
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Listen
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Tupel
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Mengen
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Dictionary
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Beschreibung & flexible Anzahl von Elementen beliebigen Typs & Elemente
beliebigen Typs, unveränderlich & ungeordnete Sammlung, jedes Element
nur einmal enthalten & Zuordnungstabelle aus Schlüssel-Wert-Paaren \\
Speicherbereich bei Zuweisung geteilt & ja & ja (aber unveränderlich) &
ja (aber Zugriffsoperator nicht anwendbar) & ja \\
Methode .copy() definiert & ja & nein & ja & ja \\
Slice-Operator anwendbar & ja & ja & nein & ja (nach Schlüssel) \\
\end{longtable}

~

\section{Löschen: das Schlüsselwort
del}\label{luxf6schen-das-schluxfcsselwort-del}

Um Sammeltypen, Elemente oder Slices zu löschen kann das Schlüsselwort
\texttt{del} verwendet werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Löschen einer Liste}
\KeywordTok{del}\NormalTok{ liste1}

\CommentTok{\# Löschen eines Indexbereichs aus einer Liste}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Liste vor dem Löschen:"}\NormalTok{, liste2)}
\KeywordTok{del}\NormalTok{ liste2[}\DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Liste nach dem Löschen:"}\NormalTok{, liste2)}

\CommentTok{\# Löschen eines Schlüsselworts aus einem Dictionary}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Dictionary vor dem Löschen"}\NormalTok{, dictionary1)}
\KeywordTok{del}\NormalTok{ dictionary1[}\DecValTok{1}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Dictionary nach dem Löschen"}\NormalTok{, dictionary1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Liste vor dem Löschen: [1, 'xy', True, 'abc']
Liste nach dem Löschen: [1, 'abc']
Dictionary vor dem Löschen {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)}
Dictionary nach dem Löschen {'b': [1, 2, 3], 'c': ('tupel', 5, 6)}
\end{verbatim}

\section{Funktionen}\label{funktionen-1}

Die Sammeltypen können ineinander umgewandelt werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dictionary }\OperatorTok{=}\NormalTok{ \{}\DecValTok{1}\NormalTok{: }\StringTok{\textquotesingle{}Kater\textquotesingle{}}\NormalTok{, }\DecValTok{2}\NormalTok{: }\StringTok{\textquotesingle{}Fähe\textquotesingle{}}\NormalTok{, }\DecValTok{3}\NormalTok{: }\StringTok{\textquotesingle{}Ricke\textquotesingle{}}\NormalTok{\}}
\BuiltInTok{print}\NormalTok{( (liste }\OperatorTok{:=} \BuiltInTok{list}\NormalTok{(dictionary)) )}
\BuiltInTok{print}\NormalTok{( (menge }\OperatorTok{:=} \BuiltInTok{set}\NormalTok{(liste)) )}
\BuiltInTok{print}\NormalTok{( (tupel }\OperatorTok{:=} \BuiltInTok{tuple}\NormalTok{(menge)) )}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 2, 3]
{1, 2, 3}
(1, 2, 3)
\end{verbatim}

Einige praktische Funktionen lassen sich auch auf Sammeltypen anwenden:

\begin{itemize}
\tightlist
\item
  \texttt{len()} gibt die Anzahl der Elemente in einem Sammeltyp zurück.
\item
  \texttt{min()}, \texttt{max()}, \texttt{sum()} gibt das Minimum,
  Maximum bzw. die Summe eines Sammeltyps zurück (bei Dictionaries wird
  die Anzahl der Schlüssel gezählt).
\end{itemize}

\section{Operationen: Verwendung von
Schleifen}\label{operationen-verwendung-von-schleifen}

Um arithmetische und logische Operatoren auf die in einem Sammeltyp
gespeicherten Elemente anzuwenden, wird eine for-Schleife verwendet. Im
folgenden Beispiel wird eine Liste `zahlen' durchlaufen, die darin
gespeicherten Zahlen quadriert und das jeweilige Ergebnis an die Liste
`quadratzahlen' angehängt. Auch wird geprüft, ob die quadrierten Zahlen
ganzzahlig durch 3 teilbar sind und das Prüfergebnis in einer Liste
`modulo\_3' gespeichert.

\begin{codelisting}

\caption{\label{lst-quadratzahlen}}

\centering{

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zahlen }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{))}

\NormalTok{quadratzahlen }\OperatorTok{=}\NormalTok{ [] }\CommentTok{\# die Liste muss vor der Schleife angelegt werden}
\NormalTok{modulo\_3 }\OperatorTok{=}\NormalTok{ [] }\CommentTok{\# leere Liste vor der Schleife anlegen}

\ControlFlowTok{for}\NormalTok{ zahl }\KeywordTok{in}\NormalTok{ zahlen:}
\NormalTok{  quadratzahl }\OperatorTok{=}\NormalTok{ zahl }\OperatorTok{**} \DecValTok{2}
\NormalTok{  quadratzahlen.append(quadratzahl)}
\NormalTok{  modulo\_3.append(quadratzahl }\OperatorTok{\%} \DecValTok{3} \OperatorTok{==} \DecValTok{0}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(quadratzahlen)}
\BuiltInTok{print}\NormalTok{(modulo\_3)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
[False, False, True, False, False, True, False, False, True, False]
\end{verbatim}

}

\end{codelisting}%

\section{Aufgaben Sammeltypen}\label{aufgaben-sammeltypen}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Modifizieren Sie den Programmcode in Listing~\ref{lst-quadratzahlen}
  so, dass nur die Quadratzahlen gespeichert werden, die ganzzahlig
  durch 3 teilbar sind.
\item
  Umrechnung von Geschwindigkeiten\\
  Erstellen Sie ein Skript, welches eine Umrechnungstabelle für
  Geschwindigkeiten erzeugt. Folgende Randbedingungen sollen beachtet
  werden:
\end{enumerate}

\begin{itemize}
\item
  Die Umrechnung soll von km/h in m/s erfolgen.
\item
  Der Start- und Endwert soll in km/h frei wählbar sein, wobei beide
  ganzzahlig sein sollen.
\item
  Die Anzahl der Umrechnungspunkte soll definiert werden können und die
  Zwischenschritte (in km/h) immer als ganze Zahlen ausgegeben werden.
\end{itemize}

\emph{Tipp: In Ihrem Skript können Sie die Funktion
\href{https://docs.python.org/3/library/functions.html\#input}{input()}
verwenden, um Werte per Eingabe zu erfassen.}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Sortieren: Gegeben ist die Liste
  \texttt{meine\_liste\ =\ list(range(9,\ 0,\ -1))}. Diese soll mittels
  for-Schleifen sortiert werden (zum Beispiel mit dem
  Bubblesort-Algorithmus).
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-musterlösungsammeltypen}: Musterlösung Aufgaben Sammeltypen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-musterlösungsammeltypen} 

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Ganzzahlig durch 3 teilbare Quadratzahlen
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zahlen }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{))}

\NormalTok{quadratzahlen }\OperatorTok{=}\NormalTok{ [] }\CommentTok{\# die Liste muss vor der Schleife angelegt werden}
\NormalTok{modulo\_3 }\OperatorTok{=}\NormalTok{ [] }\CommentTok{\# leere Liste vor der Schleife anlegen}

\ControlFlowTok{for}\NormalTok{ zahl }\KeywordTok{in}\NormalTok{ zahlen:}
\NormalTok{  quadratzahl }\OperatorTok{=}\NormalTok{ zahl }\OperatorTok{**} \DecValTok{2}
  \ControlFlowTok{if}\NormalTok{ quadratzahl }\OperatorTok{\%} \DecValTok{3} \OperatorTok{==} \DecValTok{0}\NormalTok{:}
\NormalTok{    quadratzahlen.append(quadratzahl)}

\BuiltInTok{print}\NormalTok{(quadratzahlen)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[9, 36, 81]
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Umrechnung von Geschwindigkeiten
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Freie Eingabe}
\CommentTok{\#\# start = int(input("Startwert in Kilometer pro Stunde eingeben."))}
\CommentTok{\#\# ende = int(input("Endwert in Kilometer pro Stunde eingeben."))}
\CommentTok{\#\# ausgabeschritte =  int(input("Anzahl auszugebener Schritte ein geben."))}

\CommentTok{\# Fixe Werte für die Lösung}
\NormalTok{start }\OperatorTok{=} \DecValTok{5}
\NormalTok{ende }\OperatorTok{=} \DecValTok{107}
\NormalTok{ausgabeschritte }\OperatorTok{=} \DecValTok{8}

\CommentTok{\# Liste für km erstellen}
\NormalTok{schrittweite }\OperatorTok{=}\NormalTok{ (ende }\OperatorTok{{-}}\NormalTok{ start) }\OperatorTok{/}\NormalTok{ (ausgabeschritte }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}
\NormalTok{liste\_km }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(ausgabeschritte):}
\NormalTok{    liste\_km.append(}\BuiltInTok{round}\NormalTok{(start }\OperatorTok{+}\NormalTok{ i }\OperatorTok{*}\NormalTok{ schrittweite))}

\CommentTok{\# Umrechnung}
\CommentTok{\# meter = 1000 * kilometer}
\CommentTok{\# Sekunde = Stunde * 60 * 60}
\NormalTok{liste\_m }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ wert }\KeywordTok{in}\NormalTok{ liste\_km:}
\NormalTok{    liste\_m.append(}\BuiltInTok{round}\NormalTok{((wert }\OperatorTok{*} \DecValTok{1000}\NormalTok{) }\OperatorTok{/}\NormalTok{ (}\DecValTok{60} \OperatorTok{*} \DecValTok{60}\NormalTok{), }\DecValTok{2}\NormalTok{))}

\CommentTok{\# Ausgabe}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Schrittweite: }\SpecialCharTok{\{}\NormalTok{schrittweite}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Kilometer pro Stunde"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(liste\_km)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Meter pro Sekunde"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(liste\_m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Schrittweite: 14.57
Kilometer pro Stunde
[5, 20, 34, 49, 63, 78, 92, 107]
Meter pro Sekunde
[1.39, 5.56, 9.44, 13.61, 17.5, 21.67, 25.56, 29.72]
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Sortieren: Bubble Sort Algorithmus
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# statische Liste, Textausgabe}
\NormalTok{meine\_liste }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{9}\NormalTok{, }\DecValTok{0}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{))}

\ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(meine\_liste) }\OperatorTok{\textgreater{}} \DecValTok{1}\NormalTok{: }

    \BuiltInTok{print}\NormalTok{(}\StringTok{"Liste zu Beginn}\CharTok{\textbackslash{}t\textbackslash{}t}\StringTok{  :"}\NormalTok{, meine\_liste)}

    \CommentTok{\# äußere Schleife}
\NormalTok{    Schritt }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(meine\_liste) }\OperatorTok{{-}} \DecValTok{1}\NormalTok{):}

    \CommentTok{\# innere Schleife}
        \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(meine\_liste) }\OperatorTok{{-}} \DecValTok{1}\NormalTok{):}
            \ControlFlowTok{if}\NormalTok{ meine\_liste[j] }\OperatorTok{\textgreater{}}\NormalTok{ meine\_liste[j }\OperatorTok{+} \DecValTok{1}\NormalTok{]:}
\NormalTok{                meine\_liste[j], meine\_liste[j }\OperatorTok{+} \DecValTok{1}\NormalTok{] }\OperatorTok{=}\NormalTok{ meine\_liste[j }\OperatorTok{+} \DecValTok{1}\NormalTok{], meine\_liste[j]}

\NormalTok{        Schritt }\OperatorTok{+=} \DecValTok{1}
        \BuiltInTok{print}\NormalTok{(}\StringTok{"Liste nach Schritt "}\NormalTok{, Schritt, }\StringTok{":"}\NormalTok{, meine\_liste)}

    \BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Liste sortiert:"}\NormalTok{, }\OperatorTok{*}\NormalTok{meine\_liste) }\CommentTok{\# * unterdrückt die Kommas zwischen den Listenelementen}

\ControlFlowTok{else}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Die Liste muss mindenstens zwei Elemente enthalten!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Liste zu Beginn       : [9, 8, 7, 6, 5, 4, 3, 2, 1]
Liste nach Schritt  1 : [8, 7, 6, 5, 4, 3, 2, 1, 9]
Liste nach Schritt  2 : [7, 6, 5, 4, 3, 2, 1, 8, 9]
Liste nach Schritt  3 : [6, 5, 4, 3, 2, 1, 7, 8, 9]
Liste nach Schritt  4 : [5, 4, 3, 2, 1, 6, 7, 8, 9]
Liste nach Schritt  5 : [4, 3, 2, 1, 5, 6, 7, 8, 9]
Liste nach Schritt  6 : [3, 2, 1, 4, 5, 6, 7, 8, 9]
Liste nach Schritt  7 : [2, 1, 3, 4, 5, 6, 7, 8, 9]
Liste nach Schritt  8 : [1, 2, 3, 4, 5, 6, 7, 8, 9]

Liste sortiert: 1 2 3 4 5 6 7 8 9
\end{verbatim}

\end{tcolorbox}

~\\
(@Arnold-2023-schleifen-abzweigungen)

\chapter{Eigene Funktionen
definieren}\label{eigene-funktionen-definieren}

Das Definieren eigener Funktionen eröffnet vielfältige Möglichkeiten in
Python:

\begin{itemize}
\item
  Komplexe Programme können mit einer einzigen Zeile Code aufgerufen und
  ausgeführt werden.
\item
  Funktionen können praktisch beliebig oft aufgerufen werden und sind
  durch den Einsatz von Parametern und Methoden der Flusskontrolle
  gleichzeitig in der Lage, flexibel auf wechselnde Bedingungen zu
  reagieren.
\item
  Funktionen machen Programmcode kürzer und lesbarer. Außerdem gibt es
  nur eine Stelle, welche bei Änderungen angepasst werden muss.
\end{itemize}

\section{Syntax}\label{syntax}

Das Schlüsselwort \texttt{def} leitet die Funktionsdefinition ein. Es
wird gefolgt vom Funktionsnamen und den Funktionsparametern, welche in
runden Klammern \texttt{()} eingeschlossen sind. Der Funktionskopf wird
mit einem Doppelpunkt \texttt{:} beendet. Der Anweisungsblock der
Funktion ist eingerückt. Jede Funktion liefert einen Rückgabewert,
welche durch das Schlüsselwort \texttt{return} an die aufrufende Stelle
zurückgegeben wird. \texttt{return} beendet die Ausführung der Schleife,
auch wenn es nicht am Ende des Anweisungsblocks steht.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ Funktionsname(Parameter1, Parameter2):}
\NormalTok{    Anweisungsblock}
    \ControlFlowTok{return}\NormalTok{ Rückgabewert}
\end{Highlighting}
\end{Shaded}

Damit die Funktion ausgeführt wird, muss der definierte Funktionsname
aufgerufen werden. In der Funktion ist nach dem Schlüsselwort
\texttt{return} eine weitere Anweisung enthalten, die nicht mehr
ausgeführt wird.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beispiel 1: Summe der Quadrate}

\CommentTok{\# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten}
\KeywordTok{def}\NormalTok{ sum\_quadrate(a, b):}
    \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Argument a:\textquotesingle{}}\NormalTok{, a)}
    \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Argument b:\textquotesingle{}}\NormalTok{, b)}
    \BuiltInTok{print}\NormalTok{(}\DecValTok{18} \OperatorTok{*} \StringTok{\textquotesingle{}=\textquotesingle{}}\NormalTok{)}
\NormalTok{    summe }\OperatorTok{=}\NormalTok{ a}\OperatorTok{**}\DecValTok{2} \OperatorTok{+}\NormalTok{ b}\OperatorTok{**}\DecValTok{2}
    \ControlFlowTok{return}\NormalTok{ summe}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Anweisungen nach dem Schlüsselwort return werden nicht mehr ausgeführt."}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(sum\_quadrate(}\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Argument a: 6
Argument b: 7
==================
85
\end{verbatim}

Der Rückgabewert kann in einer Variablen gespeichert werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ergebnis }\OperatorTok{=}\NormalTok{ sum\_quadrate(}\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(ergebnis)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Argument a: 6
Argument b: 7
==================
85
\end{verbatim}

\section{Optionale Parameter}\label{optionale-parameter}

Mit Hilfe von optionalen Parametern kann die Programmausführung
gesteuert werden. Optionale Parameter müssen nach verpflichtend zu
übergebenen Parametern definiert werden. In diesem Beispiel wird die
print-Ausgabe der Funktion mit dem Parameter \texttt{ausgabe} gesteuert.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beispiel 2: optionale Argumente}

\CommentTok{\# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten}
\KeywordTok{def}\NormalTok{ sum\_quadrate(a, b, ausgabe }\OperatorTok{=} \VariableTok{False}\NormalTok{):}
    \ControlFlowTok{if}\NormalTok{ ausgabe:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Wert Argument a:\textquotesingle{}}\NormalTok{, a)}
      \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Wert Argument b:\textquotesingle{}}\NormalTok{, b)}
      \BuiltInTok{print}\NormalTok{(}\DecValTok{18} \OperatorTok{*} \StringTok{\textquotesingle{}=\textquotesingle{}}\NormalTok{)}
\NormalTok{    summe }\OperatorTok{=}\NormalTok{ a}\OperatorTok{**}\DecValTok{2} \OperatorTok{+}\NormalTok{ b}\OperatorTok{**}\DecValTok{2}
    \ControlFlowTok{return}\NormalTok{ summe}

\BuiltInTok{print}\NormalTok{(sum\_quadrate(}\DecValTok{42}\NormalTok{, }\DecValTok{7}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(sum\_quadrate(}\DecValTok{42}\NormalTok{, }\DecValTok{7}\NormalTok{, ausgabe }\OperatorTok{=} \VariableTok{True}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1813 

Wert Argument a: 42
Wert Argument b: 7
==================
1813
\end{verbatim}

Gibt es mehrere optionale Parameter, so erfolgt die Zuweisung von
Argumenten positional oder über das Schlüsselwort.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beispiel 3: mehrere optionale Argumente}

\CommentTok{\# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten}
\KeywordTok{def}\NormalTok{ sum\_potenzen(a, b, p }\OperatorTok{=} \DecValTok{2}\NormalTok{, ausgabe }\OperatorTok{=} \VariableTok{False}\NormalTok{):}
    \ControlFlowTok{if}\NormalTok{ ausgabe:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Argument a:\textquotesingle{}}\NormalTok{, a)}
      \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Argument b:\textquotesingle{}}\NormalTok{, b)}
      \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Argument p:\textquotesingle{}}\NormalTok{, p)}
      \BuiltInTok{print}\NormalTok{(}\DecValTok{18} \OperatorTok{*} \StringTok{\textquotesingle{}=\textquotesingle{}}\NormalTok{)}
\NormalTok{    summe }\OperatorTok{=}\NormalTok{ a}\OperatorTok{**}\NormalTok{p }\OperatorTok{+}\NormalTok{ b}\OperatorTok{**}\NormalTok{p}
    \ControlFlowTok{return}\NormalTok{ summe}

\CommentTok{\# positionale Übergabe}
\BuiltInTok{print}\NormalTok{(sum\_potenzen(}\DecValTok{42}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{3}\NormalTok{, }\VariableTok{True}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# Übergabe per Schlüsselwort}
\BuiltInTok{print}\NormalTok{(sum\_potenzen(}\DecValTok{42}\NormalTok{, }\DecValTok{7}\NormalTok{, ausgabe }\OperatorTok{=} \VariableTok{True}\NormalTok{, p }\OperatorTok{=} \DecValTok{4}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Argument a: 42
Argument b: 7
Argument p: 3
==================
74431 

Argument a: 42
Argument b: 7
Argument p: 4
==================
3114097
\end{verbatim}

\section{Rückgabewert(e)}\label{ruxfcckgabewerte}

Funktionen können in Python nur einen einzigen Rückgabewert haben.
Trotzdem können mehrere Rückgabewerte mit einem Komma getrennt werden.
Python gibt diese als Tupel zurück.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beispiel 4: mehrere Rückgabewerte}

\CommentTok{\# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten}
\KeywordTok{def}\NormalTok{ sum\_potenzen(a, b, p }\OperatorTok{=} \DecValTok{2}\NormalTok{, ausgabe }\OperatorTok{=} \VariableTok{False}\NormalTok{):}
    \ControlFlowTok{if}\NormalTok{ ausgabe:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Argument a:\textquotesingle{}}\NormalTok{, a)}
      \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Argument b:\textquotesingle{}}\NormalTok{, b)}
      \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Argument p:\textquotesingle{}}\NormalTok{, p)}
      \BuiltInTok{print}\NormalTok{(}\DecValTok{18} \OperatorTok{*} \StringTok{\textquotesingle{}=\textquotesingle{}}\NormalTok{)}
\NormalTok{    summe }\OperatorTok{=}\NormalTok{ a}\OperatorTok{**}\NormalTok{p }\OperatorTok{+}\NormalTok{ b}\OperatorTok{**}\NormalTok{p}
    \ControlFlowTok{return}\NormalTok{ a, b, summe}

\NormalTok{ergebnis }\OperatorTok{=}\NormalTok{ sum\_potenzen(}\DecValTok{2}\NormalTok{, }\DecValTok{7}\NormalTok{, ausgabe }\OperatorTok{=} \VariableTok{False}\NormalTok{, p }\OperatorTok{=} \DecValTok{4}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(ergebnis, }\BuiltInTok{type}\NormalTok{(ergebnis))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(2, 7, 2417) <class 'tuple'>
\end{verbatim}

Mit dem Slice Operator kann ein bestimmter Rückgabewert ausgewählt
werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(ergebnis[}\DecValTok{2}\NormalTok{])}

\NormalTok{summe\_potenzen }\OperatorTok{=}\NormalTok{ sum\_potenzen(}\DecValTok{2}\NormalTok{, }\DecValTok{7}\NormalTok{, ausgabe }\OperatorTok{=} \VariableTok{False}\NormalTok{, p }\OperatorTok{=} \DecValTok{4}\NormalTok{)[}\DecValTok{2}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(summe\_potenzen, }\BuiltInTok{type}\NormalTok{(summe\_potenzen))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2417
2417 <class 'int'>
\end{verbatim}

\section{Aufgaben Funktionen
definieren}\label{aufgaben-funktionen-definieren}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Palindrom\\
  Schreiben Sie eine Funktion is\_palindrome(), die prüft, ob es sich
  bei einer übergebenen Zeichenkette um ein Palindrom handelt.
\end{enumerate}

\emph{Hinweis: Ein Palindrom ist eine Zeichenkette, die von vorne und
von hinten gelesen gleich bleibt, wie beispielsweise `Anna', `Otto',
`Lagerregal'. Palindrome müssen nicht aus Buchstaben bestehen, sie
können sich auch aus Zahlen oder Buchstaben und Zahlen zusammensetzen
wie beispielsweise `345g543'.}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Fibonacci-Zahlenreihe
\end{enumerate}

Entwickeln Sie eine Funktion fibonacci(n), die die ersten n Zahlen der
Fibonacci-Reihe generiert und als Liste zurückgibt. Die Fibonacci-Reihe
beginnt mit 0 und 1, jede weitere Zahl ist die Summe der beiden
vorhergehenden Zahlen.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Verschlüsselung
\end{enumerate}

Bei Geocachen werden oft verschlüsselte Botschaften als Rätsel
verwendet. Oft wird folgende Logik zur Verschlüsselung angewendet:

\begin{itemize}
\item
  A -\textgreater{} Z
\item
  B -\textgreater{} Y
\item
  C -\textgreater{} X
\item
  \ldots{}
\end{itemize}

Schreiben Sie eine Funktion \texttt{verschluesseln(str)}, die einen
String als Eingabewert bekommt und einen verschlüsselten String
zurückgibt. Wie können Sie einen verschlüsselten String am einfachsten
wieder entschlüsseln?

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Temperaturkonverter
\end{enumerate}

Entwickeln Sie eine Funktion
\texttt{temperatur\_umrechnen(wert,\ von\_einheit,\ nach\_einheit)}, die
eine Temperatur von einer Einheit in eine andere umwandelt. Die Funktion
soll folgende Parameter verwenden:

\begin{itemize}
\item
  wert: Der Temperaturwert, der umgewandelt werden soll.
\item
  von\_einheit / nach\_einheit: Die Einheit des Ausgangs- bzw. des
  Zielwerts als string. Mögliche Werte sind `C' für Celsius, `F' für
  Fahrenheit und `K' für Kelvin.
\end{itemize}

Es gelten die folgenden Umrechnungsformeln zwischen den Einheiten:

\begin{itemize}
\item
  Celsius nach Fahrenheit: F = C * 9/5 + 32
\item
  Fahrenheit nach Celsius: C = (F - 32) * 5/9
\item
  Celsius nach Kelvin: K = C + 273.15
\item
  Kelvin nach Celsius: C = K - 273.15
\item
  Fahrenheit nach Kelvin: K = (F - 32) * 5/9 + 273.15
\item
  Kelvin nach Fahrenheit: F = (K - 273.15) * 9/5 + 32
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Musterlösung Aufgaben Funktionen definieren}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Aufgabe Palindrom
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 1.}
\KeywordTok{def}\NormalTok{ is\_palindrome(text):}
\NormalTok{    text }\OperatorTok{=}\NormalTok{ text.lower()}

    \ControlFlowTok{return}\NormalTok{ text }\OperatorTok{==}\NormalTok{ text[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}

\CommentTok{\# zu prüfende Zeichenkette in dieser Variablen anlegen}
\NormalTok{xyz }\OperatorTok{=} \StringTok{"Lagerregal"}
\ControlFlowTok{if}\NormalTok{ is\_palindrome(xyz) }\OperatorTok{==} \VariableTok{True}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Ja, }\SpecialCharTok{\{}\NormalTok{xyz}\SpecialCharTok{\}}\SpecialStringTok{ ist ein Palindrom"}\NormalTok{)}
\ControlFlowTok{else}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Nein, }\SpecialCharTok{\{}\NormalTok{xyz}\SpecialCharTok{\}}\SpecialStringTok{ ist kein Palindrom"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Ja, Lagerregal ist ein Palindrom
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Aufgabe Fibonacci
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 2.}
\KeywordTok{def}\NormalTok{ fibonacci(n):}

    \CommentTok{\# die Sonderfälle müssen beachtet werden:}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textless{}=} \DecValTok{0}\NormalTok{:}
        \ControlFlowTok{return}\NormalTok{ []}
    \ControlFlowTok{elif}\NormalTok{ n }\OperatorTok{==} \DecValTok{1}\NormalTok{:}
        \ControlFlowTok{return}\NormalTok{ [}\DecValTok{0}\NormalTok{]}

    \CommentTok{\# nachdem die beiden Sonderfälle berücksichtigt wurden, sieht die Liste zum Start immer wie folgt aus:}
\NormalTok{    fibonacci\_reihe }\OperatorTok{=}\NormalTok{ [}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{]}
    
    \ControlFlowTok{while} \BuiltInTok{len}\NormalTok{(fibonacci\_reihe) }\OperatorTok{\textless{}}\NormalTok{ n:}
\NormalTok{        naechste\_zahl }\OperatorTok{=}\NormalTok{ fibonacci\_reihe[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{] }\OperatorTok{+}\NormalTok{ fibonacci\_reihe[}\OperatorTok{{-}}\DecValTok{2}\NormalTok{]}
\NormalTok{        fibonacci\_reihe.append(naechste\_zahl)}
    
    \ControlFlowTok{return}\NormalTok{ fibonacci\_reihe}

\NormalTok{fibonacci(}\DecValTok{8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[0, 1, 1, 2, 3, 5, 8, 13]
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Aufgabe Verschlüsselung
\end{enumerate}

\section{mit Listen}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 3.}
\KeywordTok{def}\NormalTok{ verschluesseln(}\BuiltInTok{str}\NormalTok{):}

    \CommentTok{\# in sechs Variablen wird einmal das normale und einmal das umgekehrte Alphabet sowie die Ziffern 0{-}9 definiert}
\NormalTok{    abc }\OperatorTok{=} \StringTok{"abcdefghijklmnopqrstuvwxyz"}
\NormalTok{    abc\_2 }\OperatorTok{=} \StringTok{"zyxwvutsrqponmlkjihgfedcba"}
\NormalTok{    ABC }\OperatorTok{=} \StringTok{"ABCDEFGHIJKLMNOPQRSTUVWXYZ"}
\NormalTok{    ABC\_2 }\OperatorTok{=} \StringTok{"ZYXWVUTSRQPONMLKJIHGFEDCBA"}
\NormalTok{    ziffern }\OperatorTok{=} \StringTok{"0123456789"}
\NormalTok{    ziffern\_2 }\OperatorTok{=} \StringTok{"9876543210"}

\NormalTok{    neuer\_string }\OperatorTok{=} \StringTok{""}

    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{str}\NormalTok{:}
        \ControlFlowTok{if}\NormalTok{ i }\KeywordTok{in}\NormalTok{ ABC: }\CommentTok{\# Großbuchstaben}
\NormalTok{            position }\OperatorTok{=}\NormalTok{ ABC.index(i)}
\NormalTok{            neuer\_buchstabe }\OperatorTok{=}\NormalTok{ ABC\_2[position]}

\NormalTok{            neuer\_string }\OperatorTok{+=}\NormalTok{ neuer\_buchstabe}
        \ControlFlowTok{elif}\NormalTok{ i }\KeywordTok{in}\NormalTok{ abc: }\CommentTok{\# Kleinbuchstaben}
\NormalTok{            position }\OperatorTok{=}\NormalTok{ abc.index(i)}
\NormalTok{            neuer\_buchstabe }\OperatorTok{=}\NormalTok{ abc\_2[position]}

\NormalTok{            neuer\_string }\OperatorTok{+=}\NormalTok{ neuer\_buchstabe   }
        \ControlFlowTok{elif}\NormalTok{ i }\KeywordTok{in}\NormalTok{ ziffern: }\CommentTok{\# Ziffern}
\NormalTok{            position }\OperatorTok{=}\NormalTok{ ziffern.index(i)}
\NormalTok{            neuer\_buchstabe }\OperatorTok{=}\NormalTok{ ziffern\_2[position]}

\NormalTok{            neuer\_string }\OperatorTok{+=}\NormalTok{ neuer\_buchstabe                    }
        \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# sonstige Zeichen werden unverändert übernommen}
\NormalTok{            neuer\_string }\OperatorTok{+=}\NormalTok{ i}
    
    \ControlFlowTok{return}\NormalTok{ neuer\_string}
    
\CommentTok{\# zu verschlüsselnde Nachricht:}
\NormalTok{geheime\_nachricht }\OperatorTok{=} \StringTok{\textquotesingle{}Dies ist das Geheimnis: \textless{}*)))\textgreater{}\textless{}\textquotesingle{}}
\NormalTok{enkodierter\_text }\OperatorTok{=}\NormalTok{ verschluesseln(geheime\_nachricht)}
\BuiltInTok{print}\NormalTok{(enkodierter\_text)}

\CommentTok{\# die einfachste Möglichkeit die verschlüsselte Nachricht wieder zu entschlüsseln ist, die gleiche Funktion erneut auf die verschlüsselte Nachricht anzuwenden}
\NormalTok{dekodierter\_text }\OperatorTok{=}\NormalTok{ verschluesseln(enkodierter\_text)}
\BuiltInTok{print}\NormalTok{(dekodierter\_text)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Wrvh rhg wzh Tvsvrnmrh: <*)))><
Dies ist das Geheimnis: <*)))><
\end{verbatim}

\section{mit ord() und chr()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ verschluesseln(a):}
\NormalTok{    a }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(a)}
    \CommentTok{\# print(a)}
\NormalTok{    b }\OperatorTok{=}\NormalTok{ [] }\CommentTok{\# output list}
    
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ a:}
        \CommentTok{\# print(i, ord(i))}
\NormalTok{        b.append(}\BuiltInTok{ord}\NormalTok{(i))}
    \CommentTok{\# print(b)}
            
    \CommentTok{\# invertieren a = 97, z = 122, A = 65, Z = 90, 0 = 48, 9 = 57}
    \CommentTok{\# Max {-} Wert + Min }
    
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(b)):}
        \ControlFlowTok{if}\NormalTok{ b[i] }\OperatorTok{\textgreater{}=} \DecValTok{65} \KeywordTok{and}\NormalTok{ b[i] }\OperatorTok{\textless{}=} \DecValTok{90}\NormalTok{: }\CommentTok{\# Großbuchstaben}
\NormalTok{            b[i] }\OperatorTok{=} \BuiltInTok{chr}\NormalTok{(}\DecValTok{90} \OperatorTok{{-}}\NormalTok{ b[i] }\OperatorTok{+} \DecValTok{65}\NormalTok{)}
        \ControlFlowTok{elif}\NormalTok{ b[i] }\OperatorTok{\textgreater{}=} \DecValTok{97} \KeywordTok{and}\NormalTok{ b[i] }\OperatorTok{\textless{}=} \DecValTok{122}\NormalTok{: }\CommentTok{\# Kleinbuchstaben}
\NormalTok{            b[i] }\OperatorTok{=} \BuiltInTok{chr}\NormalTok{(}\DecValTok{122} \OperatorTok{{-}}\NormalTok{ b[i] }\OperatorTok{+} \DecValTok{97}\NormalTok{)}
        \ControlFlowTok{elif}\NormalTok{ b[i] }\OperatorTok{\textgreater{}=} \DecValTok{48} \KeywordTok{and}\NormalTok{ b[i] }\OperatorTok{\textless{}=} \DecValTok{57}\NormalTok{: }\CommentTok{\# Zahlen}
\NormalTok{            b[i] }\OperatorTok{=} \BuiltInTok{chr}\NormalTok{(}\DecValTok{57} \OperatorTok{{-}}\NormalTok{ b[i] }\OperatorTok{+} \DecValTok{48}\NormalTok{) }
        \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# sonstige Zeichen}
\NormalTok{            b[i] }\OperatorTok{=} \BuiltInTok{chr}\NormalTok{(b[i])}
            
    \ControlFlowTok{return} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{.join(b)}

\BuiltInTok{print}\NormalTok{(enkodierter\_text)}
\BuiltInTok{print}\NormalTok{(verschluesseln(a }\OperatorTok{=}\NormalTok{ enkodierter\_text))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Wrvh rhg wzh Tvsvrnmrh: <*)))><
Dies ist das Geheimnis: <*)))><
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Temperaturkonverter
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 4.}
\KeywordTok{def}\NormalTok{ temperatur\_umrechnen(wert, von\_einheit, nach\_einheit):}

    \CommentTok{\# if{-}Abfragen um zu prüfen, welche Einheit der umzuwandelnde Wert hat. Je nachdem welcher Zweig ausgelöst wird, wird der Wert in weiteren if{-}Abfragen entsprechend der Zieleinheit umgerechnet}
    
    \CommentTok{\# if{-}Abfrage für Ursprungswert in Celsius:}
    \ControlFlowTok{if}\NormalTok{ von\_einheit }\OperatorTok{==} \StringTok{"C"}\NormalTok{:}
        \ControlFlowTok{if}\NormalTok{ nach\_einheit }\OperatorTok{==} \StringTok{"F"}\NormalTok{:}
            \ControlFlowTok{return}\NormalTok{ wert }\OperatorTok{*} \DecValTok{9}\OperatorTok{/}\DecValTok{5} \OperatorTok{+} \DecValTok{32}
        \ControlFlowTok{elif}\NormalTok{ nach\_einheit }\OperatorTok{==} \StringTok{"K"}\NormalTok{:}
            \ControlFlowTok{return}\NormalTok{ wert }\OperatorTok{+} \FloatTok{273.15}
        \ControlFlowTok{elif}\NormalTok{ nach\_einheit }\OperatorTok{==} \StringTok{"C"}\NormalTok{:}
            \ControlFlowTok{return}\NormalTok{ wert}
    
    \CommentTok{\# if{-}Abfrage für Ursprungswert in Fahrenheit:}
    \ControlFlowTok{if}\NormalTok{ von\_einheit }\OperatorTok{==} \StringTok{"F"}\NormalTok{:}
        \ControlFlowTok{if}\NormalTok{ nach\_einheit }\OperatorTok{==} \StringTok{"C"}\NormalTok{:}
            \ControlFlowTok{return}\NormalTok{ (wert }\OperatorTok{{-}} \DecValTok{32}\NormalTok{) }\OperatorTok{*} \DecValTok{5}\OperatorTok{/}\DecValTok{9}
        \ControlFlowTok{elif}\NormalTok{ nach\_einheit }\OperatorTok{==} \StringTok{"K"}\NormalTok{:}
            \ControlFlowTok{return}\NormalTok{ (wert }\OperatorTok{{-}} \DecValTok{32}\NormalTok{) }\OperatorTok{*} \DecValTok{5}\OperatorTok{/}\DecValTok{9} \OperatorTok{+} \FloatTok{273.15}
        \ControlFlowTok{elif}\NormalTok{ nach\_einheit }\OperatorTok{==} \StringTok{"F"}\NormalTok{:}
            \ControlFlowTok{return}\NormalTok{ wert}
    
    \CommentTok{\# if{-}Abfrage für Ursprungswert in Kelvin:}
    \ControlFlowTok{if}\NormalTok{ von\_einheit }\OperatorTok{==} \StringTok{"K"}\NormalTok{:}
        \ControlFlowTok{if}\NormalTok{ nach\_einheit }\OperatorTok{==} \StringTok{"C"}\NormalTok{:}
            \ControlFlowTok{return}\NormalTok{ wert }\OperatorTok{{-}} \FloatTok{273.15}
        \ControlFlowTok{elif}\NormalTok{ nach\_einheit }\OperatorTok{==} \StringTok{"F"}\NormalTok{:}
            \ControlFlowTok{return}\NormalTok{ (wert }\OperatorTok{{-}} \FloatTok{273.15}\NormalTok{) }\OperatorTok{*} \DecValTok{9}\OperatorTok{/}\DecValTok{5} \OperatorTok{+} \DecValTok{32}
        \ControlFlowTok{elif}\NormalTok{ nach\_einheit }\OperatorTok{==} \StringTok{"K"}\NormalTok{:}
            \ControlFlowTok{return}\NormalTok{ wert}

    \CommentTok{\# für ungültige Einheiten wird None zurückgegeben    }
    \ControlFlowTok{return} \VariableTok{None}

\NormalTok{test\_temp }\OperatorTok{=}\NormalTok{ temperatur\_umrechnen(}\DecValTok{37}\NormalTok{, }\StringTok{"C"}\NormalTok{, }\StringTok{"F"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"37°C sind in Fahrenheit: }\SpecialCharTok{\{}\NormalTok{test\_temp}\SpecialCharTok{\}}\SpecialStringTok{°F"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
37°C sind in Fahrenheit: 98.6°F
\end{verbatim}

Musterlösung von Marc Sönnecken und Maik Poetzsch

\end{tcolorbox}

~ (@Arnold-2023-funktionen-module-dateien)

\chapter{Dateien lesen und schreiben}\label{dateien-lesen-und-schreiben}

Maya und Hans haben je sechs Mal einen Würfel geworfen und ihre
Wurfergebnisse in einer .txt-Datei protokolliert. Wir wollen die Dateien
mit Python auswerten, um zu bestimmen, wer von beiden in Summe die
höchste Augenzahl erreicht hat.

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Daten & Dateiname \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Würfelergebnisse Maya & dice-maya.txt \\
Würfelergebnisse Hans & dice-hans.txt \\
\end{longtable}

~

\section{Dateiobjekte}\label{dateiobjekte}

Um mit Python auf eine Datei zuzugreifen, muss diese fürs Lesen oder
Schreiben geöffnet werden. Dazu wird in Python die Funktion
\href{https://docs.python.org/3/library/functions.html\#open}{open}
verwendet. Diese nimmt zwei Argumente, den Pfad der Datei und den
Zugriffsmodus, an und liefert ein
\href{https://docs.python.org/3/glossary.html\#term-file-object}{Dateiobjekt}
zurück. Aus dem Dateiobjekt werden dann die Inhalte der Datei
ausgelesen.

\subsection{Dateipfad}\label{dateipfad}

Der lokale Dateipfad wird ausgehend vom aktuellen Arbeitsverzeichnis
angegeben.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pfad\_maya }\OperatorTok{=} \StringTok{"01{-}daten/dice{-}maya.txt"}
\NormalTok{pfad\_hans }\OperatorTok{=} \StringTok{"01{-}daten/dice{-}hans.txt"}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-wd-Python}: Arbeitsverzeichnis in Python ermitteln und wechseln}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-wd-Python} 

Der Pfad des aktuellen Arbeitsverzeichnisses kann mit dem Modul os
mittels \texttt{os.getcwd()} ermittelt werden (hier ohne Ausgabe). Mit
\texttt{os.chdir(\textquotesingle{}neuer\_pfad\textquotesingle{})} kann
das Arbeitsverzeichnis ggf. gewechselt werden. Die korrekte Formatierung
des Pfads erkennen Sie an der Ausgabe von \texttt{os.getcwd()}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ os}
\BuiltInTok{print}\NormalTok{(os.getcwd())}
\end{Highlighting}
\end{Shaded}

Das Importieren von Modulen wird in einem späteren Kapitel behandelt.

\end{tcolorbox}

\subsection{Zugriffsmodus}\label{zugriffsmodus}

Als Zugriffsmodus stehen unter anderem folgende Optionen zur Verfügung:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.2143}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.7857}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Modus
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Beschreibung
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{r} & lesender Zugriff \\
\texttt{w} & Schreibzugriff, Datei wird überschrieben \\
\texttt{x} & Erzeugt die Datei, Fehlermeldung, wenn die Datei bereits
existiert \\
\texttt{a} & Schreibzugriff, Inhalte werden angehängt \\
\texttt{b} & Binärmodus (z. B. für Grafiken) \\
\texttt{t} & Textmodus, default \\
\end{longtable}

~

Die Zugriffsmodi können auch kombiniert werden. Weitere Informationen
dazu finden Sie in der
\href{https://docs.python.org/3/library/functions.html\#open}{Dokumentation}.
Sofern nicht im Binärmodus auf Dateien zugegriffen wird, liefert die
Funktion \texttt{open()} den Dateiinhalt als string zurück.

Im Lesemodus wird ein Datenobjekt erzeugt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{daten\_maya }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(pfad\_maya, mode }\OperatorTok{=} \StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(daten\_maya)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<_io.TextIOWrapper name='01-daten/dice-maya.txt' mode='r' encoding='UTF-8'>
\end{verbatim}

Wenn das Datenobjekt \texttt{daten\_maya} der Funktion \texttt{print()}
übergeben wird, gibt Python die Klasse des Objekts zurück, in diesem
Fall also \_io.TextIOWrapper. Diese Klasse stammt aus dem Modul io und
ist für das Lesen und Schreiben von Textdateien zuständig. Ebenfalls
werden als Attribute des Dateiobjekts der Dateipfad, der Zugriffsmodus
und die Enkodierung der Datei ausgegeben (siehe
Note~\ref{nte-attribute}). Sollte die Enkodierung nicht automatisch als
UTF-8 erkannt werden, kann diese mit dem Argument
\texttt{encoding\ =\ \textquotesingle{}UTF-8\textquotesingle{}}
übergeben werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{daten\_maya }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(pfad\_maya, mode }\OperatorTok{=} \StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{, encoding }\OperatorTok{=} \StringTok{\textquotesingle{}UTF{-}8\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(daten\_maya)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<_io.TextIOWrapper name='01-daten/dice-maya.txt' mode='r' encoding='UTF-8'>
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-attribute}: Attribute eines Objekts bestimmen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-attribute} 

Mit der Funktion \texttt{dir(objekt)} können die verfügbaren Attribute
eines Objekts ausgegeben werden. Dabei werden jedoch auch die vererbten
Attribute und Methoden der Klasse des Objekts ausgegeben, sodass die
Ausgabe oft sehr umfangreich ist. Zum Beispiel für die Ganzzahl 1:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{dir}\NormalTok{(}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__getstate__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_count', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'is_integer', 'numerator', 'real', 'to_bytes']
\end{verbatim}

Um die Ausgabe auf Attribute einzugrenzen, kann folgende Funktion
verwendet werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{objekt }\OperatorTok{=} \DecValTok{1}

\NormalTok{attribute }\OperatorTok{=}\NormalTok{ [attr }\ControlFlowTok{for}\NormalTok{ attr }\KeywordTok{in} \BuiltInTok{dir}\NormalTok{(objekt) }\ControlFlowTok{if} \KeywordTok{not} \BuiltInTok{callable}\NormalTok{ (}\BuiltInTok{getattr}\NormalTok{(objekt, attr))]}
\BuiltInTok{print}\NormalTok{(attribute)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['__doc__', 'denominator', 'imag', 'numerator', 'real']
\end{verbatim}

Mit doppelten Unterstrichen umschlossene Attribute sind für Python
reserviert und nicht für den:die Nutzer:in gedacht. Folgende Funktion
entfernt Attribute mit doppelten Unterstrichen aus der Ausgabe:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{objekt }\OperatorTok{=} \DecValTok{1}

\NormalTok{attribute }\OperatorTok{=}\NormalTok{ [attr }\ControlFlowTok{for}\NormalTok{ attr }\KeywordTok{in} \BuiltInTok{dir}\NormalTok{(objekt) }\ControlFlowTok{if} \KeywordTok{not}\NormalTok{ (}\BuiltInTok{callable}\NormalTok{(}\BuiltInTok{getattr}\NormalTok{(objekt, attr)) }\KeywordTok{or}\NormalTok{ attr.startswith(}\StringTok{\textquotesingle{}\_\_\textquotesingle{}}\NormalTok{))]}
\BuiltInTok{print}\NormalTok{(attribute)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['denominator', 'imag', 'numerator', 'real']
\end{verbatim}

Im Fall einer Ganzzahl können Attribute (zur Abgrenzung von
Gleitkommazahlen in umschließenden Klammern) wie folgt aufgerufen
werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\DecValTok{1}\NormalTok{).numerator}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

Wenn wir uns die Attribute des Dateiobjekts `daten\_maya' ansehen,
fallen Attribute mit einem einzelnen führenden Unterstrich auf.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{objekt }\OperatorTok{=}\NormalTok{ daten\_maya}

\NormalTok{attribute }\OperatorTok{=}\NormalTok{ [attr }\ControlFlowTok{for}\NormalTok{ attr }\KeywordTok{in} \BuiltInTok{dir}\NormalTok{(objekt) }\ControlFlowTok{if} \KeywordTok{not}\NormalTok{ (}\BuiltInTok{callable}\NormalTok{(}\BuiltInTok{getattr}\NormalTok{(objekt, attr)) }\KeywordTok{or}\NormalTok{ attr.startswith(}\StringTok{\textquotesingle{}\_\_\textquotesingle{}}\NormalTok{))]}
\BuiltInTok{print}\NormalTok{(attribute)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['_CHUNK_SIZE', '_finalizing', 'buffer', 'closed', 'encoding', 'errors', 'line_buffering', 'mode', 'name', 'newlines', 'write_through']
\end{verbatim}

Hierbei handelt es sich um Attribute, die nicht durch den:die Nutzer:in
aufgerufen werden sollen (weitere Informationen dazu finden Sie
\href{https://dbader.org/blog/meaning-of-underscores-in-python}{hier}).
Folgender Programmcode gibt alle Attribute ohne führende Unterstriche
aus:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{objekt }\OperatorTok{=}\NormalTok{ daten\_maya}

\NormalTok{attribute }\OperatorTok{=}\NormalTok{ [attr }\ControlFlowTok{for}\NormalTok{ attr }\KeywordTok{in} \BuiltInTok{dir}\NormalTok{(objekt) }\ControlFlowTok{if} \KeywordTok{not}\NormalTok{ (}\BuiltInTok{callable}\NormalTok{(}\BuiltInTok{getattr}\NormalTok{(objekt, attr)) }\KeywordTok{or}\NormalTok{ attr.startswith(}\StringTok{\textquotesingle{}\_\textquotesingle{}}\NormalTok{))]}
\BuiltInTok{print}\NormalTok{(attribute)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['buffer', 'closed', 'encoding', 'errors', 'line_buffering', 'mode', 'name', 'newlines', 'write_through']
\end{verbatim}

\end{tcolorbox}

Die Attribute der Datei können mit entsprechenden Befehlen abgerufen
werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Dateipfad: }\SpecialCharTok{\{}\NormalTok{daten\_maya}\SpecialCharTok{.}\NormalTok{name}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Dateiname: }\SpecialCharTok{\{}\NormalTok{os}\SpecialCharTok{.}\NormalTok{path}\SpecialCharTok{.}\NormalTok{basename(daten\_maya.name)}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Datei ist geschlossen: }\SpecialCharTok{\{}\NormalTok{daten\_maya}\SpecialCharTok{.}\NormalTok{closed}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Zugriffsmodus: }\SpecialCharTok{\{}\NormalTok{daten\_maya}\SpecialCharTok{.}\NormalTok{mode}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Enkodierung: }\SpecialCharTok{\{}\NormalTok{daten\_maya}\SpecialCharTok{.}\NormalTok{encoding}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Dateipfad: 01-daten/dice-maya.txt
Dateiname: dice-maya.txt
Datei ist geschlossen: False
Zugriffsmodus: r
Enkodierung: UTF-8
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-rückfalloption}: Rückfalloption}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-rückfalloption} 

In der Datenanalyse werden in der Regel spezialisierte Pakete wie NumPy
oder Pandas verwendet. Diese vereinfachen das Einlesen von Dateien
gegenüber der Pythonbasis erheblich. Dennoch ist es sinnvoll, sich mit
den Methoden der Pythonbasis zum Einlesen von Dateien vertraut zu
machen. Denn das Einlesen mit der Funktion \texttt{open()} klappt so gut
wie immer - es ist eine gute Rückfalloption.

\end{tcolorbox}

\subsection{Dateiinhalt ausgeben}\label{sec-dateiinhalt}

Um den Dateiinhalt auszugeben, kann das Datenobjekt mit einer Schleife
zeilenweise durchlaufen und ausgegeben werden. (Die Datei dice-maya hat
nur eine Zeile.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i }\OperatorTok{=} \DecValTok{0}
\ControlFlowTok{for}\NormalTok{ zeile }\KeywordTok{in}\NormalTok{ daten\_maya:}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Inhalt Zeile }\SpecialCharTok{\{}\NormalTok{i}\SpecialCharTok{\}}\SpecialStringTok{, mit }\SpecialCharTok{\{}\BuiltInTok{len}\NormalTok{(zeile)}\SpecialCharTok{\}}\SpecialStringTok{ Zeichen:"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(zeile)}
\NormalTok{    i }\OperatorTok{+=} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Inhalt Zeile 0, mit 28 Zeichen:
"5", "6", "2", "1", "4", "5"
\end{verbatim}

Dies ist jedoch für größere Dateien nicht sonderlich praktikabel. Die
Ausgabe einzelner Zeilen mit der Funktion \texttt{print()} kann aber
nützlich sein, um die genaue Formatierung der Zeichenkette zu prüfen. In
diesem Fall hat Maya ihre Daten in Anführungszeichen gesetzt und mit
einem Komma voneinander getrennt.

\section{Dateien einlesen}\label{dateien-einlesen}

Um den gesamten Inhalt einer Datei einzulesen, kann die Methode
\href{https://docs.python.org/3/tutorial/inputoutput.html}{datenobjekt.read()}
verwendet werden. Die Methode hat als optionalen Parameter
\texttt{.read(size)}. size wird als Ganzzahl übergeben und entsprechend
viele Zeichen (im Binärmodus entsprechend viele Bytes) werden ggf. bis
zum Dateiende ausgelesen. Der Parameter \texttt{size} ist nützlich, um
die Formatierung des Inhalts einer großen Datei zu prüfen und dabei die
Ausgabe auf eine überschaubare Anzahl von Zeichen zu begrenzen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{augen\_maya }\OperatorTok{=}\NormalTok{ daten\_maya.read()}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"len(augen\_maya): }\SpecialCharTok{\{}\BuiltInTok{len}\NormalTok{(augen\_maya)}\SpecialCharTok{\}}\CharTok{\textbackslash{}n\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Inhalt der Datei augen\_maya:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{augen\_maya}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
len(augen_maya): 0

Inhalt der Datei augen_maya:
\end{verbatim}

Das hat offensichtlich nicht geklappt, der ausgelesene Dateiinhalt ist
leer! Der Grund dafür ist, dass beim Lesen (und beim Schreiben) einer
Datei der Dateizeiger die Datei durchläuft. Nachdem die Datei
daten\_maya in Section~\ref{sec-dateiinhalt} zeilenweise ausgegeben
wurde, steht der Dateizeiger am Ende der Datei.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-Dateizeiger} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-Dateizeiger}: Dateizeiger in Python}\vspace{3mm}

Wird eine Datei zeilenweise oder mit der Methode \texttt{.read()}
ausgelesen, wird der Dateizeiger um die angegebene Zeichenzahl bzw. bis
ans Ende der Datei bewegt. Wird beispielsweise ein Datensatz `daten'
geöffnet und mit der Methode \texttt{daten.read(3)} die ersten drei
Zeichen ausgelesen, bewegt sich der Dateizeiger von der Indexposition 0
zur Indexposition 3 (bzw. steht jeweils davor).

\begin{figure}[H]

\begin{minipage}{0.50\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{books/w-python/skript/00-bilder/indexposition-0.png}}\end{minipage}%
%
\begin{minipage}{0.50\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{books/w-python/skript/00-bilder/indexposition-3.png}}\end{minipage}%

\caption{\label{fig-Dateizeiger}Bewegung des Dateizeigers beim Auslesen
von drei Zeichen}

\end{figure}%

Die Methode \texttt{daten.tell()} gibt zurück, an welcher Position sich
der Dateizeiger befindet.

Mit der Methode \texttt{daten.seek(offset,\ whence\ =\ 0)} wird der
Zeiger an eine bestimmte Position gesetzt. Die Methode akzeptiert das
Argument offset (Versatz) und das optionale Argument whence (woher),
dessen Standardwert 0 (Dateianfang) ist. Für Zugriffe \textbf{im
Binärmodus}
(\texttt{open(pfad,\ mode\ =\ \textquotesingle{}rb\textquotesingle{})})
kann das Argument whence außerdem die Werte 1 (aktuelle Position) oder 2
(Dateiende) annehmen.

\begin{itemize}
\item
  \texttt{daten.seek(0,\ 0)} bezeichnet den Dateianfang
\item
  \texttt{daten.seek(0,\ 1)} bezeichnet die aktuelle Position in der
  Datei
\item
  \texttt{daten.seek(0,\ 2)} bezeichnet das Dateiende
\item
  \texttt{daten.seek(-3,\ 2)} bezeichnet das dritte Zeichen vor dem
  Dateiende
\end{itemize}

\end{minipage}%
\end{tcolorbox}

Wird der Dateizeiger mit der Methode \texttt{datenobjekt.seek(0)} an den
Dateianfang gestellt, gelingt das Auslesen der Datei.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Position des Dateizeigers vor dem Zurücksetzen auf 0: }\SpecialCharTok{\{}\NormalTok{daten\_maya}\SpecialCharTok{.}\NormalTok{tell()}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{daten\_maya.seek(}\DecValTok{0}\NormalTok{)}\OperatorTok{;}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Position des Dateizeigers nach dem Zurücksetzen auf 0: }\SpecialCharTok{\{}\NormalTok{daten\_maya}\SpecialCharTok{.}\NormalTok{tell()}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{augen\_maya }\OperatorTok{=}\NormalTok{ daten\_maya.read()}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Inhalt des Objekts augen\_maya:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{augen\_maya}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Position des Dateizeigers vor dem Zurücksetzen auf 0: 28
Position des Dateizeigers nach dem Zurücksetzen auf 0: 0
Inhalt des Objekts augen_maya:
"5", "6", "2", "1", "4", "5"
\end{verbatim}

\textbf{Geben Sie aus dem Datenobjekt daten\_maya mit den Methoden
.seek() und .read() die Zahlen and zweiter und dritter Stelle, also 6
und 2, aus.}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-Musterlösung-Zeigerposition}: Musterlösung Dateizeiger bewegen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-Musterlösung-Zeigerposition} 

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{daten\_maya.seek(}\DecValTok{6}\NormalTok{, }\DecValTok{0}\NormalTok{)}\OperatorTok{;}
\BuiltInTok{print}\NormalTok{(daten\_maya.read(}\DecValTok{1}\NormalTok{))}

\NormalTok{daten\_maya.seek(daten\_maya.tell() }\OperatorTok{+} \DecValTok{4}\NormalTok{, }\DecValTok{0}\NormalTok{)}\OperatorTok{;}
\BuiltInTok{print}\NormalTok{(daten\_maya.read(}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
6
2
\end{verbatim}

\end{tcolorbox}

Um Mayas Würfelergebnisse zu addieren, müssen die Zahlen extrahiert und
in Ganzzahlen umgewandelt werden, da im Textmodus stets eine
Zeichenfolge zurückgegeben wird.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(augen\_maya))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'str'>
\end{verbatim}

Dazu werden mit der Methode \texttt{str.strip(")} das führende und
abschließende Anführungszeichen entfernt sowie anschließend mit der
Methode \texttt{str.split(\textquotesingle{}",\ "\textquotesingle{})}
die Zeichenfolge über das Trennzeichen in eine Liste aufgeteilt.
Anschließend werden die Listenelemente in Ganzzahlen umgewandelt und
summiert. (Methoden der string-Bearbeitung werden im nächsten Abschnitt
ausführlich behandelt.)

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"augen\_maya:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{augen\_maya}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{augen\_maya }\OperatorTok{=}\NormalTok{ augen\_maya.strip(}\StringTok{\textquotesingle{}"\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{augen\_maya.strip(\textquotesingle{}}\CharTok{\textbackslash{}"}\SpecialStringTok{\textquotesingle{}):}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{augen\_maya}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{augen\_maya }\OperatorTok{=}\NormalTok{ augen\_maya.split(}\StringTok{\textquotesingle{}", "\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{augen\_maya.split(\textquotesingle{}}\CharTok{\textbackslash{}"}\SpecialStringTok{, }\CharTok{\textbackslash{}"}\SpecialStringTok{\textquotesingle{}):}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{augen\_maya}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{augen\_maya\_int }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ augen\_maya:}
\NormalTok{  augen\_maya\_int.append(}\BuiltInTok{int}\NormalTok{(i))}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{augen\_maya\_int:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{augen\_maya\_int}\SpecialCharTok{\}}\CharTok{\textbackslash{}n\textbackslash{}n}\SpecialStringTok{Summe Augen: }\SpecialCharTok{\{}\BuiltInTok{sum}\NormalTok{(augen\_maya\_int)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
augen_maya:
"5", "6", "2", "1", "4", "5"

augen_maya.strip('"'):
5", "6", "2", "1", "4", "5

augen_maya.split('", "'):
['5', '6', '2', '1', '4', '5']

augen_maya_int:
[5, 6, 2, 1, 4, 5]

Summe Augen: 23
\end{verbatim}

\subsubsection{Datei schließen}\label{datei-schlieuxdfen}

Nach dem Zugriff auf die Datei, muss diese wieder geschlossen werden, um
diese für andere Programme freizugeben.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{daten\_maya.close()}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-Schreiboperationen} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-Schreiboperationen}: Schreiboperationen mit Python}\vspace{3mm}

Das Schließen einer Datei ist besonders für Schreiboperationen auf
Datenobjekten wichtig. Andernfalls kann es passieren, dass Inhalte mit
\texttt{datenobjekt.write()} nicht vollständig auf den Datenträger
geschrieben werden. Siehe dazu die
\href{https://docs.python.org/3/tutorial/inputoutput.html\#reading-and-writing-files}{Dokumentation}.

\end{minipage}%
\end{tcolorbox}

\section{Aufgabe Dateien einlesen}\label{aufgabe-dateien-einlesen}

\textbf{Welche Augenzahl hat Hans erreicht?}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-Musterlösung-Augenzahlvergleich}: Musterlösung Augenzahlvergleich}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-Musterlösung-Augenzahlvergleich} 

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Erst Einlesen der Datei:}
\NormalTok{daten\_hans }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(pfad\_hans, mode }\OperatorTok{=} \StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{, encoding }\OperatorTok{=} \StringTok{\textquotesingle{}UTF{-}8\textquotesingle{}}\NormalTok{)}
\NormalTok{augen\_hans }\OperatorTok{=}\NormalTok{ daten\_hans.read()}
\BuiltInTok{print}\NormalTok{(augen\_hans)}
\CommentTok{\# Hier muss man erkennen, dass Hans seinen Namen an den Anfang seiner Liste gesetzt hat. Dieser String muss also entfernt werden, bevor die Summe gebildet werden kann!}

\NormalTok{augen\_hans }\OperatorTok{=}\NormalTok{ augen\_hans.strip(}\StringTok{\textquotesingle{}"Hans", \textquotesingle{}}\NormalTok{)}
\NormalTok{augen\_hans }\OperatorTok{=}\NormalTok{ augen\_hans.strip(}\StringTok{\textquotesingle{}"\textquotesingle{}}\NormalTok{)}
\NormalTok{augen\_hans }\OperatorTok{=}\NormalTok{ augen\_hans.split(}\StringTok{\textquotesingle{}", "\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(augen\_hans)}
\CommentTok{\# print{-}Ausgabe zeigt, dass die Liste nun korrekt bereinigt wurde. Sie besteht nur noch aus Integerwerten und diese können summiert werden}

\CommentTok{\# Neue (leere) Liste für die Würfe von Hans anlegen:}
\NormalTok{augen\_hans\_int }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ augen\_hans:}
\NormalTok{   augen\_hans\_int.append(}\BuiltInTok{int}\NormalTok{(i))}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Summe Augenzahl von Hans: }\SpecialCharTok{\{}\BuiltInTok{sum}\NormalTok{(augen\_hans\_int)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"Hans", "3", "5", "1", "3", "2", "5"
['3', '5', '1', '3', '2', '5']
Summe Augenzahl von Hans: 19
\end{verbatim}

Musterlösung von Marc Sönnecken.

\end{tcolorbox}

\section{Daten interpretieren}\label{daten-interpretieren}

Datensätze liegen typischerweise wenigstens in zweidimensionaler Form
vor, d.~h. die Daten sind in Zeilen und Spalten organisiert. Außerdem
weisen Datensätze in der Regel auch unterschiedliche Datentypen auf. Die
Funktion \texttt{open(datei)} gibt ein Dateiobjekt zurück, das mit
Methoden wie zum Beispiel \texttt{dateiobjekt.read()} als Zeichenfolge
eingelesen wird. Um die Daten sinnvoll weiterverarbeiten zu können, ist
es deshalb notwendig, die Zeichenfolge korrekt zu interpretieren und
Daten von Trennzeichen zu unterscheiden.

Für die Bearbeitung von Zeichenfolgen bietet Python eine Reihe von
\href{https://docs.python.org/3/library/stdtypes.html\#string-methods}{String-Methoden}.
Einige davon werden in diesem Kapitel exemplarisch verwendet.
String-Methoden werden in der Regel mit einem führenden `str' in der
Form \texttt{str.methode()} genannt.

Beispielsweise soll eine Datei mit den Einwohnerzahlen der europäischen
Länder eingelesen werden.

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Daten & Dateiname \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Einwohner Europas & einwohner\_europa\_2019.csv \\
\end{longtable}

~

Um einen Überblick über den Aufbau der Datei zu erhalten, werden die
ersten drei Zeilen der Datei ausgegeben. Dafür kann die Datei
zeilenweise mit einer for-Schleife durchlaufen werden, die mit dem
Schlüsselwort \texttt{break} abgebrochen wird, wenn die Laufvariable den
Wert 3 erreicht hat. Eine andere Möglichkeit ist die Methode
\texttt{dateiobjekt.readline()}, die eine einzelne Zeile ausliest. Hier
wird die Häufigkeit der Schleifenausführung über die Laufvariable mit
\texttt{for\ i\ in\ range(3):} gesteuert.

\section{for-Schleife mit break}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/einwohner\_europa\_2019.csv"}
\NormalTok{dateiobjekt\_einwohner }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(dateipfad, }\StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}

\CommentTok{\# erste 3 Zeilen anschauen}
\NormalTok{i }\OperatorTok{=} \DecValTok{0}
\ControlFlowTok{for}\NormalTok{ zeile }\KeywordTok{in}\NormalTok{ dateiobjekt\_einwohner:}
  
  \BuiltInTok{print}\NormalTok{(zeile)}
\NormalTok{  i }\OperatorTok{+=} \DecValTok{1}
  \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{==} \DecValTok{3}\NormalTok{:}
    \ControlFlowTok{break}

\CommentTok{\# Datei schließen}
\NormalTok{dateiobjekt\_einwohner.close()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
GEO,Value

Belgien,11467923

Bulgarien,7000039
\end{verbatim}

\section{Methode dateiobjekt.readline()}

Mit der Methode \texttt{dateiobjekt.readline()} kann eine einzelne Zeile
eingelesen werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/einwohner\_europa\_2019.csv"}
\NormalTok{dateiobjekt\_einwohner }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(dateipfad, }\StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}

\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{3}\NormalTok{):}
  \BuiltInTok{print}\NormalTok{(dateiobjekt\_einwohner.readline())}

\CommentTok{\# Datei schließen}
\NormalTok{dateiobjekt\_einwohner.close()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
GEO,Value

Belgien,11467923

Bulgarien,7000039
\end{verbatim}

Die Datei hat also zwei Spalten. In der ersten Spalte sind die
Ländernamen eingetragen, in der zweiten Spalte die Werte. Als
Trennzeichen wird das Komma verwendet. In der ersten Zeile sind die
Spaltenbeschriftungen eingetragen.

Im vorherigen Abschnitt haben wir die Methode
\texttt{dateiobjekt.read()} kennengelernt, mit der eine Datei
vollständig als string eingelesen wird. Zunächst wird die Datei mit der
Methode \texttt{dateiobjekt.read()} in das Objekt einwohner eingelesen
und wieder geschlossen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/einwohner\_europa\_2019.csv"}
\NormalTok{dateiobjekt\_einwohner }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(dateipfad, }\StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}

\NormalTok{einwohner }\OperatorTok{=}\NormalTok{ dateiobjekt\_einwohner.read()}
\BuiltInTok{print}\NormalTok{(einwohner)}

\CommentTok{\# Datei schließen}
\NormalTok{dateiobjekt\_einwohner.close()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
GEO,Value
Belgien,11467923
Bulgarien,7000039
Tschechien,10528984
Daenemark,5799763
Deutschland einschliesslich ehemalige DDR,82940663
Estland,1324820
Irland,4904240
Griechenland,10722287
Spanien,46934632
Frankreich,67028048
Kroatien,4076246
Italien,61068437
Zypern,875898
Lettland,1919968
Litauen,2794184
Luxemburg,612179
Uganda,-1
Ungarn,9772756
Malta,493559
Niederlande,17423013
Oesterreich,8842000
Polen,37972812
Portugal,10276617
Rumaenien,19405156
Slowenien,2080908
Slowakei,5450421
Finnland,5512119
Schweden,10243000
Vereinigtes Koenigreich,66647112
\end{verbatim}

Anschließend können die eingelesenen Daten mit der Methode
\texttt{str.split(\textquotesingle{}\textbackslash{}n\textquotesingle{})}
zeilweise aufgeteilt werden. Mit
\texttt{\textquotesingle{}\textbackslash{}n\textquotesingle{}} wird als
Argument der Zeilenumbruch übergeben. Die Methode liefert eine Liste
zurück.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{liste\_einwohner\_zeilenweise }\OperatorTok{=}\NormalTok{ einwohner.split(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(liste\_einwohner\_zeilenweise[}\DecValTok{0}\NormalTok{:}\DecValTok{3}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['GEO,Value', 'Belgien,11467923', 'Bulgarien,7000039']
\end{verbatim}

Die Liste enthält an der Indexposition die Spaltenbeschriftungen. Diese
können mit der Methode \texttt{liste.pop(index)} aus der Liste entfernt
und zugleich in einem neuen Objekt gespeichert werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{spaltennamen }\OperatorTok{=}\NormalTok{ liste\_einwohner\_zeilenweise.pop(}\DecValTok{0}\NormalTok{)}
\NormalTok{spaltennamen }\OperatorTok{=}\NormalTok{ spaltennamen.split(}\StringTok{\textquotesingle{},\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Überschrift Spalte 0: }\SpecialCharTok{\{}\NormalTok{spaltennamen[}\DecValTok{0}\NormalTok{]}\SpecialCharTok{\}}\CharTok{\textbackslash{}t}\SpecialStringTok{Überschrift Spalte 1: }\SpecialCharTok{\{}\NormalTok{spaltennamen[}\DecValTok{1}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Überschrift Spalte 0: GEO   Überschrift Spalte 1: Value
\end{verbatim}

Anschließend kann die Liste mit der Methode
\texttt{str.split(\textquotesingle{},\textquotesingle{})} nach Ländern
und Werten aufgeteilt werden. Der Vorgang bricht allerdings mit einer
Fehlermeldung ab. Die Fehlermeldung wird im folgenden Code-Block per
Ausnahmebehandlung abgefangen. Neben der Fehlermeldung werden der
verursachende Listeneintrag und dessen Indexposition ausgegeben.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Leere Listen vor der Schleife anlegen}
\NormalTok{geo }\OperatorTok{=}\NormalTok{ []}
\NormalTok{einwohnerzahl }\OperatorTok{=}\NormalTok{ []}

\ControlFlowTok{try}\NormalTok{:}
  \ControlFlowTok{for}\NormalTok{ zeile }\KeywordTok{in}\NormalTok{ liste\_einwohner\_zeilenweise:}
\NormalTok{    eintrag }\OperatorTok{=}\NormalTok{ zeile.split(}\StringTok{\textquotesingle{},\textquotesingle{}}\NormalTok{)}
\NormalTok{    geo.append(eintrag[}\DecValTok{0}\NormalTok{])}
\NormalTok{    einwohnerzahl.append(eintrag[}\DecValTok{1}\NormalTok{])}

  \BuiltInTok{print}\NormalTok{(spaltennamen[}\DecValTok{0}\NormalTok{])}
  \BuiltInTok{print}\NormalTok{(geo, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

  \BuiltInTok{print}\NormalTok{(spaltennamen[}\DecValTok{1}\NormalTok{])}
  \BuiltInTok{print}\NormalTok{(einwohnerzahl)}

\ControlFlowTok{except} \PreprocessorTok{Exception} \ImportTok{as}\NormalTok{ error:}
  \CommentTok{\# print Fehlermeldung}
  \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Fehlermeldung: }\SpecialCharTok{\{}\NormalTok{error}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
  
  \CommentTok{\# print Eintrag und Index}
  \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Eintrag: }\SpecialCharTok{\{}\NormalTok{eintrag}\SpecialCharTok{\}}\CharTok{\textbackslash{}t}\SpecialStringTok{ Zeilenindex: }\SpecialCharTok{\{}\NormalTok{liste\_einwohner\_zeilenweise}\SpecialCharTok{.}\NormalTok{index(zeile)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Fehlermeldung: list index out of range
Eintrag: ['']    Zeilenindex: 29
\end{verbatim}

Die Fehlermeldung ist so zu deuten, dass eine der Listenoperationen mit
dem Slice Operator einen ungültigen Index anspricht. Leicht angepasst,
liefert der Code-Block auch die Ursache der Fehlermeldung.

Wird die leere Zeile aus der Liste entfernt, klappt das Aufteilen der
Ländernamen und der Werte.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# leere Zeile entfernen}
\NormalTok{liste\_einwohner\_zeilenweise.remove(}\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Leere Listen vor der Schleife anlegen}
\NormalTok{geo }\OperatorTok{=}\NormalTok{ []}
\NormalTok{einwohnerzahl }\OperatorTok{=}\NormalTok{ []}

\ControlFlowTok{try}\NormalTok{:}
  \ControlFlowTok{for}\NormalTok{ zeile }\KeywordTok{in}\NormalTok{ liste\_einwohner\_zeilenweise:}
\NormalTok{    eintrag }\OperatorTok{=}\NormalTok{ zeile.split(}\StringTok{\textquotesingle{},\textquotesingle{}}\NormalTok{)}
\NormalTok{    geo.append(eintrag[}\DecValTok{0}\NormalTok{])}
\NormalTok{    einwohnerzahl.append(eintrag[}\DecValTok{1}\NormalTok{])}

  \BuiltInTok{print}\NormalTok{(spaltennamen[}\DecValTok{0}\NormalTok{])}
  \BuiltInTok{print}\NormalTok{(geo, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

  \BuiltInTok{print}\NormalTok{(spaltennamen[}\DecValTok{1}\NormalTok{])}
  \BuiltInTok{print}\NormalTok{(einwohnerzahl)}

\ControlFlowTok{except} \PreprocessorTok{IndexError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(error)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
GEO
['Belgien', 'Bulgarien', 'Tschechien', 'Daenemark', 'Deutschland einschliesslich ehemalige DDR', 'Estland', 'Irland', 'Griechenland', 'Spanien', 'Frankreich', 'Kroatien', 'Italien', 'Zypern', 'Lettland', 'Litauen', 'Luxemburg', 'Uganda', 'Ungarn', 'Malta', 'Niederlande', 'Oesterreich', 'Polen', 'Portugal', 'Rumaenien', 'Slowenien', 'Slowakei', 'Finnland', 'Schweden', 'Vereinigtes Koenigreich'] 

Value
['11467923', '7000039', '10528984', '5799763', '82940663', '1324820', '4904240', '10722287', '46934632', '67028048', '4076246', '61068437', '875898', '1919968', '2794184', '612179', '-1', '9772756', '493559', '17423013', '8842000', '37972812', '10276617', '19405156', '2080908', '5450421', '5512119', '10243000', '66647112']
\end{verbatim}

\section{Aufgabe Daten
interpretieren}\label{aufgabe-daten-interpretieren}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Bestimmen Sie das Minimum und das Maximum der Einwohnerzahl und die
  dazugehörigen Länder.
\item
  Bereinigen Sie ggf. fehlerhafte Werte.
\item
  Wie viele Einwohner leben in Europa insgesamt?
\end{enumerate}

\begin{itemize}
\item
  Welchen Datentyp hat die Liste einwohnerzahl?
\item
  Welchen Datentyp haben die Einträge der Liste einwohnerzahl?
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Musterlösung vollständiges Einlesen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 1. Minimum und Maximum der Einwohnerzahlen und dazugehörige Länder bestimmen}
\NormalTok{liste\_einwohner }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ ele }\KeywordTok{in}\NormalTok{ einwohnerzahl:}
\NormalTok{     liste\_einwohner.append(}\BuiltInTok{int}\NormalTok{(ele))}

\CommentTok{\# Umwandeln der Strings in Integer bei der Einwohnerzahl}
\NormalTok{einwohnerzahl }\OperatorTok{=}\NormalTok{ [}\BuiltInTok{int}\NormalTok{(zahl) }\ControlFlowTok{for}\NormalTok{ zahl }\KeywordTok{in}\NormalTok{ einwohnerzahl]}

\CommentTok{\# 2. Fehler bereinigen}
\CommentTok{\# Sowohl der Fehler in der Liste der Einwohnerzahlen als auch das entsprechende Land werden entfernt.}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(einwohnerzahl) }\OperatorTok{{-}}\DecValTok{1}\NormalTok{,}\OperatorTok{{-}}\DecValTok{1}\NormalTok{,}\OperatorTok{{-}}\DecValTok{1}\NormalTok{): }\CommentTok{\# Hiermit wird rückwärts durch die Liste iteriert, damit das Entfernen eines Elements die Indizes der bereits durchlaufenen Elemente nicht beeinflusst}
    \ControlFlowTok{if}\NormalTok{ einwohnerzahl[i] }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{:}
\NormalTok{        einwohnerzahl.pop(i)}
\NormalTok{        geo.pop(i)}

\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(einwohnerzahl)):}
    \ControlFlowTok{if}\NormalTok{ einwohnerzahl[i] }\OperatorTok{==} \BuiltInTok{max}\NormalTok{(einwohnerzahl):}
\NormalTok{        maximum }\OperatorTok{=}\NormalTok{ i}
    \ControlFlowTok{elif}\NormalTok{ einwohnerzahl[i] }\OperatorTok{==} \BuiltInTok{min}\NormalTok{(einwohnerzahl):}
\NormalTok{        minimum }\OperatorTok{=}\NormalTok{ i}

\NormalTok{maximum\_land }\OperatorTok{=}\NormalTok{ geo[maximum]}
\NormalTok{minimum\_land }\OperatorTok{=}\NormalTok{ geo[minimum]}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Maximum: }\SpecialCharTok{\{}\NormalTok{maximum\_land}\SpecialCharTok{\}}\SpecialStringTok{ mit }\SpecialCharTok{\{}\BuiltInTok{max}\NormalTok{(einwohnerzahl)}\SpecialCharTok{\}}\SpecialStringTok{ Einwohnern"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Minimum: }\SpecialCharTok{\{}\NormalTok{minimum\_land}\SpecialCharTok{\}}\SpecialStringTok{ mit }\SpecialCharTok{\{}\BuiltInTok{min}\NormalTok{(einwohnerzahl)}\SpecialCharTok{\}}\SpecialStringTok{ Einwohnern"}\NormalTok{)}
\CommentTok{\# 3. Einwohner Europa insgesamt}

\NormalTok{pop\_gesamt }\OperatorTok{=} \BuiltInTok{sum}\NormalTok{(einwohnerzahl) }\CommentTok{\# Uganda gehört nicht zu Europa, wurde durch die Fehlerbehandlung aber bereits entfernt}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Summe aller Einwohner in Europa beträgt }\SpecialCharTok{\{}\NormalTok{pop\_gesamt}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# 4. }
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Liste einwohnerzahl hat den Datentypen }\SpecialCharTok{\{}\BuiltInTok{type}\NormalTok{(einwohnerzahl)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Einträge der Liste haben den Datentypen }\SpecialCharTok{\{}\BuiltInTok{type}\NormalTok{(einwohnerzahl[}\DecValTok{0}\NormalTok{])}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Maximum: Deutschland einschliesslich ehemalige DDR mit 82940663 Einwohnern
Minimum: Malta mit 493559 Einwohnern
Die Summe aller Einwohner in Europa beträgt 514117784
Die Liste einwohnerzahl hat den Datentypen <class 'list'>
Die Einträge der Liste haben den Datentypen <class 'int'>
\end{verbatim}

Musterlösung von Marc Sönnecken.

\end{tcolorbox}

\section{Einlesen als Liste}\label{einlesen-als-liste}

Ein Dateiobjekt kann auch direkt als Liste eingelesen werden. Die
Methode \texttt{dateiobjekt.readlines()} gibt eine Liste zurück, in der
jede Zeile einen Eintrag darstellt. Ebenso kann die Listenfunktion
\texttt{list()} auf Dateiobjekte angewendet werden. Beide
Vorgehensweisen liefern die gleiche Liste zurück, in der der
Zeilenumbruch \texttt{\textbackslash{}n} mit ausgelesen wird.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/einwohner\_europa\_2019.csv"}
\NormalTok{dateiobjekt\_einwohner }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(dateipfad, }\StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Methode readlines}
\NormalTok{einwohner }\OperatorTok{=}\NormalTok{ dateiobjekt\_einwohner.readlines()}
\BuiltInTok{print}\NormalTok{(einwohner)}

\CommentTok{\#\# Dateizeiger zurücksetzen}
\NormalTok{dateiobjekt\_einwohner.seek(}\DecValTok{0}\NormalTok{)}\OperatorTok{;}

\CommentTok{\# Funktion list}
\NormalTok{einwohner }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(dateiobjekt\_einwohner)}
\BuiltInTok{print}\NormalTok{(einwohner)}

\CommentTok{\# Datei schließen}
\NormalTok{dateiobjekt\_einwohner.close()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['GEO,Value\n', 'Belgien,11467923\n', 'Bulgarien,7000039\n', 'Tschechien,10528984\n', 'Daenemark,5799763\n', 'Deutschland einschliesslich ehemalige DDR,82940663\n', 'Estland,1324820\n', 'Irland,4904240\n', 'Griechenland,10722287\n', 'Spanien,46934632\n', 'Frankreich,67028048\n', 'Kroatien,4076246\n', 'Italien,61068437\n', 'Zypern,875898\n', 'Lettland,1919968\n', 'Litauen,2794184\n', 'Luxemburg,612179\n', 'Uganda,-1\n', 'Ungarn,9772756\n', 'Malta,493559\n', 'Niederlande,17423013\n', 'Oesterreich,8842000\n', 'Polen,37972812\n', 'Portugal,10276617\n', 'Rumaenien,19405156\n', 'Slowenien,2080908\n', 'Slowakei,5450421\n', 'Finnland,5512119\n', 'Schweden,10243000\n', 'Vereinigtes Koenigreich,66647112\n']
['GEO,Value\n', 'Belgien,11467923\n', 'Bulgarien,7000039\n', 'Tschechien,10528984\n', 'Daenemark,5799763\n', 'Deutschland einschliesslich ehemalige DDR,82940663\n', 'Estland,1324820\n', 'Irland,4904240\n', 'Griechenland,10722287\n', 'Spanien,46934632\n', 'Frankreich,67028048\n', 'Kroatien,4076246\n', 'Italien,61068437\n', 'Zypern,875898\n', 'Lettland,1919968\n', 'Litauen,2794184\n', 'Luxemburg,612179\n', 'Uganda,-1\n', 'Ungarn,9772756\n', 'Malta,493559\n', 'Niederlande,17423013\n', 'Oesterreich,8842000\n', 'Polen,37972812\n', 'Portugal,10276617\n', 'Rumaenien,19405156\n', 'Slowenien,2080908\n', 'Slowakei,5450421\n', 'Finnland,5512119\n', 'Schweden,10243000\n', 'Vereinigtes Koenigreich,66647112\n']
\end{verbatim}

Um den Zeilenumbruch zu entfernen, könnte mit dem Slice Operator das
letzte Zeichen jedes Listeneintrags entfernt werden.

Eine andere Möglichkeit ist die Methode
\texttt{str.replace(old,\ new,\ count=-1)}, mit der Zeichen ersetzt oder
gelöscht werden können. Die Parameter \texttt{old} und \texttt{new}
geben die zu ersetzende bzw. die einzusetzende Zeichenfolge an und
\emph{müssen positional} übergeben werden. Über den Parameter
\texttt{count} kann eingestellt werden, wie oft die Zeichenfolge
\texttt{old} ersetzt werden soll. Standardmäßig wird jedes Vorkommen
ersetzt.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}Hund\textquotesingle{}}\NormalTok{.replace(}\StringTok{\textquotesingle{}Hu\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Mu\textquotesingle{}}\NormalTok{))}

\NormalTok{zeichenfolge }\OperatorTok{=} \StringTok{\textquotesingle{}Ein  kurzer Text ohne  doppelte Leerzeichen.\textquotesingle{}}

\BuiltInTok{print}\NormalTok{(zeichenfolge.replace(}\StringTok{\textquotesingle{}  \textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{} \textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Mund
Ein kurzer Text ohne doppelte Leerzeichen.
\end{verbatim}

Die Methode \texttt{str.replace()} kann auch zum Löschen verwendet
werden. Wird für den Parameter \texttt{new} eine leere Zeichenfolge
übergeben, wird die in \texttt{old} übergebene Zeichenfolge gelöscht.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(zeichenfolge.replace(}\StringTok{\textquotesingle{} \textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{).replace(}\StringTok{\textquotesingle{}doppelte\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
EinkurzerTextohneLeerzeichen.
\end{verbatim}

Mit der Methode \texttt{str.replace()} kann die eingelesene Liste um den
Zeilenumbruch bereinigt werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/einwohner\_europa\_2019.csv"}
\NormalTok{dateiobjekt\_einwohner }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(dateipfad, }\StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Methode readlines}
\NormalTok{einwohner }\OperatorTok{=}\NormalTok{ dateiobjekt\_einwohner.readlines()}
\NormalTok{einwohner\_neu }\OperatorTok{=}\NormalTok{ []}

\ControlFlowTok{for}\NormalTok{ element }\KeywordTok{in}\NormalTok{ einwohner:}
\NormalTok{  einwohner\_neu.append(element.replace(}\StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{))}

\NormalTok{einwohner }\OperatorTok{=}\NormalTok{ einwohner\_neu}
\BuiltInTok{print}\NormalTok{(einwohner)}

\CommentTok{\# Datei schließen}
\NormalTok{dateiobjekt\_einwohner.close()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['GEO,Value', 'Belgien,11467923', 'Bulgarien,7000039', 'Tschechien,10528984', 'Daenemark,5799763', 'Deutschland einschliesslich ehemalige DDR,82940663', 'Estland,1324820', 'Irland,4904240', 'Griechenland,10722287', 'Spanien,46934632', 'Frankreich,67028048', 'Kroatien,4076246', 'Italien,61068437', 'Zypern,875898', 'Lettland,1919968', 'Litauen,2794184', 'Luxemburg,612179', 'Uganda,-1', 'Ungarn,9772756', 'Malta,493559', 'Niederlande,17423013', 'Oesterreich,8842000', 'Polen,37972812', 'Portugal,10276617', 'Rumaenien,19405156', 'Slowenien,2080908', 'Slowakei,5450421', 'Finnland,5512119', 'Schweden,10243000', 'Vereinigtes Koenigreich,66647112']
\end{verbatim}

\section{Dateien schreiben}\label{dateien-schreiben}

Um Dateien zu schreiben, müssen diese mit der \texttt{write}-Methode
eines Dateiobjekts verwendet werden. Dieser Methode wird als Argument
die zu schreibende Zeichenfolge übergeben.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/neue\_datei.txt"}

\CommentTok{\# Öffne Datei zum Schreiben öffnen}
\NormalTok{datei }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(dateipfad, mode }\OperatorTok{=} \StringTok{\textquotesingle{}w\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Inhalt in die Datei schreiben}
\NormalTok{datei.write(}\StringTok{"Prokrastination an Hochschulen}\CharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{.upper())}
\NormalTok{datei.write(}\StringTok{"KAPITEL 1: Aller Anfang ist schwer}\CharTok{\textbackslash{}n}\StringTok{Platzhalter: Den Rest schreibe ich später."}\NormalTok{)}

\CommentTok{\# Datei schließen}

\NormalTok{datei.close()}
\end{Highlighting}
\end{Shaded}

Die Datei kann nun ausgelesen werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateiinhalt }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(dateipfad, mode }\OperatorTok{=} \StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}
\NormalTok{text }\OperatorTok{=}\NormalTok{ dateiinhalt.read()}
\BuiltInTok{print}\NormalTok{(text)}

\NormalTok{dateiinhalt.close()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
PROKRASTINATION AN HOCHSCHULEN

KAPITEL 1: Aller Anfang ist schwer
Platzhalter: Den Rest schreibe ich später.
\end{verbatim}

\section{Aufgabe Dateien schreiben}\label{aufgabe-dateien-schreiben}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Erzeugen Sie eine neue Datei mit der Endung \texttt{.txt}, die den
  Namen ihrer Heimatstadt hat. Schreiben Sie in diese Datei 10 Zeilen
  mit Informationen zur Stadt.
\end{enumerate}

~ (@Arnold-2023-funktionen-module-dateien)

\chapter{Module und Pakete
importieren}\label{module-und-pakete-importieren}

Der Funktionsumfang von Python kann erheblich durch das Importieren von
Modulen und Paketen erweitert werden. Module und Pakete sind
Bibliotheken, die Funktionsdefinitionen enthalten.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-module-und-pakete}: Module und Pakete}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-module-und-pakete} 

\begin{description}
\tightlist
\item[Module]
Module sind Dateien, die Funktionsdefinitionen enthalten.

Module werden durch das Schlüsselwort \texttt{import} und ihren Namen
importiert, bspw. \texttt{import\ glob}.
\item[Pakete]
Pakete sind Sammlungen von Modulen.

In Paketen enthaltene Module werden durch das Schlüsselwort
\texttt{import} mit der Schreibeweise paket.modul importiert, bspw.
\texttt{import\ matplotlib.pyplot}.
\end{description}

\end{tcolorbox}

Module und Pakete werden mit dem Schlüsselwort \texttt{import} in Python
geladen. Beispielsweise kann das für die Erzeugung (pseudo-)zufälliger
Zahlen zuständige Modul random mit dem Befehl \texttt{import\ random}
eingebunden werden. Anschließend stehen die Funktionen des Moduls unter
dem Modulnamen in der Schreibweise \texttt{modul.funktion()} zur
Verfügung.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ random}

\BuiltInTok{print}\NormalTok{(random.randint(}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{)) }\CommentTok{\# Zufällige Ganzzahl zwischen 1 und 10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
6
\end{verbatim}

Das Paket Matplotlib bringt viele Funktionen zur grafischen Darstellung
von Daten mit. Das Modul \texttt{matplotlib.pyplot} stellt eine
Schnittstelle zu den enthaltenen Funktionen dar.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib.pyplot}

\NormalTok{zufallsdaten }\OperatorTok{=}\NormalTok{ [] }\CommentTok{\# leere Liste anlegen}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{10}\NormalTok{):}
\NormalTok{    zufallszahl }\OperatorTok{=}\NormalTok{ random.randint(}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\NormalTok{    zufallsdaten.append(zufallszahl)}

\NormalTok{matplotlib.pyplot.plot(zufallsdaten)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/w-python/skript/module-und-pakete-importieren_files/figure-pdf/cell-3-output-1.png}}

}

\caption{Grafik mit dem Modul pyplot aus dem Paket matplotlib}

\end{figure}%

~

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-fromimport} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-fromimport}: Namensraum direkt einbinden}\vspace{3mm}

In Python ist es auch möglich, Funktionen direkt in den Namensraum von
Python zu importieren, sodass diese ohne die Schreibweise
\texttt{modul.funktion()} aufgerufen werden können. Dies ist mit dem
Schlüsselwort \texttt{from} möglich.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ random }\ImportTok{import}\NormalTok{ randint}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Funktion randint steht nun direkt zur Verfügung: }\SpecialCharTok{\{}\NormalTok{randint(}\DecValTok{1}\NormalTok{, }\DecValTok{100}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Funktion randint steht nun direkt zur Verfügung: 21
\end{verbatim}

Durch \texttt{from\ modulname\ import\ *} ist es sogar möglich, alle
Funktionen aus einem Modul in den Namensraum von Python zu importieren.
Im Allgemeinen sollte das direkte Importieren von Funktionen oder eines
ganzen Moduls in den Namensraum von Python jedoch unterlassen werden.
Einerseits wird damit eine Namensraumkollision riskiert, beispielsweise
gibt es die Funktion \texttt{sum()} in der Pythonbasis, in NumPy und in
Pandas. Andererseits wird der Programmcode dadurch weniger
nachvollziehbar, da nicht mehr überall ersichtlich ist, aus welchem
Modul eine verwendete Funktion stammt.

\end{minipage}%
\end{tcolorbox}

\section{import as}\label{import-as}

Um lange Modulnamen zu vereinfachen, kann beim Importieren das
Schlüsselwort \texttt{as} verwendet werden, um dem Modul einen neuen
Namen zuzuweisen.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{plt.plot(zufallsdaten)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/w-python/skript/module-und-pakete-importieren_files/figure-pdf/cell-5-output-1.png}}

}

\caption{Grafik mit dem Modul pyplot aus dem Paket matplotlib}

\end{figure}%

~

Für häufig verwendete Module haben sich bestimmte Kürzel etabliert. In
den Bausteinen werden häufig die folgenden Pakete und Kürzel genutzt:

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Modul & Kürzel & Befehl \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
NumPy & np & import numpy as np \\
Pandas & pd & import pandas as pd \\
matplotlib.pyplot & plt & import matplotlib.pyplot as plt \\
\end{longtable}

\section{Kleine Modulübersicht}\label{kleine-moduluxfcbersicht}

Da es nicht möglich ist, auf alle diese Module einzugehen, werden im
folgenden nur einige wenige Module aufgelistet, welche für die
Zielgruppe dieses Skripts interessant sein könnten. \emph{Hinweis: Die
Eigennamen einiger Module weisen eine Groß- und Kleinschreibung auf,
bspw. das Modul NumPy. Beim Importieren der Module werden die Modulnamen
jedoch klein geschrieben.} In der folgenden Liste wird auf die Groß- und
Kleinschreibung daher verzichtet.

\begin{itemize}
\tightlist
\item
  \textbf{math}: mathematische Funktionen und Konstanten
\item
  \textbf{scipy}: wissenschaftliche Funktionen
\item
  \textbf{sys}: Interaktion mit dem Python-Interpreter
\item
  \textbf{os}: Interaktion mit dem Betriebssystem
\item
  \textbf{glob}: Durchsuchen von Dateisystempfaden
\item
  \textbf{multiprocessing / threading}: Parallelprogramierung mit
  Prozessen / Threads
\item
  \textbf{matplotlib}: Visualisierung von Daten und Erstellen von
  Abbildungen
\item
  \textbf{numpy}: numerische Operationen und Funktionen
\item
  \textbf{pandas}: Daten einlesen und auswerten
\item
  \textbf{time}: Zeitfunktionen
\end{itemize}

~ (@Arnold-2023-funktionen-module-dateien)

\chapter{Das Wichtigste}\label{das-wichtigste-2}

Python ist eine sehr vielseitige und deshalb auch eine der am häufigsten
genutzen Programmiersprachen. Die Pythonbasis bringt das Grundgerüst für
die statistische Programmierung mit. Durch spezialisierte Module wird
der Funktionsumfang noch erheblich erweitert. Mehr dazu erfahren Sie in
dem Video.

\part{w-python-numpy}

\chapter*{Werkzeugbaustein NumPy}\label{werkzeugbaustein-numpy}
\addcontentsline{toc}{chapter}{Werkzeugbaustein NumPy}

\markboth{Werkzeugbaustein NumPy}{Werkzeugbaustein NumPy}

\phantomsection\label{Lizenz}
\begin{figure}

\begin{minipage}{0.20\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/by.png}}\end{minipage}%
%
\begin{minipage}{0.80\linewidth}
Bausteine Computergestützter Datenanalyse von Lukas Arnold, Simone
Arnold, Florian Bagemihl, Matthias Baitsch, Marc Fehr, Franca Hollmann,
Maik Poetzsch und Sebastian Seipel. ``Werkzeugbaustein NumPy'' von Marc
Fehr und Maik Poetzsch ist lizensiert unter
\href{https://creativecommons.org/licenses/by/4.0/deed.de}{CC BY 4.0}.
Das Werk ist abrufbar unter
\url{https://github.com/bausteine-der-datenanalyse/w-python-numpy-grundlagen}.
Ausgenommen von der Lizenz sind alle Logos und anders gekennzeichneten
Inhalte. 2025\end{minipage}%

\end{figure}%

Zitiervorschlag

Arnold, Lukas, Simone Arnold, Matthias Baitsch, Marc Fehr, Franca
Hollmann, Maik Poetzsch, und Sebastian Seipel. 2025. „Bausteine
Computergestützter Datenanalyse. Werkzeugbaustein NumPy``.
\url{https://github.com/bausteine-der-datenanalyse/w-python-numpy-grundlagen}.

BibTeX-Vorlage

\begin{verbatim}
@misc{BCD-numpy-2025,
 title={Bausteine Computergestützter Datenanalyse. Werkzeugbaustein NumPy},
 author={Arnold, Lukas and Arnold, Simone and Baitsch, Matthias and Fehr, Marc and Hollmann, Franca and Poetzsch, Maik and Seipel, Sebastian},
 year={2025},
 url={https://github.com/bausteine-der-datenanalyse/w-python-numpy-grundlagen}} 
\end{verbatim}

\chapter*{Intro}\label{intro}
\addcontentsline{toc}{chapter}{Intro}

\markboth{Intro}{Intro}

\section*{Voraussetzungen}\label{voraussetzungen-3}
\addcontentsline{toc}{section}{Voraussetzungen}

\markright{Voraussetzungen}

\begin{itemize}
\tightlist
\item
  Grundlagen Python
\item
  Einbinden von zusätzlichen Paketen
\item
  Plotten mit Matplotlib
\end{itemize}

\section*{Verwendete Pakete und
Datensätze}\label{verwendete-pakete-und-datensuxe4tze}
\addcontentsline{toc}{section}{Verwendete Pakete und Datensätze}

\markright{Verwendete Pakete und Datensätze}

\subsection*{Pakete}\label{pakete}
\addcontentsline{toc}{subsection}{Pakete}

\begin{itemize}
\tightlist
\item
  \href{https://numpy.org/}{NumPy}
\item
  \href{https://matplotlib.org/}{Matplotlib}
\end{itemize}

\subsection*{Datensätze}\label{datensuxe4tze}
\addcontentsline{toc}{subsection}{Datensätze}

\begin{itemize}
\tightlist
\item
  \href{https://firedynamics.github.io/LectureComputerScience/_downloads/0d1a3bfbc82fa134e08585d6151e9f46/TC01.csv}{TC01.csv}
\item
  \href{https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Mona_Lisa.jpg/677px-Mona_Lisa.jpg}{Bild:
  Mona Lisa}
\item
  \href{https://firedynamics.github.io/LectureComputerScience/_downloads/592f1fc843fc7c01bdcad17bf85ec15c/campus_haspel.jpeg}{Bild:
  Campus}
\end{itemize}

\section*{Bearbeitungszeit}\label{bearbeitungszeit}
\addcontentsline{toc}{section}{Bearbeitungszeit}

\markright{Bearbeitungszeit}

Geschätzte Bearbeitungszeit: 2h

\section*{Lernziele}\label{lernziele-3}
\addcontentsline{toc}{section}{Lernziele}

\markright{Lernziele}

\begin{itemize}
\tightlist
\item
  Einleitung: was ist NumPy, Vor- und Nachteile
\item
  Nutzen des NumPy-Moduls
\item
  Erstellen von NumPy-Arrays
\item
  Slicing
\item
  Lesen und schreiben von Dateien
\item
  Arbeiten mit Bildern
\end{itemize}

\chapter{Einführung NumPy}\label{einfuxfchrung-numpy}

NumPy ist eine leistungsstarke Bibliothek für Python, die für
numerisches Rechnen und Datenanalyse verwendet wird. Daher auch der Name
NumPy, ein Akronym für ``Numerisches Python'' (englisch: ``Numeric
Python'' oder ``Numerical Python''). NumPy selbst ist hauptsächlich in
der Programmiersprache C geschrieben, weshalb NumPy generell sehr
schnell ist.

NumPy bietet ein effizientes Arbeiten mit kleinen und großen Vektoren
und Matrizen, die so ansonsten nur umständlich in nativem Python
implementiert werden würden. Dabei bietet NumPy auch die Möglichkeit,
einfach mit Vektoren und Matrizen zu rechnen und das auch für sehr große
Datenmengen.

Diese Einführung wird Ihnen dabei helfen, die Grundlagen von NumPy zu
verstehen und zu nutzen.

\section{Vorteile \& Nachteile}\label{vorteile-nachteile}

Fast immer sind Operationen mit Numpy Datenstrukturen schneller. Im
Gegensatz zu nativen Python Listen kann man dort aber nur einen Datentyp
pro Liste speichern.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Warum ist numpy oftmals schneller?}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

NumPy implementiert eine effizientere Speicherung von Listen im
Speicher. Nativ speichert Python Listeninhalte aufgeteilt, wo gerade
Platz ist.

\begin{figure}[H]

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/w-python-numpy/skript/../skript/00-bilder/data_memory_list.pdf}}

}

\caption{\label{fig-python_memory}Speicherung von Daten in nativem
Python}

\end{figure}%

Dagegen werden NumPy-Arrays und Matritzen zusammenhängend gespeichert,
was einen effizienteren Datenaufruf ermöglicht.

\begin{figure}[H]

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/w-python-numpy/skript/../skript/00-bilder/data_memory_numpy.pdf}}

}

\caption{\label{fig-numpy_memory}Speicherung von Daten bei Numpy}

\end{figure}%

Dies bedeutet aber auch, dass eine Erweiterung einer Liste deutlich
schneller ist als eine Erweiterung von Arrays oder Matrizen. Bei Listen
kann jeder freie Platz genutzt werden, während Arrays und Matrizen an
einen neuen Ort im Speicher kopiert werden müssen.

\end{tcolorbox}

\section{Einbinden des Pakets}\label{einbinden-des-pakets}

NumPy wird über folgende Zeile eingebunden. Dabei hat sich global der
Standard entwickelt, als Alias \texttt{np} zu verwenden.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\end{Highlighting}
\end{Shaded}

\section{Referenzen}\label{referenzen}

Sämtliche hier vorgestellten Funktionen lassen sich in der (englischen)
NumPy-Dokumentation nachschlagen:
\href{https://numpy.org/doc/}{Dokumentation}

\chapter{Erstellen von NumPy arrays}\label{erstellen-von-numpy-arrays}

Typischerweise werden in Python Vektoren durch Listen und Matrizen durch
geschachtelte Listen ausgedrückt. Beispielsweise würde man den Vektor

\begin{figure}

\begin{minipage}{0.33\linewidth}
\[
(1, 2, 3, 4, 5, 6) 
\]\end{minipage}%
%
\begin{minipage}{0.33\linewidth}
und die Matrix\end{minipage}%
%
\begin{minipage}{0.33\linewidth}
\[
\begin{pmatrix}
1 & 2 & 3\\
4 & 5 & 6
\end{pmatrix}
\]\end{minipage}%

\end{figure}%

nativ in Python so erstellen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{liste }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]}

\NormalTok{matrix }\OperatorTok{=}\NormalTok{ [[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]]}

\BuiltInTok{print}\NormalTok{(liste)}
\BuiltInTok{print}\NormalTok{(matrix)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1, 2, 3, 4, 5, 6]
[[1, 2, 3], [4, 5, 6]]
\end{verbatim}

Möchte man jetzt NumPy-Arrays verwenden, benutzt man den Befehl
\texttt{np.array()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{liste }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{])}

\NormalTok{matrix }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]])}

\BuiltInTok{print}\NormalTok{(liste)}
\BuiltInTok{print}\NormalTok{(matrix)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1 2 3 4 5 6]
[[1 2 3]
 [4 5 6]]
\end{verbatim}

Betrachtet man die Ausgaben der \texttt{print()} Befehle, fallen zwei
Sachen auf: Zum einen fallen die Kommata weg und zum anderen wird die
Matrix passend ausgegeben.

Es gibt auch die Möglichkeit, höherdimensionale Arrays zu erstellen.
Dabei wird eine neue Ebene der Verschachtelung benutzt. Im folgenden
Beispiel wird eine dreidimensionale Matrix erstellt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{matrix\_3d }\OperatorTok{=}\NormalTok{ np.array([[[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]], [[}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{], [}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{]]])}
\end{Highlighting}
\end{Shaded}

Es gilt als ``good practice'', Arrays immer zu initialisieren. Dafür
bietet NumPy drei Funktionen, um vorinitialisierte Arrays zu erzeugen.
Alternativ können Arrays auch mit festgesetzten Werten initialisiert
werden. Dafür kann entweder die Funktion \texttt{np.zeros()}verwendet
werden, die alle Werte auf 0 setzt, oder aber \texttt{np.ones()}, welche
alle Werte mit 1 initialisiert. Der Funktion wird die Form im Format
\texttt{{[}Reihen,Spalten{]}} übergeben. Möchte man alle Einträge auf
einen spezifischen Wert setzen, kann man den Befehl \texttt{np.full()}
benutzen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.zeros([}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([[0., 0., 0.],
       [0., 0., 0.]])
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.ones([}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([[1., 1., 1.],
       [1., 1., 1.]])
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.full([}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{],}\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([[7, 7, 7],
       [7, 7, 7]])
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Wie könnte man Arrays, die mit einer Zahl x gefüllt sind, auch
erstellen?}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Der Trick besteht hierbei darin, ein Array mit \texttt{np.ones()} zu
initialisieren und dieses Array dann mit der Zahl x zu multiplizieren.
Im folgenden Beispiel ist \texttt{x\ =\ 5}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.ones([}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{]) }\OperatorTok{*} \DecValTok{5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([[5., 5., 5.],
       [5., 5., 5.]])
\end{verbatim}

\end{tcolorbox}

Möchte man zum Beispiel für eine Achse in einem Plot einen Vektor mit
gleichmäßig verteilten Werten erstellen, bieten sich in NumPy zwei
Möglichkeiten. Mit den Befehlen
\texttt{np.linspace(Start,Stopp,\#Anzahl\ Werte)} und
\texttt{np.arrange(Start,Stopp,Abstand\ zwischen\ Werten)} können solche
Arrays erstellt werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.linspace(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{11}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ])
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.arange(}\DecValTok{0}\NormalTok{,}\DecValTok{10}\NormalTok{,}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([0, 2, 4, 6, 8])
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Zwischenübung: Array Erstellung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Erstellen Sie jeweils ein NumPy-Array, mit dem folgenden Inhalt:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  mit den Werten 1, 7, 42, 99
\item
  zehn mal die Zahl 5
\item
  mit den Zahlen von 35 \textbf{bis einschließlich} 50
\item
  mit allen geraden Zahlen von 20 \textbf{bis einschließlich} 40
\item
  eine Matrix mit 5 Spalten und 4 Reihen mit dem Wert 4 an jeder Stelle
\item
  mit 10 Werten die gleichmäßig zwischen 22 und einschlieslich 40
  verteilt sind
\end{enumerate}

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 1. }
\BuiltInTok{print}\NormalTok{(np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{42}\NormalTok{, }\DecValTok{99}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[ 1  7 42 99]
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 2. }
\BuiltInTok{print}\NormalTok{(np.full(}\DecValTok{10}\NormalTok{,}\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[5 5 5 5 5 5 5 5 5 5]
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 3. }
\BuiltInTok{print}\NormalTok{(np.arange(}\DecValTok{35}\NormalTok{, }\DecValTok{51}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50]
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 4. }
\BuiltInTok{print}\NormalTok{(np.arange(}\DecValTok{20}\NormalTok{, }\DecValTok{41}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[20 22 24 26 28 30 32 34 36 38 40]
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 5. }
\BuiltInTok{print}\NormalTok{(np.full([}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{],}\DecValTok{4}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[4 4 4 4 4]
 [4 4 4 4 4]
 [4 4 4 4 4]
 [4 4 4 4 4]]
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 6. }
\BuiltInTok{print}\NormalTok{(np.linspace(}\DecValTok{22}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[22. 24. 26. 28. 30. 32. 34. 36. 38. 40.]
\end{verbatim}
\end{quote}

\end{tcolorbox}

\chapter{Größe, Struktur und Typ}\label{gruxf6uxdfe-struktur-und-typ}

Wenn man sich nicht mehr sicher ist, welche Struktur oder Form ein Array
hat oder diese Größen zum Beispiel für Schleifen nutzen möchte, bietet
NumPy folgende Funktionen für das Auslesen dieser Größen an.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{matrix }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\texttt{np.shape()} gibt die Längen der Dimensionen in Form eines Tupels
zurück.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.shape(matrix)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(2, 3)
\end{verbatim}

Die native Python Funktion \texttt{len()} gibt dagegen nur die Länge der
ersten Dimension, also die Anzahl der Elemente in den äußeren Klammern
wieder. Im obrigen Beispiel würde \texttt{len()} also die beiden Listen
\texttt{{[}1,\ 2,\ 3{]}} und \texttt{{[}4,\ 5,\ 6{]}} sehen.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{len}\NormalTok{(matrix)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
\end{verbatim}

Die Funktion \texttt{np.ndym()} gibt im Gegensatz zu \texttt{np.shape()}
nur die Anzahl der Dimensionen zurück.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.ndim(matrix)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Die Ausgabe von \texttt{np.ndim()} kann mit \texttt{np.shape()}und einer
nativen Python-Funktion erreicht werden. Wie?}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\texttt{np.ndim()} gibt die Länge der Liste von \texttt{np.shape()} aus.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{len}\NormalTok{(np.shape(matrix))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
\end{verbatim}

\end{tcolorbox}

Möchte man die Anzahl aller Elemente in einem Array ausgeben, kann man
die Funktion \texttt{np.size()} benutzen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.size(matrix)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
6
\end{verbatim}

NumPy-Arrays können verschiedene Datentypen haben. Im Folgenden haben
wir drei Arrays mit jeweils unterschiedlichem Datentyp.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{typ\_a }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{])}
\NormalTok{typ\_b }\OperatorTok{=}\NormalTok{ np.array([}\FloatTok{0.1}\NormalTok{, }\FloatTok{0.2}\NormalTok{, }\FloatTok{0.3}\NormalTok{, }\FloatTok{0.4}\NormalTok{, }\FloatTok{0.5}\NormalTok{])}
\NormalTok{typ\_c }\OperatorTok{=}\NormalTok{ np.array([}\StringTok{"Montag"}\NormalTok{, }\StringTok{"Dienstag"}\NormalTok{, }\StringTok{"Mittwoch"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

Mit der Methode \texttt{np.dtype} können wir den Datentyp von Arrays
ausgeben lassen. Meist wird dabei der Typ plus eine Zahl ausgegeben,
welche die zum Speichern benötigte Bytezahl angibt. Das Array
\emph{typ\_a} beinhaltet den Datentyp int64, also ganze Zahlen.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(typ\_a.dtype)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
int64
\end{verbatim}

Das Array \emph{typ\_b} beinhaltet den Datentyp float64, wobei float für
Gleitkommazahlen steht.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(typ\_b.dtype)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
float64
\end{verbatim}

Das Array \emph{typ\_c} beinhaltet den Datentyp U8, wobei das U für
Unicode steht. Hier wird als Unicodetext gespeichert.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(typ\_c.dtype)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<U8
\end{verbatim}

Im folgenden finden Sie eine Tabelle mit den typischen Datentypen, die
sie häufig antreffen.

\begin{longtable}[]{@{}lll@{}}
\caption{Typische Datentypen in
NumPy}\label{tbl-datatypes}\tabularnewline
\toprule\noalign{}
Datentyp & Numpy Name & Beispiele \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Datentyp & Numpy Name & Beispiele \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Wahrheitswert & \texttt{bool} & {[}True, False, True{]} \\
Ganze Zahl & \texttt{int} & {[}-2, 5, -6, 7, 3{]} \\
Positive ganze Zahl & \texttt{uint} & {[}1, 2, 3, 4, 5{]} \\
Kommazahl & \texttt{float} & {[}1.3, 7.4, 3.5, 5.5{]} \\
komplexe Zahl & \texttt{complex} & {[}-1 + 9j, 2-77j, 72 + 11j{]} \\
Textzeichen & \texttt{U} & {[}``montag'', ``dienstag''{]} \\
\end{longtable}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Zwischenübung: Array-Informationen auslesen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Gegeben sei folgende Matrix:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{matrix }\OperatorTok{=}\NormalTok{ np.array([[[ }\DecValTok{0}\NormalTok{,  }\DecValTok{1}\NormalTok{,  }\DecValTok{2}\NormalTok{,  }\DecValTok{3}\NormalTok{],}
\NormalTok{                 [ }\DecValTok{4}\NormalTok{,  }\DecValTok{5}\NormalTok{,  }\DecValTok{6}\NormalTok{,  }\DecValTok{7}\NormalTok{],}
\NormalTok{                 [ }\DecValTok{8}\NormalTok{,  }\DecValTok{9}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{]],}

\NormalTok{                [[}\DecValTok{12}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{15}\NormalTok{],}
\NormalTok{                 [}\DecValTok{16}\NormalTok{, }\DecValTok{17}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{19}\NormalTok{],}
\NormalTok{                 [}\DecValTok{20}\NormalTok{, }\DecValTok{21}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{23}\NormalTok{]],}

\NormalTok{                [[}\DecValTok{24}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{26}\NormalTok{, }\DecValTok{27}\NormalTok{],}
\NormalTok{                 [}\DecValTok{28}\NormalTok{, }\DecValTok{29}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{31}\NormalTok{],}
\NormalTok{                 [}\DecValTok{32}\NormalTok{, }\DecValTok{33}\NormalTok{, }\DecValTok{34}\NormalTok{, }\DecValTok{35}\NormalTok{]]])}
\end{Highlighting}
\end{Shaded}

Bestimmen Sie durch Anschauen die Anzahl an Dimensionen und die Länge
jeder Dimension. Von welchem Datentyp ist der Inhalt dieser Matrix?

Überprüfen Sie daraufhin Ihre Ergebnisse, indem Sie die passenden
NumPy-Funktionen anwenden.

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{matrix }\OperatorTok{=}\NormalTok{ np.array([[[ }\DecValTok{0}\NormalTok{,  }\DecValTok{1}\NormalTok{,  }\DecValTok{2}\NormalTok{,  }\DecValTok{3}\NormalTok{],}
\NormalTok{                 [ }\DecValTok{4}\NormalTok{,  }\DecValTok{5}\NormalTok{,  }\DecValTok{6}\NormalTok{,  }\DecValTok{7}\NormalTok{],}
\NormalTok{                 [ }\DecValTok{8}\NormalTok{,  }\DecValTok{9}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{]],}

\NormalTok{                [[}\DecValTok{12}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{15}\NormalTok{],}
\NormalTok{                 [}\DecValTok{16}\NormalTok{, }\DecValTok{17}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{19}\NormalTok{],}
\NormalTok{                 [}\DecValTok{20}\NormalTok{, }\DecValTok{21}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{23}\NormalTok{]],}

\NormalTok{                [[}\DecValTok{24}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{26}\NormalTok{, }\DecValTok{27}\NormalTok{],}
\NormalTok{                 [}\DecValTok{28}\NormalTok{, }\DecValTok{29}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{31}\NormalTok{],}
\NormalTok{                 [}\DecValTok{32}\NormalTok{, }\DecValTok{33}\NormalTok{, }\DecValTok{34}\NormalTok{, }\DecValTok{35}\NormalTok{]]])}

\NormalTok{anzahl\_dimensionen }\OperatorTok{=}\NormalTok{ np.ndim(matrix)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Anzahl unterschiedlicher Dimensionen: "}\NormalTok{, anzahl\_dimensionen)}

\NormalTok{laenge\_dimensionen }\OperatorTok{=}\NormalTok{ np.shape(matrix)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Länge der einzelnen Dimensionen: "}\NormalTok{, laenge\_dimensionen)}

\BuiltInTok{print}\NormalTok{(matrix.dtype)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Anzahl unterschiedlicher Dimensionen:  3
Länge der einzelnen Dimensionen:  (3, 3, 4)
int64
\end{verbatim}
\end{quote}

\end{tcolorbox}

\chapter{Rechnen mit Arrays}\label{rechnen-mit-arrays}

\section{Arithmetische Funktionen}\label{arithmetische-funktionen}

Ein großer Vorteil von NumPy ist das Rechnen mit Arrays. Ohne NumPy
müsste man entweder eine \texttt{Schleife} oder aber
\texttt{list\ comprehension} benutzen, um mit sämtlichen Werten in der
Liste zu rechnen. In NumPy fällt diese Unannehmlichkeit weg.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{])}

\NormalTok{b }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{9}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

Normale mathematische Operationen wie die Addition lassen sich auf zwei
Arten ausdrücken: Entweder über die \texttt{np.add()} Funktion oder aber
simpel über den Operator \texttt{+}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.add(a,b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([10, 10, 10, 10, 10])
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{+}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([10, 10, 10, 10, 10])
\end{verbatim}

Ohne NumPy würde die Operation folgendermaßen aussehen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ergebnis }\OperatorTok{=}\NormalTok{ np.ones(}\DecValTok{5}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(a)):}
\NormalTok{    ergebnis[i] }\OperatorTok{=}\NormalTok{ a[i] }\OperatorTok{+}\NormalTok{ b[i]}

\BuiltInTok{print}\NormalTok{(ergebnis)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[10. 10. 10. 10. 10.]
\end{verbatim}

Für die anderen Rechenarten existieren auch Funktionen:
\texttt{np.subtract()}, \texttt{np.multiply()} und \texttt{np.divide()}.

Auch für die höheren Rechenoperationen gibt es Funktionen:

\begin{itemize}
\tightlist
\item
  \texttt{np.exp(a)}
\item
  \texttt{np.sqrt(a)}
\item
  \texttt{np.power(a,\ 3)}
\item
  \texttt{np.sin(a)}
\item
  \texttt{np.cos(a)}
\item
  \texttt{np.tan(a)}
\item
  \texttt{np.log(a)}
\item
  \texttt{a.dot(b)}
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-warning-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame, coltitle=black, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Arbeiten mit Winkelfunktionen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Wie auch am Taschenrechner birgt das Arbeiten mit den Winkelfunktionen
(sin, cos, \ldots) die Fehlerquelle, dass man nicht mit Radian-Werten,
sondern mit Grad-Werten arbeitet. Die Winkelfunktionen in NumPy erwarten
jedoch Radian-Werte.

Für eine einfache Umrechnung bietet NumPy die Funktionen
\texttt{np.deh2rad()} und \texttt{np.rad2deg()}.

\end{tcolorbox}

\section{Vergleiche}\label{vergleiche}

NumPy-Arrays lassen sich auch miteinander vergleichen. Betrachten wir
die folgenden zwei Arrays:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{])}

\NormalTok{b }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{9}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

Möchten wir feststellen, ob diese zwei Arrays identisch sind, können wir
den \texttt{==}-Komparator benutzen. Dieser vergleicht die Arrays
elementweise.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{==}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([False,  True, False,  True,  True])
\end{verbatim}

Es ist außerdem möglich Arrays mit den \texttt{\textgreater{}}- und
\texttt{\textless{}}-Operatoren zu vergleichen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{\textless{}}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([ True, False,  True, False, False])
\end{verbatim}

Möchte man Arrays mit Gleitkommazahlen vergleichen, ist es oftmals
nötig, eine gewisse Toleranz zu benutzen, da bei Rechenoperationen
minimale Rundungsfehler entstehen können.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.array(}\FloatTok{0.1} \OperatorTok{+} \FloatTok{0.2}\NormalTok{)}
\NormalTok{b }\OperatorTok{=}\NormalTok{ np.array(}\FloatTok{0.3}\NormalTok{)}
\NormalTok{a }\OperatorTok{==}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
np.False_
\end{verbatim}

Für diesen Fall gibt es eine Vergleichsfunktion
\texttt{np.isclose(a,b,atol)}, wobei \texttt{atol} für die absolute
Toleranz steht. Im folgenden Beispiel wird eine absolute Toleranz von
0,001 verwendet.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.array(}\FloatTok{0.1} \OperatorTok{+} \FloatTok{0.2}\NormalTok{)}
\NormalTok{b }\OperatorTok{=}\NormalTok{ np.array(}\FloatTok{0.3}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(np.isclose(a, b, atol}\OperatorTok{=}\FloatTok{0.001}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Warum ist 0.1 + 0.2 nicht gleich 0.3?}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Zahlen werden intern als Binärzahlen dargestellt. So wie 1/3 nicht mit
einer endlichen Anzahl an Ziffern korrekt dargestellt werden kann,
müssen Zahlen ggf. gerundet werden, um im Binärsystem dargestellt zu
werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \FloatTok{0.1}
\NormalTok{b }\OperatorTok{=} \FloatTok{0.2}
\BuiltInTok{print}\NormalTok{(a }\OperatorTok{+}\NormalTok{ b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.30000000000000004
\end{verbatim}

\end{tcolorbox}

\section{Aggregatfunktionen}\label{aggregatfunktionen}

Für verschiedene Auswertungen benötigen wir Funktionen, wie etwa die
Summen- oder die Mittelwert-Funktion. Starten wir mit einem
Beispiel-Array a:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{8}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

Die Summe wird über die Funktion \texttt{np.sum()} berechnet.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.}\BuiltInTok{sum}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
np.int64(18)
\end{verbatim}

Natürlich lassen sich auch der Minimalwert und der Maximalwert eines
Arrays ermitteln. Die beiden Funktionen lauten \texttt{np.min()}und
\texttt{np.max()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.}\BuiltInTok{min}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
np.int64(1)
\end{verbatim}

Möchte man nicht das Maximum selbst, sondern die Position des Maximums
bestimmen, wird statt \texttt{np.max()} die Funktion
\texttt{np.argmax()}verwendet.

Für statistische Auswertungen werden häufig die Funktion für den
Mittelwert \texttt{np.mean()}, die Funktion für den Median
\texttt{np.median()}und die Funktion für die Standardabweichung
\texttt{np.std()}verwendet.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.mean(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
np.float64(3.6)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.median(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
np.float64(3.0)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.std(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
np.float64(2.4166091947189146)
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Zwischenübung: Rechnen mit Arrays}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Gegeben sind zwei eindimensionale Arrays a und b:

a = np.array({[}10, 20, 30, 40, 50, 60, 70, 80, 90, 100{]}) und b =
np.array({[}5, 15, 25, 35, 45, 55, 65, 75, 85, 95{]})

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Erstellen Sie ein neues Array, das die Sinuswerte der addierten Arrays
  a und b enthält.
\item
  Berechnen Sie die Summe, den Mittelwert und die Standardabweichung der
  Elemente in a.
\item
  Finden Sie den jeweils größten und den kleinsten Wert in a und b.
\end{enumerate}

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{10}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{70}\NormalTok{, }\DecValTok{80}\NormalTok{, }\DecValTok{90}\NormalTok{, }\DecValTok{100}\NormalTok{])}
\NormalTok{b }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{5}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{35}\NormalTok{, }\DecValTok{45}\NormalTok{, }\DecValTok{55}\NormalTok{, }\DecValTok{65}\NormalTok{, }\DecValTok{75}\NormalTok{, }\DecValTok{85}\NormalTok{, }\DecValTok{95}\NormalTok{])}

\CommentTok{\# 1.}
\NormalTok{sin\_ab }\OperatorTok{=}\NormalTok{ np.sin(a }\OperatorTok{+}\NormalTok{ b)}

\CommentTok{\# 2.}
\NormalTok{sum\_a }\OperatorTok{=}\NormalTok{ np.}\BuiltInTok{sum}\NormalTok{(a)}
\NormalTok{mean\_a }\OperatorTok{=}\NormalTok{ np.mean(a)}
\NormalTok{std\_a }\OperatorTok{=}\NormalTok{ np.std(a)}

\CommentTok{\# 3.}
\NormalTok{max\_a }\OperatorTok{=}\NormalTok{ np.}\BuiltInTok{max}\NormalTok{(a)}
\NormalTok{min\_a }\OperatorTok{=}\NormalTok{ np.}\BuiltInTok{min}\NormalTok{(a)}
\NormalTok{max\_b }\OperatorTok{=}\NormalTok{ np.}\BuiltInTok{max}\NormalTok{(b)}
\NormalTok{min\_b }\OperatorTok{=}\NormalTok{ np.}\BuiltInTok{min}\NormalTok{(b)}
\end{Highlighting}
\end{Shaded}
\end{quote}

\end{tcolorbox}

\chapter{Slicing}\label{slicing}

\section{Normales Slicing mit
Zahlenwerten}\label{normales-slicing-mit-zahlenwerten}

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-numpy/skript/../skript/00-bilder/slicing.png}}

}

\caption{\label{fig-slicing}Ansprechen der einzelnen Achsen für den
ein-, zwei- und dreidimensionallen Fall inkl. jeweiligem Beispiel}

\end{figure}%

Möchte man Daten innerhalb eines Arrays auswählen, so geschieht das in
der Form:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{array{[}a{]}} wobei ein einzelner Wert an Position a
  ausgegeben wird.
\item
  \texttt{array{[}a:b{]}} wobei alle Werte von Position a bis Position
  b-1 ausgegeben werden.
\item
  \texttt{array{[}a:b:c{]}} wobei die Werte von Position a bis Position
  b-1 mit einer Schrittweite von c ausgegeben werden.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{liste }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Auswählen des ersten Elements}
\NormalTok{liste[}\DecValTok{0}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
np.int64(1)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Auswählen des letzten Elements}
\NormalTok{liste[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
np.int64(6)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Auswählen einer Reihe von Elementen}
\NormalTok{liste[}\DecValTok{1}\NormalTok{:}\DecValTok{4}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([2, 3, 4])
\end{verbatim}

Für zweidimensionale Arrays wählt man mit einer zweiten, durch ein Komma
von der ersten getrennten Zahl die zweite Dimension aus.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{matrix }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Auswählen eines Elements}
\NormalTok{matrix[}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
np.int64(5)
\end{verbatim}

Für dreidimensionale Arrays wählt man mit einer weiteren, ebenfalls
durch ein Komma getrennten Zahl die dritte Dimension aus. Dabei wird
diese jedoch an die erste Stelle gesetzt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{matrix\_3d }\OperatorTok{=}\NormalTok{ np.array([[[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]], [[}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{], [}\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{]]])}
\BuiltInTok{print}\NormalTok{(matrix\_3d)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[[ 1  2  3]
  [ 4  5  6]]

 [[ 7  8  9]
  [10 11 12]]]
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Auswählen eines Elements}
\NormalTok{matrix\_3d[}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
np.int64(9)
\end{verbatim}

\section{Slicing mit logischen Werten (boolesche
Masken)}\label{slicing-mit-logischen-werten-boolesche-masken}

Beim logischen Slicing wird eine boolesche Maske verwendet, um bestimmte
Elemente eines Arrays auszuwählen. Die Maske ist ein Array gleicher
Länge wie das Original, das aus den Werten \texttt{True} oder
\texttt{False} besteht.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Erstellen wir ein Beispiel Array}
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{])}

\CommentTok{\# Erstellen der Maske}
\NormalTok{maske }\OperatorTok{=}\NormalTok{ a }\OperatorTok{\textgreater{}} \DecValTok{3}

\BuiltInTok{print}\NormalTok{(maske)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[False False False  True  True  True]
\end{verbatim}

Wir erhalten also ein Array mit boolschen Werten. Verwenden wir diese
Maske nun zum slicen, erhalten wir alle Werte an den Stellen, an denen
die Maske den Wert \texttt{True} besitzt.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Anwenden der Maske}
\BuiltInTok{print}\NormalTok{(a[maske])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[4 5 6]
\end{verbatim}

Mehrere Masken können mit dem Operator \texttt{*} zu einem logischen UND
verknüpft werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 2 Masken}
\NormalTok{gerade\_zahlen }\OperatorTok{=}\NormalTok{ a }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}
\NormalTok{kleiner\_3 }\OperatorTok{=}\NormalTok{ a }\OperatorTok{\textless{}} \DecValTok{3}
\BuiltInTok{print}\NormalTok{(gerade\_zahlen, kleiner\_3, sep }\OperatorTok{=} \StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}

\CommentTok{\# logisches UND beider Masken}
\BuiltInTok{print}\NormalTok{(a[kleiner\_3 }\OperatorTok{*}\NormalTok{ gerade\_zahlen])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[False  True False  True False  True]
[ True  True False False False False]
[2]
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-warning-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame, coltitle=black, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Warning}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Das Verwenden von booleschen Arrays ist nicht für native Python-Listen
möglich. Hier muss durch die Liste iterriert werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]}
\NormalTok{ergebnis }\OperatorTok{=}\NormalTok{ [x }\ControlFlowTok{for}\NormalTok{ x }\KeywordTok{in}\NormalTok{ a }\ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{3}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(ergebnis) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[4, 5, 6]
\end{verbatim}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Zwischenübung: Array-Slicing}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Wählen Sie die farblich markierten Bereiche aus dem Array ``matrix'' mit
den eben gelernten Möglichkeiten des Array-Slicing aus.

\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/w-python-numpy/skript/../skript/00-bilder/exercise_slicing.pdf}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{matrix }\OperatorTok{=}\NormalTok{ np.array([}
\NormalTok{    [}\DecValTok{2}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{47}\NormalTok{, }\DecValTok{33}\NormalTok{, }\DecValTok{48}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{41}\NormalTok{],}
\NormalTok{    [}\DecValTok{55}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{91}\NormalTok{, }\DecValTok{56}\NormalTok{, }\DecValTok{17}\NormalTok{, }\DecValTok{54}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{12}\NormalTok{],}
\NormalTok{    [}\DecValTok{19}\NormalTok{, }\DecValTok{99}\NormalTok{, }\DecValTok{56}\NormalTok{, }\DecValTok{72}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{34}\NormalTok{, }\DecValTok{16}\NormalTok{, }\DecValTok{77}\NormalTok{, }\DecValTok{56}\NormalTok{],}
\NormalTok{    [}\DecValTok{37}\NormalTok{, }\DecValTok{75}\NormalTok{, }\DecValTok{67}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{46}\NormalTok{, }\DecValTok{98}\NormalTok{, }\DecValTok{57}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{7}\NormalTok{],}
\NormalTok{    [}\DecValTok{4}\NormalTok{, }\DecValTok{57}\NormalTok{, }\DecValTok{32}\NormalTok{, }\DecValTok{78}\NormalTok{, }\DecValTok{56}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{43}\NormalTok{, }\DecValTok{61}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{88}\NormalTok{],}
\NormalTok{    [}\DecValTok{96}\NormalTok{, }\DecValTok{16}\NormalTok{, }\DecValTok{92}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{90}\NormalTok{, }\DecValTok{35}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{36}\NormalTok{, }\DecValTok{97}\NormalTok{],}
\NormalTok{    [}\DecValTok{75}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{38}\NormalTok{, }\DecValTok{53}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{79}\NormalTok{, }\DecValTok{56}\NormalTok{, }\DecValTok{73}\NormalTok{, }\DecValTok{45}\NormalTok{, }\DecValTok{56}\NormalTok{],}
\NormalTok{    [}\DecValTok{15}\NormalTok{, }\DecValTok{76}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{93}\NormalTok{, }\DecValTok{87}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{58}\NormalTok{, }\DecValTok{86}\NormalTok{, }\DecValTok{94}\NormalTok{],}
\NormalTok{    [}\DecValTok{51}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{57}\NormalTok{, }\DecValTok{74}\NormalTok{, }\DecValTok{42}\NormalTok{, }\DecValTok{59}\NormalTok{, }\DecValTok{71}\NormalTok{, }\DecValTok{88}\NormalTok{, }\DecValTok{52}\NormalTok{],}
\NormalTok{    [}\DecValTok{49}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{43}\NormalTok{, }\DecValTok{39}\NormalTok{, }\DecValTok{17}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{95}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{44}\NormalTok{, }\DecValTok{75}\NormalTok{]}
\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{quote}
\textbf{Lösung}

\begin{itemize}
\tightlist
\item
  Rot: matrix{[}1,3{]}
\item
  Grün: matrix{[}4:6,2:6{]}
\item
  Pink: matrix{[}:,7{]}
\item
  Orange: matrix{[}7,:5{]}
\item
  Blau: matrix{[}-1,-1{]}
\end{itemize}
\end{quote}

\end{tcolorbox}

\chapter{Array Manipulation}\label{array-manipulation}

\section{Ändern der Form}\label{uxe4ndern-der-form}

Durch verschiedene Funktionen lassen sich die Form und die Einträge der
Arrays verändern.

Eine der wichtigsten Array-Operationen ist das Transponieren. Dabei
werden Reihen in Spalten und Spalten in Reihen umgewandelt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{matrix }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]])}
\BuiltInTok{print}\NormalTok{(matrix)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[1 2 3]
 [4 5 6]]
\end{verbatim}

Transponieren wir dieses Array nun, erhalten wir:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(np.transpose(matrix))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[1 4]
 [2 5]
 [3 6]]
\end{verbatim}

Wollen wir nun aus dieser Matrix einen Vektor erstellen, so können wir
die Methode \texttt{np.flatten()} benutzen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vector }\OperatorTok{=}\NormalTok{ matrix.flatten()}
\BuiltInTok{print}\NormalTok{(vector)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1 2 3 4 5 6]
\end{verbatim}

Um wieder eine zweidimensionale Datenstruktur zu erhalten, benutzen wir
die Funktion \texttt{np.reshape(Ziel,\ Form)}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(np.reshape(matrix, [}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[1 2]
 [3 4]
 [5 6]]
\end{verbatim}

Möchten wir den Inhalt eines bereits bestehenden Arrays erweitern,
verkleinern oder ändern, bietet NumPy ebenfalls die passenden
Funktionen.

Haben wir ein leeres Array oder wollen wir ein schon volles Array
erweitern, benutzen wir die Funktion \texttt{np.append()}. Dabei hängen
wir einen Wert an das bereits bestehende Array an.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{liste }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{])}

\NormalTok{neue\_liste }\OperatorTok{=}\NormalTok{ np.append(liste, }\DecValTok{7}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(neue\_liste)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1 2 3 4 5 6 7]
\end{verbatim}

Gegebenenfalls ist es nötig, einen Wert nicht am Ende, sondern an einer
beliebigen Position im Array einzufügen. Das passende Werkzeug ist
hierfür die Funktion \texttt{np.insert(Array,\ Position,\ Einschub)}. Im
folgenden Beispiel wird an der Indexposition 3 die Zahl 7 eingesetzt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{liste }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{])}

\NormalTok{neue\_liste }\OperatorTok{=}\NormalTok{ np.insert(liste, }\DecValTok{3}\NormalTok{, }\DecValTok{7}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(neue\_liste)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1 2 3 7 4 5 6]
\end{verbatim}

Wenn sich neue Elemente einfügen lassen, können natürlich auch Elemente
gelöscht werden. Hierfür wird die Funktion
\texttt{np.delete(Array,\ Position)} benutzt, die ein Array und die
Position der zu löschenden Funktion übergeben bekommt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{liste }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{])}

\NormalTok{neue\_liste }\OperatorTok{=}\NormalTok{ np.delete(liste, }\DecValTok{3}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(neue\_liste)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1 2 3 5 6]
\end{verbatim}

Zuletzt wollen wir uns noch die Verbindung zweier Arrays anschauen. Im
folgenden Beispiel wird dabei das Array \texttt{b} an das Array
\texttt{a} mithilfe der Funktion
\texttt{np.concatenate((Array\ a,\ Array\ b))}angehängt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{])}
\NormalTok{b }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{10}\NormalTok{])}

\NormalTok{neue\_liste }\OperatorTok{=}\NormalTok{ np.concatenate((a, b))}
\BuiltInTok{print}\NormalTok{(neue\_liste)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[ 1  2  3  4  5  6  7  8  9 10]
\end{verbatim}

\section{Sortieren von Arrays}\label{sortieren-von-arrays}

NumPy bietet auch die Möglichkeit, Arrays zu sortieren. Im folgenden
Beispiel starten wir mit einem unsortierten Array. Mit der Funktion
\texttt{np.sort()} erhalten wir ein sortiertes Array.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\NormalTok{unsortiert }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{4}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{])}

\NormalTok{sortiert }\OperatorTok{=}\NormalTok{ np.sort(unsortiert)}

\BuiltInTok{print}\NormalTok{(sortiert)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1 2 3 4 5 6]
\end{verbatim}

\section{Unterlisten mit einzigartigen
Werten}\label{unterlisten-mit-einzigartigen-werten}

Arbeitet man mit Daten, bei denen zum Beispiel Projekten Personalnummern
zugeordnet werden, hat man Daten mit einer endlichen Anzahl an
Personalnummern, die jedoch mehrfach vorkommen können, wenn diese an
mehr als einem Projekt gleichzeitig arbeiten.

Möchte man nun eine Liste erstellen, die jede Nummer nur einmal enthält,
kann die Funktion \texttt{np.unique()} verwendet werden.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\NormalTok{liste\_mit\_dopplungen }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{4}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{])}

\NormalTok{einzigartige\_werte }\OperatorTok{=}\NormalTok{ np.unique(liste\_mit\_dopplungen)}

\BuiltInTok{print}\NormalTok{(einzigartige\_werte)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1 3 4 6 7]
\end{verbatim}

Setzt man dann noch die Option \texttt{return\_counts=True} kann in
einer zweiten Variable gespeichert werden, wie oft jeder Wert vorkommt.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\NormalTok{liste\_mit\_dopplungen }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{4}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{])}

\NormalTok{einzigartige\_werte, anzahl }\OperatorTok{=}\NormalTok{ np.unique(liste\_mit\_dopplungen, return\_counts}\OperatorTok{=}\VariableTok{True}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(anzahl)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[2 3 2 1 1]
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Zwischenübung: Array-Manipulation}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Gegeben ist das folgende zweidimensionale Array matrix:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{matrix }\OperatorTok{=}\NormalTok{ np.array([}
\NormalTok{    [}\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{8}\NormalTok{],}
\NormalTok{    [}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{6}\NormalTok{],}
\NormalTok{    [}\DecValTok{9}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{]}
\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Ändern Sie die Form des Arrays matrix in ein eindimensionales Array.
\item
  Sortieren Sie das eindimensionale Array in aufsteigender Reihenfolge.
\item
  Ändern Sie die Form des sortierten Arrays in ein zweidimensionales
  Array mit 2 Zeilen und 6 Spalten.
\item
  Bestimmen Sie die eindeutigen Elemente im ursprünglichen Array matrix
  und geben Sie diese aus.
\end{enumerate}

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{matrix }\OperatorTok{=}\NormalTok{ np.array([}
\NormalTok{    [}\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{8}\NormalTok{],}
\NormalTok{    [}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{6}\NormalTok{],}
\NormalTok{    [}\DecValTok{9}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{]}
\NormalTok{])}

\CommentTok{\# 1. Ändern der Form in ein eindimensionales Array}
\NormalTok{flat\_array }\OperatorTok{=}\NormalTok{ matrix.flatten()}

\CommentTok{\# 2. Sortieren des eindimensionalen Arrays in aufsteigender Reihenfolge}
\NormalTok{sorted\_array }\OperatorTok{=}\NormalTok{ np.sort(flat\_array)}

\CommentTok{\# 3. Ändern der Form des sortierten Arrays in ein 2x6{-}Array}
\NormalTok{reshaped\_array }\OperatorTok{=}\NormalTok{ sorted\_array.reshape(}\DecValTok{2}\NormalTok{, }\DecValTok{6}\NormalTok{)}

\CommentTok{\# 4. Bestimmen der eindeutigen Elemente im ursprünglichen Array}
\NormalTok{unique\_elements\_original }\OperatorTok{=}\NormalTok{ np.unique(matrix)}
\end{Highlighting}
\end{Shaded}
\end{quote}

\end{tcolorbox}

\chapter{Lesen und Schreiben von
Dateien}\label{lesen-und-schreiben-von-dateien}

Das Modul NumPy stellt Funktionen zum Lesen und Schreiben von
strukturierten Textdateien bereit.

\section{Lesen von Dateien}\label{lesen-von-dateien}

Zum Lesen von strukturierten Textdateien, z. B. im CSV-Format (comma
separated values), kann die Funktion \texttt{np.loadtxt()} verwendet
werden. Diese bekommt als Argumente den einzulesenden Dateinamen und
weitere Optionen zur Definition der Struktur der Daten. Der Rückgabewert
ist ein (mehrdimensionales) Array.

Im folgenden Beispiel wird die Datei
\href{https://firedynamics.github.io/LectureComputerScience/_downloads/0d1a3bfbc82fa134e08585d6151e9f46/TC01.csv}{TC01.csv}
eingelesen und deren Inhalt graphisch dargestellt. Die erste Zeile der
Datei wird dabei ignoriert, da sie als Kommentar -- eingeleitet durch
das \#-Zeichen -- interpretiert wird.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateiname }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/TC01.csv\textquotesingle{}}
\NormalTok{daten }\OperatorTok{=}\NormalTok{ np.loadtxt(dateiname)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Daten:"}\NormalTok{, daten)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Form:"}\NormalTok{, daten.shape)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Daten: [20.1 20.1 20.1 ... 24.3 24.2 24.2]
Form: (1513,)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(daten)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Datenindex\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Temperatur in °C\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-numpy/skript/array_read_n_write_files/figure-pdf/cell-5-output-1.png}}

~

Standardmäßig erwartet die \texttt{np.loadtxt()}-Funktion Komma
separierte Werte. Werden die Daten durch ein anderes Trennzeichen
getrennt, kann mit der Option \texttt{delimiter\ =\ ""} ein anderes
Trenzeichen ausgewählt werden. Beispielsweise würde der Funktionsaufruf
bei einem Semikolon folgendermaßen aussehen:
\texttt{np.loadtxt(data.txt,\ delimiter\ =\ ";")}.

Enthalten die ersten Zeilen einer Datei zusätzliche Informationen wie
die verwenden Einheiten oder eine Beschreibung des Experiments, können
diese Zeilen mit der Option \texttt{skiprows=\ \#Reihen} übersprungen
werden.

\section{Schreiben von Dateien}\label{schreiben-von-dateien}

Zum Schreiben von Arrays in Dateien, kann die in NumPy verfügbare
Funktion \texttt{np.savetxt()} verwendet werden. Dieser müssen
mindestens die zu schreibenden Arrays als auch ein Dateiname übergeben
werden. Darüber hinaus sind zahlreiche Formatierungs- bzw.
Strukturierungsoptionen möglich.

Folgendes Beispiel skaliert die oben eingelesenen Daten und schreibt
jeden zehnten Wert in eine Datei. Dabei wird auch ein Kommentar
(\texttt{header}-Argument) am Anfang der Datei erzeugt. Das
Ausgabeformat der Zahlen kann mit dem \texttt{fmt}-Argument angegeben
werden. Das Format ähnelt der Darstellungsweise, welche bei den
formatierten Zeichenketten vorgestellt wurde.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{wertebereich }\OperatorTok{=}\NormalTok{ np.}\BuiltInTok{max}\NormalTok{(daten) }\OperatorTok{{-}}\NormalTok{ np.}\BuiltInTok{min}\NormalTok{(daten)}
\NormalTok{daten\_skaliert }\OperatorTok{=}\NormalTok{ ( daten }\OperatorTok{{-}}\NormalTok{ np.}\BuiltInTok{min}\NormalTok{(daten) ) }\OperatorTok{/}\NormalTok{ wertebereich}
\NormalTok{daten\_skaliert }\OperatorTok{=}\NormalTok{ daten\_skaliert[::}\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(daten\_skaliert)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Datenindex\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Skalierte Temperatur\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-numpy/skript/array_read_n_write_files/figure-pdf/cell-7-output-1.png}}

Beim Schreiben der Datei wird ein mehrzeiliger Kommentar mithilfe des
Zeilenumbruchzeichens \texttt{\textbackslash{}n} definiert. Die Ausgabe
der Gleitkommazahlen wird mit \texttt{\%5.2f} formatiert, was 5 Stellen
insgesamt und zwei Nachkommastellen entspricht.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Zuweisung ist auf mehrere Zeilen aufgeteilt, aufgrund der }
\CommentTok{\# schmalen Darstellung im Skript}
\NormalTok{kommentar }\OperatorTok{=} \SpecialStringTok{f\textquotesingle{}Daten aus }\SpecialCharTok{\{}\NormalTok{dateiname}\SpecialCharTok{\}}\SpecialStringTok{ skaliert auf den Bereich \textquotesingle{}} \OperatorTok{+} \OperatorTok{\textbackslash{}}
             \StringTok{\textquotesingle{}0 bis 1 }\CharTok{\textbackslash{}n}\StringTok{originales Min / Max:\textquotesingle{}} \OperatorTok{+} \OperatorTok{\textbackslash{}}
            \SpecialStringTok{f\textquotesingle{}}\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\BuiltInTok{min}\NormalTok{(daten)}\SpecialCharTok{\}}\SpecialStringTok{/}\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\BuiltInTok{max}\NormalTok{(daten)}\SpecialCharTok{\}}\SpecialStringTok{\textquotesingle{}}
\NormalTok{neu\_dateiname }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/TC01\_skaliert.csv\textquotesingle{}}

\NormalTok{np.savetxt(neu\_dateiname, daten\_skaliert, }
\NormalTok{           header}\OperatorTok{=}\NormalTok{kommentar, fmt}\OperatorTok{=}\StringTok{\textquotesingle{}}\SpecialCharTok{\%5.2f}\StringTok{\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Zum Veranschaulichen werden die ersten Zeilen der neuen Datei
ausgegeben.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Einlesen der ersten Zeilen der neu erstellten Datei}
\NormalTok{datei }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(neu\_dateiname, }\StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{10}\NormalTok{):}
    \BuiltInTok{print}\NormalTok{( datei.readline() , end}\OperatorTok{=}\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}
\NormalTok{datei.close()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# Daten aus 01-daten/TC01.csv skaliert auf den Bereich 0 bis 1 
# originales Min / Max:20.1/31.1
 0.00
 0.00
 0.00
 0.01
 0.01
 0.01
 0.01
 0.01
\end{verbatim}

\chapter{Arbeiten mit Bildern}\label{arbeiten-mit-bildern}

Bilder werden digital als Matrizen gespeichert. Dabei werden pro Pixel
drei Farbwerte (rot, grün, blau) gespeichert. Aus diesen drei Farbwerten
(Wertebereich 0-255) werden dann alle gewünschten Farben
zusammengestellt.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/w-python-numpy/skript/../skript/00-bilder/pixel_mona_lisa_split.pdf}}

}

\caption{\label{fig-pixel_colors}Ein hochaufgelöstes Bild besteht aus
sehr vielen Pixeln. Jedes Pixel enthält 3 Farbwerte, einen für die Farbe
Rot, einen für Grün und einen für Blau.}

\end{figure}%

Aufgrund der digitalen Darstellung von Bildern lassen sich diese mit den
Werkzeugen von NumPy leicht bearbeiten. Wir verwenden für folgendes
Beispiel als Bild die Mona Lisa. Das Bild ist unter folgendem
\href{https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Mona_Lisa.jpg/677px-Mona_Lisa.jpg}{Link}
zu finden.

Importieren wir dieses Bild nun mit der Funktion \texttt{imread()} aus
dem matplotlib-package, sehen wir, dass es sich um ein dreidimensionales
NumPy-Array handelt.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{data }\OperatorTok{=}\NormalTok{ plt.imread(}\StringTok{"00{-}bilder/mona\_lisa.jpg"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Form:"}\NormalTok{, data.shape)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Form: (1024, 677, 3)
\end{verbatim}

Schauen wir uns einmal mit der \texttt{print()}-Funktion diese Daten an.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(data)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[[ 68  62  38]
  [ 88  82  56]
  [ 92  87  55]
  ...
  [ 54  97  44]
  [ 68 110  60]
  [ 69 111  63]]

 [[ 65  59  33]
  [ 68  63  34]
  [ 83  78  46]
  ...
  [ 66 103  51]
  [ 66 103  52]
  [ 66 102  56]]

 [[ 97  90  62]
  [ 87  80  51]
  [ 78  72  38]
  ...
  [ 79 106  53]
  [ 62  89  38]
  [ 62  88  41]]

 ...

 [[ 25  14  18]
  [ 21  10  14]
  [ 20   9  13]
  ...
  [ 11   5   9]
  [ 11   5   9]
  [ 10   4   8]]

 [[ 23  12  16]
  [ 23  12  16]
  [ 21  10  14]
  ...
  [ 11   5   9]
  [ 11   5   9]
  [ 10   4   8]]

 [[ 22  11  15]
  [ 26  15  19]
  [ 24  13  17]
  ...
  [ 11   5   9]
  [ 10   4   8]
  [  9   3   7]]]
\end{verbatim}

Mit der Funktion \texttt{plt.imshow()} kann das Bild in Echtfarben
dargestellt werden. Dies funktioniert, da die Funktion die einzelnen
Ebenen, hier der letzte Index des Datensatzes, als Farbinformationen
(Rot, Grün, Blau) interpretiert. Wäre noch eine vierte Ebene dabei,
würde sie als Transparenzwert verwendet worden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.imshow(data)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-numpy/skript/array_images_files/figure-pdf/cell-5-output-1.png}}

Natürlich können auch die einzelnen Farbebenen individuell betrachtet
werden. Dazu wird der letzte Index festgehalten. Hier betrachten wir nur
den roten Anteil des Bildes. Stellen wir ein einfaches Array dar, werden
die Daten mit der Standardfarbpalette `viridis' ausgegeben. Mit Hilfe
der Option \texttt{cmap=\textquotesingle{}Reds\textquotesingle{}} können
wir die Farbskala anpassen.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Als Farbskala wird die Rotskala }
\CommentTok{\# verwendet \textquotesingle{}Reds\textquotesingle{}}
\NormalTok{plt.imshow( data[:,:,}\DecValTok{0}\NormalTok{], cmap}\OperatorTok{=}\StringTok{\textquotesingle{}Reds\textquotesingle{}}\NormalTok{ )}
\NormalTok{plt.colorbar()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-numpy/skript/array_images_files/figure-pdf/cell-6-output-1.png}}

Da die Bilddaten als Arrays gespeichert sind, sind viele der möglichen
Optionen, z. B. zur Teilauswahl oder Operationen, verfügbar. Das untere
Beispiel zeigt einen Ausschnitt im Rotkanal des Bildes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bereich }\OperatorTok{=}\NormalTok{ np.array(data[}\DecValTok{450}\NormalTok{:}\DecValTok{500}\NormalTok{, }\DecValTok{550}\NormalTok{:}\DecValTok{600}\NormalTok{,}\DecValTok{0}\NormalTok{], dtype}\OperatorTok{=}\BuiltInTok{float}\NormalTok{)}
\NormalTok{plt.imshow( bereich, cmap}\OperatorTok{=}\StringTok{"Greys"}\NormalTok{ )}
\NormalTok{plt.colorbar()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-numpy/skript/array_images_files/figure-pdf/cell-7-output-1.png}}

Betrachten wir nun eine komplexere Operation an Bilddaten, den
\href{https://de.wikipedia.org/wiki/Laplace-Operator}{Laplace-Operator}.
Er kann genutzt werden, um Ränder von Objekten zu identifizieren. Dazu
wird für jeden Bildpunkt \(B_{i,j}\) -- außer an den Rändern
--~folgender Wert \(\phi_{i, j}\) berechnet:

\[ \phi_{i, j} = \left|B_{i-1, j} + B_{i, j-1} - 4\cdot B_{i, j} + B_{i+1, j} + B_{i, j+1}\right| \]

Folgende Funktion implementiert diese Operation. Darüber hinaus werden
alle Werte von \(\phi\) unterhalb eines Schwellwerts auf Null und
oberhalb auf 255 gesetzt.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ img\_lap(data, schwellwert}\OperatorTok{=}\DecValTok{25}\NormalTok{):}
    
    \CommentTok{\# Erstellung einer Kopie der Daten, nun jedoch als}
    \CommentTok{\# Array mit Gleitkommazahlen}
\NormalTok{    bereich }\OperatorTok{=}\NormalTok{ np.array(data, dtype}\OperatorTok{=}\BuiltInTok{float}\NormalTok{)}
    
    \CommentTok{\# Aufteilung der obigen Gleichung in zwei Teile}
\NormalTok{    lapx }\OperatorTok{=}\NormalTok{ bereich[}\DecValTok{2}\NormalTok{:, :] }\OperatorTok{{-}} \DecValTok{2}\OperatorTok{*}\NormalTok{bereich[}\DecValTok{1}\NormalTok{:}\OperatorTok{{-}}\DecValTok{1}\NormalTok{, :] }\OperatorTok{+}\NormalTok{ bereich[:}\OperatorTok{{-}}\DecValTok{2}\NormalTok{, :]}
\NormalTok{    lapy }\OperatorTok{=}\NormalTok{ bereich[:, }\DecValTok{2}\NormalTok{:] }\OperatorTok{{-}} \DecValTok{2}\OperatorTok{*}\NormalTok{bereich[:, }\DecValTok{1}\NormalTok{:}\OperatorTok{{-}}\DecValTok{1}\NormalTok{] }\OperatorTok{+}\NormalTok{ bereich[:, :}\OperatorTok{{-}}\DecValTok{2}\NormalTok{]}
    
    \CommentTok{\# Zusammenführung der Teile und Bildung des Betrags}
\NormalTok{    lap }\OperatorTok{=}\NormalTok{ np.}\BuiltInTok{abs}\NormalTok{(lapx[:,}\DecValTok{1}\NormalTok{:}\OperatorTok{{-}}\DecValTok{1}\NormalTok{] }\OperatorTok{+}\NormalTok{ lapy[}\DecValTok{1}\NormalTok{:}\OperatorTok{{-}}\DecValTok{1}\NormalTok{, :])}
    
    \CommentTok{\# Schwellwertanalyse}
\NormalTok{    lap[lap }\OperatorTok{\textgreater{}}\NormalTok{ schwellwert] }\OperatorTok{=} \DecValTok{255}
\NormalTok{    lap[lap }\OperatorTok{\textless{}}\NormalTok{ schwellwert] }\OperatorTok{=} \DecValTok{0}
    
    \ControlFlowTok{return}\NormalTok{ lap}
\end{Highlighting}
\end{Shaded}

Betrachten wir ein
\href{https://firedynamics.github.io/LectureComputerScience/_downloads/592f1fc843fc7c01bdcad17bf85ec15c/campus_haspel.jpeg}{Bild}
vom Haspel Campus in Wuppertal. Die Anwendung des Laplace-Operators auf
den oberen Bildausschnitt ergibt folgende Ausgabe:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data }\OperatorTok{=}\NormalTok{ plt.imread(}\StringTok{\textquotesingle{}01{-}daten/campus\_haspel.jpeg\textquotesingle{}}\NormalTok{)}
\NormalTok{bereich }\OperatorTok{=}\NormalTok{ np.array(data[}\DecValTok{1320}\NormalTok{:}\DecValTok{1620}\NormalTok{, }\DecValTok{400}\NormalTok{:}\DecValTok{700}\NormalTok{, }\DecValTok{1}\NormalTok{], dtype}\OperatorTok{=}\BuiltInTok{float}\NormalTok{)}

\NormalTok{lap }\OperatorTok{=}\NormalTok{ img\_lap(bereich)}

\NormalTok{plt.figure(figsize}\OperatorTok{=}\NormalTok{(}\DecValTok{9}\NormalTok{, }\DecValTok{3}\NormalTok{))}

\NormalTok{ax }\OperatorTok{=}\NormalTok{ plt.subplot(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{ax.imshow(data, cmap}\OperatorTok{=}\StringTok{"Greys\_r"}\NormalTok{)}

\NormalTok{ax }\OperatorTok{=}\NormalTok{ plt.subplot(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{ax.imshow(bereich, cmap}\OperatorTok{=}\StringTok{"Greys\_r"}\NormalTok{)}\OperatorTok{;}

\NormalTok{ax }\OperatorTok{=}\NormalTok{ plt.subplot(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{ax.imshow(lap, cmap}\OperatorTok{=}\StringTok{"Greys"}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-numpy/skript/array_images_files/figure-pdf/cell-9-output-1.png}}

Wir können damit ganz klar die Formen des Fensters erkennen.

Wollen wir zum Beispiel eine Farbkomponente bearbeiten und dann das Bild
wieder zusammensetzen, benötigen wir die Funktion
\texttt{np.dstack((rot,\ grün,\ blau)).astype(\textquotesingle{}uint8\textquotesingle{})},
wobei \texttt{rot}, \texttt{grün}und \texttt{blau} die jeweiligen
2D-Arrays sind. Versuchen wir nun, die grüne Farbe aus dem Baum links zu
entfernen.

Wichtig ist, dass die Daten nach dem Zusammensetzen im Format
\texttt{uint8} vorliegen, deswegen die Methode
\texttt{.astype(\textquotesingle{}uint8\textquotesingle{})}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data }\OperatorTok{=}\NormalTok{ plt.imread(}\StringTok{\textquotesingle{}01{-}daten/campus\_haspel.jpeg\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Speichern der einzelnen Farben in Arrays}
\NormalTok{rot }\OperatorTok{=}\NormalTok{ np.array(data[:, :, }\DecValTok{0}\NormalTok{], dtype}\OperatorTok{=}\BuiltInTok{float}\NormalTok{)}
\NormalTok{gruen }\OperatorTok{=}\NormalTok{ np.array(data[:, :, }\DecValTok{1}\NormalTok{], dtype}\OperatorTok{=}\BuiltInTok{float}\NormalTok{)}
\NormalTok{blau }\OperatorTok{=}\NormalTok{ np.array(data[:, :, }\DecValTok{2}\NormalTok{], dtype}\OperatorTok{=}\BuiltInTok{float}\NormalTok{)}

\CommentTok{\# Setzen wir den Bereich des linken Baumes im Array auf 0}
\NormalTok{gruen\_neu }\OperatorTok{=}\NormalTok{ gruen.copy()}
\NormalTok{gruen\_neu[}\DecValTok{800}\NormalTok{:}\DecValTok{2000}\NormalTok{, }\DecValTok{700}\NormalTok{:}\DecValTok{1700}\NormalTok{] }\OperatorTok{=} \DecValTok{0}

\NormalTok{zusammengesetzt }\OperatorTok{=}\NormalTok{ np.dstack((rot, gruen\_neu, blau)).astype(}\StringTok{\textquotesingle{}uint8\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.figure(figsize}\OperatorTok{=}\NormalTok{(}\DecValTok{8}\NormalTok{, }\DecValTok{5}\NormalTok{))}

\NormalTok{ax }\OperatorTok{=}\NormalTok{ plt.subplot(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{ax.imshow(data, cmap}\OperatorTok{=}\StringTok{"Greys\_r"}\NormalTok{)}

\NormalTok{ax }\OperatorTok{=}\NormalTok{ plt.subplot(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{ax.imshow(zusammengesetzt)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-numpy/skript/array_images_files/figure-pdf/cell-10-output-1.png}}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Zwischenübung: Bilder bearbeiten}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Lesen Sie folgendes Bild vom Haspel Campus in Wuppertal ein:
\href{https://firedynamics.github.io/LectureComputerScience/_downloads/592f1fc843fc7c01bdcad17bf85ec15c/campus_haspel.jpeg}{Bild}.

Extrahieren Sie den blauen Anteil und lassen Sie sich die Zeile in der
Mitte des Bildes sowie einen beliebigen Bildauschnitt ausgeben.

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{data }\OperatorTok{=}\NormalTok{ plt.imread(}\StringTok{\textquotesingle{}01{-}daten/campus\_haspel.jpeg\textquotesingle{}}\NormalTok{)}

\NormalTok{form }\OperatorTok{=}\NormalTok{  data.shape}
\BuiltInTok{print}\NormalTok{( }\StringTok{"Form:"}\NormalTok{, data.shape )}

\NormalTok{blau }\OperatorTok{=}\NormalTok{  data[:,:,}\DecValTok{2}\NormalTok{]}
\NormalTok{plt.imshow(blau, cmap}\OperatorTok{=}\StringTok{\textquotesingle{}Blues\textquotesingle{}}\NormalTok{)}

\NormalTok{zeile }\OperatorTok{=}\NormalTok{  data[}\BuiltInTok{int}\NormalTok{(form[}\DecValTok{0}\NormalTok{]}\OperatorTok{/}\DecValTok{2}\NormalTok{),:,}\DecValTok{2}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(zeile)}

\NormalTok{ausschnitt }\OperatorTok{=}\NormalTok{  data[}\DecValTok{10}\NormalTok{:}\DecValTok{50}\NormalTok{,}\DecValTok{10}\NormalTok{:}\DecValTok{50}\NormalTok{,:]}
\NormalTok{plt.imshow(ausschnitt)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Form: (3024, 4032, 3)
[221 220 220 ...  28  28  28]
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-numpy/skript/array_images_files/figure-pdf/cell-11-output-2.png}}
\end{quote}

\end{tcolorbox}

\chapter{Lernzielkontrolle}\label{lernzielkontrolle-1}

Herzlich willkommen zur Lernzielkontrolle!

Diese Selbstlernkontrolle dient dazu, Ihr Verständnis der bisher
behandelten Themen zu überprüfen und Ihnen die Möglichkeit zu geben,
Ihren Lernfortschritt eigenständig zu bewerten. Sie ist so konzipiert,
dass Sie Ihre Stärken und Schwächen erkennen und gezielt an den
Bereichen arbeiten können, die noch verbessert werden müssen.

Es stehen hier zwei Möglichkeiten zur Verfügung, Ihr Wissen zu prüfen.
Sie können das Quiz benutzen, welches Sie automatisch durch die
verschiedenen Themen führt. Alternativ finden Sie darunter normale
Fragen, wie Sie bisher im Skript verwendet wurden.

Bitte nehmen Sie sich ausreichend Zeit für die Bearbeitung der Fragen
und gehen Sie diese in Ruhe durch. Seien Sie ehrlich zu sich selbst und
versuchen Sie, die Aufgaben ohne Hilfsmittel zu lösen, um ein
realistisches Bild Ihres aktuellen Wissensstands zu erhalten. Sollten
Sie bei einer Frage Schwierigkeiten haben, ist dies ein Hinweis darauf,
dass Sie in diesem Bereich noch weiter üben sollten.

Viel Erfolg bei der Bearbeitung und beim weiteren Lernen!

\section*{Aufgabe 1}\label{aufgabe-1}
\addcontentsline{toc}{section}{Aufgabe 1}

\markright{Aufgabe 1}

Wie wird das NumPy-Paket typischerweise eingebunden?

\section*{Aufgabe 2}\label{aufgabe-2}
\addcontentsline{toc}{section}{Aufgabe 2}

\markright{Aufgabe 2}

Erstellen Sie mit Hilfe von NumPy die folgenden Arrays:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Erstellen sie aus der Liste {[}1, 2, 3{]} ein NumPy-Array.
\item
  Ein eindimensionales Array, das die Zahlen von 0 bis 9 enthält.
\item
  Ein zweidimensionales Array der Form 3×3, das nur aus Einsen besteht.
\item
  Ein eindimensionales Array, das die Zahlen von 10 bis 50
  (einschließlich) in Schritten von 5 enthält.
\end{enumerate}

\section*{Aufgabe 3}\label{aufgabe-3}
\addcontentsline{toc}{section}{Aufgabe 3}

\markright{Aufgabe 3}

Was ist der Unterschied zwischenden den Funktionen \texttt{np.ndim()},
\texttt{np.shape()} und \texttt{np.size()}?

\section*{Aufgabe 4}\label{aufgabe-4}
\addcontentsline{toc}{section}{Aufgabe 4}

\markright{Aufgabe 4}

Welchen Datentyp hat folgendes Array? Mit welcher Funktion kann man den
Datentyp eines Arrays auslesen?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vector }\OperatorTok{=}\NormalTok{ np.array([ }\FloatTok{4.8}\NormalTok{,  }\FloatTok{8.2}\NormalTok{, }\FloatTok{15.6}\NormalTok{, }\FloatTok{16.6}\NormalTok{, }\FloatTok{23.2}\NormalTok{, }\FloatTok{42.8}\NormalTok{ ])}
\end{Highlighting}
\end{Shaded}

\section*{Aufgabe 5}\label{aufgabe-5}
\addcontentsline{toc}{section}{Aufgabe 5}

\markright{Aufgabe 5}

Führen Sie mit den folgenden zwei Arrays diese mathematischen
Operationen durch:

a = np.array({[}5, 1, 3, 6, 4{]}) und b = np.array({[}6, 5, 2, 6, 9{]})

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Addieren Sie beide Arrays.
\item
  Berechnen Sie das elementweise Produkt von a und b.
\item
  Addieren Sie zu jedem Eintrag von a 3 dazu.
\end{enumerate}

\section*{Aufgabe 6}\label{aufgabe-6}
\addcontentsline{toc}{section}{Aufgabe 6}

\markright{Aufgabe 6}

a = np.array({[}9, 2, 3, 1, 3{]})

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Bestimmen Sie Mittelwert und Standardabweichung für das Array a.
\item
  Bestimmen Sie Minimum und Maximum des Arrays.
\end{enumerate}

\section*{Aufgabe 7}\label{aufgabe-7}
\addcontentsline{toc}{section}{Aufgabe 7}

\markright{Aufgabe 7}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{matrix }\OperatorTok{=}\NormalTok{ np.array([}
\NormalTok{    [ }\DecValTok{1}\NormalTok{,  }\DecValTok{2}\NormalTok{,  }\DecValTok{3}\NormalTok{,  }\DecValTok{4}\NormalTok{,  }\DecValTok{5}\NormalTok{],}
\NormalTok{    [ }\DecValTok{6}\NormalTok{,  }\DecValTok{7}\NormalTok{,  }\DecValTok{8}\NormalTok{,  }\DecValTok{9}\NormalTok{, }\DecValTok{10}\NormalTok{],}
\NormalTok{    [}\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{15}\NormalTok{],}
\NormalTok{    [}\DecValTok{16}\NormalTok{, }\DecValTok{17}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{20}\NormalTok{],}
\NormalTok{    [}\DecValTok{21}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{25}\NormalTok{]}
\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Extrahieren Sie die erste Zeile.
\item
  Extrahieren Sie die letzte Spalte.
\item
  Extrahieren Sie die Untermatrix, die aus den Zeilen 2 bis 4 und den
  Spalten 1 bis 3 besteht.
\end{enumerate}

\section*{Aufgabe 8}\label{aufgabe-8}
\addcontentsline{toc}{section}{Aufgabe 8}

\markright{Aufgabe 8}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{array }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{1}\NormalTok{, }\DecValTok{21}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Ändern Sie die Form des Arrays in eine zweidimensionale Matrix der
  Form 4×5.
\item
  Ändern Sie die Form des Arrays in eine zweidimensionale Matrix der
  Form 5×4.
\item
  Ändern Sie die Form des Arrays in eine dreidimensionale Matrix der
  Form 2×2×5.
\item
  Flachen Sie das dreidimensionale Array aus Aufgabe 3 wieder zu einem
  eindimensionalen Array ab.
\item
  Transponieren Sie die 4×5-Matrix aus Aufgabe 1.
\end{enumerate}

\section*{Aufgabe 9}\label{aufgabe-9}
\addcontentsline{toc}{section}{Aufgabe 9}

\markright{Aufgabe 9}

Mit welchen zwei Funktionen können Daten aus einer Datei gelesen und in
einer Datei gespeichert werden?

\section*{Aufgabe 10}\label{aufgabe-10}
\addcontentsline{toc}{section}{Aufgabe 10}

\markright{Aufgabe 10}

Sie möchten aus einem Bild die Bilddaten einer Farkomponente isolieren.
Was müssen Sie dafür tun?

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-caution-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-caution-color-frame, coltitle=black, title={Lösung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\subsection*{Aufgabe 1}\label{aufgabe-1-1}
\addcontentsline{toc}{subsection}{Aufgabe 1}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\end{Highlighting}
\end{Shaded}

\subsection*{Aufgabe 2}\label{aufgabe-2-1}
\addcontentsline{toc}{subsection}{Aufgabe 2}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 1.}
\NormalTok{np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{])}

\CommentTok{\# 2. }
\BuiltInTok{print}\NormalTok{(np.arange(}\DecValTok{10}\NormalTok{))}

\CommentTok{\# 3. }
\BuiltInTok{print}\NormalTok{(np.ones((}\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{)))}

\CommentTok{\# 4. }
\BuiltInTok{print}\NormalTok{(np.arange(}\DecValTok{10}\NormalTok{, }\DecValTok{51}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[0 1 2 3 4 5 6 7 8 9]
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
[10 15 20 25 30 35 40 45 50]
\end{verbatim}

\subsection*{Aufgabe 3}\label{aufgabe-3-1}
\addcontentsline{toc}{subsection}{Aufgabe 3}

\texttt{np.ndim()}: Gibt die Anzahl der Dimensionen zurück.
\texttt{np.shape()}: Gibt die Längen der einzelnen Dimensionen wieder.
\texttt{np.size()}: Gibt die Anzahl aller Elemente aus.

\subsection*{Aufgabe 4}\label{aufgabe-4-1}
\addcontentsline{toc}{subsection}{Aufgabe 4}

Da es sich hier um Gleitkommazahlen handelt, ist der Datentyp
\texttt{float64}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vector }\OperatorTok{=}\NormalTok{ np.array([ }\FloatTok{4.8}\NormalTok{,  }\FloatTok{8.2}\NormalTok{, }\FloatTok{15.6}\NormalTok{, }\FloatTok{16.6}\NormalTok{, }\FloatTok{23.2}\NormalTok{, }\FloatTok{42.8}\NormalTok{ ])}
\BuiltInTok{print}\NormalTok{(vector.dtype)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
float64
\end{verbatim}

\subsection*{Aufgabe 5}\label{aufgabe-5-1}
\addcontentsline{toc}{subsection}{Aufgabe 5}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{4}\NormalTok{])}
\NormalTok{b }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{9}\NormalTok{])}

\CommentTok{\# 1.}
\NormalTok{ergebnis }\OperatorTok{=}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Die Summe beider Vektoren ergibt: "}\NormalTok{, ergebnis) }

\CommentTok{\# 2.}
\NormalTok{ergebnis }\OperatorTok{=}\NormalTok{ a }\OperatorTok{*}\NormalTok{ b}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Das Produkt beider Vektoren ergibt: "}\NormalTok{, ergebnis) }

\CommentTok{\# 3.}
\NormalTok{ergebnis }\OperatorTok{=}\NormalTok{ a }\OperatorTok{+} \DecValTok{3}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Die Summe von a und 3 ergibt: "}\NormalTok{, ergebnis) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Summe beider Vektoren ergibt:  [11  6  5 12 13]
Das Produkt beider Vektoren ergibt:  [30  5  6 36 36]
Die Summe von a und 3 ergibt:  [8 4 6 9 7]
\end{verbatim}

\subsection*{Aufgabe 6}\label{aufgabe-6-1}
\addcontentsline{toc}{subsection}{Aufgabe 6}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{9}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{])}

\CommentTok{\# 1.}
\NormalTok{mittelwert }\OperatorTok{=}\NormalTok{ np.mean(a)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Der Mittelwert ist: "}\NormalTok{, mittelwert)}

\NormalTok{standardabweichung }\OperatorTok{=}\NormalTok{ np.std(a)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Die Standardabweichung von a beträgt: "}\NormalTok{, standardabweichung) }

\CommentTok{\# 2.}
\NormalTok{minimum }\OperatorTok{=}\NormalTok{ np.}\BuiltInTok{min}\NormalTok{(a)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Das Minimum beträgt: "}\NormalTok{, minimum)}

\NormalTok{maximum }\OperatorTok{=}\NormalTok{ np.}\BuiltInTok{max}\NormalTok{(a)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Das Maximum beträgt: "}\NormalTok{, maximum)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der Mittelwert ist:  3.6
Die Standardabweichung von a beträgt:  2.8000000000000003
Das Minimum beträgt:  1
Das Maximum beträgt:  9
\end{verbatim}

\subsection*{Aufgabe 7}\label{aufgabe-7-1}
\addcontentsline{toc}{subsection}{Aufgabe 7}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{matrix }\OperatorTok{=}\NormalTok{ np.array([}
\NormalTok{    [ }\DecValTok{1}\NormalTok{,  }\DecValTok{2}\NormalTok{,  }\DecValTok{3}\NormalTok{,  }\DecValTok{4}\NormalTok{,  }\DecValTok{5}\NormalTok{],}
\NormalTok{    [ }\DecValTok{6}\NormalTok{,  }\DecValTok{7}\NormalTok{,  }\DecValTok{8}\NormalTok{,  }\DecValTok{9}\NormalTok{, }\DecValTok{10}\NormalTok{],}
\NormalTok{    [}\DecValTok{11}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{15}\NormalTok{],}
\NormalTok{    [}\DecValTok{16}\NormalTok{, }\DecValTok{17}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{20}\NormalTok{],}
\NormalTok{    [}\DecValTok{21}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{25}\NormalTok{]}
\NormalTok{])}

\CommentTok{\# 1. Erste Zeile}
\BuiltInTok{print}\NormalTok{(matrix[}\DecValTok{0}\NormalTok{,:])}

\CommentTok{\# 2. Letzte Spalte}
\BuiltInTok{print}\NormalTok{(matrix[:,}\OperatorTok{{-}}\DecValTok{1}\NormalTok{])}

\CommentTok{\# 3. Ausschnitt}
\BuiltInTok{print}\NormalTok{(matrix[}\DecValTok{1}\NormalTok{:}\DecValTok{4}\NormalTok{,}\DecValTok{0}\NormalTok{:}\DecValTok{3}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1 2 3 4 5]
[ 5 10 15 20 25]
[[ 6  7  8]
 [11 12 13]
 [16 17 18]]
\end{verbatim}

\subsection*{Aufgabe 8}\label{aufgabe-8-1}
\addcontentsline{toc}{subsection}{Aufgabe 8}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{array }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{1}\NormalTok{, }\DecValTok{21}\NormalTok{)}

\CommentTok{\# 1. Ändern der Form in eine 4x5{-}Matrix}
\NormalTok{matrix\_4x5 }\OperatorTok{=}\NormalTok{ array.reshape(}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}

\CommentTok{\# 2. Ändern der Form in eine 5x4{-}Matrix}
\NormalTok{matrix\_5x4 }\OperatorTok{=}\NormalTok{ array.reshape(}\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{)}

\CommentTok{\# 3. Ändern der Form in eine 2x2x5{-}Matrix}
\NormalTok{matrix\_2x2x5 }\OperatorTok{=}\NormalTok{ array.reshape(}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{)}

\CommentTok{\# 4. Abflachen der 2x2x5{-}Matrix zu einem eindimensionalen Array}
\NormalTok{flattened\_array }\OperatorTok{=}\NormalTok{ matrix\_2x2x5.flatten()}

\CommentTok{\# 5. Transponieren der 4x5{-}Matrix}
\NormalTok{transposed\_matrix }\OperatorTok{=}\NormalTok{ matrix\_4x5.T}

\CommentTok{\# Ausgabe der Ergebnisse (optional)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Originales Array:"}\NormalTok{, array)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"4x5{-}Matrix:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, matrix\_4x5)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"5x4{-}Matrix:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, matrix\_5x4)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"2x2x5{-}Matrix:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, matrix\_2x2x5)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Abgeflachtes Array:"}\NormalTok{, flattened\_array)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Transponierte 4x5{-}Matrix:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, transposed\_matrix)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Originales Array: [ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20]
4x5-Matrix:
 [[ 1  2  3  4  5]
 [ 6  7  8  9 10]
 [11 12 13 14 15]
 [16 17 18 19 20]]
5x4-Matrix:
 [[ 1  2  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]
 [13 14 15 16]
 [17 18 19 20]]
2x2x5-Matrix:
 [[[ 1  2  3  4  5]
  [ 6  7  8  9 10]]

 [[11 12 13 14 15]
  [16 17 18 19 20]]]
Abgeflachtes Array: [ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20]
Transponierte 4x5-Matrix:
 [[ 1  6 11 16]
 [ 2  7 12 17]
 [ 3  8 13 18]
 [ 4  9 14 19]
 [ 5 10 15 20]]
\end{verbatim}

\subsection*{Aufgabe 9}\label{aufgabe-9-1}
\addcontentsline{toc}{subsection}{Aufgabe 9}

Die passenden Funktionen sind \texttt{np.loadtxt()} und
\texttt{np.savetxt()}.

\subsection*{Aufgabe 10}\label{aufgabe-10-1}
\addcontentsline{toc}{subsection}{Aufgabe 10}

Typischerweise sind Bilddaten große Matrizen, wobei die Farben in drei
unterschieldichen Matrizen gespeichert werden. Dabei ist die
Farbreihenfolge oft ``Rot'', ``Grün'' und ``Blau''. Dementsprechen
müssen wir, wenn die Daten in der Matrix \texttt{data} gespeichert sind,
mit Slicing eine Dimension auswählen: \texttt{data{[}:,:,0{]}}, wobei
die Zahl 0-2 für die jeweilige Farbe steht.

\end{tcolorbox}

\chapter{Übung}\label{uxfcbung}

\section{Aufgabe 1 Filmdatenbank}\label{aufgabe-1-filmdatenbank}

In der ersten Aufgabe wollen wir fiktive Daten für Filmbewertungen
untersuchen. Das Datenset ist dabei vereinfacht und beinhaltet folgende
Spalten:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Film ID
\item
  Benutzer ID
\item
  Bewertung
\end{enumerate}

Hier ist das Datenset:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\NormalTok{bewertungen }\OperatorTok{=}\NormalTok{ np.array([}
\NormalTok{    [}\DecValTok{1}\NormalTok{, }\DecValTok{101}\NormalTok{, }\FloatTok{4.5}\NormalTok{],}
\NormalTok{    [}\DecValTok{1}\NormalTok{, }\DecValTok{102}\NormalTok{, }\FloatTok{3.0}\NormalTok{],}
\NormalTok{    [}\DecValTok{2}\NormalTok{, }\DecValTok{101}\NormalTok{, }\FloatTok{2.5}\NormalTok{],}
\NormalTok{    [}\DecValTok{2}\NormalTok{, }\DecValTok{103}\NormalTok{, }\FloatTok{4.0}\NormalTok{],}
\NormalTok{    [}\DecValTok{3}\NormalTok{, }\DecValTok{101}\NormalTok{, }\FloatTok{5.0}\NormalTok{],}
\NormalTok{    [}\DecValTok{3}\NormalTok{, }\DecValTok{104}\NormalTok{, }\FloatTok{3.5}\NormalTok{],}
\NormalTok{    [}\DecValTok{3}\NormalTok{, }\DecValTok{105}\NormalTok{, }\FloatTok{4.0}\NormalTok{]}
\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{a) Bestimmen Sie die niedrigste und höchste Bewertung, die jemals
gegeben wurde}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{niedrigste\_bewertung }\OperatorTok{=}\NormalTok{ np.}\BuiltInTok{min}\NormalTok{(bewertungen[:,}\DecValTok{2}\NormalTok{])}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Die niedrigste jemals gegebene Bewertung ist:"}\NormalTok{, niedrigste\_bewertung)}

\NormalTok{hoechste\_bewertung }\OperatorTok{=}\NormalTok{ np.}\BuiltInTok{max}\NormalTok{(bewertungen[:,}\DecValTok{2}\NormalTok{])}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Die höchste jemals gegebene Bewertung ist:"}\NormalTok{, hoechste\_bewertung)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die niedrigste jemals gegebene Bewertung ist: 2.5
Die höchste jemals gegebene Bewertung ist: 5.0
\end{verbatim}
\end{quote}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{b) Nennen Sie alle Bewertungen für Film 1}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bewertungen\_film\_1 }\OperatorTok{=}\NormalTok{ bewertungen[np.where(bewertungen[:,}\DecValTok{0}\NormalTok{]}\OperatorTok{==}\DecValTok{1}\NormalTok{)]}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Bewertungen für Film 1:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, bewertungen\_film\_1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Bewertungen für Film 1:
 [[  1.  101.    4.5]
 [  1.  102.    3. ]]
\end{verbatim}
\end{quote}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{c) Nennen Sie alle Bewertungen von Person 101}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bewertungen\_101 }\OperatorTok{=}\NormalTok{ bewertungen[np.where(bewertungen[:,}\DecValTok{1}\NormalTok{]}\OperatorTok{==}\DecValTok{101}\NormalTok{)]}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Bewertungen von Person 101:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, bewertungen\_101)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Bewertungen von Person 101:
 [[  1.  101.    4.5]
 [  2.  101.    2.5]
 [  3.  101.    5. ]]
\end{verbatim}
\end{quote}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{d) Berechnen Sie die mittlere Bewertung für jeden Film und geben Sie
diese nacheinander aus}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ ID }\KeywordTok{in}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]:}

\NormalTok{    mittelwert }\OperatorTok{=}\NormalTok{ np.mean(bewertungen[np.where(bewertungen[:,}\DecValTok{0}\NormalTok{]}\OperatorTok{==}\NormalTok{ID),}\DecValTok{2}\NormalTok{])}

    \BuiltInTok{print}\NormalTok{(}\StringTok{"Die mittlere Bewertung für Film"}\NormalTok{, ID, }\StringTok{"beträgt:"}\NormalTok{, mittelwert) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die mittlere Bewertung für Film 1 beträgt: 3.75
Die mittlere Bewertung für Film 2 beträgt: 3.25
Die mittlere Bewertung für Film 3 beträgt: 4.166666666666667
\end{verbatim}
\end{quote}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{e) Finden Sie den Film mit der höchsten Bewertung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{index\_hoechste\_bewertung }\OperatorTok{=}\NormalTok{ np.argmax(bewertungen[:,}\DecValTok{2}\NormalTok{])}

\BuiltInTok{print}\NormalTok{(bewertungen[index\_hoechste\_bewertung,:])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[  3. 101.   5.]
\end{verbatim}
\end{quote}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{f) Finden Sie die Person mit den meisten Bewertungen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{einzigartige\_person, anzahl }\OperatorTok{=}\NormalTok{ np.unique(bewertungen[:, }\DecValTok{1}\NormalTok{],return\_counts}\OperatorTok{=}\VariableTok{True}\NormalTok{)}

\NormalTok{meist\_aktive\_person }\OperatorTok{=}\NormalTok{ einzigartige\_person[np.argmax(anzahl)]}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Personen mit den meisten Bewertungen:"}\NormalTok{, meist\_aktive\_person)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Personen mit den meisten Bewertungen: 101.0
\end{verbatim}
\end{quote}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{g) Nennen Sie alle Filme mit einer Wertung von 4 oder besser.}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{index\_bewertung\_besser\_vier }\OperatorTok{=}\NormalTok{ bewertungen[:,}\DecValTok{2}\NormalTok{] }\OperatorTok{\textgreater{}=} \DecValTok{4}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Filme mit einer Wertung von 4 oder besser:"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(bewertungen[index\_bewertung\_besser\_vier,:])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Filme mit einer Wertung von 4 oder besser:
[[  1.  101.    4.5]
 [  2.  103.    4. ]
 [  3.  101.    5. ]
 [  3.  105.    4. ]]
\end{verbatim}
\end{quote}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{h) Film Nr. 4 ist erschienen. Der Film wurde von Person 102 mit einer
Note von 3.5 bewertet. Fügen Sie diesen zur Datenbank hinzu.}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{neue\_bewertung }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{4}\NormalTok{, }\DecValTok{102}\NormalTok{, }\FloatTok{3.5}\NormalTok{])}

\NormalTok{bewertungen }\OperatorTok{=}\NormalTok{ np.append(bewertungen, [neue\_bewertung], axis}\OperatorTok{=}\DecValTok{0}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(bewertungen)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[  1.  101.    4.5]
 [  1.  102.    3. ]
 [  2.  101.    2.5]
 [  2.  103.    4. ]
 [  3.  101.    5. ]
 [  3.  104.    3.5]
 [  3.  105.    4. ]
 [  4.  102.    3.5]]
\end{verbatim}
\end{quote}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{i) Person 102 hat sich Film Nr. 1 nochmal angesehen und hat das Ende
jetzt doch verstanden. Dementsprechend soll die Berwertung jetzt auf 5.0
geändert werden.}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bewertungen[(bewertungen[:, }\DecValTok{0}\NormalTok{] }\OperatorTok{==} \DecValTok{1}\NormalTok{) }\OperatorTok{\&} 
\NormalTok{            (bewertungen[:, }\DecValTok{1}\NormalTok{] }\OperatorTok{==} \DecValTok{102}\NormalTok{), }\DecValTok{2}\NormalTok{] }\OperatorTok{=} \FloatTok{5.0}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Aktualisieren der Bewertung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, bewertungen)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Aktualisieren der Bewertung:
 [[  1.  101.    4.5]
 [  1.  102.    5. ]
 [  2.  101.    2.5]
 [  2.  103.    4. ]
 [  3.  101.    5. ]
 [  3.  104.    3.5]
 [  3.  105.    4. ]
 [  4.  102.    3.5]]
\end{verbatim}
\end{quote}

\end{tcolorbox}

\section{Aufgabe 2 - Kryptographie -
Caesar-Chiffre}\label{aufgabe-2---kryptographie---caesar-chiffre}

In dieser Aufgabe wollen wir Text sowohl ver- als auch entschlüsseln.

Jedes Zeichen hat über die sogenannte ASCII-Tabelle einen Zahlenwert
zugeordnet.

\begin{longtable}[]{@{}llll@{}}
\caption{Ascii-Tabelle}\label{tbl-ascii}\tabularnewline
\toprule\noalign{}
Buchstabe & ASCII Code & Buchstabe & ASCII Code \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Buchstabe & ASCII Code & Buchstabe & ASCII Code \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
a & 97 & n & 110 \\
b & 98 & o & 111 \\
c & 99 & p & 112 \\
d & 100 & q & 113 \\
e & 101 & r & 114 \\
f & 102 & s & 115 \\
g & 103 & t & 116 \\
h & 104 & u & 117 \\
i & 105 & v & 118 \\
j & 106 & w & 119 \\
k & 107 & x & 120 \\
l & 108 & y & 121 \\
m & 109 & z & 122 \\
\end{longtable}

Der Einfachheit halber ist im Folgenden schon der Code zur Umwandlung
von Buchstaben in Zahlenwerte und wieder zurück aufgeführt. Außerdem
beschränken wir uns auf Texte mit kleinen Buchstaben.

Ihre Aufgabe ist nun, die Zahlenwerte zu verändern.

Zunächste wollen wir eine einfache Caesar-Chiffre anwenden. Dabei werden
alle Buchstaben um eine gewisse Anzahl verschoben. Ist Beispielsweise
der der Verschlüsselungswert ``1'' wird aus einem A ein B, einem M, ein
N. Ist der Wert ``4'' wird aus einem A ein E und aus einem M ein Q. Die
Verschiebung findet zyklisch statt, das heißt, bei einer Verschiebung
von 1 wird aus einem Z ein A.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\CommentTok{\# Funktion, die einen Buchstaben in ihren ASCII{-}Wert umwandelt}
\KeywordTok{def}\NormalTok{ buchstabe\_zu\_ascii(c):}
    \ControlFlowTok{return}\NormalTok{ np.array([}\BuiltInTok{ord}\NormalTok{(c)])}

\CommentTok{\# Funktion, die einen ASCII{-}Wert in den passenden Buchstaben umwandelt}
\KeywordTok{def}\NormalTok{ ascii\_zu\_buchstabe(a):}
    \ControlFlowTok{return} \BuiltInTok{chr}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{1. Überlegen Sie sich zunächst, wie man diese zyklische Verschiebung
mathematisch ausdrücken könnte (Hinweis: Modulo Rechnung)}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{quote}
\textbf{Lösung}

\[ \textrm{ASCII}_{\textrm{verschoben}} = (\textrm{ASCII} - 97 + \textrm{Versatz}) \textrm{ mod } 26 + 97\]
\end{quote}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{2. Schreiben Sie Code, der mit einer Schleife alle Zeichen umwandelt.}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Zunächst sollen alle Zeichen in ASCII-Code umgewandelt werden. Dann wird
die Formel auf die Zahlenwerte angewendet und schlussendlich in einer
dritten Schleife wieder alle Werte in Buchstaben übersetzt.

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\CommentTok{\# Funktion, die einen Buchstaben in ihren ASCII{-}Wert umwandelt}
\KeywordTok{def}\NormalTok{ buchstabe\_zu\_ascii(c):}
    \ControlFlowTok{return} \BuiltInTok{ord}\NormalTok{(c)}

\CommentTok{\# Funktion, die einen ASCII{-}Wert in den passenden Buchstaben umwandelt}
\KeywordTok{def}\NormalTok{ ascii\_zu\_buchstabe(a):}
    \ControlFlowTok{return} \BuiltInTok{chr}\NormalTok{(a)}

\NormalTok{klartext }\OperatorTok{=} \StringTok{"abrakadabra"}
\NormalTok{versatz }\OperatorTok{=} \DecValTok{3}

\NormalTok{umgewandelter\_text }\OperatorTok{=}\NormalTok{ []}
\NormalTok{verschluesselte\_zahl }\OperatorTok{=}\NormalTok{ []}
\NormalTok{verschluesselter\_text}\OperatorTok{=}\NormalTok{ []}



\ControlFlowTok{for}\NormalTok{ buchstabe }\KeywordTok{in}\NormalTok{ klartext:}
\NormalTok{    umgewandelter\_text.append(buchstabe\_zu\_ascii(buchstabe))}
\BuiltInTok{print}\NormalTok{(umgewandelter\_text)}


\ControlFlowTok{for}\NormalTok{ zahl }\KeywordTok{in}\NormalTok{ umgewandelter\_text:    }
\NormalTok{    verschluesselt }\OperatorTok{=}\NormalTok{ (zahl }\OperatorTok{{-}} \DecValTok{97} \OperatorTok{+}\NormalTok{ versatz) }\OperatorTok{\%} \DecValTok{26} \OperatorTok{+} \DecValTok{97}
\NormalTok{    verschluesselte\_zahl.append(verschluesselt)}
\BuiltInTok{print}\NormalTok{(verschluesselte\_zahl)}


\ControlFlowTok{for}\NormalTok{ zahl }\KeywordTok{in}\NormalTok{ verschluesselte\_zahl:    }
\NormalTok{    verschluesselter\_text.append(ascii\_zu\_buchstabe(zahl))}
\BuiltInTok{print}\NormalTok{(verschluesselter\_text)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[97, 98, 114, 97, 107, 97, 100, 97, 98, 114, 97]
[100, 101, 117, 100, 110, 100, 103, 100, 101, 117, 100]
['d', 'e', 'u', 'd', 'n', 'd', 'g', 'd', 'e', 'u', 'd']
\end{verbatim}
\end{quote}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{3. Ersetzen Sie die Schleife, indem Sie die Rechenoperation mit einem
NumPy-Array durchführen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\CommentTok{\# Funktion, die einen Buchstaben in ihren ASCII{-}Wert umwandelt}
\KeywordTok{def}\NormalTok{ buchstabe\_zu\_ascii(c):}
    \ControlFlowTok{return} \BuiltInTok{ord}\NormalTok{(c)}

\CommentTok{\# Funktion, die einen ASCII{-}Wert in den passenden Buchstaben umwandelt}
\KeywordTok{def}\NormalTok{ ascii\_zu\_buchstabe(a):}
    \ControlFlowTok{return} \BuiltInTok{chr}\NormalTok{(a)}

\NormalTok{klartext }\OperatorTok{=} \StringTok{"abrakadabra"}
\NormalTok{versatz }\OperatorTok{=} \DecValTok{3}

\NormalTok{umgewandelter\_text }\OperatorTok{=}\NormalTok{ []}
\NormalTok{verschluesselte\_zahl }\OperatorTok{=}\NormalTok{ []}
\NormalTok{verschluesselter\_text}\OperatorTok{=}\NormalTok{ []}



\ControlFlowTok{for}\NormalTok{ buchstabe }\KeywordTok{in}\NormalTok{ klartext:}
\NormalTok{    umgewandelter\_text.append(buchstabe\_zu\_ascii(buchstabe))}
\BuiltInTok{print}\NormalTok{(umgewandelter\_text)}

\NormalTok{umgewandelter\_text }\OperatorTok{=}\NormalTok{ np.array(umgewandelter\_text)}
\NormalTok{verschluesselte\_zahl }\OperatorTok{=}\NormalTok{ (umgewandelter\_text }\OperatorTok{{-}} \DecValTok{97} \OperatorTok{+}\NormalTok{ versatz) }\OperatorTok{\%} \DecValTok{26} \OperatorTok{+} \DecValTok{97}
\BuiltInTok{print}\NormalTok{(verschluesselte\_zahl)}

\ControlFlowTok{for}\NormalTok{ zahl }\KeywordTok{in}\NormalTok{ verschluesselte\_zahl:    }
\NormalTok{    verschluesselter\_text.append(ascii\_zu\_buchstabe(zahl))}
\BuiltInTok{print}\NormalTok{(verschluesselter\_text)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[97, 98, 114, 97, 107, 97, 100, 97, 98, 114, 97]
[100 101 117 100 110 100 103 100 101 117 100]
['d', 'e', 'u', 'd', 'n', 'd', 'g', 'd', 'e', 'u', 'd']
\end{verbatim}
\end{quote}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{4. Schreiben sie den Code so um, dass der verschlüsselte Text
entschlüsselt wird.}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{quote}
\textbf{Lösung}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\CommentTok{\# Funktion, die einen Buchstaben in ihren ASCII{-}Wert umwandelt}
\KeywordTok{def}\NormalTok{ buchstabe\_zu\_ascii(c):}
    \ControlFlowTok{return} \BuiltInTok{ord}\NormalTok{(c)}

\CommentTok{\# Funktion, die einen ASCII{-}Wert in den passenden Buchstaben umwandelt}
\KeywordTok{def}\NormalTok{ ascii\_zu\_buchstabe(a):}
    \ControlFlowTok{return} \BuiltInTok{chr}\NormalTok{(a)}


\NormalTok{versatz }\OperatorTok{=} \DecValTok{3}

\NormalTok{umgewandelter\_text }\OperatorTok{=}\NormalTok{ []}
\NormalTok{verschluesselte\_zahl }\OperatorTok{=}\NormalTok{ []}
\NormalTok{entschluesselter\_text}\OperatorTok{=}\NormalTok{ []}



\ControlFlowTok{for}\NormalTok{ buchstabe }\KeywordTok{in}\NormalTok{ verschluesselter\_text:}
\NormalTok{    umgewandelter\_text.append(buchstabe\_zu\_ascii(buchstabe))}
\BuiltInTok{print}\NormalTok{(umgewandelter\_text)}

\NormalTok{umgewandelter\_text }\OperatorTok{=}\NormalTok{ np.array(umgewandelter\_text)}
\NormalTok{verschluesselte\_zahl }\OperatorTok{=}\NormalTok{ (umgewandelter\_text }\OperatorTok{{-}} \DecValTok{97} \OperatorTok{{-}}\NormalTok{ versatz) }\OperatorTok{\%} \DecValTok{26} \OperatorTok{+} \DecValTok{97}
\BuiltInTok{print}\NormalTok{(verschluesselte\_zahl)}

\ControlFlowTok{for}\NormalTok{ zahl }\KeywordTok{in}\NormalTok{ verschluesselte\_zahl:    }
\NormalTok{    entschluesselter\_text.append(ascii\_zu\_buchstabe(zahl))}
\BuiltInTok{print}\NormalTok{(entschluesselter\_text)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[100, 101, 117, 100, 110, 100, 103, 100, 101, 117, 100]
[ 97  98 114  97 107  97 100  97  98 114  97]
['a', 'b', 'r', 'a', 'k', 'a', 'd', 'a', 'b', 'r', 'a']
\end{verbatim}
\end{quote}

\end{tcolorbox}

\chapter{Klausurfragen}\label{klausurfragen}

\section*{Aufgabe 1}\label{aufgabe-1-2}
\addcontentsline{toc}{section}{Aufgabe 1}

\markright{Aufgabe 1}

Ein rechteckiger Träger aus Beton wird entlang seiner Länge mit einer
gleichmäßig verteilten Last belastet. Die Spannungsverteilung entlang
der Länge des Trägers soll analysiert werden. Der Träger hat eine Länge
von 10 Metern und eine Breite von 0,3 Metern. Die Höhe des Trägers
beträgt 0,5 Meter. Die gleichmäßig verteilte Last beträgt 5000 N/m.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Erstellen Sie ein NumPy-Array \texttt{x} mit 100 gleichmäßig
  verteilten Punkten entlang der Länge des Trägers von 0 bis 10 Metern.
\item
  Berechnen Sie die Biegemomente \(M(x)\) entlang der Länge des Trägers
  unter Verwendung der Formel: \[
  \left[M(x) = \frac{w \cdot x \cdot (L - x)}{2}\right]
  \]
\end{enumerate}

wobei \(w\) die verteilte Last (in N/m), \(x\) die Position entlang des
Trägers (in m) und \(L\) die Länge des Trägers (in m) ist.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Berechnen Sie die maximale Biegespannung \(σ_{max}\)\hspace{0pt} an
  jedem Punkt entlang des Trägers unter Verwendung der Formel: \[
  \left[\sigma_{\text{max}}(x) = \frac{M(x) \cdot c}{I}\right]
  \]
\end{enumerate}

wobei \(c\) der Abstand von der neutralen Faser zur äußersten Faser des
Trägers (in m) und \(I\) das Flächenträgheitsmoment ist. Das
Flächenträgheitsmoment eines rechteckigen Querschnitts ist: \[
\left[
I = \frac{b \cdot h^3}{12}
\right]
\]

wobei \(b\) die Breite (in m) und \(h\) die Höhe des Trägers (in m) ist.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Bestimmen Sie die maximale Biegespannung
\item
  Plotten Sie die Spannungsverteilung \(\sigma_{max}​(x)\) entlang der
  Länge des Trägers.
\end{enumerate}

\part{w-python-matplotlib}

\chapter*{Preamble}\label{preamble}
\addcontentsline{toc}{chapter}{Preamble}

\markboth{Preamble}{Preamble}

\phantomsection\label{Lizenz}
\begin{figure}

\begin{minipage}{0.20\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/by.png}}\end{minipage}%
%
\begin{minipage}{0.80\linewidth}
Bausteine Computergestützter Datenanalyse von Lukas Arnold, Simone
Arnold, Florian Bagemihl, Matthias Baitsch, Marc Fehr, Franca Hollmann,
Maik Poetzsch und Sebastian Seipel. ``Werkzeugbaustein Matplotlib'' von
Marc Fehr ist lizensiert unter
\href{https://creativecommons.org/licenses/by/4.0/deed.de}{CC BY 4.0}.
Das Werk ist abrufbar unter
\url{https://github.com/bausteine-der-datenanalyse/w-python-matplotlib}.
Ausgenommen von der Lizenz sind alle Logos und anders gekennzeichneten
Inhalte. 2025\end{minipage}%

\end{figure}%

Zitiervorschlag

Arnold, Lukas, Simone Arnold, Matthias Baitsch, Marc Fehr, Franca
Hollmann, Maik Poetzsch, und Sebastian Seipel. 2025. „Bausteine
Computergestützter Datenanalyse. Werkzeugbaustein Matplotlib``.
\url{https://github.com/bausteine-der-datenanalyse/w-python-matplotlib}.

BibTeX-Vorlage

\begin{verbatim}
@misc{BCD-python-matplotlib-2025,
 title={Bausteine Computergestützter Datenanalyse. Werkzeugbaustein Matplotlib},
 author={Arnold, Lukas and Arnold, Simone and Baitsch, Matthias and Fehr, Marc and Hollmann, Franca and Poetzsch, Maik and Seipel, Sebastian},
 year={2025},
 url={https://github.com/bausteine-der-datenanalyse/w-python-matplotlib}} 
\end{verbatim}

\chapter*{Intro}\label{intro-1}
\addcontentsline{toc}{chapter}{Intro}

\markboth{Intro}{Intro}

\section*{Voraussetzungen}\label{voraussetzungen-4}
\addcontentsline{toc}{section}{Voraussetzungen}

\markright{Voraussetzungen}

\begin{itemize}
\tightlist
\item
  Grundlagen Python
\item
  Einbinden von zusätzlichen Paketen
\end{itemize}

\section*{Verwendete Pakete und
Datensätze}\label{verwendete-pakete-und-datensuxe4tze-1}
\addcontentsline{toc}{section}{Verwendete Pakete und Datensätze}

\markright{Verwendete Pakete und Datensätze}

\begin{itemize}
\tightlist
\item
  matplotlib
\end{itemize}

\section*{Bearbeitungszeit}\label{bearbeitungszeit-1}
\addcontentsline{toc}{section}{Bearbeitungszeit}

\markright{Bearbeitungszeit}

Geschätzte Bearbeitungszeit: 1h

\section*{Lernziele}\label{lernziele-4}
\addcontentsline{toc}{section}{Lernziele}

\markright{Lernziele}

\begin{itemize}
\tightlist
\item
  Einleitung: wie visualisiere ich Daten in Python
\item
  Anpassen von Plots
\item
  Do's \& Dont's für wissenschaftliche Plots
\end{itemize}

\chapter{Einführung in Matplotlib}\label{einfuxfchrung-in-matplotlib}

Matplotlib ist eine der bekanntesten Bibliotheken zur
Datenvisualisierung in Python. Sie ermöglicht das Erstellen statischer,
animierter und interaktiver Diagramme mit hoher Flexibilität.

\section{Warum Matplotlib?}\label{warum-matplotlib}

\begin{itemize}
\tightlist
\item
  \textbf{Breite Unterstützung:} Funktioniert mit NumPy, Pandas und
  SciPy.
\item
  \textbf{Hohe Anpassbarkeit:} Vollständige Kontrolle über Diagramme.
\item
  \textbf{Integration in Jupyter Notebooks:} Ideal für interaktive
  Datenanalyse.
\item
  \textbf{Kompatibilität:} Unterstützt verschiedene Ausgabeformate (PNG,
  SVG, PDF etc.).
\end{itemize}

\section{Alternativen zu Matplotlib}\label{alternativen-zu-matplotlib}

Während Matplotlib leistungsstark ist, gibt es Alternativen, die für
bestimmte Zwecke besser geeignet sein können: - \textbf{Seaborn:}
Basiert auf Matplotlib, erleichtert statistische Visualisierung. -
\textbf{Plotly:} Erzeugt interaktive Plots, gut für Dashboards. -
\textbf{Bokeh:} Ideal für Web-Anwendungen mit interaktiven
Visualisierungen.

\section{Erstes Beispiel: Einfache Linie
plotten}\label{erstes-beispiel-einfache-linie-plotten}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\CommentTok{\# Beispiel{-}Daten}
\NormalTok{t }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{100}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ np.sin(t)}

\CommentTok{\# Erstellen des Plots}
\NormalTok{plt.plot(t, y, label}\OperatorTok{=}\StringTok{\textquotesingle{}sin(t)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Zeit (s)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Amplitude\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Einfaches Linien{-}Diagramm\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

Dieses einfache Beispiel zeigt, wie man mit Matplotlib eine
\textbf{Sinuskurve} visualisieren kann.

\section{Nächste Schritte}\label{nuxe4chste-schritte}

Im nächsten Kapitel werden wir uns mit den verschiedenen Diagrammtypen
beschäftigen, die Matplotlib bietet.

\chapter{Diagrammtypen in Matplotlib}\label{diagrammtypen-in-matplotlib}

Matplotlib bietet eine Vielzahl von Diagrammtypen, die für
unterschiedliche Zwecke geeignet sind. In diesem Kapitel werden die
wichtigsten Diagrammtypen vorgestellt und ihre Anwendungsfälle erklärt.

\section{\texorpdfstring{1. Liniendiagramme
(\texttt{plt.plot()})}{1. Liniendiagramme (plt.plot())}}\label{liniendiagramme-plt.plot}

Liniendiagramme eignen sich hervorragend zur Darstellung von Trends über
Zeit.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\NormalTok{t }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{100}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ np.sin(t)}

\NormalTok{plt.plot(t, y, label}\OperatorTok{=}\StringTok{\textquotesingle{}sin(t)\textquotesingle{}}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Zeit (s)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Amplitude\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Liniendiagramm\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/basic_plot_types_files/figure-pdf/cell-2-output-1.png}}

\section{\texorpdfstring{2. Streudiagramme
(\texttt{plt.scatter()})}{2. Streudiagramme (plt.scatter())}}\label{streudiagramme-plt.scatter}

Streudiagramme werden verwendet, um Zusammenhänge zwischen zwei
Variablen darzustellen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.random.rand(}\DecValTok{50}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ np.random.rand(}\DecValTok{50}\NormalTok{)}

\NormalTok{plt.scatter(x, y, color}\OperatorTok{=}\StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.5}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Variable X\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Variable Y\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Streudiagramm\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/basic_plot_types_files/figure-pdf/cell-3-output-1.png}}

\section{\texorpdfstring{3. Balkendiagramme
(\texttt{plt.bar()})}{3. Balkendiagramme (plt.bar())}}\label{balkendiagramme-plt.bar}

Balkendiagramme eignen sich zur Darstellung kategorialer Daten.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{kategorien }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}B\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}C\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}D\textquotesingle{}}\NormalTok{]}
\NormalTok{werte }\OperatorTok{=}\NormalTok{ [}\DecValTok{3}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{]}

\NormalTok{plt.bar(kategorien, werte, color}\OperatorTok{=}\StringTok{\textquotesingle{}g\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Kategorien\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Wert\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Balkendiagramm\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/basic_plot_types_files/figure-pdf/cell-4-output-1.png}}

\section{\texorpdfstring{4. Histogramme
(\texttt{plt.hist()})}{4. Histogramme (plt.hist())}}\label{histogramme-plt.hist}

Histogramme zeigen die Verteilung numerischer Daten.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{daten }\OperatorTok{=}\NormalTok{ np.random.randn(}\DecValTok{1000}\NormalTok{)}
\NormalTok{plt.hist(daten, bins}\OperatorTok{=}\DecValTok{30}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}purple\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.7}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Wert\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Häufigkeit\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Histogramm\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/basic_plot_types_files/figure-pdf/cell-5-output-1.png}}

\section{\texorpdfstring{5. Boxplots
(\texttt{plt.boxplot()})}{5. Boxplots (plt.boxplot())}}\label{boxplots-plt.boxplot}

Boxplots helfen, Ausreißer und die Verteilung von Daten zu
visualisieren.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{daten }\OperatorTok{=}\NormalTok{ [np.random.randn(}\DecValTok{100}\NormalTok{) }\ControlFlowTok{for}\NormalTok{ \_ }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{4}\NormalTok{)]}
\NormalTok{plt.boxplot(daten, labels}\OperatorTok{=}\NormalTok{[}\StringTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}B\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}C\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}D\textquotesingle{}}\NormalTok{])}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Wert\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Boxplot\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_80633/2728911591.py:2: MatplotlibDeprecationWarning: The 'labels' parameter of boxplot() has been renamed 'tick_labels' since Matplotlib 3.9; support for the old name will be dropped in 3.11.
  plt.boxplot(daten, labels=['A', 'B', 'C', 'D'])
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/basic_plot_types_files/figure-pdf/cell-6-output-2.png}}

\section{\texorpdfstring{6. Heatmaps
(\texttt{plt.imshow()})}{6. Heatmaps (plt.imshow())}}\label{heatmaps-plt.imshow}

Heatmaps eignen sich zur Darstellung von 2D-Daten.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{daten }\OperatorTok{=}\NormalTok{ np.random.rand(}\DecValTok{10}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\NormalTok{plt.imshow(daten, cmap}\OperatorTok{=}\StringTok{\textquotesingle{}coolwarm\textquotesingle{}}\NormalTok{, interpolation}\OperatorTok{=}\StringTok{\textquotesingle{}nearest\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.colorbar()}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Heatmap\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/basic_plot_types_files/figure-pdf/cell-7-output-1.png}}

\section{Fazit}\label{fazit}

Die Wahl des richtigen Diagrammtyps hängt von der Art der Daten und der
gewünschten Darstellung ab. Im nächsten Kapitel werden wir uns mit der
Anpassung und Gestaltung von Plots beschäftigen.

\chapter{Anpassung und Gestaltung von Plots in
Matplotlib}\label{anpassung-und-gestaltung-von-plots-in-matplotlib}

Ein gut gestaltetes Diagramm verbessert die Lesbarkeit und
Verständlichkeit der dargestellten Daten. In diesem Kapitel werden wir
verschiedene Möglichkeiten zur Anpassung und Gestaltung von Plots in
Matplotlib erkunden.

\section{1. Achsentitel und
Diagrammtitel}\label{achsentitel-und-diagrammtitel}

Klare Achsen- und Diagrammtitel sind essenziell für die Verständlichkeit
eines Plots.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\NormalTok{t }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{100}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ np.sin(t)}

\NormalTok{plt.plot(t, y, label}\OperatorTok{=}\StringTok{\textquotesingle{}sin(t)\textquotesingle{}}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Zeit (s)\textquotesingle{}}\NormalTok{, fontsize}\OperatorTok{=}\DecValTok{12}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Amplitude\textquotesingle{}}\NormalTok{, fontsize}\OperatorTok{=}\DecValTok{12}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Liniendiagramm mit Beschriftung\textquotesingle{}}\NormalTok{, fontsize}\OperatorTok{=}\DecValTok{14}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/adapting_plots_files/figure-pdf/cell-2-output-1.png}}

\section{2. Anpassung der Achsen}\label{anpassung-der-achsen}

Die Skalierung der Achsen sollte sinnvoll gewählt werden, um die Daten
bestmöglich darzustellen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(t, y, label}\OperatorTok{=}\StringTok{\textquotesingle{}sin(t)\textquotesingle{}}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Zeit (s)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Amplitude\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlim(}\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\NormalTok{plt.ylim(}\OperatorTok{{-}}\FloatTok{1.2}\NormalTok{, }\FloatTok{1.2}\NormalTok{)}
\NormalTok{plt.grid(}\VariableTok{True}\NormalTok{, linestyle}\OperatorTok{=}\StringTok{\textquotesingle{}{-}{-}\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.7}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Liniendiagramm mit angepassten Achsen\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/adapting_plots_files/figure-pdf/cell-3-output-1.png}}

\section{3. Farben und Linienstile}\label{farben-und-linienstile}

Farben und Linienstile helfen dabei, wichtige Informationen im Plot
hervorzuheben.

\subsection{Wichtige Farben (Standardfarben in
Matplotlib)}\label{wichtige-farben-standardfarben-in-matplotlib}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Farbe & Kürzel & Beschreibung \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Blau & `b' & blue \\
Grün & `g' & green \\
Rot & `r' & red \\
Cyan & `c' & cyan \\
Magenta & `m' & magenta \\
Gelb & `y' & yellow \\
Schwarz & `k' & black \\
Weiß & `w' & white \\
\end{longtable}

\subsection{Wichtige Linienstile}\label{wichtige-linienstile}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Linienstil & Kürzel & Beschreibung \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Durchgezogen & `-' & Standardlinie \\
Gestrichelt & `--' & lange Striche \\
Gepunktet & `:' & nur Punkte \\
Strich-Punkt & `-.' & abwechselnd Strich-Punkt \\
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(t, np.sin(t), linestyle}\OperatorTok{=}\StringTok{\textquotesingle{}{-}\textquotesingle{}}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}sin(t)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(t, np.cos(t), linestyle}\OperatorTok{=}\StringTok{\textquotesingle{}{-}{-}\textquotesingle{}}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}g\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}cos(t)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Zeit (s)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Amplitude\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Anpassung von Farben und Linienstilen\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/adapting_plots_files/figure-pdf/cell-4-output-1.png}}

\section{4. Mehrere Plots mit
Subplots}\label{mehrere-plots-mit-subplots}

Manchmal ist es sinnvoll, mehrere Diagramme in einer Abbildung
darzustellen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fig, axs }\OperatorTok{=}\NormalTok{ plt.subplots(}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, figsize}\OperatorTok{=}\NormalTok{(}\DecValTok{6}\NormalTok{, }\DecValTok{6}\NormalTok{))}
\NormalTok{axs[}\DecValTok{0}\NormalTok{].plot(t, np.sin(t), color}\OperatorTok{=}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{)}
\NormalTok{axs[}\DecValTok{0}\NormalTok{].set\_title(}\StringTok{\textquotesingle{}Sinusfunktion\textquotesingle{}}\NormalTok{)}
\NormalTok{axs[}\DecValTok{1}\NormalTok{].plot(t, np.cos(t), color}\OperatorTok{=}\StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}
\NormalTok{axs[}\DecValTok{1}\NormalTok{].set\_title(}\StringTok{\textquotesingle{}Kosinusfunktion\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.tight\_layout()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/adapting_plots_files/figure-pdf/cell-5-output-1.png}}

\section{5. Speichern von Plots}\label{speichern-von-plots}

Man kann Diagramme in verschiedenen Formaten speichern.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(t, y, label}\OperatorTok{=}\StringTok{\textquotesingle{}sin(t)\textquotesingle{}}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Zeit (s)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Amplitude\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Speicherung eines Plots\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.savefig(}\StringTok{\textquotesingle{}mein\_plot.png\textquotesingle{}}\NormalTok{, dpi}\OperatorTok{=}\DecValTok{300}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/adapting_plots_files/figure-pdf/cell-6-output-1.png}}

\section{Fazit}\label{fazit-1}

Durch geschickte Anpassungen lassen sich wissenschaftliche Plots
deutlich verbessern. Im nächsten Kapitel werden wir uns mit erweiterten
Techniken wie logarithmischen Skalen und Annotationen beschäftigen.

\chapter{Erweiterte Techniken in
Matplotlib}\label{erweiterte-techniken-in-matplotlib}

In diesem Kapitel betrachten wir einige fortgeschrittene Funktionen von
Matplotlib, die für die wissenschaftliche Datenvisualisierung besonders
nützlich sind.

\section{1. Logarithmische Skalen}\label{logarithmische-skalen}

Logarithmische Skalen werden oft verwendet, wenn Werte große
Größenordnungen umfassen.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\NormalTok{x }\OperatorTok{=}\NormalTok{ np.logspace(}\FloatTok{0.1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{100}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ np.log10(x)}

\NormalTok{plt.plot(x, y, label}\OperatorTok{=}\StringTok{\textquotesingle{}log10(x)\textquotesingle{}}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xscale(}\StringTok{\textquotesingle{}log\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}X{-}Wert (log{-}Skala)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Y{-}Wert\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Logarithmische Skalierung\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.grid(}\VariableTok{True}\NormalTok{, which}\OperatorTok{=}\StringTok{\textquotesingle{}both\textquotesingle{}}\NormalTok{, linestyle}\OperatorTok{=}\StringTok{\textquotesingle{}{-}{-}\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.7}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/advanced_techniques_files/figure-pdf/cell-2-output-1.png}}

\section{2. Twin-Achsen für verschiedene
Skalierungen}\label{twin-achsen-fuxfcr-verschiedene-skalierungen}

Manchmal möchte man zwei verschiedene y-Achsen in einem Plot darstellen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{100}\NormalTok{)}
\NormalTok{y1 }\OperatorTok{=}\NormalTok{ np.sin(x)}
\NormalTok{y2 }\OperatorTok{=}\NormalTok{ np.exp(x }\OperatorTok{/} \DecValTok{3}\NormalTok{)}

\NormalTok{fig, ax1 }\OperatorTok{=}\NormalTok{ plt.subplots()}
\NormalTok{ax2 }\OperatorTok{=}\NormalTok{ ax1.twinx()}
\NormalTok{ax1.plot(x, y1, }\StringTok{\textquotesingle{}g{-}\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}sin(x)\textquotesingle{}}\NormalTok{)}
\NormalTok{ax2.plot(x, y2, }\StringTok{\textquotesingle{}b{-}{-}\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}exp(x/3)\textquotesingle{}}\NormalTok{)}

\NormalTok{ax1.set\_xlabel(}\StringTok{\textquotesingle{}X{-}Wert\textquotesingle{}}\NormalTok{)}
\NormalTok{ax1.set\_ylabel(}\StringTok{\textquotesingle{}Sinus\textquotesingle{}}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}g\textquotesingle{}}\NormalTok{)}
\NormalTok{ax2.set\_ylabel(}\StringTok{\textquotesingle{}Exponentiell\textquotesingle{}}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{)}
\NormalTok{ax1.set\_title(}\StringTok{\textquotesingle{}Twin{-}Achsen für unterschiedliche Skalierungen\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/advanced_techniques_files/figure-pdf/cell-3-output-1.png}}

\section{3. Annotationen in
Diagrammen}\label{annotationen-in-diagrammen}

Wichtige Punkte oder Werte in einem Diagramm können mit Annotationen
hervorgehoben werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{100}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ np.sin(x)}

\NormalTok{plt.plot(x, y, label}\OperatorTok{=}\StringTok{\textquotesingle{}sin(x)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}X{-}Wert\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Amplitude\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Annotationen in Matplotlib\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.annotate(}\StringTok{\textquotesingle{}Maximalwert\textquotesingle{}}\NormalTok{, xy}\OperatorTok{=}\NormalTok{(np.pi}\OperatorTok{/}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{), xytext}\OperatorTok{=}\NormalTok{(}\DecValTok{2}\NormalTok{, }\FloatTok{1.2}\NormalTok{),}
\NormalTok{             arrowprops}\OperatorTok{=}\BuiltInTok{dict}\NormalTok{(facecolor}\OperatorTok{=}\StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{, shrink}\OperatorTok{=}\FloatTok{0.05}\NormalTok{))}
\NormalTok{plt.legend()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/advanced_techniques_files/figure-pdf/cell-4-output-1.png}}

\section{Fazit}\label{fazit-2}

Diese erweiterten Funktionen helfen dabei, wissenschaftliche Plots noch
informativer zu gestalten. Im nächsten Kapitel werden wir Best Practices
und typische Fehler in der wissenschaftlichen Visualisierung betrachten.

\chapter{Best Practices in Matplotlib: Fehler und
Verbesserungen}\label{best-practices-in-matplotlib-fehler-und-verbesserungen}

In diesem Kapitel zeigen wir für häufige Problemstellungen jeweils ein
schlechtes und ein verbessertes Beispiel.

\section{1. Fehlende Beschriftungen}\label{fehlende-beschriftungen}

\subsection{❌ Schlechtes Beispiel}\label{schlechtes-beispiel}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\NormalTok{x }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{100}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ np.sin(x)}

\NormalTok{plt.plot(x, y)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/scientific_plotting_files/figure-pdf/cell-2-output-1.png}}

\subsection{✅ Besseres Beispiel}\label{besseres-beispiel}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y, label}\OperatorTok{=}\StringTok{\textquotesingle{}sin(x)\textquotesingle{}}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Zeit (s)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Amplitude\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Sinuskurve\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/scientific_plotting_files/figure-pdf/cell-3-output-1.png}}

\section{2. Ungünstige Farbwahl}\label{unguxfcnstige-farbwahl}

\subsection{❌ Schlechtes Beispiel}\label{schlechtes-beispiel-1}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y, color}\OperatorTok{=}\StringTok{\textquotesingle{}yellow\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/scientific_plotting_files/figure-pdf/cell-4-output-1.png}}

\subsection{✅ Besseres Beispiel}\label{besseres-beispiel-1}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y, color}\OperatorTok{=}\StringTok{\textquotesingle{}darkblue\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.grid(}\VariableTok{True}\NormalTok{, linestyle}\OperatorTok{=}\StringTok{\textquotesingle{}{-}{-}\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.7}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Gute Kontraste für bessere Lesbarkeit\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/scientific_plotting_files/figure-pdf/cell-5-output-1.png}}

\section{3. Keine sinnvolle
Achsenskalierung}\label{keine-sinnvolle-achsenskalierung}

\subsection{❌ Schlechtes Beispiel}\label{schlechtes-beispiel-2}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y)}
\NormalTok{plt.ylim(}\FloatTok{0.5}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/scientific_plotting_files/figure-pdf/cell-6-output-1.png}}

\subsection{✅ Besseres Beispiel}\label{besseres-beispiel-2}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y)}
\NormalTok{plt.ylim(}\OperatorTok{{-}}\FloatTok{1.2}\NormalTok{, }\FloatTok{1.2}\NormalTok{)}
\NormalTok{plt.xlim(}\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\NormalTok{plt.grid(}\VariableTok{True}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Sinnvolle Achsenskalierung\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/scientific_plotting_files/figure-pdf/cell-7-output-1.png}}

\section{4. Überladung durch zu viele
Linien}\label{uxfcberladung-durch-zu-viele-linien}

\subsection{❌ Schlechtes Beispiel}\label{schlechtes-beispiel-3}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{10}\NormalTok{):}
\NormalTok{    plt.plot(x, np.sin(x }\OperatorTok{+}\NormalTok{ i }\OperatorTok{*} \FloatTok{0.2}\NormalTok{))}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/scientific_plotting_files/figure-pdf/cell-8-output-1.png}}

\subsection{✅ Besseres Beispiel}\label{besseres-beispiel-3}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, np.sin(x), label}\OperatorTok{=}\StringTok{\textquotesingle{}sin(x)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(x, np.cos(x), label}\OperatorTok{=}\StringTok{\textquotesingle{}cos(x)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Weniger ist mehr: Reduzierte Informationsdichte\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.grid(}\VariableTok{True}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-python-matplotlib/skript/scientific_plotting_files/figure-pdf/cell-9-output-1.png}}

\section{Fazit}\label{fazit-3}

Gute Plots zeichnen sich durch klare Beschriftungen, gute Lesbarkeit und
eine sinnvolle Informationsdichte aus.

\part{w-python-pandas}

\chapter*{Werkzeugbaustein Pandas}\label{werkzeugbaustein-pandas}
\addcontentsline{toc}{chapter}{Werkzeugbaustein Pandas}

\markboth{Werkzeugbaustein Pandas}{Werkzeugbaustein Pandas}

\phantomsection\label{Lizenz}
\begin{figure}

\begin{minipage}{0.20\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/w-pandas/skript/00-bilder/CC-BY.pdf}}\end{minipage}%
%
\begin{minipage}{0.80\linewidth}
Bausteine Computergestützter Datenanalyse von Lukas Arnold, Simone
Arnold, Florian Bagemihl, Matthias Baitsch, Marc Fehr, Franca Hollmann,
Maik Poetzsch und Sebastian Seipel. Werkzeugbaustein Pandas von Marc
Fehr und Maik Poetzsch ist lizensiert unter
\href{https://creativecommons.org/licenses/by/4.0/deed.de}{CC BY 4.0}.
Das Werk ist abrufbar auf
\href{https://github.com/bausteine-der-datenanalyse/w-pandas}{GitHub}.
Ausgenommen von der Lizenz sind alle Logos Dritter und anders
gekennzeichneten Inhalte. 2025\end{minipage}%

\end{figure}%

Zitiervorschlag

Arnold, Lukas, Simone Arnold, Matthias Baitsch, Marc Fehr, Franca
Hollmann, Maik Poetzsch, und Sebastian Seipel. 2025. „Bausteine
Computergestützter Datenanalyse. Werkzeugbaustein Pandas``.
\url{https://github.com/bausteine-der-datenanalyse/w-pandas}.

BibTeX-Vorlage

\begin{verbatim}
@misc{BCD-w-pandas-2025,
 title={Bausteine Computergestützter Datenanalyse. Werkzeugbaustein Pandas},
 author={Arnold, Lukas and Arnold, Simone and Baitsch, Matthias and Fehr, Marc and Hollmann, Franca and Poetzsch, Maik and Seipel, Sebastian},
 year={2025},
 url={https://github.com/bausteine-der-datenanalyse/w-pandas}} 
\end{verbatim}

\section*{Voraussetzungen}\label{voraussetzungen-5}
\addcontentsline{toc}{section}{Voraussetzungen}

\markright{Voraussetzungen}

Die Bearbeitungszeit dieses Bausteins beträgt circa 8 Stunden. Folgende
Bausteine sollte Sie bereits bearbeitet haben:

\begin{itemize}
\tightlist
\item
  w-Python
\item
  w-NumPy
\end{itemize}

In diesem Baustein werden die folgenden Module verwendet:

\begin{itemize}
\tightlist
\item
  NumPy
\item
  Pandas
\item
  Matplotlib
\item
  zoneinfo (optional)
\end{itemize}

Im Baustein werden folgende Daten verwendet:

\begin{itemize}
\tightlist
\item
  Zahnwachstum bei Meerschweinchen
  \href{https://github.com/vincentarelbundock/Rdatasets/blob/master/csv/datasets/ToothGrowth.csv}{CSV-Datei}
\item
  Fahrzeugdaten aus der Zeitschrift Motor Trend
  \href{https://gist.github.com/seankross/a412dfbd88b3db70b74b}{GitHub}
\item
  Vermessung von Pinguinen an der Palmer Station
  \href{https://github.com/allisonhorst/palmerpenguins?tab=readme-ov-file\#meet-the-palmer-penguins}{GitHub}
\item
  Kursdaten der Microsoft-Aktie
  \href{https://www.kaggle.com/datasets/vijayvvenkitesh/microsoft-stock-time-series-analysis}{kaggle}
\end{itemize}

\section*{Lernziele}\label{lernziele-5}
\addcontentsline{toc}{section}{Lernziele}

\markright{Lernziele}

In diesem Baustein lernen Sie \ldots{}

\begin{itemize}
\item
  die Datenstrukturen des Moduls Pandas Series und DataFrame kennen.
\item
  wie Operationen in Pandas ausgeführt werden.
\item
  wie Grafiken mit Pandas erstellt werden.
\item
  Dateien einzulesen (und zu schreiben).
\end{itemize}

\chapter{Einleitung}\label{einleitung-1}

~

Das Modul Pandas wurde für die Arbeit mit strukturierten Daten
konzipiert. Pandas erleichtert die Analyse insbesondere von in
Tabellenform vorliegenden Daten, da es mit dem DataFrame eine leicht zu
benutzende Struktur für die Verarbeitung unterschiedlicher Datentypen
und fehlenden Werten bietet. Wie NumPy erlaubt Pandas vektorisierte
Operationen, ohne mit Hilfe einer Schleife jedes Element eines
Sammeltyps durchlaufen zu müssen. Pandas integriert darüber hinaus
Funktionalitäten anderer Module und bietet unter anderem einen
einheitlichen Zugang zu:

\begin{itemize}
\tightlist
\item
  Datumsinformationen und Zeitreihen
\item
  Grafikerstellung
\item
  Einlesen von Dateien
\end{itemize}

Das Modul Pandas wird mit dem Befehl \texttt{import\ pandas} geladen.
Als Kürzel hat sich pd etabliert. Da Pandas auf dem Modul NumPy aufbaut,
werden häufig beide Module geladen. Viele Funktionen und Methoden von
NumPy und Pandas sind miteinander kompatibel.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\end{Highlighting}
\end{Shaded}

\section{Die Datenstrukturen Series und
DataFrame}\label{die-datenstrukturen-series-und-dataframe}

Pandas führt die zwei Klassen \texttt{Series} und \texttt{DataFrame}
ein.

\begin{itemize}
\item
  \texttt{Series} sind eindimensionale Arrays, die genau einen Datentyp
  haben.
\item
  \texttt{DataFrame} sind zweidimensionale Arrays, die spaltenweise aus
  \texttt{Series} bestehen und so verschiedene Datentypen enthalten
  können. (Durch hierarchische Indexierung sind mehrdimensionale
  Datenstrukturen möglich, siehe
  \href{https://pandas.pydata.org/docs/user_guide/advanced.html}{MultiIndex}.)
\end{itemize}

Beide Datenstrukturen verfügen über einen Index, der in der Ausgabe
angezeigt wird.

\begin{verbatim}
Der Index beginnt wie in der Pythonbasis bei 0.
0    Frühschicht
1    Frühschicht
2    Spätschicht
dtype: string
\end{verbatim}

Der Index ist standardmäßig numerisch, kann aber mit beliebigen Werten
versehen werden.

\begin{verbatim}
Der Index kann angepasst werden.
Montag      Frühschicht
Dienstag    Frühschicht
Mittwoch    Spätschicht
dtype: string
\end{verbatim}

\subsection{Series}\label{series}

\texttt{Series} werden mit der Funktion \texttt{pd.Series(data)}
erstellt. data kann ein Einzelwert, ein Sammeltyp oder ein NumPy-Array
sein.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{einzelwert\_series }\OperatorTok{=}\NormalTok{ pd.Series(}\StringTok{\textquotesingle{}Hallo Welt!\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Series aus Einzelwert:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{einzelwert\_series}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{numerische\_series }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Series aus Liste:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{numerische\_series}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{alphanumerische\_series }\OperatorTok{=}\NormalTok{ pd.Series((}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}5\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}g\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Series aus Tupel:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{alphanumerische\_series}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{boolean\_series }\OperatorTok{=}\NormalTok{ pd.Series(np.array([}\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{])) }\CommentTok{\# NumPy{-}Array}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Series aus NumPy{-}Array:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{boolean\_series}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Series aus Einzelwert:
0    Hallo Welt!
dtype: object

Series aus Liste:
0    1
1    2
2    3
dtype: int64

Series aus Tupel:
0    a
1    5
2    g
dtype: object

Series aus NumPy-Array:
0     True
1    False
2     True
dtype: bool
\end{verbatim}

Beim Anlegen einer \texttt{pd.Series} können verschiedene Parameter
übergeben werden:

\begin{itemize}
\item
  \texttt{pd.Series(data,\ dtype\ =\ \textquotesingle{}float\textquotesingle{})}
  legt den Datentyp der Series fest.
\item
  \texttt{pd.Series(data,\ index\ =\ {[}\textquotesingle{}A1\textquotesingle{},\ \textquotesingle{}B2\textquotesingle{},\ \textquotesingle{}C3\textquotesingle{}{]})}
  übergibt Werte für den Index.
\item
  \texttt{pd.Series(data,\ name\ =\ \textquotesingle{}der\ Name\textquotesingle{})}
  legt einen Namen für die Series fest.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numerische\_series }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], dtype }\OperatorTok{=} \StringTok{\textquotesingle{}float\textquotesingle{}}\NormalTok{, index }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}A1\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}B2\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}C3\textquotesingle{}}\NormalTok{], name }\OperatorTok{=} \StringTok{\textquotesingle{}Gleitkommazahlen\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(numerische\_series)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
A1    1.0
B2    2.0
C3    3.0
Name: Gleitkommazahlen, dtype: float64
\end{verbatim}

Für eine bestehende Series können Name und Index über entsprechende
Attribute aufgerufen und geändert werden. Um den Datentyp zu ändern,
wird die Methode \texttt{pd.Series.astype()} verwendet. Eine Übersicht
der in Pandas verfügbaren Datentypen finden Sie in der
\href{https://pandas.pydata.org/docs/user_guide/basics.html\#dtypes}{Pandas-Dokumentation}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Name der Series: }\SpecialCharTok{\{}\NormalTok{numerische\_series}\SpecialCharTok{.}\NormalTok{name}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\NormalTok{numerische\_series.name }\OperatorTok{=} \StringTok{\textquotesingle{}Fließkommazahlen\textquotesingle{}}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Index der Series: }\SpecialCharTok{\{}\NormalTok{numerische\_series}\SpecialCharTok{.}\NormalTok{index}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\NormalTok{numerische\_series.index }\OperatorTok{=}\NormalTok{  [}\StringTok{\textquotesingle{}eins\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}zwei\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}drei\textquotesingle{}}\NormalTok{]}

\NormalTok{numerische\_series }\OperatorTok{=}\NormalTok{ numerische\_series.astype(}\StringTok{\textquotesingle{}string\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Die geänderte Series:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{numerische\_series}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Name der Series: Gleitkommazahlen
Index der Series: Index(['A1', 'B2', 'C3'], dtype='object')

Die geänderte Series:
eins    1.0
zwei    2.0
drei    3.0
Name: Fließkommazahlen, dtype: string
\end{verbatim}

\subsection{Aufgabe Series}\label{aufgabe-series}

Ändern Sie den Datentyp des Objekts `numerische\_series' in Ganzzahl und
wählen Sie einen neuen Namen für die Series aus.
\texttt{numerische\_series\ =\ pd.Series({[}1,\ 2,\ 3{]},\ dtype\ =\ \textquotesingle{}float\textquotesingle{},\ index\ =\ {[}\textquotesingle{}A1\textquotesingle{},\ \textquotesingle{}B2\textquotesingle{},\ \textquotesingle{}C3\textquotesingle{}{]},\ name\ =\ \textquotesingle{}Gleitkommazahlen\textquotesingle{})}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-dtype}: Musterlösung dtype}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-dtype} 

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numerische\_series }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], dtype }\OperatorTok{=} \StringTok{\textquotesingle{}float\textquotesingle{}}\NormalTok{, index }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}A1\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}B2\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}C3\textquotesingle{}}\NormalTok{], name }\OperatorTok{=} \StringTok{\textquotesingle{}Gleitkommazahlen\textquotesingle{}}\NormalTok{)}

\NormalTok{numerische\_series.name }\OperatorTok{=} \StringTok{\textquotesingle{}Ganzzahlen\textquotesingle{}}

\CommentTok{\# falls numerische\_series vorher vom dtype string ist,}
\CommentTok{\# muss erst in dtype float konvertiert werden}
\CommentTok{\# numerische\_series = numerische\_series.astype(\textquotesingle{}float\textquotesingle{})}

\NormalTok{numerische\_series }\OperatorTok{=}\NormalTok{ numerische\_series.astype(}\StringTok{\textquotesingle{}int\textquotesingle{}}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(numerische\_series)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
A1    1
B2    2
C3    3
Name: Ganzzahlen, dtype: int64
\end{verbatim}

\end{tcolorbox}

\subsection{DataFrame}\label{dataframe}

Ein \texttt{DataFrame} wird mit der Funktion
\texttt{pd.DataFrame({[}data{]})} angelegt. data ist listenartig, kann
aber aus einem Einzelwert, einer Series, einem Numpy-Array oder aus
mehreren Series und Sammeltypen bestehen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{einzelwert\_df }\OperatorTok{=}\NormalTok{ pd.DataFrame([}\StringTok{\textquotesingle{}Hallo Welt!\textquotesingle{}}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(einzelwert\_df, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{df\_aus\_listen }\OperatorTok{=}\NormalTok{ pd.DataFrame([[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]])}
\BuiltInTok{print}\NormalTok{(df\_aus\_listen, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{df\_aus\_series }\OperatorTok{=}\NormalTok{ pd.DataFrame([alphanumerische\_series, boolean\_series])}
\BuiltInTok{print}\NormalTok{(df\_aus\_series, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{df\_aus\_verschieden }\OperatorTok{=}\NormalTok{ pd.DataFrame([np.array([}\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{]), alphanumerische\_series, [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]]) }\CommentTok{\# NumPy{-}Array}
\BuiltInTok{print}\NormalTok{(df\_aus\_verschieden)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
             0
0  Hallo Welt! 

   0  1  2
0  1  2  3
1  4  5  6 

      0      1     2
0     a      5     g
1  True  False  True 

      0      1     2
0  True  False  True
1     a      5     g
2     1      2     3
\end{verbatim}

Beim Anlegen eines DataFrames können ebenfalls verschiedene Parameter
übergeben werden:

\begin{itemize}
\item
  \texttt{pd.DataFrame(data,\ dtype\ =\ \textquotesingle{}float\textquotesingle{})}
  legt den Datentyp des DataFrames für alle Werte fest. Wird der
  Parameter nicht übergeben, wählt Pandas einen passenden Datentyp für
  jede Spalte aus.
\item
  \texttt{pd.DataFrame(data,\ index\ =\ {[}\textquotesingle{}A1\textquotesingle{},\ \textquotesingle{}B2\textquotesingle{},\ \textquotesingle{}C3\textquotesingle{}{]})}
  übergibt Werte für den Index.
\item
  \texttt{pd.DataFrame(data,\ columns\ =\ {[}\textquotesingle{}Spalte1\textquotesingle{},\ \textquotesingle{}Spalte2\textquotesingle{}{]})}
  übergibt Werte für die Spaltenbeschriftung.
\end{itemize}

Um Daten spaltenweise einzutragen, kann der DataFrame zum einen mit dem
Attribut \texttt{DataFrame.T} transponiert werden. Dabei müssen die
Spaltenbeschriftungen als Argument \texttt{index} und die
Indexbeschriftung als Argument \texttt{columns} übergeben werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_transponiert }\OperatorTok{=}\NormalTok{ pd.DataFrame([[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{]], index }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Spalte 1\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Spalte 2\textquotesingle{}}\NormalTok{], columns }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Zeile 1\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Zeile 2\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Zeile 3\textquotesingle{}}\NormalTok{]).T}
\BuiltInTok{print}\NormalTok{(df\_transponiert)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
        Spalte 1 Spalte 2
Zeile 1        1     True
Zeile 2        2    False
Zeile 3        3     True
\end{verbatim}

Eine direkte Zuordnung der Beschriftungen ist möglich, indem zuerst der
transponierte DataFrame angelegt und anschließend über die Attribute
\texttt{.index} und \texttt{.columns} die Beschriftungen eingetragen
werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_transponiert }\OperatorTok{=}\NormalTok{ pd.DataFrame([[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{]]).T}
\NormalTok{df\_transponiert.columns }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Spalte 1\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Spalte 2\textquotesingle{}}\NormalTok{]}
\NormalTok{df\_transponiert.index }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Zeile 1\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Zeile 2\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Zeile 3\textquotesingle{}}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(df\_transponiert)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
        Spalte 1 Spalte 2
Zeile 1        1     True
Zeile 2        2    False
Zeile 3        3     True
\end{verbatim}

Das Anlegen von transponierten DataFrames hat den Nachteil, dass Pandas
die Datentypen der eingegebenen Daten spaltenweise verwaltet. Bei der
zeilenweise erfolgenden Eingabe von Daten unterschiedlichen Datentyps
wird ein für alle Spalten passender Datentyp gewählt. Im folgenden
Beispiel wird deshalb von Pandas der Datentyp \texttt{object} für
gemischte Datentypen gewählt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df\_transponiert }\OperatorTok{=}\NormalTok{ pd.DataFrame([[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{]], index }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Zahlen\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Buchstaben\textquotesingle{}}\NormalTok{]).T}
\BuiltInTok{print}\NormalTok{(df\_transponiert)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{df\_transponiert}\SpecialCharTok{.}\NormalTok{dtypes}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  Zahlen Buchstaben
0      1          a
1      2          b
2      3          c

Zahlen        object
Buchstaben    object
dtype: object
\end{verbatim}

Zum anderen kann ein DataFrame direkt aus einem Dictionary erzeugt
werden. Dabei werden die Schlüssel als Spaltenbeschriftung verwendet.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}Spalte 1\textquotesingle{}}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], }\StringTok{\textquotesingle{}Spalte 2\textquotesingle{}}\NormalTok{: [}\FloatTok{4.1}\NormalTok{, }\FloatTok{5.6}\NormalTok{, }\FloatTok{6.0}\NormalTok{]\}, index }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}oben\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}mitte\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}unten\textquotesingle{}}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
       Spalte 1  Spalte 2
oben          1       4.1
mitte         2       5.6
unten         3       6.0
\end{verbatim}

Außerdem kann ein DataFrame durch Zuweisung von Daten erweitert werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# einen leeren DataFrame erzeugen}
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame()}

\CommentTok{\# Zuweisung von Daten}
\NormalTok{df[}\StringTok{\textquotesingle{}Spaltenbeschriftung\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{df[}\StringTok{\textquotesingle{}zweite Spalte\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ alphanumerische\_series}

\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   Spaltenbeschriftung zweite Spalte
0                    1             a
1                    2             5
2                    3             g
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-index}: Der Index}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-index} 

In den meisten Fällen ist der von 0 bis n-1 reichende Index am
praktischsten. Der numerische Index hilft bei der Auswahl von
Indexbereichen (Slicing) und der Arbeit mit mehreren Datenstrukturen.
Probieren Sie einmal aus, was passiert, wenn Sie einen DataFrame aus
zwei Series mit unterschiedlichen Indizes erstellen.

Auch widerspricht das Auslagern beschreibender oder gemessener Variablen
in den Index dem Konzept tidy data, einem System zum Strukturieren von
Datensätzen, das Sie im
\href{https://bausteine-der-datenanalyse.github.io/m-einlesen-strukturierter-datens-tze/einlesen-strukturierter-datens\%C3\%A4tze.html}{Methodenbaustein
Einlesen strukturierter Datensätze} kennenlernen.

\end{tcolorbox}

Bestehende DataFrames können ähnlich wie Series modifiziert werden. Um
den Datentyp einer oder mehrerer Spalten zu ändern, wird die Methode
\texttt{pd.DataFrame.astype()} verwendet.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}Spalte 1\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}1\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}2\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}3\textquotesingle{}}\NormalTok{], }\StringTok{\textquotesingle{}Spalte 2\textquotesingle{}}\NormalTok{: [}\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{]\})}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Datentypen von df:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{df}\SpecialCharTok{.}\NormalTok{dtypes}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# Datentyp von Spalte 1 ändern}
\NormalTok{df[}\StringTok{\textquotesingle{}Spalte 1\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ df[}\StringTok{\textquotesingle{}Spalte 1\textquotesingle{}}\NormalTok{].astype(}\StringTok{\textquotesingle{}string\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Die Datentypen von df:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{df}\SpecialCharTok{.}\NormalTok{dtypes}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Datentypen von df:
Spalte 1    object
Spalte 2      bool
dtype: object

Die Datentypen von df:
Spalte 1    string[python]
Spalte 2              bool
dtype: object
\end{verbatim}

Ebenso kann allen Spalten eines DataFrames ein Datentyp zugewiesen
werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OperatorTok{=}\NormalTok{ df.astype(}\StringTok{\textquotesingle{}string\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Die Datentypen von df:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{df}\SpecialCharTok{.}\NormalTok{dtypes}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}

Die Datentypen von df:
Spalte 1    string[python]
Spalte 2    string[python]
dtype: object
\end{verbatim}

Um unterschiedliche Datentypen zuzweisen, wird ein Dictionary verwendet.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OperatorTok{=}\NormalTok{ df.astype(\{}\StringTok{\textquotesingle{}Spalte 1\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}int\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Spalte 2\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}bool\textquotesingle{}}\NormalTok{\})}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Die Datentypen von df:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{df}\SpecialCharTok{.}\NormalTok{dtypes}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}

Die Datentypen von df:
Spalte 1    int64
Spalte 2     bool
dtype: object
\end{verbatim}

Spaltennamen und Index eines bestehenden \texttt{DataFrame} können über
entsprechende Attribute oder Methoden verändert werden. Die Spaltennamen
können über das Attribut \texttt{pd.DataFrame.columns} geändert werden.
Dabei wird eine Liste übergeben, deren Länge der Spaltenanzahl
entsprechen muss. Der Index kann über das Attribut
\texttt{pd.DataFrame.index} geändert werden, indem eine Liste zugewiesen
wird. Dabei muss die Länge der Liste der Anzahl Zeilen entsprechen.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# ändern der Spaltennamen über das Attribut .columns}
\NormalTok{df.columns }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Spalte1\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Spalte2\textquotesingle{}}\NormalTok{]}
\NormalTok{df.index }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   Spalte1  Spalte2
1        1     True
2        2     True
3        3     True
\end{verbatim}

Mit der Methode
\texttt{pd.DataFrame.rename(columns\ =\ \{"alt1":\ "neu1",\ "alt2":\ "neu2"\},\ index\ =\ \{"alt1":\ "neu1",\ "alt2":\ "neu2"\},\ inplace\ =\ True)}
können Spalten- und Zeilenbeschriftungen als Dictionary übergeben
werden. Auf diese Weise können alle oder ausgewählte Beschriftungen
geändert werden. Durch das Argument \texttt{inplace\ =\ True} erfolgt
die Zuweisung direkt ohne Neuzuweisung des Objekts.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.rename(columns }\OperatorTok{=}\NormalTok{ \{}\StringTok{\textquotesingle{}Spalte1\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}Spalte\_1\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Spalte2\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}Spalte\_2\textquotesingle{}}\NormalTok{\}, index }\OperatorTok{=}\NormalTok{ \{}\DecValTok{1}\NormalTok{: }\StringTok{\textquotesingle{}A1\textquotesingle{}}\NormalTok{, }\DecValTok{2}\NormalTok{: }\StringTok{\textquotesingle{}B2\textquotesingle{}}\NormalTok{, }\DecValTok{3}\NormalTok{: }\StringTok{\textquotesingle{}C3\textquotesingle{}}\NormalTok{\}, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
    Spalte_1  Spalte_2
A1         1      True
B2         2      True
C3         3      True
\end{verbatim}

Mit der Methode
\texttt{pd.DataFrame.reset\_index(inplace\ =\ True,\ drop\ =\ True)}
wird der Index auf die Standardwerte zurückgesetzt. Wird der Parameter
\texttt{drop\ =\ False} gesetzt, wird der alte Index als Spalte an
Indexposition 0 in den DataFrame eingefügt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.reset\_index(inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{, drop }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   Spalte_1  Spalte_2
0         1      True
1         2      True
2         3      True
\end{verbatim}

\subsection{Aufgabe DataFrame}\label{aufgabe-dataframe}

Erstellen Sie einen DataFrame.

\begin{itemize}
\tightlist
\item
  Die erste Spalte soll die Zahlen von 1 bis 12 enthalten und mit
  `Nummer' beschriftet werden. Die zweite Spalte soll die Monatsnamen
  des Jahres enthalten und mit `Monat' beschriftet werden.
\item
  Fügen Sie nachträglich die Series `ferien' als dritte Spalte mit der
  Spaltenbeschriftung `Ferien' ein.\\
  \texttt{ferien\ =\ {[}False,\ False,\ False,\ True,\ False,\ True,\ True,\ True,\ False,\ True,\ False,\ True{]}}
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-musterloesungdataframe}: Musterlösung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-musterloesungdataframe} 

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ferien }\OperatorTok{=}\NormalTok{ [}\VariableTok{False}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{, }\VariableTok{True}\NormalTok{, }\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{, }\VariableTok{False}\NormalTok{, }\VariableTok{True}\NormalTok{]}

\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}
  \StringTok{\textquotesingle{}Nummer\textquotesingle{}}\NormalTok{: }\BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{13}\NormalTok{)),}
  \StringTok{\textquotesingle{}Monat\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}Januar\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Februar\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}März\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}April\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Mai\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Juni\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Juli\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}August\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}September\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Oktober\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}November\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Dezember\textquotesingle{}}\NormalTok{],}
\NormalTok{\})}

\NormalTok{df[}\StringTok{\textquotesingle{}Ferien\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ ferien}

\BuiltInTok{print}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
    Nummer      Monat  Ferien
0        1     Januar   False
1        2    Februar   False
2        3       März   False
3        4      April    True
4        5        Mai   False
5        6       Juni    True
6        7       Juli    True
7        8     August    True
8        9  September   False
9       10    Oktober    True
10      11   November   False
11      12   Dezember    True
\end{verbatim}

\end{tcolorbox}

\section{Deskriptive Datenanalyse mit
Pandas}\label{deskriptive-datenanalyse-mit-pandas}

Pandas bietet einige praktische Funktionen, um den Aufbau eines
Datensatzes und die enthaltenen Daten zu beschreiben. Als
Beispieldatensatz dienen Daten zur Länge zahnbildender Zellen bei
Meerschweinchen, die Vitamin C direkt (VC) oder in Form von Orangensaft
(OJ) in unterschiedlichen Dosen erhielten.

\begin{codelisting}

\caption{\label{lst-readfile}}

\centering{

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/ToothGrowth.csv"}
\NormalTok{meerschweinchen }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ dateipfad, sep }\OperatorTok{=} \StringTok{\textquotesingle{},\textquotesingle{}}\NormalTok{, header }\OperatorTok{=} \DecValTok{0}\NormalTok{, }\OperatorTok{\textbackslash{}}
\NormalTok{  names }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}ID\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}supp\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{], dtype }\OperatorTok{=}\NormalTok{ \{}\StringTok{\textquotesingle{}ID\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}int\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}float\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}float\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}supp\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}category\textquotesingle{}}\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

}

\end{codelisting}%

Crampton, E. W. 1947. „THE GROWTH OF THE ODONTOBLASTS OF THE INCISOR
TOOTH AS A CRITERION OF THE VITAMIN C INTAKE OF THE GUINEA PIG``. The
Journal of Nutrition 33 (5): 491--504.
\url{https://doi.org/10.1093/jn/33.5.491}

Der Datensatz kann in R mit dem Befehl ``ToothGrowth'' aufgerufen
werden.

~

Ein Aussschnitt des Datensatzes:

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
& ID & len & supp & dose \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 1 & 4.2 & VC & 0.5 \\
10 & 11 & 16.5 & VC & 1.0 \\
20 & 21 & 23.6 & VC & 2.0 \\
30 & 31 & 15.2 & OJ & 0.5 \\
40 & 41 & 19.7 & OJ & 1.0 \\
50 & 51 & 25.5 & OJ & 2.0 \\
\end{longtable}

~

Die Methode \texttt{pd.DataFrame.info()} erzeugt eine Beschreibung des
Datensatzes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{meerschweinchen.info()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 60 entries, 0 to 59
Data columns (total 4 columns):
 #   Column  Non-Null Count  Dtype   
---  ------  --------------  -----   
 0   ID      60 non-null     int64   
 1   len     60 non-null     float64 
 2   supp    60 non-null     category
 3   dose    60 non-null     float64 
dtypes: category(1), float64(2), int64(1)
memory usage: 1.7 KB
\end{verbatim}

Die Dimensionen einer Series oder eines DataFrame können mit dem
Attribut \texttt{shape} abgerufen werden. Der DataFrame hat 60 Zeilen
und 4 Spalten.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(meerschweinchen.shape)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(60, 4)
\end{verbatim}

Die Methode \texttt{pd.DataFrame.describe()} erzeugt eine beschreibende
Statistik für einen DataFrame. Standardmäßig werden alle numerischen
Spalten berücksichtigt. Mit dem Parameter \texttt{include} können die zu
berücksichtigenden Spalten vorgegeben werden. \texttt{include\ =\ all}
berücksichtigt alle Spalten, was nicht unbedingt sinnvoll ist, da auf
diese Weise auch die Spalte mit den ID-Nummern der Meerschweinchen
ausgewertet wird.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(meerschweinchen.describe(include }\OperatorTok{=} \StringTok{\textquotesingle{}all\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
               ID        len supp       dose
count   60.000000  60.000000   60  60.000000
unique        NaN        NaN    2        NaN
top           NaN        NaN   OJ        NaN
freq          NaN        NaN   30        NaN
mean    30.500000  18.813333  NaN   1.166667
std     17.464249   7.649315  NaN   0.628872
min      1.000000   4.200000  NaN   0.500000
25%     15.750000  13.075000  NaN   0.500000
50%     30.500000  19.250000  NaN   1.000000
75%     45.250000  25.275000  NaN   2.000000
max     60.000000  33.900000  NaN   2.000000
\end{verbatim}

Mit dem Parameter \texttt{include} kann eine Liste zu berücksichtigender
Datentypen übergeben werden. Der Parameter \texttt{exclude} schließt auf
die gleiche Weise Datentypen von der Ausgabe aus.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(meerschweinchen.describe(include }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}float\textquotesingle{}}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
             len       dose
count  60.000000  60.000000
mean   18.813333   1.166667
std     7.649315   0.628872
min     4.200000   0.500000
25%    13.075000   0.500000
50%    19.250000   1.000000
75%    25.275000   2.000000
max    33.900000   2.000000
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(meerschweinchen.describe(include }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}category\textquotesingle{}}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
       supp
count    60
unique    2
top      OJ
freq     30
\end{verbatim}

Die Methode \texttt{pd.DataFrame.count()} zählt alle nicht fehlenden
Werte in jeder Spalte oder mit
\texttt{pd.DataFrame.count(axis\ =\ \textquotesingle{}columns\textquotesingle{})}
in jeder Zeile.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{meerschweinchen.count(axis }\OperatorTok{=} \StringTok{\textquotesingle{}rows\textquotesingle{}}\NormalTok{) }\CommentTok{\# der Standardwert von axis ist \textquotesingle{}rows\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ID      60
len     60
supp    60
dose    60
dtype: int64
\end{verbatim}

Die Methode \texttt{pd.Series.value\_counts()} zählt die Anzahl der
Merkmalsausprägungen in einer Series. Die Methode kann auch auf einen
DataFrame angewendet werden, dann wird die Häufigkeit jeder
einzigartigen Zeile gezählt (was hier nicht sinnvoll ist).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{meerschweinchen[}\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{].value\_counts()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
dose
0.5    20
1.0    20
2.0    20
Name: count, dtype: int64
\end{verbatim}

Die Methode \texttt{pd.unique()} listet alle einzigartigen Werte einer
Series auf.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{meerschweinchen[}\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{].unique()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([0.5, 1. , 2. ])
\end{verbatim}

\section{Slicing}\label{slicing-1}

\begin{figure}[H]

{\centering \includegraphics[width=0.45\linewidth,height=\textheight,keepaspectratio]{books/w-pandas/skript/00-bilder/zweidimensionaler-datensatz-slicing-mf-mp.png}

}

\caption{zweidimensionaler Datensatz}

\end{figure}%

slicing von Marc Fehr ist lizensiert unter
\href{https://github.com/bausteine-der-datenanalyse/w-python-numpy-grundlagen\#CC-BY-4.0-1-ov-file}{CC-BY-4.0}
und abrufbar auf
\href{https://github.com/bausteine-der-datenanalyse/w-python-numpy-grundlagen}{GitHub}.
Die Grafik wurde auf den gezeigten Teil beschnitten und die obenstehende
Beschriftung entfernt. 2024

~

Pandas bringt eigene Werkzeuge für die Auswahl von Indexbereichen mit.
Der Slice Operator aus der Pythonbasis wird deshalb nur kurz
vorgestellt.

\subsection{Slice Operator}\label{slice-operator}

Mit dem Slice Operator können wie bei einer Liste Indexbereiche aus
einer Series ausgewählt werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zehn\_zahlen }\OperatorTok{=}\NormalTok{ pd.Series(}\BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(zehn\_zahlen[}\DecValTok{3}\NormalTok{:}\DecValTok{6}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3    3
4    4
5    5
dtype: int64
\end{verbatim}

Mit dem Slice Operator werden die Zeilen eines DataFrames ausgewählt.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(meerschweinchen[}\DecValTok{7}\NormalTok{:}\DecValTok{12}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
    ID   len supp  dose
7    8  11.2   VC   0.5
8    9   5.2   VC   0.5
9   10   7.0   VC   0.5
10  11  16.5   VC   1.0
11  12  16.5   VC   1.0
\end{verbatim}

Durch Angabe eines Spaltennamens wird die entsprechende Spalte
ausgewählt, die als Series zurückgegeben wird. Durch das Anfügen eines
zweiten Slice Operators ist es möglich, wie bei einem eindimensionalen
Datensatz die Werte in einem bestimmten Indexbereich abzurufen. Dies
wird verkettete Indexierung genannt.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(meerschweinchen[}\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{][}\DecValTok{10}\NormalTok{:}\DecValTok{15}\NormalTok{], }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(meerschweinchen[}\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{][}\DecValTok{10}\NormalTok{:}\DecValTok{15}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
10    1.0
11    1.0
12    1.0
13    1.0
14    1.0
Name: dose, dtype: float64 

<class 'pandas.core.series.Series'>
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-chainedassignment} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-chainedassignment}: Verkettete Indexierung}\vspace{3mm}

Die verkettete Indexierung erzeugt in Pandas abhängig vom Kontext eine
Kopie des Objekts oder greift auf den Speicherbereich des Objekts zu.
Mit Pandas 3.0 wird die verkettete Indexierung nicht mehr unterstützt,
das Anlegen einer Kopie wird zum Standard werden. Weitere Informationen
erhalten Sie im zitierten Link.

\begin{figure}[H]

\begin{minipage}{0.05\linewidth}
~\end{minipage}%
%
\begin{minipage}{0.90\linewidth}
``Whether a copy or a reference is returned for a setting operation, may
depend on the context. This is sometimes called
\texttt{chained\ assignment} and should be avoided. See
\href{https://pandas.pydata.org/docs/user_guide/indexing.html\#indexing-view-versus-copy}{Returning
a View versus Copy}.''\end{minipage}%
%
\begin{minipage}{0.05\linewidth}
~\end{minipage}%

\end{figure}%

(\href{https://pandas.pydata.org/docs/user_guide/indexing.html}{Pandas
Dokumentation})

\end{minipage}%
\end{tcolorbox}

\subsection{Slicing mit
Pandas-Methoden}\label{slicing-mit-pandas-methoden}

Für das Slicing von Series und DataFrames werden in Pandas die Methoden
\texttt{.iloc{[}{]}} und \texttt{.loc{[}{]}} verwendet.

\begin{itemize}
\item
  \texttt{.loc{[}{]}} arbeitet mit Index- oder Spaltenbeschriftungen,
  akzeptiert aber auch ein boolsches Array.
\item
  \texttt{.iloc{[}{]}} arbeitet mit Ganzzahlen, akzeptiert aber auch ein
  boolsches Array.
\end{itemize}

Für das Slicing von Series wird eine Bereichsangabe übergeben, bspw.
\texttt{pd.Series.iloc{[}5:8{]}}. Für das Slicing von DataFrames werden
zwei durch ein Komma getrennte Bereichsangaben übergeben, wobei an
erster Stelle die Zeilen und an zweiter Stelle die Spalten ausgewählt
werden, bspw. \texttt{pd.DataFrame.iloc{[}5,\ 2:4{]}}. Um alle Zeilen
oder Spalten auszuwählen kann der Doppelpunkt verwendet werden, etwa
\texttt{pd.DataFrame.iloc{[}5,\ :{]}}.

\subsubsection{Beschriftungsbasiertes Slicing mit
.loc{[}{]}}\label{beschriftungsbasiertes-slicing-mit-.loc}

Für eine Series interpretiert \texttt{.loc} übergebene Zeichen als
Indexbeschriftung. Buchstaben und andere Zeichen werden wie strings in
Anführungszeichen übergeben, bspw.
\texttt{.loc{[}\textquotesingle{}e\textquotesingle{}{]}}, Zahlen ohne
Anführungszeichen. Neben Einzelwerten
(\texttt{\textquotesingle{}a\textquotesingle{}} oder \texttt{0}) können
Listen oder Arrays
(\texttt{{[}\textquotesingle{}a\textquotesingle{},\ \textquotesingle{}b\textquotesingle{},\ \textquotesingle{}c\textquotesingle{}{]}}
oder \texttt{{[}1,\ 2,\ 3{]}}) und Slices übergeben werden
(\texttt{\textquotesingle{}a\textquotesingle{}:\textquotesingle{}c\textquotesingle{}}
oder \texttt{0:2}). Das Slicing mit einem Einzelwert führt zur Rückgabe
eines Einzelwerts (sog. Skalar).

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-inklusiveslicing} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-inklusiveslicing}: inklusives Slicing}\vspace{3mm}

Anders als die Pythonbasis und das Slicing mit \texttt{.iloc{[}{]}}
zählt Pandas beim beschriftungsbasiertem Slicing inklusiv, gibt also die
letzte ausgewählte Position mit aus.

\end{minipage}%
\end{tcolorbox}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Nummern}
\NormalTok{zehn\_zahlen }\OperatorTok{=}\NormalTok{ pd.Series(}\BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Rückgabe eines Einzelwerts:"}\NormalTok{, zehn\_zahlen.loc[}\DecValTok{5}\NormalTok{]) }\CommentTok{\# Einzelwert}
\BuiltInTok{print}\NormalTok{(zehn\_zahlen.loc[[}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{]]) }\CommentTok{\# Liste}
\BuiltInTok{print}\NormalTok{(zehn\_zahlen.loc[}\DecValTok{5}\NormalTok{:}\DecValTok{7}\NormalTok{], }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{) }\CommentTok{\# Slice}

\CommentTok{\# Buchstaben und andere Zeichen}
\NormalTok{sechs\_zahlen }\OperatorTok{=}\NormalTok{ pd.Series(}\BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{6}\NormalTok{)), index }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}d\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}e\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}f\textquotesingle{}}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Rückgabe eines Einzelwerts:"}\NormalTok{, sechs\_zahlen.loc[}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{]) }\CommentTok{\# Einzelwert}
\BuiltInTok{print}\NormalTok{(sechs\_zahlen.loc[[}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}f\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{]]) }\CommentTok{\# Liste}
\BuiltInTok{print}\NormalTok{(sechs\_zahlen.loc[}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}e\textquotesingle{}}\NormalTok{]) }\CommentTok{\# Slice}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Rückgabe eines Einzelwerts: 5
2    2
4    4
7    7
dtype: int64
5    5
6    6
7    7
dtype: int64 

Rückgabe eines Einzelwerts: 2
c    2
f    5
a    0
dtype: int64
c    2
d    3
e    4
dtype: int64
\end{verbatim}

Die Interpretation als Beschriftung bedeutet, dass bei einem nicht
numerischen Index als Slice übergebene Zahlen nicht gefunden werden.
Hier muss mit der übergebenen Beschriftung gearbeitet werden.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(sechs\_zahlen.loc[}\DecValTok{2}\NormalTok{:}\DecValTok{4}\NormalTok{])}
\ControlFlowTok{except} \PreprocessorTok{Exception} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(error)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, sechs\_zahlen.loc[}\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{:}\StringTok{\textquotesingle{}e\textquotesingle{}}\NormalTok{], sep }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
cannot do slice indexing on Index with these indexers [2] of type int


c    2
d    3
e    4
dtype: int64
\end{verbatim}

Für DataFrames funktioniert das Slicing genauso.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(meerschweinchen.loc[}\DecValTok{18}\NormalTok{:}\DecValTok{22}\NormalTok{, [}\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     len  dose
18  18.8   1.0
19  15.5   1.0
20  23.6   2.0
21  18.5   2.0
22  33.9   2.0
\end{verbatim}

\subsection{Indexbasiertes Slicing mit
.iloc{[}{]}}\label{indexbasiertes-slicing-mit-.iloc}

Die Methode \texttt{.iloc{[}{]}} ermöglicht die Auswahl von Ausschnitten
basierend auf Indexpositionen. Die Methode akzeptiert die gleichen
Eingaben wie die Methode \texttt{.loc{[}{]}}.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-exklusiveslicing} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-exklusiveslicing}: exklusives Slicing}\vspace{3mm}

Beim Slicing mit der Methode \texttt{.iloc{[}{]}} zählt Pandas wie die
Pythonbasis exklusiv.

\end{minipage}%
\end{tcolorbox}

Das Slicing mit Einzelwerten führt zur Ausgabe eines Einzelwertes. Die
Methode akzeptiert ebenfalls eine Liste oder ein Slice.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Rückgabe eines Einzelwerts:"}\NormalTok{, meerschweinchen.iloc[}\DecValTok{27}\NormalTok{, }\DecValTok{2}\NormalTok{]) }\CommentTok{\# Einzelwerte}
\BuiltInTok{print}\NormalTok{(meerschweinchen.iloc[[}\DecValTok{27}\NormalTok{, }\DecValTok{29}\NormalTok{, }\DecValTok{52}\NormalTok{], }\DecValTok{2}\NormalTok{:}\DecValTok{4}\NormalTok{]) }\CommentTok{\# Liste und Slice}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Rückgabe eines Einzelwerts: VC
   supp  dose
27   VC   2.0
29   VC   2.0
52   OJ   2.0
\end{verbatim}

\subsubsection{Die Methoden .head() und
.tail()}\label{die-methoden-.head-und-.tail}

Vereinfachte Varianten des indexbasierten Slicings sind die Methoden
\texttt{.head(n=5)} und \texttt{.tail(n=5)}, mit denen die ersten bzw.
letzten n Zeilen eines DataFrame oder einer Series ausgegeben werden
können. Über den optionalen Paramenter \texttt{n} kann die Anzahl der
angezeigten Zeilen gesteuert werden. Die Methoden eignen sich gut, um
sich einen ersten Eindruck von einem Datensatz zu verschaffen.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(meerschweinchen.head(}\DecValTok{3}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(meerschweinchen.tail(}\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   ID   len supp  dose
0   1   4.2   VC   0.5
1   2  11.5   VC   0.5
2   3   7.3   VC   0.5 

    ID   len supp  dose
57  58  27.3   OJ   2.0
58  59  29.4   OJ   2.0
59  60  23.0   OJ   2.0
\end{verbatim}

Ebenso können Series damit betrachtet werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(meerschweinchen[}\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{].tail(}\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
57    27.3
58    29.4
59    23.0
Name: len, dtype: float64
\end{verbatim}

\section{Aufgaben Slicing}\label{aufgaben-slicing}

Gegeben ist eine Pandas Series `temperaturen\_2021' mit den
durchschnittlichen Monatstemperaturen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{temperaturen\_2021 }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{5}\NormalTok{],}
\NormalTok{                         index }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Jan\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Feb\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Mär\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Apr\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Mai\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Jun\textquotesingle{}}\NormalTok{, }
                         \StringTok{\textquotesingle{}Jul\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Aug\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Sep\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Okt\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Nov\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Dez\textquotesingle{}}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Wählen Sie die Temperaturen für die Frühlingsmonate (März bis Mai)
  aus.
\item
  Wählen Sie die Temperaturen für die letzten drei Monate des Jahres
  einmal mit Hilfe des Slicing Operators und einmal mit Hilfe der
  Pandas-Methoden aus.
\item
  Wählen Sie mit der Methode \texttt{.loc{[}{]}} die Spalten `dose' und
  `len' des DataFrame meerschweinchen aus und geben Sie die ersten 4 und
  die letzten 3 Zeilen aus. (Code zum Einlesen der Datei siehe
  Listing~\ref{lst-readfile})
\item
  Die Methoden \texttt{.loc{[}{]}} und \texttt{.iloc{[}{]}} akzeptieren
  auch ein boolsches Array als Eingabe. Geben Sie aus der Spalte `dose'
  des DataFrame meerschweinchen alle Zeilen mit dem Wert 2.0 aus.
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-dose}: Musterlösung Slicing}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-dose} 

Aufgabe 1

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(temperaturen\_2021.loc[[}\StringTok{\textquotesingle{}Mär\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Apr\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Mai\textquotesingle{}}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Mär     7
Apr    12
Mai    19
dtype: int64
\end{verbatim}

Aufgabe 2

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(temperaturen\_2021[}\OperatorTok{{-}}\DecValTok{3}\NormalTok{:], }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(temperaturen\_2021.iloc[}\OperatorTok{{-}}\DecValTok{3}\NormalTok{:])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Okt    15
Nov     9
Dez     5
dtype: int64 

Okt    15
Nov     9
Dez     5
dtype: int64
\end{verbatim}

Aufgabe 3

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(meerschweinchen.loc[ :, [}\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{]].head(n }\OperatorTok{=} \DecValTok{4}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(meerschweinchen.loc[ :, [}\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{]].tail(n }\OperatorTok{=} \DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   dose   len
0   0.5   4.2
1   0.5  11.5
2   0.5   7.3
3   0.5   5.8 

    dose   len
57   2.0  27.3
58   2.0  29.4
59   2.0  23.0
\end{verbatim}

Aufgabe 4

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Slice aus Series}
\CommentTok{\# print(meerschweinchen[\textquotesingle{}dose\textquotesingle{}].loc[meerschweinchen[\textquotesingle{}dose\textquotesingle{}] == 2.0])}

\CommentTok{\# Slice aus DataFrame}
\BuiltInTok{print}\NormalTok{(meerschweinchen.loc[meerschweinchen[}\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{] }\OperatorTok{==} \FloatTok{2.0}\NormalTok{, [}\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
    dose
20   2.0
21   2.0
22   2.0
23   2.0
24   2.0
25   2.0
26   2.0
27   2.0
28   2.0
29   2.0
50   2.0
51   2.0
52   2.0
53   2.0
54   2.0
55   2.0
56   2.0
57   2.0
58   2.0
59   2.0
\end{verbatim}

\end{tcolorbox}

\section{Datenstrukturen verbinden}\label{datenstrukturen-verbinden}

DataFrames sind flexible Datenspeicher. Mit der Funktion
\texttt{pd.concat()} können Series und DataFrames zusammengeführt
werden.

\begin{itemize}
\tightlist
\item
  Mit dem Argument \texttt{pd.concat(ignore\_index\ =\ True)} wird ein
  neuer Index generiert.
\item
  Mit dem Argument \texttt{pd.concat(axis\ =\ 1)} werden die übergebenen
  objekte spaltenweise zusammengeführt.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{series\_1 }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{])}
\NormalTok{series\_2 }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(pd.concat([series\_1, series\_2]), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(pd.concat([series\_1, series\_2], ignore\_index }\OperatorTok{=} \VariableTok{True}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(pd.concat([series\_1, series\_2], ignore\_index }\OperatorTok{=} \VariableTok{True}\NormalTok{, axis }\OperatorTok{=} \DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0    1
1    2
0    4
1    5
dtype: int64 

0    1
1    2
2    4
3    5
dtype: int64 

   0  1
0  1  4
1  2  5
\end{verbatim}

Gleichermaßen können DataFrames verbunden werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{temperaturen\_2021 }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{5}\NormalTok{],}
\NormalTok{                         index }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Jan\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Feb\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Mär\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Apr\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Mai\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Jun\textquotesingle{}}\NormalTok{, }
                         \StringTok{\textquotesingle{}Jul\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Aug\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Sep\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Okt\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Nov\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Dez\textquotesingle{}}\NormalTok{])}

\NormalTok{temperaturen\_2022 }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{3}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{21}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{4}\NormalTok{],}
\NormalTok{                         index }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Jan\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Feb\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Mär\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Apr\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Mai\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Jun\textquotesingle{}}\NormalTok{, }
                         \StringTok{\textquotesingle{}Jul\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Aug\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Sep\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Okt\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Nov\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Dez\textquotesingle{}}\NormalTok{])}

\NormalTok{temperaturen\_2023 }\OperatorTok{=}\NormalTok{ pd.Series([}\OperatorTok{{-}}\DecValTok{3}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{16}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{],}
\NormalTok{                         index }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Jan\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Feb\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Mär\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Apr\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Mai\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Jun\textquotesingle{}}\NormalTok{, }
                         \StringTok{\textquotesingle{}Jul\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Aug\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Sep\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Okt\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Nov\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Dez\textquotesingle{}}\NormalTok{])}

\NormalTok{temperaturen\_2024 }\OperatorTok{=}\NormalTok{ pd.Series([}\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{17}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{17}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{2}\NormalTok{],}
\NormalTok{                         index }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Jan\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Feb\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Mär\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Apr\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Mai\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Jun\textquotesingle{}}\NormalTok{, }
                         \StringTok{\textquotesingle{}Jul\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Aug\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Sep\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Okt\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Nov\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Dez\textquotesingle{}}\NormalTok{])}

\CommentTok{\# Series zu DataFrame verbinden}
\NormalTok{df1 }\OperatorTok{=}\NormalTok{ pd.concat([temperaturen\_2021, temperaturen\_2022], axis }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{df2 }\OperatorTok{=}\NormalTok{ pd.concat([temperaturen\_2023, temperaturen\_2024], axis }\OperatorTok{=} \DecValTok{1}\NormalTok{)}

\CommentTok{\# DataFrames verbinden}
\NormalTok{temperaturen }\OperatorTok{=}\NormalTok{ pd.concat([df1, df2], axis }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{temperaturen.columns }\OperatorTok{=}\NormalTok{ [}\DecValTok{2021}\NormalTok{, }\DecValTok{2022}\NormalTok{, }\DecValTok{2023}\NormalTok{, }\DecValTok{2024}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(temperaturen)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     2021  2022  2023  2024
Jan     2     3    -3    -1
Feb     4     6    -1     2
Mär     7     9     4     5
Apr    12    13     9     8
Mai    19    18    15    17
Jun    23    21    20    24
Jul    25    24    20    25
Aug    23    23    19    20
Sep    18    19    16    17
Okt    15    14    15    14
Nov     9     8     7     9
Dez     5     4     6     2
\end{verbatim}

\section{Einfügen und löschen in
Datenstrukturen}\label{einfuxfcgen-und-luxf6schen-in-datenstrukturen}

Der Operator \texttt{del} aus der Pythonbasis löscht Spalten aus einem
DataFrame, zum Beispiel:
\texttt{del\ DataFrame{[}\textquotesingle{}Spaltenname\textquotesingle{}{]}}.
Pandas bringt aber auch eigene Methoden mit, um Einträge zeilen- / oder
spaltenweise zu ergänzen und zu löschen.

\begin{itemize}
\item
  \texttt{pd.DataFrame.drop(labels\ =\ None,\ axis\ =\ 0,\ index\ =\ None,\ columns\ =\ None,\ inplace\ =\ False)}
  entfernt Zeilen oder Spalten nach den mit dem Parameter
  \texttt{labels} als Einzelwert
  (\texttt{\textquotesingle{}Spalte\ 1\textquotesingle{}}) oder als
  Liste
  (\texttt{{[}\textquotesingle{}Spalte\ 1\textquotesingle{},\ \textquotesingle{}Spalte\ 2\textquotesingle{}{]}})
  übergebenen Beschriftungen. Der Parameter \texttt{axis} steuert, ob
  Zeilen oder Spalten (\texttt{axis\ =\ 1}) entfernt werden sollen. Die
  Parameter \texttt{index} und \texttt{columns} sind alternative
  Möglichkeiten, Index- oder Spaltenbeschriftungen direkt zu übergeben
  und ersetzen die Parameter \texttt{labels} und \texttt{axis}.
\item
  \texttt{pd.DataFrame.insert(loc,\ column,\ value)} fügt eine Spalte an
  Position \texttt{loc} mit dem Spaltennamen \texttt{column} und dem
  Inhalt \texttt{value} ein. Falls \texttt{value} eine Series mit
  abweichendem Index ist, kann über das Attribut
  \texttt{value\ =\ Series.values} auf die enthaltenen Werte der Series
  zugegriffen und diese in den bestehenden Index einfgefügt werden
  (andernfalls gleicht Pandas die Indizes der Series und des DataFrames
  ab und fügt nur die Werte übereinstimmender Indizes ein).
\item
  Werte können zeilenweise mit der Methode
  \texttt{pd.DataFrame.loc{[}index{]}\ =\ value} eingefügt werden. Falls
  \texttt{value} eine Series ist, muss über das Attribut
  \texttt{value\ =\ Series.values} auf die enthaltenen Werte der Series
  zugegriffen werden, da Pandas andernfalls versucht, den Index der
  Series mit den Spaltennamen des DataFrames abzugleichen. Wird als
  \texttt{value} ein Einzelwert übergeben, füllt dieser die gesamte
  Zeile aus.
\end{itemize}

\section{Aufgaben verbinden und
löschen}\label{aufgaben-verbinden-und-luxf6schen}

Legen Sie einen leeren DataFrame \texttt{df\ =\ pd.DataFrame()} an.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Fügen Sie die Spalten `len' und `dose' aus dem DataFrame
  `meerschweinchen' ein.
\item
  Löschen Sie alle ungeraden Zeilen aus dem DataFrame df.
\item
  Benutzen Sie die Indizes der verbleibenden geraden Zeilen des
  DataFrame df, um die entsprechenden Zeilen aus der Spalte `ID' des
  DataFrame `meerschweinchen' auszuwählen. Fügen Sie diese als Spalte an
  Indexposition 0 in den DataFrame df ein.
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-mergeanddelete}: Musterlösung verbinden und löschen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-mergeanddelete} 

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame()}

\CommentTok{\# Alternative 1}
\NormalTok{df[}\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ meerschweinchen[}\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{]}

\CommentTok{\# Alternative 2}
\NormalTok{df.insert(loc }\OperatorTok{=} \DecValTok{1}\NormalTok{, column }\OperatorTok{=} \StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{, value }\OperatorTok{=}\NormalTok{ meerschweinchen[}\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{])}

\BuiltInTok{print}\NormalTok{(df.head(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df.shape)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
    len  dose
0   4.2   0.5
1  11.5   0.5
2   7.3   0.5
3   5.8   0.5
4   6.4   0.5 
 (60, 2)
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OperatorTok{=}\NormalTok{ df.drop(index }\OperatorTok{=} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\BuiltInTok{len}\NormalTok{(df), }\DecValTok{2}\NormalTok{))}

\BuiltInTok{print}\NormalTok{(df.head(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, df.shape)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
    len  dose
0   4.2   0.5
2   7.3   0.5
4   6.4   0.5
6  11.2   0.5
8   5.2   0.5 
 (30, 2)
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df.insert(loc }\OperatorTok{=} \DecValTok{0}\NormalTok{, column }\OperatorTok{=} \StringTok{\textquotesingle{}ID\textquotesingle{}}\NormalTok{, value }\OperatorTok{=}\NormalTok{ meerschweinchen.loc[df.index, }\StringTok{\textquotesingle{}ID\textquotesingle{}}\NormalTok{])}

\BuiltInTok{print}\NormalTok{(df.head(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(df.tail(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"df.shape:"}\NormalTok{, df.shape)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   ID   len  dose
0   1   4.2   0.5
2   3   7.3   0.5
4   5   6.4   0.5
6   7  11.2   0.5
8   9   5.2   0.5 

    ID   len  dose
50  51  25.5   2.0
52  53  22.4   2.0
54  55  24.8   2.0
56  57  26.4   2.0
58  59  29.4   2.0 

df.shape: (30, 3)
\end{verbatim}

\end{tcolorbox}

\section*{Quellen}\label{quellen}
\addcontentsline{toc}{section}{Quellen}

\markright{Quellen}

\url{https://pandas.pydata.org/docs/user_guide/dsintro.html}
\url{https://pandas.pydata.org/docs/user_guide/basics.html}

\chapter{Operationen}\label{operationen}

Pandas erlaubt wie NumPy vektorisierte Operationen, dass heißt,
Berechnungen mit einer Series oder einem DataFrame werden auf jedes
Element angewendet. So können die Rechenoperatoren direkt verwendet
werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Temperaturen in Celsius:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\DecValTok{27} \OperatorTok{*} \StringTok{"="}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(temperaturen, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Temperaturen in Fahrenheit:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\DecValTok{27} \OperatorTok{*} \StringTok{"="}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(temperaturen  }\OperatorTok{*} \DecValTok{9}\OperatorTok{/}\DecValTok{5} \OperatorTok{+} \DecValTok{32}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Temperaturen in Celsius:
===========================
     2021  2022  2023  2024
Jan     2     3    -3    -1
Feb     4     6    -1     2
Mär     7     9     4     5
Apr    12    13     9     8
Mai    19    18    15    17
Jun    23    21    20    24
Jul    25    24    20    25
Aug    23    23    19    20
Sep    18    19    16    17
Okt    15    14    15    14
Nov     9     8     7     9
Dez     5     4     6     2 

Temperaturen in Fahrenheit:
===========================
     2021  2022  2023  2024
Jan  35.6  37.4  26.6  30.2
Feb  39.2  42.8  30.2  35.6
Mär  44.6  48.2  39.2  41.0
Apr  53.6  55.4  48.2  46.4
Mai  66.2  64.4  59.0  62.6
Jun  73.4  69.8  68.0  75.2
Jul  77.0  75.2  68.0  77.0
Aug  73.4  73.4  66.2  68.0
Sep  64.4  66.2  60.8  62.6
Okt  59.0  57.2  59.0  57.2
Nov  48.2  46.4  44.6  48.2
Dez  41.0  39.2  42.8  35.6
\end{verbatim}

Auch boolsche Operationen können direkt ausgeführt werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Minusgrade:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\DecValTok{27} \OperatorTok{*} \StringTok{"="}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(temperaturen  }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Minusgrade:
===========================
      2021   2022   2023   2024
Jan  False  False   True   True
Feb  False  False   True  False
Mär  False  False  False  False
Apr  False  False  False  False
Mai  False  False  False  False
Jun  False  False  False  False
Jul  False  False  False  False
Aug  False  False  False  False
Sep  False  False  False  False
Okt  False  False  False  False
Nov  False  False  False  False
Dez  False  False  False  False
\end{verbatim}

\section{Zeilen- und spaltenweise
Operationen}\label{zeilen--und-spaltenweise-operationen}

Pandas umfasst eine Vielzahl von Methoden, die arithmetische,
summarische, boolsche und Indexfunktionen umsetzen. Eine vollständige
Übersicht finden Sie hier:
\url{https://pandas.pydata.org/docs/reference/index.html}.

In der Regel werden die Funktionen standardmäßig spaltenweise
angewendet. Mit dem Argument \texttt{axis\ =\ 1} wird die jeweilige
Funktion zeilenweise ausgeführt. Die Funktionen sind auch für Series
verfügbar.

Im Folgenden werden einige Methoden exemplarisch vorgestellt.

\subsection{arithmetische Funktionen}\label{arithmetische-funktionen-1}

Die Methoden \texttt{pd.DataFrame.add()}, \texttt{pd.DataFrame.sub()},
\texttt{pd.DataFrame.mul()}, \texttt{pd.DataFrame.div()},
\texttt{pd.DataFrame.floordiv()}, \texttt{pd.DataFrame.mod()} und
\texttt{pd.DataFrame.pow()} entsprechen den Grundrechenarten mit den
Operatoren +, -, *, /, //, \%, **. Sie eignen sich gut für verkettete
Operationen.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Temperaturen in Fahrenheit:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\DecValTok{27} \OperatorTok{*} \StringTok{"="}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(temperaturen.mul(}\DecValTok{9}\NormalTok{).div(}\DecValTok{5}\NormalTok{).add(}\DecValTok{32}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Temperaturen in Fahrenheit:
===========================
     2021  2022  2023  2024
Jan  35.6  37.4  26.6  30.2
Feb  39.2  42.8  30.2  35.6
Mär  44.6  48.2  39.2  41.0
Apr  53.6  55.4  48.2  46.4
Mai  66.2  64.4  59.0  62.6
Jun  73.4  69.8  68.0  75.2
Jul  77.0  75.2  68.0  77.0
Aug  73.4  73.4  66.2  68.0
Sep  64.4  66.2  60.8  62.6
Okt  59.0  57.2  59.0  57.2
Nov  48.2  46.4  44.6  48.2
Dez  41.0  39.2  42.8  35.6
\end{verbatim}

Außerdem kann mit dem Parameter \texttt{fill\_value} ein Füllwert für
fehlende Werte spezifiziert werden (dieser wird vor der Operation
eingesetzt). Wie NumPys \texttt{np.nan} umfasst auch Pandas einen
speziellen fehlenden Wert: \texttt{pd.NA} (achten Sie auf den Datentyp
der Ausgabe). Der Umgang mit fehlenden Werten wird ausführlich im
\href{https://bausteine-der-datenanalyse.github.io/m-einlesen-strukturierter-datensaetze/output/book/}{Methodenbaustein
Einlesen strukturierter Datensätze} behandelt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{missing\_value }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, pd.NA, }\DecValTok{3}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(missing\_value.add(}\DecValTok{1}\NormalTok{, fill\_value }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{999}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(missing\_value.add(}\DecValTok{1}\NormalTok{, fill\_value }\OperatorTok{=}\NormalTok{ np.nan), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(missing\_value.add(}\DecValTok{1}\NormalTok{, fill\_value }\OperatorTok{=}\NormalTok{ pd.NA))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0      2
1   -998
2      4
dtype: int64 

0    2.0
1    NaN
2    4.0
dtype: float64 

0       2
1    <NA>
2       4
dtype: object
\end{verbatim}

\subsection{summarische Funktionen}\label{summarische-funktionen}

\begin{itemize}
\tightlist
\item
  \texttt{pd.DataFrame.mean()} ermittelt den Durchschnitt.
\item
  \texttt{pd.DataFrame.median()} ermittelt den Median.
\item
  \texttt{pd.DataFrame.mode()} ermittelt den Modus.
\item
  \texttt{pd.DataFrame.sum()} ermittelt die Summe.
\item
  \texttt{pd.DataFrame.cumsum()} ermittelt die kummulierte Summe.
\item
  \texttt{pd.DataFrame.min()} und \texttt{pd.DataFrame.max()} ermitteln
  Minimum bzw. Maximum.
\item
  \texttt{pd.DataFrame.cummin()} und \texttt{pd.DataFrame.cummax()}
  ermittelt das kummulierte Minimum bzw. Maximum.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# spaltenweise}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Mittlere Jahrestemperaturen"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\DecValTok{27} \OperatorTok{*} \StringTok{"="}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(temperaturen.mean(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# zeilenweise}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Monatliche Mindesttemperatur"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\DecValTok{28} \OperatorTok{*} \StringTok{"="}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(temperaturen.}\BuiltInTok{min}\NormalTok{(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Mittlere Jahrestemperaturen
===========================
2021    13.500000
2022    13.500000
2023    10.583333
2024    11.833333
dtype: float64 

Monatliche Mindesttemperatur
============================
Jan    -3
Feb    -1
Mär     4
Apr     8
Mai    15
Jun    20
Jul    20
Aug    19
Sep    16
Okt    14
Nov     7
Dez     2
dtype: int64
\end{verbatim}

\subsection{boolsche Funktionen}\label{boolsche-funktionen}

Pandas bietet wie die Pythonbasis verschiedene boolsche Funktionen.

\texttt{pd.DataFrame.isin(values)} prüft für jedes Element des
DataFrame, ob dieses in \texttt{values} enthalten ist. Mit dem Operator
\texttt{\textasciitilde{}} kann geprüft werden, ob die Elemente eines
DataFrame nicht in \texttt{values} enthalten sind:
\texttt{\textasciitilde{}pd.DataFrame.isin(values)}.\\
Die Funktionsausführung ist abhängig vom Datentyp des in \texttt{values}
übergebenen Objekts.

\begin{itemize}
\tightlist
\item
  Wenn \texttt{values} eine Liste oder ein NumPy-Array ist, ist das
  Ergebnis True, wenn es eine Übereinstimmung mit einem der enthaltenen
  Elemente gibt.
\item
  Ist \texttt{value} eine Series oder ein DataFrame, wird die
  Übereinstimmung positionsbasiert überprüft (siehe Beispiel).
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-isin}: klassenabhängige Funktionsausführung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-isin} 

\section{Einzelwerte oder Liste}

Für Einzelwerte oder eine Liste wird die Übereinstimmung elementweise
überprüft.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(temperaturen, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(temperaturen.isin([}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     2021  2022  2023  2024
Jan     2     3    -3    -1
Feb     4     6    -1     2
Mär     7     9     4     5
Apr    12    13     9     8
Mai    19    18    15    17
Jun    23    21    20    24
Jul    25    24    20    25
Aug    23    23    19    20
Sep    18    19    16    17
Okt    15    14    15    14
Nov     9     8     7     9
Dez     5     4     6     2 

      2021   2022   2023   2024
Jan   True   True  False  False
Feb  False  False  False   True
Mär  False  False  False  False
Apr  False  False  False  False
Mai  False  False  False  False
Jun  False  False  False  False
Jul  False  False  False  False
Aug  False  False  False  False
Sep  False  False  False  False
Okt  False  False  False  False
Nov  False  False  False  False
Dez  False  False  False   True
\end{verbatim}

\section{NumPy-Array}

Für ein NumPy-Array wird die Übereinstimmung elementweise überprüft
(vergleiche zum nächsten Reiter).

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(temperaturen[}\DecValTok{2021}\NormalTok{].values), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(temperaturen.isin(temperaturen[}\DecValTok{2021}\NormalTok{].values))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'numpy.ndarray'> 

     2021   2022   2023   2024
Jan  True  False  False  False
Feb  True  False  False   True
Mär  True   True   True   True
Apr  True  False   True  False
Mai  True   True   True  False
Jun  True  False  False  False
Jul  True  False  False   True
Aug  True   True   True  False
Sep  True   True  False  False
Okt  True  False   True  False
Nov  True  False   True   True
Dez  True   True  False   True
\end{verbatim}

\section{Series}

Für eine Series wird die Übereinstimmung positionsweise geprüft
(vergleiche zum vorherigen Reiter). Der Index muss übereinstimmen.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(temperaturen.isin(temperaturen[}\DecValTok{2021}\NormalTok{]), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{temperaturen\_2021\_falscher\_index }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{5}\NormalTok{])}
\NormalTok{temperaturen\_2021\_falscher\_index.index }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}B\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}C\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}D\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}E\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}F\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Jul\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Aug\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Sep\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Okt\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Nov\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Dez\textquotesingle{}}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Der Index der Series lautet:}\CharTok{\textbackslash{}n}\StringTok{[\textquotesingle{}A\textquotesingle{}, \textquotesingle{}B\textquotesingle{}, \textquotesingle{}C\textquotesingle{}, \textquotesingle{}D\textquotesingle{}, \textquotesingle{}E\textquotesingle{}, \textquotesingle{}F\textquotesingle{}, \textquotesingle{}Jul\textquotesingle{}, \textquotesingle{}Aug\textquotesingle{}, \textquotesingle{}Sep\textquotesingle{}, \textquotesingle{}Okt\textquotesingle{}, \textquotesingle{}Nov\textquotesingle{}, \textquotesingle{}Dez\textquotesingle{}].}\CharTok{\textbackslash{}n}\StringTok{Das Ergebnis an den Indexpositionen A{-}F ist immer False."}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(temperaturen.isin(temperaturen\_2021\_falscher\_index))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     2021   2022   2023   2024
Jan  True  False  False  False
Feb  True  False  False  False
Mär  True  False  False  False
Apr  True  False  False  False
Mai  True  False  False  False
Jun  True  False  False  False
Jul  True  False  False   True
Aug  True   True  False  False
Sep  True  False  False  False
Okt  True  False   True  False
Nov  True  False  False   True
Dez  True  False  False  False 

Der Index der Series lautet:
['A', 'B', 'C', 'D', 'E', 'F', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'].
Das Ergebnis an den Indexpositionen A-F ist immer False.
      2021   2022   2023   2024
Jan  False  False  False  False
Feb  False  False  False  False
Mär  False  False  False  False
Apr  False  False  False  False
Mai  False  False  False  False
Jun  False  False  False  False
Jul   True  False  False   True
Aug   True   True  False  False
Sep   True  False  False  False
Okt   True  False   True  False
Nov   True  False  False   True
Dez   True  False  False  False
\end{verbatim}

\section{DataFrame}

Für einen DataFrame wird die Übereinstimmung positionsweise geprüft.
Index und Spaltennamen müssen übereinstimmen (Index siehe Reiter
Series).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{temperaturen\_2021\_df }\OperatorTok{=}\NormalTok{ pd.DataFrame(temperaturen[}\DecValTok{2021}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(temperaturen.isin(temperaturen\_2021\_df), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{temperaturen\_2021\_df.columns }\OperatorTok{=}\NormalTok{ [}\DecValTok{2035}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(temperaturen.isin(temperaturen\_2021\_df), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     2021   2022   2023   2024
Jan  True  False  False  False
Feb  True  False  False  False
Mär  True  False  False  False
Apr  True  False  False  False
Mai  True  False  False  False
Jun  True  False  False  False
Jul  True  False  False  False
Aug  True  False  False  False
Sep  True  False  False  False
Okt  True  False  False  False
Nov  True  False  False  False
Dez  True  False  False  False 

      2021   2022   2023   2024
Jan  False  False  False  False
Feb  False  False  False  False
Mär  False  False  False  False
Apr  False  False  False  False
Mai  False  False  False  False
Jun  False  False  False  False
Jul  False  False  False  False
Aug  False  False  False  False
Sep  False  False  False  False
Okt  False  False  False  False
Nov  False  False  False  False
Dez  False  False  False  False 
\end{verbatim}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-documentation}: Überraschungen vermeiden}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-documentation} 

Eine klassenabhängige Funktionsausführung kann, wenn das Verhalten
unbemerkt bleibt, die Ergebnisse einer Datenanalyse verfälschen. Um dies
zu verhindern, sollten Sie 3 allgemeine Ratschläge befolgen:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Schauen Sie in die Dokumentation der jeweiligen Funktion. Python und
  viele Module entwickeln sich dynamisch, sodass sich das Verhalten
  einer Funktion verändern kann.
\item
  Gehen Sie schrittweise vor und lassen sich die Zwischenergebnisse von
  Arbeitsschritten mit der Funktion \texttt{print()} ausgeben.
\item
  Bei großen Datenmengen ist es häufig einfacher, mit eigens erzeugten
  Testdaten zu arbeiten. Ein zehnzeiliger DataFrame mit den Datentypen
  und der Struktur der Arbeitsdaten, ist leichter zu überblicken. Nutzen
  Sie einen solchen Testdatensatz um die von Ihnen verwendeten
  Funktionen zu überprüfen.
\end{enumerate}

\end{tcolorbox}

Eine Gruppe von Funktionen setzt logische Vergleiche um.

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Funktion & Vergleich \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{pd.DataFrame.lt(other)} & kleiner \\
\texttt{pd.DataFrame.le(other)} & kleiner gleich \\
\texttt{pd.DataFrame.eq(other)} & gleich \\
\texttt{pd.DataFrame.ne(other)} & ungleich \\
\texttt{pd.DataFrame.ge(other)} & größer gleich \\
\texttt{pd.DataFrame.gt(other)} & größer \\
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(temperaturen.le(}\DecValTok{2}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(temperaturen[}\DecValTok{2021}\NormalTok{].gt(}\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
      2021   2022   2023   2024
Jan   True  False   True   True
Feb  False  False   True   True
Mär  False  False  False  False
Apr  False  False  False  False
Mai  False  False  False  False
Jun  False  False  False  False
Jul  False  False  False  False
Aug  False  False  False  False
Sep  False  False  False  False
Okt  False  False  False  False
Nov  False  False  False  False
Dez  False  False  False   True 

Jan    False
Feb    False
Mär     True
Apr     True
Mai     True
Jun     True
Jul     True
Aug     True
Sep     True
Okt     True
Nov     True
Dez    False
Name: 2021, dtype: bool
\end{verbatim}

\subsection{Verwendung der Methoden .agg() und
.apply()}\label{verwendung-der-methoden-.agg-und-.apply}

Pandas bringt zwei eigene Methoden mit, um Operationen zeilen- oder
spaltenweise auszuführen. \texttt{DataFrame.agg()} (oder auch
\texttt{DataFrame.aggregate()}) aggregiert einen DataFrame zeilen- oder
spaltenweise durch eine Funktion. Die Pandas-Methode \texttt{DF.apply()}
wendet eine Funktion zeilen- oder spaltenweise auf einen DataFrame an.
Die Methoden sind also sehr ähnlich und führen in den meisten Fällen zum
selben Ergebnis.

Beide Funktionen führen mit dem Argument \texttt{axis\ =\ 1} Operationen
zeilenweise aus.

\section{Funktion}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ my\_plus\_ten(x):}
\NormalTok{  y }\OperatorTok{=}\NormalTok{ x }\OperatorTok{+} \DecValTok{10}
  \ControlFlowTok{return}\NormalTok{ y}

\BuiltInTok{print}\NormalTok{(temperaturen.agg(my\_plus\_ten), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(temperaturen.}\BuiltInTok{apply}\NormalTok{(my\_plus\_ten))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     2021  2022  2023  2024
Jan    12    13     7     9
Feb    14    16     9    12
Mär    17    19    14    15
Apr    22    23    19    18
Mai    29    28    25    27
Jun    33    31    30    34
Jul    35    34    30    35
Aug    33    33    29    30
Sep    28    29    26    27
Okt    25    24    25    24
Nov    19    18    17    19
Dez    15    14    16    12 

     2021  2022  2023  2024
Jan    12    13     7     9
Feb    14    16     9    12
Mär    17    19    14    15
Apr    22    23    19    18
Mai    29    28    25    27
Jun    33    31    30    34
Jul    35    34    30    35
Aug    33    33    29    30
Sep    28    29    26    27
Okt    25    24    25    24
Nov    19    18    17    19
Dez    15    14    16    12
\end{verbatim}

\section{Funktionsname}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(temperaturen.agg(}\StringTok{"sum"}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(temperaturen.}\BuiltInTok{apply}\NormalTok{(}\StringTok{"sum"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2021    162
2022    162
2023    127
2024    142
dtype: int64 

2021    162
2022    162
2023    127
2024    142
dtype: int64
\end{verbatim}

\section{Liste von Funktionen}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(temperaturen.agg([}\StringTok{"sum"}\NormalTok{, }\StringTok{"mean"}\NormalTok{, }\StringTok{"median"}\NormalTok{]), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(temperaturen.}\BuiltInTok{apply}\NormalTok{([}\StringTok{"sum"}\NormalTok{, }\StringTok{"mean"}\NormalTok{, }\StringTok{"median"}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
         2021   2022        2023        2024
sum     162.0  162.0  127.000000  142.000000
mean     13.5   13.5   10.583333   11.833333
median   13.5   13.5   12.000000   11.500000 

         2021   2022        2023        2024
sum     162.0  162.0  127.000000  142.000000
mean     13.5   13.5   10.583333   11.833333
median   13.5   13.5   12.000000   11.500000
\end{verbatim}

\section{Dictionary von Funktionen}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(temperaturen.agg(\{}\DecValTok{2021}\NormalTok{: }\StringTok{"sum"}\NormalTok{, }\DecValTok{2022}\NormalTok{: }\StringTok{"mean"}\NormalTok{, }\DecValTok{2023}\NormalTok{: }\StringTok{"median"}\NormalTok{, }\DecValTok{2024}\NormalTok{: }\StringTok{"min"}\NormalTok{\}), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(temperaturen.}\BuiltInTok{apply}\NormalTok{(\{}\DecValTok{2021}\NormalTok{: }\StringTok{"sum"}\NormalTok{, }\DecValTok{2022}\NormalTok{: }\StringTok{"mean"}\NormalTok{, }\DecValTok{2023}\NormalTok{: }\StringTok{"median"}\NormalTok{, }\DecValTok{2024}\NormalTok{: }\StringTok{"min"}\NormalTok{\}), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2021    162.0
2022     13.5
2023     12.0
2024     -1.0
dtype: float64 

2021    162.0
2022     13.5
2023     12.0
2024     -1.0
dtype: float64 
\end{verbatim}

Besonders nützlich ist die Möglichkeit, Funktionen, die normalerweise
auf eine Series angewendet werden, auf jedes Element der Series
anzuwenden. Dafür wird die lambda Syntax verwendet:
\texttt{lambda\ x:\ x\ +\ 1}. lambda ist ein Platzhalter und kann als
``für jedes x tue:'' gelesen werden. So kann beispielsweise die Anzahl
der Zeichen in jeder Zeile bestimmt werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Auf die Series angewendet}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{len}\NormalTok{(}\BuiltInTok{str}\NormalTok{(temperaturen[}\DecValTok{2021}\NormalTok{])), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# Elementweise angewendet}
\BuiltInTok{print}\NormalTok{(temperaturen[}\DecValTok{2021}\NormalTok{].agg(}\KeywordTok{lambda}\NormalTok{ x: }\BuiltInTok{len}\NormalTok{(}\BuiltInTok{str}\NormalTok{(x))), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{) }\CommentTok{\# deprecated}
\BuiltInTok{print}\NormalTok{(temperaturen[}\DecValTok{2021}\NormalTok{].}\BuiltInTok{apply}\NormalTok{(}\KeywordTok{lambda}\NormalTok{ x: }\BuiltInTok{len}\NormalTok{(}\BuiltInTok{str}\NormalTok{(x))), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
144 

Jan    1
Feb    1
Mär    1
Apr    2
Mai    2
Jun    2
Jul    2
Aug    2
Sep    2
Okt    2
Nov    1
Dez    1
Name: 2021, dtype: int64 

Jan    1
Feb    1
Mär    1
Apr    2
Mai    2
Jun    2
Jul    2
Aug    2
Sep    2
Okt    2
Nov    1
Dez    1
Name: 2021, dtype: int64 
\end{verbatim}

Details zur Verwendung des
\href{https://docs.python.org/3/reference/expressions.html\#lambda}{Lambda-Ausdrucks}
finden Sie in der Dokumentation.

Der Vollständigkeit wegen ist zu erwähnen, dass mit den Methoden
\texttt{.map()} und \texttt{.transform()} weitere, sehr ähnliche
Alternativen bestehen. Bei Interesse können Sie die Unterschiede
\href{https://towardsdatascience.com/pandas-apply-map-or-transform-dd931659e9cf/}{in
diesem Artikel} nachlesen.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# print(temperaturen[2021].map(lambda x: len(str(x))))}
\CommentTok{\# print(temperaturen[2021].transform(lambda x: len(str(x))), "\textbackslash{}n") }
\end{Highlighting}
\end{Shaded}

\section{Aufgaben Operationen}\label{aufgaben-operationen}

Gegeben ist der DataFrame temperaturen.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Temperaturdaten}
\NormalTok{temperaturen\_2021 }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{5}\NormalTok{])}
\NormalTok{temperaturen\_2022 }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{3}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{21}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{4}\NormalTok{])}
\NormalTok{temperaturen\_2023 }\OperatorTok{=}\NormalTok{ pd.Series([}\OperatorTok{{-}}\DecValTok{3}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{19}\NormalTok{, }\DecValTok{16}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{])}
\NormalTok{temperaturen\_2024 }\OperatorTok{=}\NormalTok{ pd.Series([}\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{17}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{17}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{2}\NormalTok{])}

\CommentTok{\# DataFrame erzeugen}
\NormalTok{temperaturen }\OperatorTok{=}\NormalTok{ pd.concat([temperaturen\_2021, temperaturen\_2022, temperaturen\_2023, temperaturen\_2024], axis }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{temperaturen.columns }\OperatorTok{=}\NormalTok{ [}\DecValTok{2021}\NormalTok{, }\DecValTok{2022}\NormalTok{, }\DecValTok{2023}\NormalTok{, }\DecValTok{2024}\NormalTok{]}
\NormalTok{temperaturen.index }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Jan\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Feb\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Mär\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Apr\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Mai\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Jun\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Jul\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Aug\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Sep\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Okt\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Nov\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Dez\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Bestimmen Sie für den Dataframe temperaturen die monatliche
  Mediantemperatur.
\item
  Ermitteln Sie die Monate mit einer Mediantemperatur größer gleich 21
  Grad.
\item
  Geben Sie die Indexbeschriftung dieser Monate aus.
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-loesungoperationen}: Musterlösung Aufgaben Operationen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-loesungoperationen} 

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(temperaturen.mean(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Jan     0.25
Feb     2.75
Mär     6.25
Apr    10.50
Mai    17.25
Jun    22.00
Jul    23.50
Aug    21.25
Sep    17.50
Okt    14.50
Nov     8.25
Dez     4.25
dtype: float64
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(temperaturen.mean(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{).ge(}\DecValTok{21}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Jan    False
Feb    False
Mär    False
Apr    False
Mai    False
Jun     True
Jul     True
Aug     True
Sep    False
Okt    False
Nov    False
Dez    False
dtype: bool
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(temperaturen.index[temperaturen.mean(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{).ge(}\DecValTok{21}\NormalTok{)], }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# als Liste}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{list}\NormalTok{(temperaturen.index[temperaturen.mean(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{).ge(}\DecValTok{21}\NormalTok{)]), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Index(['Jun', 'Jul', 'Aug'], dtype='object') 

['Jun', 'Jul', 'Aug'] 
\end{verbatim}

\end{tcolorbox}

\section{Suchen und ersetzen}\label{suchen-und-ersetzen}

Um die Indexposition eines bestimmten Werts zu bestimmen, kann die
Numpy-Funktion \texttt{np.where()} verwendet werden. Diese gibt zwei
Arrays mit den jeweiligen Zeilen- und Spaltennummern zurück.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(np.where(temperaturen }\OperatorTok{==} \DecValTok{4}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(array([ 1,  2, 11]), array([0, 2, 1]))
\end{verbatim}

Unter anderem befindet sich der Wert 4 in Zeile 1 in Spalte 0 oder auch
in Zeile 2 in Spalte 2.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(temperaturen.iloc[}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(temperaturen.iloc[}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
4
4
\end{verbatim}

Pandas bietet zwei Methoden, um Werte zu ersetzen.

\begin{itemize}
\item
  \texttt{pd.DataFrame.replace(to\_replace,\ value,\ *,\ inplace\ =\ False)}
  ersetzt \texttt{to\_replace} mit \texttt{value}. Mit dem Argument
  \texttt{inplace\ =\ True} erfolgt dies direkt im Objekt.
\item
  \texttt{pd.where(cond,\ other\ =\ nan,\ inplace\ =\ False)} behält
  \texttt{cond} und ersetzt alle anderen Werte mit \texttt{other}
  (standardmäßig ein Platzhalter für fehlende Werte). Mit dem Argument
  \texttt{inplace\ =\ True} erfolgt dies direkt im Objekt.
\end{itemize}

Die Syntax beider Funktionen unterscheidet sich leicht, wie im folgenden
Beispiel zu sehen ist.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(temperaturen.replace(to\_replace }\OperatorTok{=} \DecValTok{25}\NormalTok{, value }\OperatorTok{=} \DecValTok{1000}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(temperaturen.where(temperaturen }\OperatorTok{==} \DecValTok{25}\NormalTok{, other }\OperatorTok{=} \DecValTok{1000}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     2021  2022  2023  2024
Jan     2     3    -3    -1
Feb     4     6    -1     2
Mär     7     9     4     5
Apr    12    13     9     8
Mai    19    18    15    17
Jun    23    21    20    24
Jul  1000    24    20  1000
Aug    23    23    19    20
Sep    18    19    16    17
Okt    15    14    15    14
Nov     9     8     7     9
Dez     5     4     6     2 

     2021  2022  2023  2024
Jan  1000  1000  1000  1000
Feb  1000  1000  1000  1000
Mär  1000  1000  1000  1000
Apr  1000  1000  1000  1000
Mai  1000  1000  1000  1000
Jun  1000  1000  1000  1000
Jul    25  1000  1000    25
Aug  1000  1000  1000  1000
Sep  1000  1000  1000  1000
Okt  1000  1000  1000  1000
Nov  1000  1000  1000  1000
Dez  1000  1000  1000  1000
\end{verbatim}

\section{Aufgaben suchen und
ersetzen}\label{aufgaben-suchen-und-ersetzen}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Bestimmen Sie die Position der Werte im DataFrame `temperaturen', die
  kleiner als 0 sind und geben Sie die Werte aus.
\item
  Ersetzen Sie alle Werte im DataFrame `temperaturen', die kleiner sind
  als 0 durch den Wert 0 und geben Sie das Ergebnis aus.
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-loesung-suchenersetzen}: Musterlösung suchen und ersetzen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-loesung-suchenersetzen} 

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(np.where(temperaturen }\OperatorTok{\textless{}=} \DecValTok{0}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Anzahl Werte:"}\NormalTok{, }\BuiltInTok{len}\NormalTok{(np.where(temperaturen }\OperatorTok{\textless{}=} \DecValTok{0}\NormalTok{)[}\DecValTok{0}\NormalTok{]))}

\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(np.where(temperaturen }\OperatorTok{\textless{}=} \DecValTok{0}\NormalTok{)[}\DecValTok{0}\NormalTok{])):}
  \BuiltInTok{print}\NormalTok{(temperaturen.iloc[np.where(temperaturen }\OperatorTok{\textless{}=} \DecValTok{0}\NormalTok{)[}\DecValTok{0}\NormalTok{][i], np.where(temperaturen }\OperatorTok{\textless{}=} \DecValTok{0}\NormalTok{)[}\DecValTok{1}\NormalTok{][i]])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(array([0, 0, 1]), array([2, 3, 2]))
Anzahl Werte: 3
-3
-1
-1
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(temperaturen.where(temperaturen }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{, other }\OperatorTok{=} \DecValTok{0}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     2021  2022  2023  2024
Jan     2     3     0     0
Feb     4     6     0     2
Mär     7     9     4     5
Apr    12    13     9     8
Mai    19    18    15    17
Jun    23    21    20    24
Jul    25    24    20    25
Aug    23    23    19    20
Sep    18    19    16    17
Okt    15    14    15    14
Nov     9     8     7     9
Dez     5     4     6     2
\end{verbatim}

\end{tcolorbox}

\section{Sortieren}\label{sortieren}

Die Methode
\texttt{DataFrame.sort\_index(axis\ =\ 0,\ ascending\ =\ True,\ inplace\ =\ False)}
sortiert entlang einer Achse, standardmäßig aufsteigend nach dem Index.
Durch die Übergabe des Arguments \texttt{axis\ =\ 1} werden die Spalten
sortiert. Mit dem Argument \texttt{ascending\ =\ False} wird absteigend
sortiert. Das Argument \texttt{inplace\ =\ True} sorgt, wie gewohnt,
dafür, dass das Ergebnis des Sortiervorgangs direkt im Objekt
gespeichert wird.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(temperaturen.sort\_index(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(temperaturen.sort\_index(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{, ascending }\OperatorTok{=} \VariableTok{False}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     2021  2022  2023  2024
Apr    12    13     9     8
Aug    23    23    19    20
Dez     5     4     6     2
Feb     4     6    -1     2
Jan     2     3    -3    -1
Jul    25    24    20    25
Jun    23    21    20    24
Mai    19    18    15    17
Mär     7     9     4     5
Nov     9     8     7     9
Okt    15    14    15    14
Sep    18    19    16    17 

     2024  2023  2022  2021
Jan    -1    -3     3     2
Feb     2    -1     6     4
Mär     5     4     9     7
Apr     8     9    13    12
Mai    17    15    18    19
Jun    24    20    21    23
Jul    25    20    24    25
Aug    20    19    23    23
Sep    17    16    19    18
Okt    14    15    14    15
Nov     9     7     8     9
Dez     2     6     4     5
\end{verbatim}

Die Methode
\texttt{DataFrame.sort\_values(by,\ *,\ axis\ =\ 0,\ ascending\ =\ True,\ inplace\ =\ False)}
sortiert Werte entlang einer Achse, standardmäßig entlang des Index
(\texttt{axis\ =\ 0}). Dem Parameter \texttt{by} sind
\href{https://pandas.pydata.org/pandas-docs/version/2.1/reference/api/pandas.DataFrame.sort_values.html}{laut
Dokumentation} der Spaltenname als string bzw. eine Liste von
Spaltennamen als string zu übergeben, nach denen sortiert werden soll.
Wie im folgenden Code-Beispiel zu sehen ist, muss die numerische
Spaltenbeschriftung jedoch auch in numerischer Form übergeben werden.

Wird mit dem Argument \texttt{axis\ =\ 1} entlang der zweiten Dimension
sortiert, werden entsprechend Indexbeschriftungen übergeben.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Sortieren nach numerischen Spaltenbeschriftungen}
\BuiltInTok{print}\NormalTok{(temperaturen.sort\_values(by }\OperatorTok{=} \DecValTok{2021}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(temperaturen.sort\_values(by }\OperatorTok{=}\NormalTok{ [}\DecValTok{2021}\NormalTok{, }\DecValTok{2023}\NormalTok{]), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# Sortieren nach als string übergebenen Spaltenbeschriftungen}
\CommentTok{\# führt zu KeyError, die Fehlermeldung wird nicht vollständig abgefangen}
\ControlFlowTok{try}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(temperaturen.sort\_values(by }\OperatorTok{=} \StringTok{\textquotesingle{}2021\textquotesingle{}}\NormalTok{))}
\ControlFlowTok{except} \PreprocessorTok{Exception} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(error)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     2021  2022  2023  2024
Jan     2     3    -3    -1
Feb     4     6    -1     2
Dez     5     4     6     2
Mär     7     9     4     5
Nov     9     8     7     9
Apr    12    13     9     8
Okt    15    14    15    14
Sep    18    19    16    17
Mai    19    18    15    17
Jun    23    21    20    24
Aug    23    23    19    20
Jul    25    24    20    25 

     2021  2022  2023  2024
Jan     2     3    -3    -1
Feb     4     6    -1     2
Dez     5     4     6     2
Mär     7     9     4     5
Nov     9     8     7     9
Apr    12    13     9     8
Okt    15    14    15    14
Sep    18    19    16    17
Mai    19    18    15    17
Aug    23    23    19    20
Jun    23    21    20    24
Jul    25    24    20    25 

'2021'
\end{verbatim}

\section{Aufgaben Sortieren}\label{aufgaben-sortieren}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Sortieren Sie den DataFrame `meerschweinchen' absteigend nach der
  Zahnlänge (`len'). Welches Meerschweinchen hat die längste
  zahnbildende Zelle (gesucht ist die ID)?
\item
  Welches Meerschweinchen, welches die Dosis 1.0 erhielt, hat die
  längste zahnbildende Zelle (gesucht ist die ID)?
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-musterloesungsortieren}: Musterlösung Sortieren}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-musterloesungsortieren} 

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(meerschweinchen.sort\_values(by }\OperatorTok{=} \StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{, ascending }\OperatorTok{=} \VariableTok{False}\NormalTok{).head(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Die ID lautet:"}\NormalTok{, meerschweinchen.sort\_values(by }\OperatorTok{=} \StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{, ascending }\OperatorTok{=} \VariableTok{False}\NormalTok{).iloc[}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
    ID   len supp  dose
22  23  33.9   VC   2.0
25  26  32.5   VC   2.0
55  56  30.9   OJ   2.0
29  30  29.5   VC   2.0
58  59  29.4   OJ   2.0 

Die ID lautet: 23
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dose\_1 }\OperatorTok{=}\NormalTok{ meerschweinchen[meerschweinchen[}\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{] }\OperatorTok{==} \FloatTok{1.0}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(dose\_1.sort\_values(by }\OperatorTok{=} \StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{, ascending }\OperatorTok{=} \VariableTok{False}\NormalTok{).head(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Die ID lautet:"}\NormalTok{, dose\_1.sort\_values(by }\OperatorTok{=} \StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{, ascending }\OperatorTok{=} \VariableTok{False}\NormalTok{).iloc[}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
    ID   len supp  dose
49  50  27.3   OJ   1.0
43  44  26.4   OJ   1.0
46  47  25.8   OJ   1.0
45  46  25.2   OJ   1.0
42  43  23.6   OJ   1.0 

Die ID lautet: 50
\end{verbatim}

\end{tcolorbox}

\section{GroupBy}\label{groupby}

Die Methode \texttt{pd.groupby()} teilt einen DataFrame (oder eine
Series) in Gruppen auf und gibt ein GroupBy-Objekt zurück. Das
GroupBy-Objekt hat dieselben Spalten- und Zeilenbeschriftungen wie der
DataFrame, das GroupBy-Objekt ist aber nach der Gruppenaufteilung
sortiert. Operationen, die auf das GroupBy-Objekt angewendet werden,
werden für jede Gruppe separat ausgeführt.

Dies kann am Datensatz `meerschweinchen' im folgenden Panel
nachvollzogen werden.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Reiter: Der Datensatz enthält 60 Einträge. Die ersten 30 Einträge
  haben in der Spalte `supp' die Ausprägung VC für Vitamin C, die
  letzten 30 Einträge die Ausprägung OJ für Orangensaft.
\item
  Reiter: Mit der Methode
  \texttt{pd.groupby(\textquotesingle{}supp\textquotesingle{})} kann der
  Datensatz nach den Merkmalsausprägungen in der Spalte `dose' (0.5, 1
  und 2) gruppiert werden.
\item
  Reiter: Auf das Groupby-Objekt können Operationen ausgeführt werden.
  Beispielsweise kann die Spalte `len' ausgewählt und mit der Methode
  \texttt{.mean()} die mittlere Länge der zahnbildenden Zelle bestimmt
  werden.
\item
  Reiter: Ebenso kann nach den Ausprägungen mehrerer Merkmale gruppiert
  werden, indem diese als Liste übergeben werden
  \texttt{pd.groupby(by\ =\ {[}\textquotesingle{}supp\textquotesingle{},\ \textquotesingle{}dose\textquotesingle{}{]})}.
\end{enumerate}

\section{DataFrame meerschweinchen}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(meerschweinchen.head(n }\OperatorTok{=} \DecValTok{12}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
    ID   len supp  dose
0    1   4.2   VC   0.5
1    2  11.5   VC   0.5
2    3   7.3   VC   0.5
3    4   5.8   VC   0.5
4    5   6.4   VC   0.5
5    6  10.0   VC   0.5
6    7  11.2   VC   0.5
7    8  11.2   VC   0.5
8    9   5.2   VC   0.5
9   10   7.0   VC   0.5
10  11  16.5   VC   1.0
11  12  16.5   VC   1.0
\end{verbatim}

\section{meerschweinchen gruppiert nach Verabreichungsart}

Für die Methode \texttt{.head()} wurde das Argument n halbiert, um die
gleiche Zeilenzahl in der Ausgabe anzeigen zu lassen, da auch diese
Methode für jede der beiden Gruppen (VC und OJ) ausgeführt wird.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(meerschweinchen.groupby(}\StringTok{\textquotesingle{}supp\textquotesingle{}}\NormalTok{).head(n }\OperatorTok{=} \DecValTok{6}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
    ID   len supp  dose
0    1   4.2   VC   0.5
1    2  11.5   VC   0.5
2    3   7.3   VC   0.5
3    4   5.8   VC   0.5
4    5   6.4   VC   0.5
5    6  10.0   VC   0.5
30  31  15.2   OJ   0.5
31  32  21.5   OJ   0.5
32  33  17.6   OJ   0.5
33  34   9.7   OJ   0.5
34  35  14.5   OJ   0.5
35  36  10.0   OJ   0.5
\end{verbatim}

\section{Länge nach Verabreichungsart}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(meerschweinchen.groupby(by }\OperatorTok{=} \StringTok{\textquotesingle{}supp\textquotesingle{}}\NormalTok{)[}\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{].mean())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
supp
OJ    20.663333
VC    16.963333
Name: len, dtype: float64
\end{verbatim}

\section{Länge nach Verabreichungsart und Dosis}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(meerschweinchen.groupby(by }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}supp\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{])[}\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{].mean())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
supp  dose
OJ    0.5     13.23
      1.0     22.70
      2.0     26.06
VC    0.5      7.98
      1.0     16.77
      2.0     26.14
Name: len, dtype: float64
\end{verbatim}

\section{Aufgaben GroupBy}\label{aufgaben-groupby}

Der Datensatz Motor Trend Car Road Tests (mtcars) stammt aus der
us-amerikanischen Zeitschrift Motor Trend von 1974 und enthalt Daten für
32 Autos.

\begin{codelisting}

\caption{\label{lst-readfile2}}

\centering{

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=} \StringTok{"01{-}daten/mtcars.csv"}\NormalTok{, sep }\OperatorTok{=} \StringTok{","}\NormalTok{)}
\NormalTok{mtcars.rename(columns }\OperatorTok{=}\NormalTok{ \{}\StringTok{\textquotesingle{}Unnamed: 0\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}car\textquotesingle{}}\NormalTok{\}, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

\NormalTok{mtcars.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable*}[]{@{}lllllllllllll@{}}
\toprule\noalign{}
& car & mpg & cyl & disp & hp & drat & wt & qsec & vs & am & gear &
carb \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & Mazda RX4 & 21.0 & 6 & 160.0 & 110 & 3.90 & 2.620 & 16.46 & 0 & 1 &
4 & 4 \\
1 & Mazda RX4 Wag & 21.0 & 6 & 160.0 & 110 & 3.90 & 2.875 & 17.02 & 0 &
1 & 4 & 4 \\
2 & Datsun 710 & 22.8 & 4 & 108.0 & 93 & 3.85 & 2.320 & 18.61 & 1 & 1 &
4 & 1 \\
3 & Hornet 4 Drive & 21.4 & 6 & 258.0 & 110 & 3.08 & 3.215 & 19.44 & 1 &
0 & 3 & 1 \\
4 & Hornet Sportabout & 18.7 & 8 & 360.0 & 175 & 3.15 & 3.440 & 17.02 &
0 & 0 & 3 & 2 \\
\end{longtable*}

}

\end{codelisting}%

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Spalte & Bedeutung \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
mpg & Kraftstoffverbrauch in Meilen pro Gallone \\
cyl & Anzahl Zylinder \\
disp & Hubraum in Kubikzoll \\
hp & Pferdestärken \\
drat & Hinterachsübersetzung \\
wt & Gewicht in 1000 Pfund \\
qsec & Zeit auf der Viertelmeile \\
vs & Motor (0 = V-Motor, 1 = Reihenmotor) \\
am & Schaltung (0 = Automatik, 1 = Handschaltung) \\
gear & Anzahl der Vorwärtsgänge \\
carb & Anzahl der Vergaser \\
\end{longtable}

Henderson and Velleman 1981. Building multiple regression models
interactively. Biometrics 37: 391--411. Der Datensatz ist abrufbar auf
\href{https://gist.github.com/seankross/a412dfbd88b3db70b74b}{GitHub}
und in R verfügbar.

~

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Gruppieren Sie den Datensatz nach der Anzahl Zylinder und ermitteln
  Sie den durchschnittlichen Kraftstoffverbrauch für jede Gruppe.
\item
  Wie viele Liter auf 100 Kilometer sind es?
\item
  Gruppieren Sie den Datensatz nach der Anzahl der Zylinder und der
  Vergaser. Welche Gruppe ist am schnellsten auf der Viertelmeile?
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-loesunggroupby}: Musterlösung GroupBy}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-loesunggroupby} 

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars.groupby(by }\OperatorTok{=} \StringTok{\textquotesingle{}cyl\textquotesingle{}}\NormalTok{)[}\StringTok{\textquotesingle{}mpg\textquotesingle{}}\NormalTok{].mean() }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
cyl
4    26.663636
6    19.742857
8    15.100000
Name: mpg, dtype: float64
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 1 Meile = 1.60934 Kilometer}
\CommentTok{\# 1 Gallone = 3.78541 Liter}

\NormalTok{mpg }\OperatorTok{=}\NormalTok{ mtcars.groupby(by }\OperatorTok{=} \StringTok{\textquotesingle{}cyl\textquotesingle{}}\NormalTok{)[}\StringTok{\textquotesingle{}mpg\textquotesingle{}}\NormalTok{].mean()}

\NormalTok{liter\_100km }\OperatorTok{=} \DecValTok{1} \OperatorTok{/}\NormalTok{ mpg.mul(}\FloatTok{1.60934}\NormalTok{).div(}\FloatTok{3.78541}\NormalTok{).div(}\DecValTok{100}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(liter\_100km)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
cyl
4     8.821567
6    11.913932
8    15.577156
Name: mpg, dtype: float64
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(mtcars.groupby(by }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}cyl\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}carb\textquotesingle{}}\NormalTok{])[}\StringTok{\textquotesingle{}qsec\textquotesingle{}}\NormalTok{].mean(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(mtcars.groupby(by }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}cyl\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}carb\textquotesingle{}}\NormalTok{])[}\StringTok{\textquotesingle{}qsec\textquotesingle{}}\NormalTok{].mean().index[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{], }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
cyl  carb
4    1       19.378000
     2       18.936667
6    1       19.830000
     4       17.670000
     6       15.500000
8    2       17.060000
     3       17.666667
     4       16.495000
     8       14.600000
Name: qsec, dtype: float64 

(np.int64(8), np.int64(8)) 
\end{verbatim}

Die Gruppe mit 8 Zylindern und 8 Vergasern ist am schnellsten. (Hinweis:
Es handelt sich hierbei um einen sogenannten
\href{https://pandas.pydata.org/docs/user_guide/advanced.html}{MultiIndex}.)

\end{tcolorbox}

\chapter{Grafikerstellung}\label{grafikerstellung}

Mit der Methode \texttt{pd.plot()} können Series und DataFrame grafisch
dargestellt werden. Dazu greift Pandas auf matplotlib zurück. Die Syntax
von Pandas ist einfacher, dafür bietet das Modul weniger Möglichkeiten
als matplotlib. Jedoch können Befehle aus Pandas und aus matplotlib zur
Grafikerstellung kombiniert werden (siehe
\href{https://bausteine-der-datenanalyse.github.io/w-python-matplotlib/output/book/}{Werkzeugbaustein
Matplotlib}).

\section{Series}\label{series-2}

Eine Series wird gegen den Index geplottet. Standardmäßig wird ein
Liniendiagramm gezeichnet. Mit den Parametern \texttt{xlabel} und
\texttt{ylabel} können Achsenbeschriftungen eingetragen werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{meerschweinchen[}\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{].plot(xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Index\textquotesingle{}}\NormalTok{, ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-pandas/skript/plotting_files/figure-pdf/cell-3-output-1.png}}

Mit dem Parameter \texttt{kind} kann der Grafiktyp geändert werden.
Einige Möglichkeiten sind:

\begin{itemize}
\tightlist
\item
  \texttt{\textquotesingle{}line\textquotesingle{}}: Standardwert
  Liniendiagramm
\item
  \texttt{\textquotesingle{}bar\textquotesingle{}}: vertikales
  Balkendiagramm
\item
  \texttt{\textquotesingle{}hbar\textquotesingle{}}: horizontales
  Balkendiagramm
\item
  \texttt{\textquotesingle{}hist\textquotesingle{}}: Histogramm
\item
  \texttt{\textquotesingle{}box\textquotesingle{}}: Boxplot
\item
  \texttt{\textquotesingle{}pie\textquotesingle{}}: Tortendiagramm
\end{itemize}

Einige sinnvolle Parameter sind:

\begin{itemize}
\tightlist
\item
  \texttt{colormap\ =\ palette} ändert die Farbpalette. Eine Liste der
  in matplotlib verfügbaren Paletten finden Sie in der
  \href{https://matplotlib.org/stable/users/explain/colors/colormaps.html}{Dokumentation}.
\item
  \texttt{figsize\ =\ (Breite,\ Höhe)} Tupel der Bildgröße in Zoll
\item
  \texttt{legend\ =\ True} zeichnet eine Legende ein.
\item
  \texttt{title\ =\ \textquotesingle{}Titel\textquotesingle{}} trägt
  einen Titel ein.
\item
  \texttt{grid\ =\ True} fügt Gitternetzlinien ein.
\item
  \texttt{xlim\ =\ (min,\ max)} / \texttt{ylim\ =\ (min,\ max)} setzt
  den Wertebereich der x- bzw. y-Achse.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{meerschweinchen[}\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{].value\_counts().plot(kind }\OperatorTok{=} \StringTok{\textquotesingle{}pie\textquotesingle{}}\NormalTok{, ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}Dosis\textquotesingle{}}\NormalTok{, colormap }\OperatorTok{=} \StringTok{\textquotesingle{}Blues\textquotesingle{}}\NormalTok{, figsize }\OperatorTok{=}\NormalTok{ (}\DecValTok{6}\NormalTok{, }\DecValTok{6}\NormalTok{), legend }\OperatorTok{=} \VariableTok{True}\NormalTok{, title }\OperatorTok{=} \StringTok{\textquotesingle{}Tortendiagramm der Dosis Vitamin C\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-pandas/skript/plotting_files/figure-pdf/cell-4-output-1.png}}

\section{DataFrame}\label{dataframe-2}

Für DataFrames sind weitere Optionen verfügbar. Mittels der Parameter
\texttt{x} und \texttt{y} können Spalten oder Zeilen ausgewählt werden,
die auf den jeweiligen Achsen aufgetragen werden sollen. \texttt{y} kann
dabei auch eine Liste mit mehreren Einträgen enthalten.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{meerschweinchen.plot(x }\OperatorTok{=} \StringTok{\textquotesingle{}ID\textquotesingle{}}\NormalTok{, y }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-pandas/skript/plotting_files/figure-pdf/cell-5-output-1.png}}

~

Für DataFrames ist das Streudiagramm als Diagrammtyp verfügbar.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{meerschweinchen.plot(x }\OperatorTok{=} \StringTok{\textquotesingle{}ID\textquotesingle{}}\NormalTok{, y }\OperatorTok{=} \StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{, kind }\OperatorTok{=} \StringTok{\textquotesingle{}scatter\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-pandas/skript/plotting_files/figure-pdf/cell-6-output-1.png}}

\section{subplots}\label{subplots}

Mit dem Argument \texttt{subplots\ =\ True} werden Teilgrafiken
erstellt. Dabei wird automatisch das Argument \texttt{sharex\ =\ True}
gesetzt, sodass beide Teilgrafiken eine gemeinsame x-Achse nutzen
teilen. Dem Parameter \texttt{title} können Überschriften für jede
Teilgrafik als Liste übergeben werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{meerschweinchen.plot(x }\OperatorTok{=} \StringTok{\textquotesingle{}ID\textquotesingle{}}\NormalTok{, y }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{], subplots }\OperatorTok{=} \VariableTok{True}\NormalTok{, title }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Vitamin C Dosis\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Länge zahnbildender Zellen\textquotesingle{}}\NormalTok{])}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-pandas/skript/plotting_files/figure-pdf/cell-7-output-1.png}}

~

Ebenso ist das Argument \texttt{sharey\ =\ True} verfügbar. Das Argument
\texttt{sharex} wird auf False gesetzt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{meerschweinchen.plot(x }\OperatorTok{=} \StringTok{\textquotesingle{}ID\textquotesingle{}}\NormalTok{, y }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{], subplots }\OperatorTok{=} \VariableTok{True}\NormalTok{, sharex }\OperatorTok{=} \VariableTok{False}\NormalTok{, sharey }\OperatorTok{=} \VariableTok{True}\NormalTok{, title }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Vitamin C Dosis\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Länge zahnbildender Zellen\textquotesingle{}}\NormalTok{])}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-pandas/skript/plotting_files/figure-pdf/cell-8-output-1.png}}

~

Um die überdeckte Beschriftung der x-Achse zu beheben, muss auf den
Befehl \texttt{plt.tight\_layout()} aus dem Modul matplotlib.pyplot
zurückgegriffen werden.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{meerschweinchen.plot(x }\OperatorTok{=} \StringTok{\textquotesingle{}ID\textquotesingle{}}\NormalTok{, y }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{], subplots }\OperatorTok{=} \VariableTok{True}\NormalTok{, sharex }\OperatorTok{=} \VariableTok{False}\NormalTok{, sharey }\OperatorTok{=} \VariableTok{True}\NormalTok{, title }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Vitamin C Dosis\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Länge zahnbildender Zellen\textquotesingle{}}\NormalTok{])}\OperatorTok{;}
\NormalTok{plt.tight\_layout()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-pandas/skript/plotting_files/figure-pdf/cell-9-output-1.png}}

~

Auch um für jede Teilgrafik eine y-Achsenbeschriftung zu setzen, muss
auf matplotlib zurückgegriffen werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mein\_plot }\OperatorTok{=}\NormalTok{ meerschweinchen.plot(x }\OperatorTok{=} \StringTok{\textquotesingle{}ID\textquotesingle{}}\NormalTok{, y }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{], subplots }\OperatorTok{=} \VariableTok{True}\NormalTok{, sharex }\OperatorTok{=} \VariableTok{False}\NormalTok{, sharey }\OperatorTok{=} \VariableTok{True}\NormalTok{, title }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Vitamin C Dosis\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Länge zahnbildender Zellen\textquotesingle{}}\NormalTok{])}\OperatorTok{;}

\NormalTok{mein\_plot[}\DecValTok{0}\NormalTok{].set\_ylabel(}\StringTok{\textquotesingle{}Milligramm pro Tag\textquotesingle{}}\NormalTok{)}
\NormalTok{mein\_plot[}\DecValTok{1}\NormalTok{].set\_ylabel(}\StringTok{\textquotesingle{}Micron\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.tight\_layout()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-pandas/skript/plotting_files/figure-pdf/cell-10-output-1.png}}

\chapter{Datentypen}\label{datentypen-1}

Das Modul Pandas ist auf den Umgang mit unterschiedlichen Datentypen
spezialisiert. Ein Dataframe kann unterschiedliche Datentypen enthalten
(bspw. Zahlen und Wahrheitswerte).

NumPy unterstützt folgende Datentypen:

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Datentyp NumPy-Array & Datentyp in Python \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
int\_ & int \\
double & float \\
cdouble & complex \\
bytes\_ & bytes \\
str\_ & str \\
bool\_ & bool \\
datetime64 & datetime.datetime \\
timedelta64 & datetime.timedelta \\
\end{longtable}

~

Die NumPy-Datentypen haben betriebssystemabhängige Synonyme.
Beispielsweise wird für ein Array vom Datentyp \texttt{int\_} der
Datentyp \texttt{int} ausgegeben, für ein Array aus Gleitkommazahlen der
Datentyp \texttt{float64}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{skalar }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{2}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(skalar.dtype, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{skalar }\OperatorTok{=}\NormalTok{ np.array([}\FloatTok{2.1}\NormalTok{])}

\BuiltInTok{print}\NormalTok{(skalar.dtype)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
int64 

float64
\end{verbatim}

Außerdem gibt es für jeden NumPy-Datentyp ein Kürzel, das aus einem
einzigen Buchstaben besteht. Beispielsweise wird für Zeichenfolgen das
Kürzel \texttt{U} für Unicode-Zeichen und die Anzahl der Stellen
ausgegeben (Für alle anderen Datentypen repräsentiert die Zahl die
Anzahl der Bytes, die im Speicher benötigt werden.). Der Ausgabe ist ein
Zeichen zur Kodiererung der
\href{https://de.wikipedia.org/wiki/Byte-Reihenfolge}{Byte-Reihenfolge}
im Speicher vorangestellt `\textgreater{}' (big-endian), `\textless{}'
(little-endian) oder `=' (Systemstandard).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{skalar }\OperatorTok{=}\NormalTok{ np.array([}\StringTok{\textquotesingle{}2\textquotesingle{}}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(skalar.dtype, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{skalar }\OperatorTok{=}\NormalTok{ np.array([}\StringTok{\textquotesingle{}2.1\textquotesingle{}}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(skalar.dtype, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# Ein Datentyp mit mehr Speicherplatzbedarf kann zugewiesen werden}
\NormalTok{skalar }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{2}\NormalTok{], dtype }\OperatorTok{=} \StringTok{\textquotesingle{}U3\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(skalar.dtype)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<U1 

<U3 

<U3
\end{verbatim}

Alle Synonyme und Kürzel können Sie der
\href{https://numpy.org/devdocs/reference/arrays.scalars.html}{NumPy-Dokumentation}
entnehmen.

Häufig verwendet das Modul Pandas die NumPy-Datentypen. Pandas führt
aber auch einige zusätzliche Datentypen ein. Eine vollständige Liste
finden Sie in der
\href{https://pandas.pydata.org/docs/reference/arrays.html}{Pandas
Dokumentation}. Die wichtigsten zusätzlichen Datentypen sind:

\begin{itemize}
\item
  \href{https://pandas.pydata.org/docs/user_guide/categorical.html}{Kategorie}
  \texttt{dtype\ =\ \textquotesingle{}category\textquotesingle{}} für
  kategoriale, also ungeordnete, Daten.
\item
  \href{https://pandas.pydata.org/docs/reference/api/pandas.Timestamp.html\#pandas.Timestamp}{Zeitzonenbewusstes
  Datumsformat}
  \texttt{dtype\ =\ \textquotesingle{}datetime64{[}ns,\ US/Eastern{]}\textquotesingle{}}
\item
  Erweiterungen der NumPy-Datentypen mit Unterstützung fehlender Werte.
  Diese sind an der Großschreibung zu erkennen.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# NumPy{-}Datentyp int}
\NormalTok{series }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], dtype }\OperatorTok{=} \StringTok{\textquotesingle{}int\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(series, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# NumPy{-}Datentyp int unterstützt fehlende Werte nicht}
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  series }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, np.nan], dtype }\OperatorTok{=} \StringTok{\textquotesingle{}int\textquotesingle{}}\NormalTok{)}
\ControlFlowTok{except} \PreprocessorTok{Exception} \ImportTok{as}\NormalTok{ error:}
    \BuiltInTok{print}\NormalTok{(error, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# Pandas{-}Datentyp Int64 unterstützt fehlende Werte}
\NormalTok{series }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, np.nan], dtype }\OperatorTok{=} \StringTok{\textquotesingle{}Int64\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(series)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0    1
1    2
2    3
dtype: int64 

cannot convert float NaN to integer 

0       1
1       2
2       3
3    <NA>
dtype: Int64
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-string} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-string}: Pandas-Datentyp string}\vspace{3mm}

Pandas nutzt wie die Pythonbasis den Datentyp `string', der
unveränderlich (immutable) ist. Das bedeutet, es gibt keine Methode, die
eine angelegte Zeichenkette verändern kann. Operationen mit diesem
Datentyp geben ein neues Objekt mit dem Datentyp `string' zurück.

Die Übergabe des Datentyps `str' führt zur Verwendung des
NumPy-Datentyps string (dtype = `str'), der veränderlich (mutable) ist.

Je nach Situation kann die Verwendung des einen oder des anderen
Datentyps nützlich sein. Beispielsweise kann der NumPy-Datentyp `str'
mit der Methode \texttt{pd.Series.sum()} verkettet werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# mit NumPy{-}Datentyp \textquotesingle{}str\textquotesingle{}}
\NormalTok{string\_series }\OperatorTok{=}\NormalTok{ pd.Series([}\StringTok{\textquotesingle{}H\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}l\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}l\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}o\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}!\textquotesingle{}}\NormalTok{], dtype }\OperatorTok{=} \StringTok{\textquotesingle{}str\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Mit NumPy{-}Datentyp \textquotesingle{}str\textquotesingle{}: }\SpecialCharTok{\{}\NormalTok{string\_series}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# mit Pandas{-}Datentyp \textquotesingle{}string\textquotesingle{}}
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  string\_series.astype(}\StringTok{\textquotesingle{}string\textquotesingle{}}\NormalTok{).}\BuiltInTok{sum}\NormalTok{()}
\ControlFlowTok{except} \PreprocessorTok{Exception} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Mit Pandas{-}Datentyp \textquotesingle{}string\textquotesingle{}:"}\NormalTok{)}
  \BuiltInTok{print}\NormalTok{(error)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Mit NumPy-Datentyp 'str': Hallo!

Mit Pandas-Datentyp 'string':
Cannot perform reduction 'sum' with string dtype
\end{verbatim}

\end{minipage}%
\end{tcolorbox}

\chapter{Zeitreihen}\label{zeitreihen}

Die Verarbeitung von Datums- und Zeitinformationen wird in Python durch
verschiedene Module ermöglicht. Einleitend werden einige dieser Module
kurz vorgestellt, da in der Dokumentation gelegentlich auf diese
verwiesen wird. Pandas bietet einen einheitlichen Zugang zu den meisten
dieser Funktionen und verwendet die NumPy Datentypen \texttt{datetime64}
und \texttt{timedelta64}.

\begin{itemize}
\item
  Der Datentyp \texttt{datetime64} beschreibt einen bestimmten Zeitpunkt
  an einem bestimmten Datum und gehört zu der Klasse \texttt{Timestamp}.
  Der Datentyp hat die Einheit Nanosekunden und kann Informationen über
  die Zeitzone speichern.
\item
  Der Datentyp \texttt{timedelta64} beschreibt eine absolute Zeitdauer
  in der Einheit Nanosekunden und gehört zu der Klasse
  \texttt{Timedelta}.
\end{itemize}

\section{Datums- und Zeitinformationen in
Python}\label{datums--und-zeitinformationen-in-python}

In Python gibt es einige Module zur Verarbeitung von Datums- und
Zeitinformationen.

\begin{itemize}
\item
  Das Modul time stellt Zeit- und Datumsoperationen mit Objekten vom Typ
  \texttt{struct\_time} bereit.
  (\href{https://docs.python.org/3/library/time.html}{Dokumentation des
  Moduls time})
\item
  Das Modul datetime führt die Datentypen \texttt{datetime} und
  \texttt{timedelta}, zusätzliche Methoden für die Bearbeitung und die
  Ausgabe von Datums- und Zeitinformationen ein. Das Modul kann
  Jahreszahlen von 1 bis 9999 nach unserer Zeitrechnung im
  Gregorianischen Kalender verarbeiten.
  (\href{https://docs.python.org/3/library/datetime.html\#}{Dokumentation
  des Moduls datetime})
\item
  Das Modul calendar führt verschiedene Kalenderfunktionen ein und
  erweitert den verarbeitbaren Zeitraum. Basierend auf dem
  Gregorianischen Kalender reicht dieser in beide Richtungen ins
  Unendliche.
  (\href{https://docs.python.org/3/library/calendar.html\#module-calendar}{Dokumentation
  des Moduls calendar})
\item
  Das Modul pytz führt die IANA-Zeitzonendatenbank (Internet Assigned
  Numbers Authority) für Anwendungsprogramme und Betriebssysteme ein
  (auch Olsen-Datenbank genannt). Die IANA-Datenbank beinhaltet die
  Zeitzonen und Änderungen der Zeit seit 1970.
  (\href{https://de.wikipedia.org/wiki/Zeitzonen-Datenbank}{Wikipedia})
  Das Modul pytz sorgt für eine korrekte Berechnung von Zeiten zum Ende
  der Zeitumstellung (Ende Sommerzeit) über Zeitzonen hinweg.
  (\href{https://pythonhosted.org/pytz/}{Dokumentation pytz})
\item
  NumPy führt die Datentypen \texttt{datetime64} und
  \texttt{timedelta64} ein. Diese basieren auf dem Gregorianischen
  Kalender und reichen in beide Richtungen ins Unendliche.
  \url{https://numpy.org/doc/stable/reference/arrays.datetime.html}
\item
  Pandas nutzt die NumPy-Datentypen \texttt{datetime64} und
  \texttt{timedelta64} und ergänzt zahlreiche Funktionen zur
  Verarbeitung von Datums- und Zeitinformationen aus anderen Paketen.
  \url{https://pandas.pydata.org/docs/user_guide/timeseries.html}
\end{itemize}

NumPy und Pandas können Datetime-Objekte anderer Module in den Datentyp
\texttt{datetime64} umwandeln.

\subsection{Naive und bewusste
Datetime-Objekte}\label{naive-und-bewusste-datetime-objekte}

Datetime-Objekte werden abhängig davon, ob sie Informationen über
Zeitzonen enthalten, als naiv (naive) oder als bewusst (aware)
bezeichnet. Naiven Datetime-Objekten fehlt diese Information, bewusste
Datetime-Objekte enthalten diese. Objekte der Module time, datetime und
Pandas verfügen über ein Zeitzonenattribut, sind also bewusst.
\texttt{np.datetime64} ist seit NumPy-Version 1.11.0 ein naiver
Datentyp, unterstützt aber Zeitzonen aus Gründen der
Rückwärtskompatibilität.

\begin{figure}

\begin{minipage}{0.05\linewidth}
~\end{minipage}%
%
\begin{minipage}{0.90\linewidth}
``Deprecated since version 1.11.0: NumPy does not store timezone
information. For backwards compatibility, datetime64 still parses
timezone offsets, which it handles by converting to UTC±00:00 (Zulu
time). This behaviour is deprecated and will raise an error in the
future.''
\href{https://numpy.org/doc/stable/reference/arrays.datetime.html}{NumPy
Dokumentation}\end{minipage}%
%
\begin{minipage}{0.05\linewidth}
~\end{minipage}%

\end{figure}%

\subsubsection{Zeitzonen}\label{zeitzonen}

Pandas kann mit Zeitzonen umgehen und datetime-Objekte von einer in eine
andere Zeitzone umwandeln. Über das Argument \texttt{tz} kann in
verschiedenen Funktionen die Zeitzone angegeben werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zeitreihe }\OperatorTok{=}\NormalTok{ pd.Series(pd.date\_range(start }\OperatorTok{=} \StringTok{"2023{-}03{-}26T00:00"}\NormalTok{, end }\OperatorTok{=} \StringTok{"2023{-}03{-}27T00:00"}\NormalTok{, freq }\OperatorTok{=} \StringTok{"3h"}\NormalTok{, tz }\OperatorTok{=} \StringTok{"turkey"}\NormalTok{))}
\NormalTok{zeitreihe}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0   2023-03-26 00:00:00+03:00
1   2023-03-26 03:00:00+03:00
2   2023-03-26 06:00:00+03:00
3   2023-03-26 09:00:00+03:00
4   2023-03-26 12:00:00+03:00
5   2023-03-26 15:00:00+03:00
6   2023-03-26 18:00:00+03:00
7   2023-03-26 21:00:00+03:00
8   2023-03-27 00:00:00+03:00
dtype: datetime64[ns, Turkey]
\end{verbatim}

Mit der Funktion \texttt{pd.to\_datetime(arg,\ utc\ =\ True)} kann die
Zeitzone in die koordinierte Universalzeit UTC umgewandelt werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pd.to\_datetime(zeitreihe, utc }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0   2023-03-25 21:00:00+00:00
1   2023-03-26 00:00:00+00:00
2   2023-03-26 03:00:00+00:00
3   2023-03-26 06:00:00+00:00
4   2023-03-26 09:00:00+00:00
5   2023-03-26 12:00:00+00:00
6   2023-03-26 15:00:00+00:00
7   2023-03-26 18:00:00+00:00
8   2023-03-26 21:00:00+00:00
dtype: datetime64[ns, UTC]
\end{verbatim}

Eine Umwandlung in beliebige Zeitzonen ist mit der Methode
\texttt{pd.Series.dt.tz\_convert(tz\ =\ \textquotesingle{}utc\textquotesingle{})}
möglich.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zeitreihe.dt.tz\_convert(tz }\OperatorTok{=} \StringTok{\textquotesingle{}portugal\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0   2023-03-25 21:00:00+00:00
1   2023-03-26 00:00:00+00:00
2   2023-03-26 04:00:00+01:00
3   2023-03-26 07:00:00+01:00
4   2023-03-26 10:00:00+01:00
5   2023-03-26 13:00:00+01:00
6   2023-03-26 16:00:00+01:00
7   2023-03-26 19:00:00+01:00
8   2023-03-26 22:00:00+01:00
dtype: datetime64[ns, Portugal]
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-zeitzonen}: verfügbare Zeitzonen ermitteln}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-zeitzonen} 

Der folgende Code gibt die in Python verfügbaren Zeitzonen aus.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ zoneinfo }\ImportTok{import}\NormalTok{ available\_timezones}

\ControlFlowTok{for}\NormalTok{ timezone }\KeywordTok{in} \BuiltInTok{sorted}\NormalTok{(available\_timezones()):}
  \BuiltInTok{print}\NormalTok{(timezone)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Africa/Abidjan
Africa/Accra
Africa/Addis_Ababa
Africa/Algiers
Africa/Asmara
Africa/Asmera
Africa/Bamako
Africa/Bangui
Africa/Banjul
Africa/Bissau
Africa/Blantyre
Africa/Brazzaville
Africa/Bujumbura
Africa/Cairo
Africa/Casablanca
Africa/Ceuta
Africa/Conakry
Africa/Dakar
Africa/Dar_es_Salaam
Africa/Djibouti
Africa/Douala
Africa/El_Aaiun
Africa/Freetown
Africa/Gaborone
Africa/Harare
Africa/Johannesburg
Africa/Juba
Africa/Kampala
Africa/Khartoum
Africa/Kigali
Africa/Kinshasa
Africa/Lagos
Africa/Libreville
Africa/Lome
Africa/Luanda
Africa/Lubumbashi
Africa/Lusaka
Africa/Malabo
Africa/Maputo
Africa/Maseru
Africa/Mbabane
Africa/Mogadishu
Africa/Monrovia
Africa/Nairobi
Africa/Ndjamena
Africa/Niamey
Africa/Nouakchott
Africa/Ouagadougou
Africa/Porto-Novo
Africa/Sao_Tome
Africa/Timbuktu
Africa/Tripoli
Africa/Tunis
Africa/Windhoek
America/Adak
America/Anchorage
America/Anguilla
America/Antigua
America/Araguaina
America/Argentina/Buenos_Aires
America/Argentina/Catamarca
America/Argentina/ComodRivadavia
America/Argentina/Cordoba
America/Argentina/Jujuy
America/Argentina/La_Rioja
America/Argentina/Mendoza
America/Argentina/Rio_Gallegos
America/Argentina/Salta
America/Argentina/San_Juan
America/Argentina/San_Luis
America/Argentina/Tucuman
America/Argentina/Ushuaia
America/Aruba
America/Asuncion
America/Atikokan
America/Atka
America/Bahia
America/Bahia_Banderas
America/Barbados
America/Belem
America/Belize
America/Blanc-Sablon
America/Boa_Vista
America/Bogota
America/Boise
America/Buenos_Aires
America/Cambridge_Bay
America/Campo_Grande
America/Cancun
America/Caracas
America/Catamarca
America/Cayenne
America/Cayman
America/Chicago
America/Chihuahua
America/Ciudad_Juarez
America/Coral_Harbour
America/Cordoba
America/Costa_Rica
America/Coyhaique
America/Creston
America/Cuiaba
America/Curacao
America/Danmarkshavn
America/Dawson
America/Dawson_Creek
America/Denver
America/Detroit
America/Dominica
America/Edmonton
America/Eirunepe
America/El_Salvador
America/Ensenada
America/Fort_Nelson
America/Fort_Wayne
America/Fortaleza
America/Glace_Bay
America/Godthab
America/Goose_Bay
America/Grand_Turk
America/Grenada
America/Guadeloupe
America/Guatemala
America/Guayaquil
America/Guyana
America/Halifax
America/Havana
America/Hermosillo
America/Indiana/Indianapolis
America/Indiana/Knox
America/Indiana/Marengo
America/Indiana/Petersburg
America/Indiana/Tell_City
America/Indiana/Vevay
America/Indiana/Vincennes
America/Indiana/Winamac
America/Indianapolis
America/Inuvik
America/Iqaluit
America/Jamaica
America/Jujuy
America/Juneau
America/Kentucky/Louisville
America/Kentucky/Monticello
America/Knox_IN
America/Kralendijk
America/La_Paz
America/Lima
America/Los_Angeles
America/Louisville
America/Lower_Princes
America/Maceio
America/Managua
America/Manaus
America/Marigot
America/Martinique
America/Matamoros
America/Mazatlan
America/Mendoza
America/Menominee
America/Merida
America/Metlakatla
America/Mexico_City
America/Miquelon
America/Moncton
America/Monterrey
America/Montevideo
America/Montreal
America/Montserrat
America/Nassau
America/New_York
America/Nipigon
America/Nome
America/Noronha
America/North_Dakota/Beulah
America/North_Dakota/Center
America/North_Dakota/New_Salem
America/Nuuk
America/Ojinaga
America/Panama
America/Pangnirtung
America/Paramaribo
America/Phoenix
America/Port-au-Prince
America/Port_of_Spain
America/Porto_Acre
America/Porto_Velho
America/Puerto_Rico
America/Punta_Arenas
America/Rainy_River
America/Rankin_Inlet
America/Recife
America/Regina
America/Resolute
America/Rio_Branco
America/Rosario
America/Santa_Isabel
America/Santarem
America/Santiago
America/Santo_Domingo
America/Sao_Paulo
America/Scoresbysund
America/Shiprock
America/Sitka
America/St_Barthelemy
America/St_Johns
America/St_Kitts
America/St_Lucia
America/St_Thomas
America/St_Vincent
America/Swift_Current
America/Tegucigalpa
America/Thule
America/Thunder_Bay
America/Tijuana
America/Toronto
America/Tortola
America/Vancouver
America/Virgin
America/Whitehorse
America/Winnipeg
America/Yakutat
America/Yellowknife
Antarctica/Casey
Antarctica/Davis
Antarctica/DumontDUrville
Antarctica/Macquarie
Antarctica/Mawson
Antarctica/McMurdo
Antarctica/Palmer
Antarctica/Rothera
Antarctica/South_Pole
Antarctica/Syowa
Antarctica/Troll
Antarctica/Vostok
Arctic/Longyearbyen
Asia/Aden
Asia/Almaty
Asia/Amman
Asia/Anadyr
Asia/Aqtau
Asia/Aqtobe
Asia/Ashgabat
Asia/Ashkhabad
Asia/Atyrau
Asia/Baghdad
Asia/Bahrain
Asia/Baku
Asia/Bangkok
Asia/Barnaul
Asia/Beirut
Asia/Bishkek
Asia/Brunei
Asia/Calcutta
Asia/Chita
Asia/Choibalsan
Asia/Chongqing
Asia/Chungking
Asia/Colombo
Asia/Dacca
Asia/Damascus
Asia/Dhaka
Asia/Dili
Asia/Dubai
Asia/Dushanbe
Asia/Famagusta
Asia/Gaza
Asia/Harbin
Asia/Hebron
Asia/Ho_Chi_Minh
Asia/Hong_Kong
Asia/Hovd
Asia/Irkutsk
Asia/Istanbul
Asia/Jakarta
Asia/Jayapura
Asia/Jerusalem
Asia/Kabul
Asia/Kamchatka
Asia/Karachi
Asia/Kashgar
Asia/Kathmandu
Asia/Katmandu
Asia/Khandyga
Asia/Kolkata
Asia/Krasnoyarsk
Asia/Kuala_Lumpur
Asia/Kuching
Asia/Kuwait
Asia/Macao
Asia/Macau
Asia/Magadan
Asia/Makassar
Asia/Manila
Asia/Muscat
Asia/Nicosia
Asia/Novokuznetsk
Asia/Novosibirsk
Asia/Omsk
Asia/Oral
Asia/Phnom_Penh
Asia/Pontianak
Asia/Pyongyang
Asia/Qatar
Asia/Qostanay
Asia/Qyzylorda
Asia/Rangoon
Asia/Riyadh
Asia/Saigon
Asia/Sakhalin
Asia/Samarkand
Asia/Seoul
Asia/Shanghai
Asia/Singapore
Asia/Srednekolymsk
Asia/Taipei
Asia/Tashkent
Asia/Tbilisi
Asia/Tehran
Asia/Tel_Aviv
Asia/Thimbu
Asia/Thimphu
Asia/Tokyo
Asia/Tomsk
Asia/Ujung_Pandang
Asia/Ulaanbaatar
Asia/Ulan_Bator
Asia/Urumqi
Asia/Ust-Nera
Asia/Vientiane
Asia/Vladivostok
Asia/Yakutsk
Asia/Yangon
Asia/Yekaterinburg
Asia/Yerevan
Atlantic/Azores
Atlantic/Bermuda
Atlantic/Canary
Atlantic/Cape_Verde
Atlantic/Faeroe
Atlantic/Faroe
Atlantic/Jan_Mayen
Atlantic/Madeira
Atlantic/Reykjavik
Atlantic/South_Georgia
Atlantic/St_Helena
Atlantic/Stanley
Australia/ACT
Australia/Adelaide
Australia/Brisbane
Australia/Broken_Hill
Australia/Canberra
Australia/Currie
Australia/Darwin
Australia/Eucla
Australia/Hobart
Australia/LHI
Australia/Lindeman
Australia/Lord_Howe
Australia/Melbourne
Australia/NSW
Australia/North
Australia/Perth
Australia/Queensland
Australia/South
Australia/Sydney
Australia/Tasmania
Australia/Victoria
Australia/West
Australia/Yancowinna
Brazil/Acre
Brazil/DeNoronha
Brazil/East
Brazil/West
CET
CST6CDT
Canada/Atlantic
Canada/Central
Canada/Eastern
Canada/Mountain
Canada/Newfoundland
Canada/Pacific
Canada/Saskatchewan
Canada/Yukon
Chile/Continental
Chile/EasterIsland
Cuba
EET
EST
EST5EDT
Egypt
Eire
Etc/GMT
Etc/GMT+0
Etc/GMT+1
Etc/GMT+10
Etc/GMT+11
Etc/GMT+12
Etc/GMT+2
Etc/GMT+3
Etc/GMT+4
Etc/GMT+5
Etc/GMT+6
Etc/GMT+7
Etc/GMT+8
Etc/GMT+9
Etc/GMT-0
Etc/GMT-1
Etc/GMT-10
Etc/GMT-11
Etc/GMT-12
Etc/GMT-13
Etc/GMT-14
Etc/GMT-2
Etc/GMT-3
Etc/GMT-4
Etc/GMT-5
Etc/GMT-6
Etc/GMT-7
Etc/GMT-8
Etc/GMT-9
Etc/GMT0
Etc/Greenwich
Etc/UCT
Etc/UTC
Etc/Universal
Etc/Zulu
Europe/Amsterdam
Europe/Andorra
Europe/Astrakhan
Europe/Athens
Europe/Belfast
Europe/Belgrade
Europe/Berlin
Europe/Bratislava
Europe/Brussels
Europe/Bucharest
Europe/Budapest
Europe/Busingen
Europe/Chisinau
Europe/Copenhagen
Europe/Dublin
Europe/Gibraltar
Europe/Guernsey
Europe/Helsinki
Europe/Isle_of_Man
Europe/Istanbul
Europe/Jersey
Europe/Kaliningrad
Europe/Kiev
Europe/Kirov
Europe/Kyiv
Europe/Lisbon
Europe/Ljubljana
Europe/London
Europe/Luxembourg
Europe/Madrid
Europe/Malta
Europe/Mariehamn
Europe/Minsk
Europe/Monaco
Europe/Moscow
Europe/Nicosia
Europe/Oslo
Europe/Paris
Europe/Podgorica
Europe/Prague
Europe/Riga
Europe/Rome
Europe/Samara
Europe/San_Marino
Europe/Sarajevo
Europe/Saratov
Europe/Simferopol
Europe/Skopje
Europe/Sofia
Europe/Stockholm
Europe/Tallinn
Europe/Tirane
Europe/Tiraspol
Europe/Ulyanovsk
Europe/Uzhgorod
Europe/Vaduz
Europe/Vatican
Europe/Vienna
Europe/Vilnius
Europe/Volgograd
Europe/Warsaw
Europe/Zagreb
Europe/Zaporozhye
Europe/Zurich
Factory
GB
GB-Eire
GMT
GMT+0
GMT-0
GMT0
Greenwich
HST
Hongkong
Iceland
Indian/Antananarivo
Indian/Chagos
Indian/Christmas
Indian/Cocos
Indian/Comoro
Indian/Kerguelen
Indian/Mahe
Indian/Maldives
Indian/Mauritius
Indian/Mayotte
Indian/Reunion
Iran
Israel
Jamaica
Japan
Kwajalein
Libya
MET
MST
MST7MDT
Mexico/BajaNorte
Mexico/BajaSur
Mexico/General
NZ
NZ-CHAT
Navajo
PRC
PST8PDT
Pacific/Apia
Pacific/Auckland
Pacific/Bougainville
Pacific/Chatham
Pacific/Chuuk
Pacific/Easter
Pacific/Efate
Pacific/Enderbury
Pacific/Fakaofo
Pacific/Fiji
Pacific/Funafuti
Pacific/Galapagos
Pacific/Gambier
Pacific/Guadalcanal
Pacific/Guam
Pacific/Honolulu
Pacific/Johnston
Pacific/Kanton
Pacific/Kiritimati
Pacific/Kosrae
Pacific/Kwajalein
Pacific/Majuro
Pacific/Marquesas
Pacific/Midway
Pacific/Nauru
Pacific/Niue
Pacific/Norfolk
Pacific/Noumea
Pacific/Pago_Pago
Pacific/Palau
Pacific/Pitcairn
Pacific/Pohnpei
Pacific/Ponape
Pacific/Port_Moresby
Pacific/Rarotonga
Pacific/Saipan
Pacific/Samoa
Pacific/Tahiti
Pacific/Tarawa
Pacific/Tongatapu
Pacific/Truk
Pacific/Wake
Pacific/Wallis
Pacific/Yap
Poland
Portugal
ROC
ROK
Singapore
Turkey
UCT
US/Alaska
US/Aleutian
US/Arizona
US/Central
US/East-Indiana
US/Eastern
US/Hawaii
US/Indiana-Starke
US/Michigan
US/Mountain
US/Pacific
US/Samoa
UTC
Universal
W-SU
WET
Zulu
\end{verbatim}

\end{tcolorbox}

\subsection{Alles ist relativ: die
Epoche}\label{alles-ist-relativ-die-epoche}

Python speichert Zeit relativ zu einem zeitlichen Bezugspunkt, der
Unix-Zeit, der sogenannten Epoche. Die Epoche kann mit der Funktion
\texttt{pd.to\_datetime(0)} ausgegeben werden. Die Funktion konvertiert
Argumente in Zeitpunkte (Timestamp). Ganzzahlen werden dabei als
Nanosekunden seit der Epoche interpretiert. Die Funktion werden wir
später noch ausführlicher behandeln.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(}\DecValTok{0}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1970-01-01 00:00:00
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-datetimetimezones} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-datetimetimezones}: Zeit - atomar, koordiniert oder universal?}\vspace{3mm}

NumPy nutzt die Internationale Atomzeit (abgekürzt TAI für französisch
Temps Atomique International). Diese nimmt für jeden Kalendertag eine
Länge von 86.400 Sekunden an, kennt also keine Schaltsekunde. Die
Atomzeit bildet die Grundlage für die koordinierte Weltzeit UTC.

UTC steht für Coordinated Universal Time (auch bekannt als Greenwich
Mean Time). Das Kürzel UTC ist ein Kompromiss für die englische und die
französische Sprache. Die koordinierte Weltzeit gleicht die
Verlangsamung der Erdrotation (astronomisch gemessen als Universalzeit,
Universal Time UT) durch Schaltsekunden aus, um die geringfügige
Verlängerung eines Tages auszugleichen. Die TAI geht deshalb gegenüber
der UTC vor. Seit 1972 unterscheiden sich beide Zeiten um eine
ganzzahlige Anzahl von Sekunden. Aktuell (2024) geht die TAI 37 Sekunden
gegenüber UTC vor.

Eine Umwandlung in die koordinierte Weltzeit ist in NumPy bislang noch
nicht umgesetzt.
(\href{https://numpy.org/doc/stable/reference/arrays.datetime.html}{Dokumentation
NumPy},
\href{https://de.wikipedia.org/wiki/Internationale_Atomzeit}{Wikipedia}).

\end{minipage}%
\end{tcolorbox}

\subsection{Zeitumstellung - Daylight Saving
Time}\label{zeitumstellung---daylight-saving-time}

\begin{figure}

\begin{minipage}{0.05\linewidth}
~\end{minipage}%
%
\begin{minipage}{0.90\linewidth}
``DST is Daylight Saving Time, an adjustment of the timezone by
(usually) one hour during part of the year. DST rules are magic
(determined by local law) and can change from year to year. The C
library has a table containing the local rules (often it is read from a
system file for flexibility) and is the only source of True Wisdom in
this respect.''
(\href{https://docs.python.org/3/library/time.html}{Dokumentation
time})\end{minipage}%
%
\begin{minipage}{0.05\linewidth}
~\end{minipage}%

\end{figure}%

~

Pandas arbeitet standardmäßig mit der koordinierten Weltzeit UTC. Die
UTC selbst ist keine Zeitzone und kennt deshalb keine Zeitumstellung.
Die Zeitumstellung wird abhängig von der Zeitzone berücksichtigt.
Beispielsweise wurde die Zeitumstellung in der Türkei 2016 abgeschafft
(und die Sommerzeit dauerhaft eingeführt).

In den folgenden Beispielen wird am Tag vor der Zeitumstellung um 9 Uhr
eine Zeitdifferenz von 24 Stunden addiert. Da über die Nacht (der Morgen
des Folgetages) die Uhr um eine Stunde vorgestellt wird, zeigt der
resultierende Zeitstempel die Uhrzeit 10 Uhr an, sofern die
Zeitumstellung gilt.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Keine Zeitumstellung in UTC:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(pd.Timestamp(}\StringTok{"2025{-}03{-}29T09:00"}\NormalTok{) }\OperatorTok{+}\NormalTok{ pd.Timedelta(}\DecValTok{24}\NormalTok{, }\StringTok{"h"}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Zeitzone mit Zeitumstellung:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(pd.Timestamp(}\StringTok{"2025{-}03{-}29T09:00"}\NormalTok{, tz}\OperatorTok{=}\StringTok{"Europe/Berlin"}\NormalTok{) }\OperatorTok{+}\NormalTok{ pd.Timedelta(}\DecValTok{24}\NormalTok{, }\StringTok{"h"}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Heute keine Zeitumstellung in Türkei:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(pd.Timestamp(}\StringTok{"2025{-}03{-}29T09:00"}\NormalTok{, tz}\OperatorTok{=}\StringTok{"Turkey"}\NormalTok{) }\OperatorTok{+}\NormalTok{ pd.Timedelta(}\DecValTok{24}\NormalTok{, }\StringTok{"h"}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Türkei vor der Abschaffung der Zeitumstellung:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(pd.Timestamp(}\StringTok{"2014{-}03{-}30T09:00"}\NormalTok{, tz}\OperatorTok{=}\StringTok{"Turkey"}\NormalTok{)  }\OperatorTok{+}\NormalTok{ pd.Timedelta(}\DecValTok{24}\NormalTok{, }\StringTok{"h"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Keine Zeitumstellung in UTC:
2025-03-30 09:00:00 

Zeitzone mit Zeitumstellung:
2025-03-30 10:00:00+02:00 

Heute keine Zeitumstellung in Türkei:
2025-03-30 09:00:00+03:00 

Türkei vor der Abschaffung der Zeitumstellung:
2014-03-31 10:00:00+03:00
\end{verbatim}

Eine Liste der Zeitzonen finden Sie auf Wikipedia:
\url{https://en.wikipedia.org/wiki/List_of_tz_database_time_zones}

\subsection{Kalender}\label{kalender}

Die Module calendar, NumPy und Pandas verwenden den um die Zeit vor
seiner Einführung 1582 erweiterten Gregorianische Kalender, den
\href{https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar}{proleptischen
Gregorianischen Kalender}. Während das Modul date nur die Jahre 1-9999
nach unserer Zeit unterstützt, erlaubt der Datentyp \texttt{datetime64}
auch Jahre vor unserer Zeit in
\href{https://en.wikipedia.org/wiki/Astronomical_year_numbering}{astronomischer
Jahresnumerierung}. Das bedeutet, es gibt ein Jahr 0 (das erste Jahr vor
unserer Zeit) und vorausgehende Jahre werden mit negativen Zahlen
dargestellt (-1 ist das zweite Jahr vor unserer Zeit).
\href{https://numpy.org/doc/stable/reference/arrays.datetime.html\#datetime64-conventions-and-assumptions}{NumPy
Dokumentation}

\section{datetime in Pandas}\label{datetime-in-pandas}

Pandas nutzt den NumPy-Datentyp \texttt{datetime64}, um Datums- und
Zeitinformationen zu verarbeiten. In Pandas werden
\texttt{datetime64}-Objekte mit den Funktionen
\texttt{pd.to\_datetime()} oder \texttt{pd.date\_range()} angelegt.\\
\emph{Hinweis: Eine weitere Möglichkeit ist die Funktion
\texttt{pd.Timestamp()}, die umfangreichere Möglichkeiten zur Erzeugung
eines Zeitpunkts bietet, aber kein string-parsing unterstützt.}

\texttt{pd.to\_datetime()} erzeugt Werte des Datentyps
\texttt{datetime64{[}ns{]}} (mit \texttt{pd.to\_datetime()} erzeugte
Skalare (Einzelwerte) werden als Timestamp (Zeitpunkt) ausgegeben, die
kein Attribut \texttt{dtype} haben). Die Funktion
\texttt{pd.to\_datetime()} akzeptiert als Eingabewerte:

\begin{itemize}
\item
  datetime-Objekte anderer Module.
\item
  Zahlen und eine Zeiteinheit
  \texttt{pd.to\_datetime(1,\ unit\ =\ None)} (Standard sind
  Nanosekunden). Das Argument \texttt{unit} nimmt die Werte `ns', `ms',
  `s', `m', `h', `D', `W', `M', `Y' für Nanosekunde, Millisekunde,
  Sekunde, Minute, Stunde, Tag, Woche, Monat bzw. Jahr entgegen. Erzeugt
  wird ein Zeitpunkt relativ zur Epoche.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(}\DecValTok{1000}\NormalTok{, unit }\OperatorTok{=} \StringTok{\textquotesingle{}D\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(}\DecValTok{1000} \OperatorTok{*} \DecValTok{1000}\NormalTok{, unit }\OperatorTok{=} \StringTok{\textquotesingle{}h\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(}\DecValTok{1000} \OperatorTok{*} \DecValTok{1000} \OperatorTok{*} \DecValTok{1000}\NormalTok{, unit }\OperatorTok{=} \StringTok{\textquotesingle{}s\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1972-09-27 00:00:00
2084-01-29 16:00:00
2001-09-09 01:46:40
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Zeichenketten, die ein Datum oder ein Datum mit Uhrzeit ausdrücken,
  formatiert nach
  \href{https://www.iso.org/iso-8601-date-and-time-format.html}{ISO
  8601}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(}\StringTok{\textquotesingle{}2017\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(}\StringTok{\textquotesingle{}2017{-}01{-}01T00\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(}\StringTok{\textquotesingle{}2017{-}01{-}01 00:00:00\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2017-01-01 00:00:00
2017-01-01 00:00:00
2017-01-01 00:00:00
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Anders formatierte Zeichenketten mit dem Argument
  \texttt{format\ =\ "\%d/\%m/\%Y"} (siehe
  \href{https://docs.python.org/3/library/datetime.html\#strftime-and-strptime-behavior}{Dokumentation
  strftime zur string-Formatierung}).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(}\StringTok{\textquotesingle{}Monday, 12. August \textasciigrave{}24\textquotesingle{}}\NormalTok{, }\BuiltInTok{format} \OperatorTok{=} \StringTok{"\%A, }\SpecialCharTok{\%d}\StringTok{. \%B \textasciigrave{}\%y"}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(}\StringTok{\textquotesingle{}Monday, 12. August 2024, 12:15 Uhr CET\textquotesingle{}}\NormalTok{, }\BuiltInTok{format} \OperatorTok{=} \StringTok{"\%A, }\SpecialCharTok{\%d}\StringTok{. \%B \%Y, \%H:\%M Uhr \%Z"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2024-08-12 00:00:00
2024-08-12 12:15:00+02:00
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Dictionary oder DataFrame.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(\{}\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{:[}\DecValTok{2020}\NormalTok{, }\DecValTok{2024}\NormalTok{], }\StringTok{\textquotesingle{}month\textquotesingle{}}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{], }\StringTok{\textquotesingle{}day\textquotesingle{}}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{21}\NormalTok{]\}), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(pd.DataFrame(\{}\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{:[}\DecValTok{2020}\NormalTok{, }\DecValTok{2024}\NormalTok{], }\StringTok{\textquotesingle{}month\textquotesingle{}}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{], }\StringTok{\textquotesingle{}day\textquotesingle{}}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{21}\NormalTok{]\})))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0   2020-01-01
1   2024-11-21
dtype: datetime64[ns] 

0   2020-01-01
1   2024-11-21
dtype: datetime64[ns]
\end{verbatim}

Die Funktion \texttt{pd.date\_range()} erzeugt ein Array vom Typ
\texttt{DatetimeIndex} mit dtype \texttt{datetime64}. Genau drei der
folgenden vier Argumente sind für die Erzeugung erforderlich:

\begin{itemize}
\item
  \texttt{start}: Beginn der Reihe.
\item
  \texttt{end}: Ende der Reihe (inklusiv)
\item
  \texttt{freq}: Schrittweite (bspw. Jahr, Tag, Geschäftstag, Stunde
  oder Vielfache wie `6h' - siehe
  \href{https://pandas.pydata.org/docs/user_guide/timeseries.html\#timeseries-offset-aliases}{Liste
  verfügbarer strings})
\item
  \texttt{periods}: Anzahl der zu erzeugenden Werte.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.date\_range(start }\OperatorTok{=} \StringTok{\textquotesingle{}2017\textquotesingle{}}\NormalTok{, end }\OperatorTok{=} \StringTok{\textquotesingle{}2024\textquotesingle{}}\NormalTok{, periods }\OperatorTok{=} \DecValTok{3}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(pd.date\_range(start }\OperatorTok{=} \StringTok{\textquotesingle{}2017\textquotesingle{}}\NormalTok{, end }\OperatorTok{=} \StringTok{\textquotesingle{}2024\textquotesingle{}}\NormalTok{, freq }\OperatorTok{=} \StringTok{\textquotesingle{}Y\textquotesingle{}}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(pd.date\_range(end }\OperatorTok{=} \StringTok{\textquotesingle{}2024\textquotesingle{}}\NormalTok{, freq }\OperatorTok{=} \StringTok{\textquotesingle{}h\textquotesingle{}}\NormalTok{, periods }\OperatorTok{=} \DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
DatetimeIndex(['2017-01-01', '2020-07-02', '2024-01-01'], dtype='datetime64[ns]', freq=None) 

DatetimeIndex(['2017-12-31', '2018-12-31', '2019-12-31', '2020-12-31',
               '2021-12-31', '2022-12-31', '2023-12-31'],
              dtype='datetime64[ns]', freq='YE-DEC') 

DatetimeIndex(['2023-12-31 22:00:00', '2023-12-31 23:00:00',
               '2024-01-01 00:00:00'],
              dtype='datetime64[ns]', freq='h')
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-daterange} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-daterange}: pd.date\_range()}\vspace{3mm}

Die Funktion \texttt{pd.date\_range()} wird künftig das Kürzel `Y' nicht
mehr unterstützen. Stattdessen können die Kürzel `YS' (Jahresbeginn)
oder `YE' (Jahresende) verwendet werden. Ebenso wird das Kürzel `M'
künftig durch `MS' (Monatsstart), `ME' (Monatsende) ersetzt.

\end{minipage}%
\end{tcolorbox}

\section{timedelta in Pandas}\label{timedelta-in-pandas}

Zeitdifferenzen werden mit der Funktion \texttt{pd.Timedelta()} erzeugt.
Zeitdifferenzen können zum einen durch Angabe einer Ganzzahl und einer
Zeiteinheit angelegt werden. Außerdem ist die Übergabe mit Argumenten
möglich (zulässige Argumente sind: weeks, days, hours, minutes, seconds,
milliseconds, microseconds, nanoseconds).

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.Timedelta(}\DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}D\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(pd.Timedelta(days }\OperatorTok{=} \DecValTok{1}\NormalTok{, hours }\OperatorTok{=} \DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1 days 00:00:00
1 days 01:00:00
\end{verbatim}

\textbf{Wichtig:} Anders als in NumPy werden Zeitdifferenzen in Monaten
und Jahren nicht mehr von Pandas unterstützt.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(pd.Timedelta(}\DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}Y\textquotesingle{}}\NormalTok{))}
\ControlFlowTok{except} \PreprocessorTok{ValueError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(error)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(pd.Timedelta(}\DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}Y\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Units 'M', 'Y', and 'y' are no longer supported, as they do not represent unambiguous timedelta values durations.
\end{verbatim}

Zum anderen können Zeitdifferenzen mit einer Zeichenkette erzeugt
werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.Timedelta(}\StringTok{\textquotesingle{}10sec\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(pd.Timedelta(}\StringTok{\textquotesingle{}10min\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(pd.Timedelta(}\StringTok{\textquotesingle{}10hours\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(pd.Timedelta(}\StringTok{\textquotesingle{}10days\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(pd.Timedelta(}\StringTok{\textquotesingle{}10w\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0 days 00:00:10
0 days 00:10:00
0 days 10:00:00
10 days 00:00:00
70 days 00:00:00
\end{verbatim}

Mit Hilfe einer Zeitdifferenz können Zeitreihen leicht verschoben
werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pd.date\_range(start }\OperatorTok{=} \StringTok{\textquotesingle{}2024{-}01{-}01T00:00\textquotesingle{}}\NormalTok{, end }\OperatorTok{=} \StringTok{\textquotesingle{}2024{-}01{-}01T02:00\textquotesingle{}}\NormalTok{, freq }\OperatorTok{=} \StringTok{\textquotesingle{}15min\textquotesingle{}}\NormalTok{) }\OperatorTok{+}\NormalTok{ pd.Timedelta(}\StringTok{\textquotesingle{}30min\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
DatetimeIndex(['2024-01-01 00:30:00', '2024-01-01 00:45:00',
               '2024-01-01 01:00:00', '2024-01-01 01:15:00',
               '2024-01-01 01:30:00', '2024-01-01 01:45:00',
               '2024-01-01 02:00:00', '2024-01-01 02:15:00',
               '2024-01-01 02:30:00'],
              dtype='datetime64[ns]', freq='15min')
\end{verbatim}

\section{Zugriff auf Zeitreihen}\label{zugriff-auf-zeitreihen}

Pandas bietet zahlreiche Attribute und Methoden, um Informationen aus
\texttt{datetime64}-Objekten auszulesen. Eine Übersicht aller
verfügbaren Attribute und Methoden liefert
\texttt{dir(pd.to\_datetime(0))} bzw. der im folgenden Beispiel gezeigte
Code.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Attribute}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Jahr:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).year)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Monat:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).month)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Tag:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).day)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Stunde:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).hour)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Minute:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).minute)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Sekunde:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).second)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Tag des Jahres:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).dayofyear)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Wochentag:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).dayofweek)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Tage im Monat:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).days\_in\_month)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Schaltjahr:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).is\_leap\_year)}

\CommentTok{\# Methoden}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Datum:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).date())}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Zeit:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).time())}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Wochentag (0{-}6):"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).weekday())}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Monatsname:"}\NormalTok{,  pd.to\_datetime(}\DecValTok{0}\NormalTok{).month\_name())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Jahr: 1970
Monat: 1
Tag: 1
Stunde: 0
Minute: 0
Sekunde: 0
Tag des Jahres: 1
Wochentag: 3
Tage im Monat: 31
Schaltjahr: False

Datum: 1970-01-01
Zeit: 00:00:00
Wochentag (0-6): 3
Monatsname: January
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-attributeundmethoden}: Attribute und Methoden eines datetime-Objekts}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-attributeundmethoden} 

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{objekt }\OperatorTok{=}\NormalTok{ pd.to\_datetime(}\DecValTok{0}\NormalTok{)}

\NormalTok{attribute }\OperatorTok{=}\NormalTok{ [attr }\ControlFlowTok{for}\NormalTok{ attr }\KeywordTok{in} \BuiltInTok{dir}\NormalTok{(objekt) }\ControlFlowTok{if} \KeywordTok{not}\NormalTok{ (}\BuiltInTok{callable}\NormalTok{(}\BuiltInTok{getattr}\NormalTok{(objekt, attr)) }\KeywordTok{or}\NormalTok{ attr.startswith(}\StringTok{\textquotesingle{}\_\textquotesingle{}}\NormalTok{))]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Attribute:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\DecValTok{30} \OperatorTok{*} \StringTok{"="}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(attribute)}

\NormalTok{methoden }\OperatorTok{=}\NormalTok{ [attr }\ControlFlowTok{for}\NormalTok{ attr }\KeywordTok{in} \BuiltInTok{dir}\NormalTok{(objekt) }\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{callable}\NormalTok{(}\BuiltInTok{getattr}\NormalTok{(objekt, attr)) }\KeywordTok{and} \KeywordTok{not}\NormalTok{ attr.startswith(}\StringTok{\textquotesingle{}\_\_\textquotesingle{}}\NormalTok{))]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Methoden:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\DecValTok{30} \OperatorTok{*} \StringTok{"="}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(methoden)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Attribute:
==============================
['asm8', 'day', 'day_of_week', 'day_of_year', 'dayofweek', 'dayofyear', 'days_in_month', 'daysinmonth', 'fold', 'hour', 'is_leap_year', 'is_month_end', 'is_month_start', 'is_quarter_end', 'is_quarter_start', 'is_year_end', 'is_year_start', 'max', 'microsecond', 'min', 'minute', 'month', 'nanosecond', 'quarter', 'resolution', 'second', 'tz', 'tzinfo', 'unit', 'value', 'week', 'weekofyear', 'year']

Methoden:
==============================
['_from_dt64', '_from_value_and_reso', '_round', 'as_unit', 'astimezone', 'ceil', 'combine', 'ctime', 'date', 'day_name', 'dst', 'floor', 'fromisocalendar', 'fromisoformat', 'fromordinal', 'fromtimestamp', 'isocalendar', 'isoformat', 'isoweekday', 'month_name', 'normalize', 'now', 'replace', 'round', 'strftime', 'strptime', 'time', 'timestamp', 'timetuple', 'timetz', 'to_datetime64', 'to_julian_date', 'to_numpy', 'to_period', 'to_pydatetime', 'today', 'toordinal', 'tz_convert', 'tz_localize', 'tzname', 'utcfromtimestamp', 'utcnow', 'utcoffset', 'utctimetuple', 'weekday']
\end{verbatim}

\end{tcolorbox}

Für \texttt{pd.Series} erfolgt der Zugriff über den .dt-Operator (siehe
\href{https://pandas.pydata.org/docs/user_guide/basics.html\#basics-dt-accessors}{.dt
accessor}). Der Zugriff auf verschiedene Informationen über ein Attribut
(ohne Klammern) oder über eine Methode (mit Klammern) unterscheidet sich
jedoch teilweise (siehe folgendes Beispiel).

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Der dt-Operator}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Attribute}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Datum:"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.date) }\CommentTok{\# Unterschied}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Zeit:"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.time) }\CommentTok{\# Unterschied}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Jahr"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.year)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Monat"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.month)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Tag"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.day)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Stunde"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.hour)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Minute"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.minute)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Sekunde"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.second)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Tag des Jahres"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.dayofyear)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Wochentag:"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.dayofweek)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Wochentag:"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.weekday) }\CommentTok{\# Unterschied}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Tage im Monat:"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.days\_in\_month)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Schaltjahr:"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.is\_leap\_year)}

\CommentTok{\# Methoden}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Name des Monats:"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.month\_name())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Datum: 0    1970-01-01
dtype: object
Zeit: 0    00:00:00
dtype: object
Jahr 0    1970
dtype: int32
Monat 0    1
dtype: int32
Tag 0    1
dtype: int32
Stunde 0    0
dtype: int32
Minute 0    0
dtype: int32
Sekunde 0    0
dtype: int32

Tag des Jahres 0    1
dtype: int32
Wochentag: 0    3
dtype: int32
Wochentag: 0    3
dtype: int32
Tage im Monat: 0    31
dtype: int32
Schaltjahr: 0    False
dtype: bool

Name des Monats: 0    January
dtype: object
\end{verbatim}

\end{tcolorbox}

\section{Aufgaben}\label{aufgaben-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Wie alt sind Sie in Tagen? Wie alt in Sekunden?
\item
  An welchem Wochentag war ihr Geburtstag?
\item
  Wie viele Tage sind es noch bis Weihnachten?
\item
  Erstellen Sie eine Liste aller Schaltjahre im 20. Jahrhundert.
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-musterlösungaufgaben}: Musterlösung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-musterlösungaufgaben} 

Aufgabe 1

Ersetzen sie in der Lösung die Zeichenkette `YYYY-MM-DD' bzw., wenn Sie
die Uhrzeit Ihrer Geburt kennen, die Zeichenkette `YYYY-MM-DDTHH:MM'
durch Ihren Geburtstag.

In Pandas werden die Schlüsselwörter
\texttt{pd.to\_datetime(\textquotesingle{}today\textquotesingle{})} und
\texttt{pd.to\_datetime(\textquotesingle{}now\textquotesingle{})} in
Nanosekunden aufgelöst.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{print((pd.to\_datetime(\textquotesingle{}today\textquotesingle{}) {-} pd.to\_datetime(\textquotesingle{}YYYY{-}MM{-}DD\textquotesingle{})).days)}
\NormalTok{print(pd.to\_datetime(\textquotesingle{}now\textquotesingle{}) {-} pd.to\_datetime(\textquotesingle{}YYYY{-}MM{-}DDTHH:MM\textquotesingle{})).total\_seconds())}
\end{Highlighting}
\end{Shaded}

Aufgabe 2

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{print(pd.to\_datetime(\textquotesingle{}YYYY{-}MM{-}DD\textquotesingle{}).day\_of\_week)}
\end{Highlighting}
\end{Shaded}

Aufgabe 3

\begin{verbatim}
(pd.to_datetime('2025-12-25') - pd.to_datetime('now')).days
\end{verbatim}

Aufgabe 4

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{schaltjahre }\OperatorTok{=}\NormalTok{ pd.date\_range(start }\OperatorTok{=} \StringTok{\textquotesingle{}1901\textquotesingle{}}\NormalTok{, end }\OperatorTok{=} \StringTok{\textquotesingle{}2000\textquotesingle{}}\NormalTok{, freq }\OperatorTok{=} \StringTok{\textquotesingle{}YE\textquotesingle{}}\NormalTok{)}
\NormalTok{schaltjahre }\OperatorTok{=}\NormalTok{ schaltjahre[schaltjahre.is\_leap\_year]}
\BuiltInTok{print}\NormalTok{(schaltjahre.year)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Index([1904, 1908, 1912, 1916, 1920, 1924, 1928, 1932, 1936, 1940, 1944, 1948,
       1952, 1956, 1960, 1964, 1968, 1972, 1976, 1980, 1984, 1988, 1992, 1996],
      dtype='int32')
\end{verbatim}

\end{tcolorbox}

\chapter{Dateien lesen und
schreiben}\label{dateien-lesen-und-schreiben-1}

Pandas bietet eine Reihe von Funktionen, um Dateien einzulesen und zu
schreiben, deren Namensgebung einem einheitlichen Schema folgt.
Funktionen zum Lesen von Dateien werden in der Form
\texttt{pd.read\_csv()} und Funktionen zum Schreiben in der Form
\texttt{pd.to\_csv()} aufgerufen. Mit Pandas können auch Dateien aus dem
Internet abgerufen werden \texttt{pd.read\_csv(URL)}.

\begin{longtable}[]{@{}cccc@{}}
\toprule\noalign{}
Format Type & Data Description & Reader & Writer \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
text & CSV & read\_csv & to\_csv \\
text & Fixed-Width Text File & read\_fwf & NA \\
text & JSON & read\_json & to\_json \\
text & HTML & read\_html & to\_html \\
text & LaTeX & Styler.to\_latex & NA \\
text & XML & read\_xml & to\_xml \\
text & Local clipboard & read\_clipboard & to\_clipboard \\
binary & MS Excel & read\_excel & to\_excel \\
binary & OpenDocument & read\_excel & NA \\
binary & HDF5 Format & read\_hdf & to\_hdf \\
binary & Feather Format & read\_feather & to\_feather \\
binary & Parquet Format & read\_parquet & to\_parquet \\
binary & ORC Format & read\_orc & to\_orc \\
binary & Stata & read\_stata & to\_stata \\
binary & SAS & read\_sas & NA \\
binary & SPSS & read\_spss & NA \\
binary & Python Pickle Format & read\_pickle & to\_pickle \\
SQL & SQL & read\_sql & to\_sql \\
\end{longtable}

(\href{https://pandas.pydata.org/docs/user_guide/io.html}{Pandas
Dokumentation})

~

Im Folgenden wird der Datensatz palmerpenguins mit Pandas eingelesen.

\textbf{palmerpenguins}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/w-pandas/skript/00-bilder/lter_penguins_allison_horst_CC0.png}}

}

\caption{Pinguine des Palmer-Station-Datensatzes}

\end{figure}%

Meet the Palmer penguins von @allison\_horst steht unter der Lizenz
\href{https://github.com/allisonhorst/palmerpenguins?tab=CC0-1.0-1-ov-file\#creative-commons}{CC0-1.0}
und ist auf
\href{https://github.com/allisonhorst/palmerpenguins?tab=readme-ov-file\#meet-the-palmer-penguins}{GitHub}
abrufbar. 2020

Der Datensatz steht unter der Lizenz
\href{https://creativecommons.org/public-domain/cc0/}{CCO} und ist in R
sowie auf
\href{https://github.com/allisonhorst/palmerpenguins?tab=readme-ov-file}{GitHub}
verfügbar. 2020

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\# R Befehle, um den Datensatz zu laden}
\NormalTok{install.packages("palmerpenguins")}
\NormalTok{library(palmerpenguins)}
\end{Highlighting}
\end{Shaded}

Horst AM, Hill AP und Gorman KB. 2020. palmerpenguins: Palmer
Archipelago (Antarctica) penguin data. R package version 0.1.0.
\url{https://allisonhorst.github.io/palmerpenguins/}. doi:
10.5281/zenodo.3960218.

~

Die Funktionen zum Lesen von Dateien erwarten eine Pfadangabe, die
positional oder mit einem Schlüsselwort übergeben werden kann. Das
Schlüsselwort für die Pfadangabe variiert abhängig vom Dateityp und
lautet für eine kommaseparierte CSV-Datei \texttt{filepath\_or\_buffer}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{penguins }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/penguins.csv\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Ein Blick auf die Daten mit der Methode \texttt{penguins.head()}:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(penguins.head())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  species     island  bill_length_mm  bill_depth_mm  flipper_length_mm  \
0  Adelie  Torgersen            39.1           18.7              181.0   
1  Adelie  Torgersen            39.5           17.4              186.0   
2  Adelie  Torgersen            40.3           18.0              195.0   
3  Adelie  Torgersen             NaN            NaN                NaN   
4  Adelie  Torgersen            36.7           19.3              193.0   

   body_mass_g     sex  year  
0       3750.0    male  2007  
1       3800.0  female  2007  
2       3250.0  female  2007  
3          NaN     NaN  2007  
4       3450.0  female  2007  
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-pandas/skript/00-bilder/culmen_depth_allison_horst_CC0.png}}\{fig-alt:``illustrative
Grafik des Pinguinschnabels''\}

Bill dimensions von @allison\_horst steht unter der Lizenz
\href{https://github.com/allisonhorst/palmerpenguins?tab=CC0-1.0-1-ov-file\#creative-commons}{CC0-1.0}
und ist auf
\href{https://github.com/allisonhorst/palmerpenguins?tab=readme-ov-file\#meet-the-palmer-penguins}{GitHub}
abrufbar. 2020

~

Einen Überblick über den Datensatz verschafft die Methode
\texttt{DataFrame.info()}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(penguins.info())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 344 entries, 0 to 343
Data columns (total 8 columns):
 #   Column             Non-Null Count  Dtype  
---  ------             --------------  -----  
 0   species            344 non-null    object 
 1   island             344 non-null    object 
 2   bill_length_mm     342 non-null    float64
 3   bill_depth_mm      342 non-null    float64
 4   flipper_length_mm  342 non-null    float64
 5   body_mass_g        342 non-null    float64
 6   sex                333 non-null    object 
 7   year               344 non-null    int64  
dtypes: float64(4), int64(1), object(3)
memory usage: 21.6+ KB
None
\end{verbatim}

Einige Datentypen wurden nicht erkannt. Den betreffenden Spalten wurde
der Sammeltyp object zugeordnet. Den Funktionen zum Einlesen von Daten
kann mit dem Argument \texttt{dtype} der Datentyp übergeben werden. Für
mehrere Spalten ist dies in Form eines Dictionaries in der Form
\texttt{\{\textquotesingle{}Spaltenname\textquotesingle{}:\ \textquotesingle{}dtype\textquotesingle{}\}}
möglich. Mit der Methode \texttt{DataFrame.astype()} ist dies auch
nachträglich möglich.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{penguins }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/penguins.csv\textquotesingle{}}\NormalTok{, dtype }\OperatorTok{=}\NormalTok{ \{}\StringTok{\textquotesingle{}species\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}category\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}island\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}category\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}sex\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}category\textquotesingle{}}\NormalTok{\})}

\CommentTok{\# nachträglich}
\CommentTok{\# penguins = penguins.astype(\{\textquotesingle{}species\textquotesingle{}: \textquotesingle{}category\textquotesingle{}, \textquotesingle{}island\textquotesingle{}: \textquotesingle{}category\textquotesingle{}, \textquotesingle{}sex\textquotesingle{}: \textquotesingle{}category\textquotesingle{}\})}

\BuiltInTok{print}\NormalTok{(penguins.info())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 344 entries, 0 to 343
Data columns (total 8 columns):
 #   Column             Non-Null Count  Dtype   
---  ------             --------------  -----   
 0   species            344 non-null    category
 1   island             344 non-null    category
 2   bill_length_mm     342 non-null    float64 
 3   bill_depth_mm      342 non-null    float64 
 4   flipper_length_mm  342 non-null    float64 
 5   body_mass_g        342 non-null    float64 
 6   sex                333 non-null    category
 7   year               344 non-null    int64   
dtypes: category(3), float64(4), int64(1)
memory usage: 15.0 KB
None
\end{verbatim}

Einige Spalten weisen ungültige Werte auf. Die Tiere mit unvollständigen
Werten sollen aus dem Datensatz entfernt werden.

\begin{itemize}
\tightlist
\item
  Mit der Methode \texttt{DataFrame.apply(pd.isna)} werden fehlende
  Werte bestimmt.
\item
  Mit der Methode \texttt{DataFrame.any(axis\ =\ 1)} wird das Ergebnis
  zeilenweise aggregiert. any gibt True zurück, wenn mindestens ein
  Element True ist.
\item
  Mit der Methode \texttt{sum()} wird die Anzahl der Zeilen mit
  fehlenden Werten bestimmt.
\item
  Mit \texttt{np.where()} wird deren Indexposition bestimmt.
\item
  Mit der Methode \texttt{DataFrame.drop()} werden die betreffenden
  Zeilen entfernt.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Fehlende Werte bestimmen}
\BuiltInTok{print}\NormalTok{(penguins.}\BuiltInTok{apply}\NormalTok{(pd.isna).head(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# zeilenweise aggregieren}
\BuiltInTok{print}\NormalTok{(penguins.}\BuiltInTok{apply}\NormalTok{(pd.isna).}\BuiltInTok{any}\NormalTok{(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{).head(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# Anzahl der Zeilen mit fehlenden Werten}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Für }\SpecialCharTok{\{}\NormalTok{penguins}\SpecialCharTok{.}\BuiltInTok{apply}\NormalTok{(pd.isna)}\SpecialCharTok{.}\BuiltInTok{any}\NormalTok{(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{\}}\SpecialStringTok{ Pinguine liegen unvollständige Werte vor.}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# Indexpositionen bestimmen}
\BuiltInTok{print}\NormalTok{(np.where(penguins.}\BuiltInTok{apply}\NormalTok{(pd.isna).}\BuiltInTok{any}\NormalTok{(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{))[}\DecValTok{0}\NormalTok{])}

\CommentTok{\# Zeilen entfernen}
\NormalTok{penguins.drop(np.where(penguins.}\BuiltInTok{apply}\NormalTok{(pd.isna).}\BuiltInTok{any}\NormalTok{(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{))[}\DecValTok{0}\NormalTok{], inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   species  island  bill_length_mm  bill_depth_mm  flipper_length_mm  \
0    False   False           False          False              False   
1    False   False           False          False              False   
2    False   False           False          False              False   
3    False   False            True           True               True   
4    False   False           False          False              False   

   body_mass_g    sex   year  
0        False  False  False  
1        False  False  False  
2        False  False  False  
3         True   True  False  
4        False  False  False   

0    False
1    False
2    False
3     True
4    False
dtype: bool 

Für 11 Pinguine liegen unvollständige Werte vor.

[  3   8   9  10  11  47 178 218 256 268 271]
\end{verbatim}

Kontrolle:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(penguins.info())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
Index: 333 entries, 0 to 343
Data columns (total 8 columns):
 #   Column             Non-Null Count  Dtype   
---  ------             --------------  -----   
 0   species            333 non-null    category
 1   island             333 non-null    category
 2   bill_length_mm     333 non-null    float64 
 3   bill_depth_mm      333 non-null    float64 
 4   flipper_length_mm  333 non-null    float64 
 5   body_mass_g        333 non-null    float64 
 6   sex                333 non-null    category
 7   year               333 non-null    int64   
dtypes: category(3), float64(4), int64(1)
memory usage: 17.0 KB
None
\end{verbatim}

\section{Zeitreihen einlesen}\label{zeitreihen-einlesen}

Mit Pandas ist es leicht möglich, Zeitreihen einzulesen. Durch string
parsing können beliebige Zeichenketten als datetime interpretiert
werden.

Wenn der innere Aufbau einer Datei bekannt ist, können die notwendigen
Parameter direkt beim Einlesen beispielsweise mit
\texttt{pd.read\_csv()} übergeben werden. Dazu werden die Parameter
\texttt{parse\_dates} und \texttt{date\_format} verwendet.

\texttt{parse\_dates} gibt an, an welcher Stelle sich
datetime-Informationen befinden. Es können verschiedene Argumente
übergeben werden.

\begin{itemize}
\tightlist
\item
  \texttt{parse\_dates\ =\ True} bewirkt, dass der Index als datetime
  interpretiert wird.
\item
  Eine Liste von Ganzzahlen oder Spaltenbeschriftungen bewirkt, dass
  diese Spalten jeweils als eigene Spalte in datetime übersetzt werden,
  bspw \texttt{parse\_dates\ =\ {[}1,\ 2,\ 3{]}}.
\item
  Eine von einer Liste umschlossene Liste bewirkt, dass die übergebenen
  Spalten in einer einzigen Spalte zusammengeführt werden, bspw.
  \texttt{parse\_dates\ =\ {[}{[}1,\ 2,\ 3{]}{]}}. Die Werte der Spalten
  werden mit einem Leerzeichen getrennt und anschließend interpretiert.
\end{itemize}

Pandas interpretiert die Zeichenketten nach
\href{https://www.iso.org/iso-8601-date-and-time-format.html}{ISO 8601}
als Repräsentation eines Datums in der festgelegten Reihenfolge Jahr,
Monat, Tag, Stunde, Minute, Sekunde, Millisekunde im Format
\texttt{YYYY-MM-DD\ 12:00:00.000}. Als Zeichentrenner zwischen Datum und
Uhrzeit sind ein Leerzeichen oder der Buchstabe T zulässig. Der Datentyp
und die kleinste verwendete Einheit werden im Attribut \texttt{dtype}
gespeichert.

Andere Formate werden mit dem Parameter \texttt{date\_format}
spezifiziert. Mit Hilfe der
\href{https://docs.python.org/3/library/datetime.html\#strftime-and-strptime-behavior}{strftime-Dokumentation}
kann das Datumsformat übergeben werden.

Datumsinformationen können aber auch nachträglich als solche deklariert
werden. Dafür wird die Funktion
\texttt{pd.to\_datetime(arg,\ format\ =\ "\ ...\ ")} verwendet. Mit dem
Parameter \texttt{arg} wird die zu konvertierende Spalte übergeben. Mit
dem Parameter \texttt{format} kann wie mit dem Parameter
\texttt{date\_format} ein von der ISO8601 abweichendes Datumsformat
spezifiziert werden.

\section{Aufgaben Zeitreihen
einlesen}\label{aufgaben-zeitreihen-einlesen}

Unter dem Pfad `01-daten/Microsoft\_Stock.csv' sind Kursdaten der
Microsoft-Aktie gespeichert.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stock }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/Microsoft\_Stock.csv\textquotesingle{}}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(stock.head(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(stock.info())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
                Date   Open   High    Low  Close    Volume
0  4/1/2015 16:00:00  40.60  40.76  40.31  40.72  36865322
1  4/2/2015 16:00:00  40.66  40.74  40.12  40.29  37487476
2  4/6/2015 16:00:00  40.34  41.78  40.18  41.55  39223692
3  4/7/2015 16:00:00  41.61  41.91  41.31  41.53  28809375
4  4/8/2015 16:00:00  41.48  41.69  41.04  41.42  24753438 

<class 'pandas.core.frame.DataFrame'>
RangeIndex: 1511 entries, 0 to 1510
Data columns (total 6 columns):
 #   Column  Non-Null Count  Dtype  
---  ------  --------------  -----  
 0   Date    1511 non-null   object 
 1   Open    1511 non-null   float64
 2   High    1511 non-null   float64
 3   Low     1511 non-null   float64
 4   Close   1511 non-null   float64
 5   Volume  1511 non-null   int64  
dtypes: float64(4), int64(1), object(1)
memory usage: 71.0+ KB
None
\end{verbatim}

Microsoft Stock- Time Series Analysis von Vijay V Venkitesh steht unter
der Lizenz
\href{https://creativecommons.org/publicdomain/zero/1.0/}{CC0} und ist
auf
\href{https://www.kaggle.com/datasets/vijayvvenkitesh/microsoft-stock-time-series-analysis}{kaggle}
abrufbar. 2021

~

In der Spalte `Date' sind Datums- und Zeitinformationen in der Form
`Monat/Tag/Jahr Stunde:Minute:Sekunde' verzeichnet, die von Pandas nicht
automatisch erkannt wurden. Die Spalte hat deshalb den Datentyp object
erhalten.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Übergeben Sie der Funktion \texttt{pd.read\_csv()} die erforderlichen
  Argumente, um die Spalte Date korrekt als datetime einzulesen.
\item
  Berechnen Sie die Höchstkurse für jede Woche (intraday).
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-musterloesungzeitreihe}: Musterlösung Zeitreihen einlesen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-musterloesungzeitreihe} 

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Aufgabe
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stock }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/Microsoft\_Stock.csv\textquotesingle{}}\NormalTok{,}
\NormalTok{        parse\_dates }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{], }\CommentTok{\# alternativ: [0]}
\NormalTok{        date\_format }\OperatorTok{=} \StringTok{\textquotesingle{}\%m/}\SpecialCharTok{\%d}\StringTok{/\%Y \%H:\%M:\%S\textquotesingle{}}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(stock.head(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(stock.info())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
                 Date   Open   High    Low  Close    Volume
0 2015-04-01 16:00:00  40.60  40.76  40.31  40.72  36865322
1 2015-04-02 16:00:00  40.66  40.74  40.12  40.29  37487476
2 2015-04-06 16:00:00  40.34  41.78  40.18  41.55  39223692
3 2015-04-07 16:00:00  41.61  41.91  41.31  41.53  28809375
4 2015-04-08 16:00:00  41.48  41.69  41.04  41.42  24753438 

<class 'pandas.core.frame.DataFrame'>
RangeIndex: 1511 entries, 0 to 1510
Data columns (total 6 columns):
 #   Column  Non-Null Count  Dtype         
---  ------  --------------  -----         
 0   Date    1511 non-null   datetime64[ns]
 1   Open    1511 non-null   float64       
 2   High    1511 non-null   float64       
 3   Low     1511 non-null   float64       
 4   Close   1511 non-null   float64       
 5   Volume  1511 non-null   int64         
dtypes: datetime64[ns](1), float64(4), int64(1)
memory usage: 71.0 KB
None
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Aufgabe
\end{enumerate}

Die Pandas-Methode \texttt{Series.dt.weekofyear()} wird seit einiger
Zeit nicht mehr unterstützt
(\href{https://pandas.pydata.org/pandas-docs/version/1.5/reference/api/pandas.Series.dt.weekofyear.html}{siehe
Dokumentation}). Die Funktion wurde durch
\texttt{Series.dt.isocalendar().week} ersetzt.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Jahr und Woche isolieren}
\BuiltInTok{print}\NormalTok{(stock[}\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{].dt.isocalendar().week.head(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(stock[}\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{].dt.isocalendar().year.tail())}

\CommentTok{\# Jahr und Woche in den DataFrame einfügen}
\NormalTok{stock.insert(loc }\OperatorTok{=} \DecValTok{1}\NormalTok{, column }\OperatorTok{=} \StringTok{\textquotesingle{}week\textquotesingle{}}\NormalTok{, value }\OperatorTok{=}\NormalTok{ stock[}\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{].dt.isocalendar().week)}
\NormalTok{stock.insert(loc }\OperatorTok{=} \DecValTok{1}\NormalTok{, column }\OperatorTok{=} \StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{, value }\OperatorTok{=}\NormalTok{ stock[}\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{].dt.isocalendar().year)}

\CommentTok{\# Maximum für jede Woche mit groupby bestimmen}
\BuiltInTok{print}\NormalTok{(stock.groupby(by }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}week\textquotesingle{}}\NormalTok{])[}\StringTok{\textquotesingle{}High\textquotesingle{}}\NormalTok{].}\BuiltInTok{max}\NormalTok{())}

\CommentTok{\# grafisch darstellen}
\NormalTok{stock.groupby(by }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}week\textquotesingle{}}\NormalTok{])[}\StringTok{\textquotesingle{}High\textquotesingle{}}\NormalTok{].}\BuiltInTok{max}\NormalTok{().plot(ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}Wochenhöchstkurs (intraday)\textquotesingle{}}\NormalTok{, title }\OperatorTok{=} \StringTok{\textquotesingle{}Kursentwicklung der Microsoft{-}Aktie\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0    14
1    14
2    15
3    15
4    15
Name: week, dtype: UInt32 

1506    2021
1507    2021
1508    2021
1509    2021
1510    2021
Name: year, dtype: UInt32
year  week
2015  14       40.76
      15       41.95
      16       42.46
      17       48.14
      18       49.54
               ...  
2021  9       237.47
      10      239.17
      11      240.06
      12      241.05
      13      239.10
Name: High, Length: 314, dtype: float64
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/w-pandas/skript/dateien_files/figure-pdf/cell-11-output-2.png}}

\end{tcolorbox}

\section{Schwierige Dateien einlesen}\label{schwierige-dateien-einlesen}

Das Einlesen von Dateien ist nicht immer einfach. Werkzeuge und
Strategien zur Bewältigung schwieriger Fälle finden Sie im
\href{https://bausteine-der-datenanalyse.github.io/m-einlesen-strukturierter-datensaetze/output/book/}{Methodenbaustein
Einlesen strukturierter Datensätze}. Dort wird auch der Umgang mit
fehlenden Werten ausführlich behandelt.

\part{m-numerik}

\chapter*{Preamble}\label{preamble-1}
\addcontentsline{toc}{chapter}{Preamble}

\markboth{Preamble}{Preamble}

\phantomsection\label{Lizenz}
\begin{figure}

\begin{minipage}{0.20\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/by.png}}\end{minipage}%
%
\begin{minipage}{0.80\linewidth}
Bausteine Computergestützter Datenanalyse. ``Numerik'' von Lukas Arnold,
Simone Arnold, Florian Bagemihl, Matthias Baitsch, Marc Fehr, Maik
Poetzsch und Sebastian Seipel ist lizensiert unter
\href{https://creativecommons.org/licenses/by/4.0/deed.de}{CC BY 4.0}.
Das Werk ist abrufbar unter
\url{https://github.com/bausteine-der-datenanalyse/m-numerik}.
Ausgenommen von der Lizenz sind alle Logos und anders gekennzeichneten
Inhalte. 2024\end{minipage}%

\end{figure}%

Zitiervorschlag

Arnold, Lukas, Simone Arnold, Matthias Baitsch, Marc Fehr, Maik
Poetzsch, und Sebastian Seipel. 2024. „Bausteine Computergestützter
Datenanalyse. Methodenbaustein Numerik``.
\url{https://github.com/bausteine-der-datenanalyse/m-numerik}.

BibTeX-Vorlage

\begin{verbatim}
@misc{BCD-Styleguide-2024,
 title={Bausteine Computergestützter Datenanalyse. Methodenbaustein Numerik},
 author={Arnold, Lukas and Arnold, Simone and Baitsch, Matthias and Fehr, Marc and Poetzsch, Maik and Seipel, Sebastian},
 year={2024},
 url={https://github.com/bausteine-der-datenanalyse/m-numerik}} 
\end{verbatim}

\chapter*{Intro}\label{intro-2}
\addcontentsline{toc}{chapter}{Intro}

\markboth{Intro}{Intro}

\section*{Voraussetzungen}\label{voraussetzungen-6}
\addcontentsline{toc}{section}{Voraussetzungen}

\markright{Voraussetzungen}

\begin{itemize}
\tightlist
\item
  Grundlagen Python
\item
  Einbinden von zusätzlichen Paketen
\item
  Plotten mit Matplotlib
\end{itemize}

\section*{Verwendete Pakete und
Datensätze}\label{verwendete-pakete-und-datensuxe4tze-2}
\addcontentsline{toc}{section}{Verwendete Pakete und Datensätze}

\markright{Verwendete Pakete und Datensätze}

\subsection*{Pakete}\label{pakete-1}
\addcontentsline{toc}{subsection}{Pakete}

\begin{itemize}
\tightlist
\item
  \href{https://numpy.org/}{NumPy}
\item
  \href{https://matplotlib.org/}{Matplotlib}
\end{itemize}

\subsection*{Datensätze}\label{datensuxe4tze-1}
\addcontentsline{toc}{subsection}{Datensätze}

\section*{Bearbeitungszeit}\label{bearbeitungszeit-2}
\addcontentsline{toc}{section}{Bearbeitungszeit}

\markright{Bearbeitungszeit}

Geschätzte Bearbeitungszeit: 2h

\section*{Lernziele}\label{lernziele-6}
\addcontentsline{toc}{section}{Lernziele}

\markright{Lernziele}

\begin{itemize}
\tightlist
\item
  Was ist Numerik
\item
  Numerische Verfahren umsetzen
\item
  Numerische Integration
\item
  Numerische Differentiation
\end{itemize}

\chapter{Integration}\label{integration}

Die Bildung von Integralen findet beispielsweise bei der Bestimmung von
Flächeninhalten oder von Gesamtkräften Anwendung. Formal wird das
bestimmte Integral \(\mathsf{I}\) der Funktion \(\mathsf{f(x)}\) auf dem
Intervall \(\mathsf{x \in [a,b]}\) wie folgt dargestellt.

\[ \mathsf{I = \int_a^b f(x)\ dx} \]

Im Allgemeinen kann das Integral nicht analytisch gelöst werden, da die
Stammfunktion \(\mathsf{F(x)}\) nicht leicht zu bestimmen ist. In
solchen Fällen können numersiche Verfahren eingesetzt werden um den
Integralwert zu approximieren. Die numerische Integration wird oft auch
als numersiche Quadratur bezeichnet.

Dieses Kapitel bietet eine kurze Übersicht von numerischen
Integrationsmethoden:

\begin{itemize}
\tightlist
\item
  Ober- und Untersumme
\item
  Quadratur
\item
  Monte-Carlo
\end{itemize}

\subsection{Ober- und Untersumme}\label{ober--und-untersumme}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}
\ImportTok{import}\NormalTok{ seaborn }\ImportTok{as}\NormalTok{ sns}
\end{Highlighting}
\end{Shaded}

Eine der grundlegendsten Arten Integrale von Funktionen zu bestimmen
sind die
\href{https://de.wikipedia.org/wiki/Riemannsches_Integral}{Ober- und
Untersumme}. Sie nähern den Integralwert durch eine Abschätzung nach
oben bzw. unten an. Mit einer steigenden Anzahl von Stützstellen, d.h.
Positionen an welchen die Funktion ausgewertet wird, konvergieren beide
Abschätzungen gegen den Integralwert.

\section{Definition}\label{definition}

Für die Bildung der Ober- und Untersumme, werden gleichmäßig verteilte
Stützstellen auf dem Intervall \(\mathsf{[a,b]}\) benötigt. Werden
\(\mathsf{n+1}\) Stützstellen gewählt, so gilt:

\[ a = x_0 < x_1 < \cdots < x_n = b \]

Der Abstand der Stützstellen beträgt
\(\mathsf{\Delta x = (b-a)/(n-1)}\). Auf jedem der \(\mathsf{n}\)
Teilintervalle \(\mathsf{[x_{i-1}, x_{i}]}\) wird nun der maximale bzw.
minimale Wert der Funktion \(\mathsf{f(x)}\) bestimmt und als
\(\mathsf{O_i}\) bzw. \(\mathsf{U_i}\) definiert.

\[ \mathsf{O_i = \max\left( f(x) | x \in [x_{i-1}, x_{i}] \right)} \]
\[ \mathsf{U_i = \min\left( f(x) | x \in [x_{i-1}, x_{i}] \right)} \]

Die gesuchte Approximation des Integrals ist die Summe der
\(\mathsf{O_i}\) bzw. \(\mathsf{U_i}\) mal der Breite des
Teilintervalls, hier \(\mathsf{\Delta x}\):

\[ \sum_{i=1}^n \Delta x U_i \lesssim I \lesssim \sum_{i=1}^n \Delta x O_i \]

\section{Beispiel}\label{beispiel}

Beispielhaft soll folgendes Integral bestimmt werden

\[ \mathsf{I = \int_0^2\sin(3x) + 2x \ dx} \]

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ fkt(x):}
    \ControlFlowTok{return}\NormalTok{ np.sin(}\DecValTok{3}\OperatorTok{*}\NormalTok{x) }\OperatorTok{+} \DecValTok{2}\OperatorTok{*}\NormalTok{x}

\CommentTok{\# Daten für die Visualisierung}
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{100}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ fkt(x)}

\CommentTok{\# Exakte Lösung}
\NormalTok{I\_exakt }\OperatorTok{=}\NormalTok{ (}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{/}\DecValTok{3}\OperatorTok{*}\NormalTok{np.cos(}\DecValTok{3}\OperatorTok{*}\DecValTok{2}\NormalTok{) }\OperatorTok{+} \DecValTok{2}\OperatorTok{**}\DecValTok{2}\NormalTok{) }\OperatorTok{{-}}\NormalTok{ (}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{/}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Als erstes werden die Stützstellen gleichmäßig im Intervall
\(\mathsf{[0,2]}\) verteilt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{=} \DecValTok{5}

\NormalTok{xi }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, n)}
\NormalTok{yi }\OperatorTok{=}\NormalTok{ fkt(xi)}
\end{Highlighting}
\end{Shaded}

Die beiden Summen benötigen die Extremwerte der zu integrierenden
Funktion in den Teilintervallen. Diese werden mit Hilfe einer
Funktionsauswertung auf dem Teilintervall bestimmt. Für die nachfolgende
Visualisierung hat die Menge der Summen ebenfalls \(\mathsf{n}\)
Elemente.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{oben }\OperatorTok{=}\NormalTok{ np.zeros(n)}
\NormalTok{unten }\OperatorTok{=}\NormalTok{ np.zeros(n)}

\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(oben)}\OperatorTok{{-}}\DecValTok{1}\NormalTok{): }
\NormalTok{    cx }\OperatorTok{=}\NormalTok{ np.linspace(xi[i], xi[i}\OperatorTok{+}\DecValTok{1}\NormalTok{], }\DecValTok{50}\NormalTok{)}
\NormalTok{    cy }\OperatorTok{=}\NormalTok{ fkt(cx)}
\NormalTok{    oben[i}\OperatorTok{+}\DecValTok{1}\NormalTok{] }\OperatorTok{=}\NormalTok{ np.}\BuiltInTok{max}\NormalTok{(cy)}
\NormalTok{    unten[i}\OperatorTok{+}\DecValTok{1}\NormalTok{] }\OperatorTok{=}\NormalTok{ np.}\BuiltInTok{min}\NormalTok{(cy)}
\end{Highlighting}
\end{Shaded}

Die ersten Elemente der beiden Summenlisten werden auf die ersten
Funktionswerte gesetzt, dies dient nur der folgenden Darstellung.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{oben[}\DecValTok{0}\NormalTok{] }\OperatorTok{=}\NormalTok{ yi[}\DecValTok{0}\NormalTok{]}
\NormalTok{unten[}\DecValTok{0}\NormalTok{] }\OperatorTok{=}\NormalTok{ yi[}\DecValTok{0}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Visualisierung der einzelnen Funktionen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y, label}\OperatorTok{=}\StringTok{\textquotesingle{}Funktion\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.scatter(xi, yi, label}\OperatorTok{=}\StringTok{\textquotesingle{}Stützstellen\textquotesingle{}}\NormalTok{, c}\OperatorTok{=}\StringTok{\textquotesingle{}C3\textquotesingle{}}\NormalTok{, zorder}\OperatorTok{=}\DecValTok{3}\NormalTok{)}
\NormalTok{plt.plot(xi, oben, drawstyle}\OperatorTok{=}\StringTok{\textquotesingle{}steps{-}pre\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Obersumme\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(xi, unten, drawstyle}\OperatorTok{=}\StringTok{\textquotesingle{}steps{-}pre\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Untersumme\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.vlines(xi, ymin}\OperatorTok{=}\NormalTok{unten, ymax}\OperatorTok{=}\NormalTok{oben, color}\OperatorTok{=}\StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.6}\NormalTok{)}
\NormalTok{plt.vlines(xi, ymin}\OperatorTok{=}\DecValTok{0}\NormalTok{, ymax}\OperatorTok{=}\NormalTok{unten, color}\OperatorTok{=}\StringTok{\textquotesingle{}C2\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.6}\NormalTok{)}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}y\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.grid()}
\NormalTok{plt.legend()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-numerik/skript/intro_integrale_files/figure-pdf/cell-7-output-1.png}}

Das obige Verfahren kann nun in einer Funktion zusammengefasst werden,
welche die Summen der beiden Folgen zurückgibt.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ ou\_summe(n, a}\OperatorTok{=}\DecValTok{0}\NormalTok{, b}\OperatorTok{=}\DecValTok{2}\NormalTok{):}
\NormalTok{    xi }\OperatorTok{=}\NormalTok{ np.linspace(a, b, n)}
\NormalTok{    yi }\OperatorTok{=}\NormalTok{ fkt(xi)}
\NormalTok{    dx }\OperatorTok{=}\NormalTok{ xi[}\DecValTok{1}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ xi[}\DecValTok{0}\NormalTok{]}
    
\NormalTok{    sum\_oben }\OperatorTok{=} \DecValTok{0}
\NormalTok{    sum\_unten }\OperatorTok{=} \DecValTok{0}
    
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n}\OperatorTok{{-}}\DecValTok{1}\NormalTok{): }
\NormalTok{        cx }\OperatorTok{=}\NormalTok{ np.linspace(xi[i], xi[i}\OperatorTok{+}\DecValTok{1}\NormalTok{], }\DecValTok{50}\NormalTok{)}
\NormalTok{        cy }\OperatorTok{=}\NormalTok{ fkt(cx)}
\NormalTok{        oben }\OperatorTok{=}\NormalTok{ np.}\BuiltInTok{max}\NormalTok{(cy)}
\NormalTok{        unten }\OperatorTok{=}\NormalTok{ np.}\BuiltInTok{min}\NormalTok{(cy)}
\NormalTok{        sum\_oben }\OperatorTok{+=}\NormalTok{ dx }\OperatorTok{*}\NormalTok{ oben}
\NormalTok{        sum\_unten }\OperatorTok{+=}\NormalTok{ dx }\OperatorTok{*}\NormalTok{ unten}
    
    \ControlFlowTok{return}\NormalTok{ sum\_oben, sum\_unten}
\end{Highlighting}
\end{Shaded}

Für eine systematische Untersuchung des Konvergenzverhaltens, wird die
Integrationsfunktion für verschiedene Anzahlen von Stützstellen
aufgerufen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n\_max }\OperatorTok{=} \DecValTok{100}
\NormalTok{ns }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{2}\NormalTok{, n\_max, }\DecValTok{1}\NormalTok{, dtype}\OperatorTok{=}\BuiltInTok{int}\NormalTok{)}
\NormalTok{os }\OperatorTok{=}\NormalTok{ np.zeros(}\BuiltInTok{len}\NormalTok{(ns))}
\NormalTok{us }\OperatorTok{=}\NormalTok{ np.zeros(}\BuiltInTok{len}\NormalTok{(ns))}


\ControlFlowTok{for}\NormalTok{ i, n }\KeywordTok{in} \BuiltInTok{enumerate}\NormalTok{(ns):}
\NormalTok{    o, u }\OperatorTok{=}\NormalTok{ ou\_summe(n)}
\NormalTok{    os[i] }\OperatorTok{=}\NormalTok{ o}
\NormalTok{    us[i] }\OperatorTok{=}\NormalTok{ u}
\end{Highlighting}
\end{Shaded}

Die graphische Darstellung der beiden Summen zeigt eine kontinuierliche
Annäherung dieser.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(ns, os, label}\OperatorTok{=}\StringTok{\textquotesingle{}Obersumme\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(ns, us, label}\OperatorTok{=}\StringTok{\textquotesingle{}Untersumme\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.axhline(y}\OperatorTok{=}\NormalTok{I\_exakt, color}\OperatorTok{=}\StringTok{\textquotesingle{}C3\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.3}\NormalTok{)}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Anzahl der Stützstellen n\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Integralwert\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.grid()}
\NormalTok{plt.legend()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-numerik/skript/intro_integrale_files/figure-pdf/cell-10-output-1.png}}

Dies wird insbesondere deutlich, wenn die Differenz der beiden Summen
aufgetragen wird. Mit einer logarithmischen Darstellung kann die
kontinuierliche Annäherung auch quantitativ abgelesen werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(ns, os}\OperatorTok{{-}}\NormalTok{us)}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Anzahl der Stützstellen n\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Differenz Ober{-} und Untersumme\textquotesingle{}}\NormalTok{)}

\CommentTok{\# plt.xscale(\textquotesingle{}log\textquotesingle{})}
\NormalTok{plt.yscale(}\StringTok{\textquotesingle{}log\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.grid()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-numerik/skript/intro_integrale_files/figure-pdf/cell-11-output-1.png}}

\section{Interpolation}\label{interpolation}

Bei der Bildung der Ober- und Untersumme wurde die zu integrierende
Funktion durch einen konstanten Wert in den Teilintervallen zwischen den
Stützstellen angenähert. Eine genauere Berechnung des Integrals kann
durch eine bessere Interpolation erfolgen. Dazu eignen sich Polynome, da
diese leicht zu Integrieren sind.

\subsection{Trapezregel}\label{trapezregel}

Die Trapezregel beruht auf der Annäherung der zu integrierenden Funktion
durch Geraden, d.h. Polynome vom Grad 1, auf den Teilintervallen. Die
Approximation des Integralwertes ergibt sich entsprechend aus den
Flächeninhalten der so entstandenen Trapeze.

Wie im vorhergehenden Kapitel wird das Verfahren anhand folgender
Funktion demonstriert

\[ \mathsf{I = \int_0^2\sin(3x) + 2x \ dx} \]

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ fkt(x):}
    \ControlFlowTok{return}\NormalTok{ np.sin(}\DecValTok{3}\OperatorTok{*}\NormalTok{x) }\OperatorTok{+} \DecValTok{2}\OperatorTok{*}\NormalTok{x}

\CommentTok{\# Daten für die Visualisierung}
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{100}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ fkt(x)}

\CommentTok{\# Exakte Lösung}
\NormalTok{I\_exakt }\OperatorTok{=}\NormalTok{ (}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{/}\DecValTok{3}\OperatorTok{*}\NormalTok{np.cos(}\DecValTok{3}\OperatorTok{*}\DecValTok{2}\NormalTok{) }\OperatorTok{+} \DecValTok{2}\OperatorTok{**}\DecValTok{2}\NormalTok{) }\OperatorTok{{-}}\NormalTok{ (}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{/}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Bildung der Stützpunkte:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{=} \DecValTok{5}

\NormalTok{xi }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, n)}
\NormalTok{yi }\OperatorTok{=}\NormalTok{ fkt(xi)}
\end{Highlighting}
\end{Shaded}

Zunächst erfolgt noch die Visualisierung des Verfahrens.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y, label}\OperatorTok{=}\StringTok{\textquotesingle{}Funktion\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.scatter(xi, yi, label}\OperatorTok{=}\StringTok{\textquotesingle{}Stützstellen\textquotesingle{}}\NormalTok{, c}\OperatorTok{=}\StringTok{\textquotesingle{}C3\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(xi, yi, label}\OperatorTok{=}\StringTok{\textquotesingle{}Approximation\textquotesingle{}}\NormalTok{, c}\OperatorTok{=}\StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.vlines(xi, ymin}\OperatorTok{=}\DecValTok{0}\NormalTok{, ymax}\OperatorTok{=}\NormalTok{yi, color}\OperatorTok{=}\StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.3}\NormalTok{)}

\NormalTok{plt.grid()}
\NormalTok{plt.legend()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-numerik/skript/intro_integrale_files/figure-pdf/cell-15-output-1.png}}

Die Integration selbst kann mittels der
\href{https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.trapezoid.html\#scipy.integrate.trapezoid}{Funktion
\texttt{scipy.integrate.trapezoid}} ausgeführt werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res }\OperatorTok{=}\NormalTok{ scipy.integrate.trapezoid(yi, xi)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Integralwert mit }\SpecialCharTok{\{}\NormalTok{n}\SpecialCharTok{\}}\SpecialStringTok{ Stützstellen: }\SpecialCharTok{\{}\NormalTok{res}\SpecialCharTok{:.4f\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Integralwert mit 5 Stützstellen: 4.0107
\end{verbatim}

Der so ermittelte Wert nähert sich dem exakten Wert mit zunehmender
Anzahl der Stützstellen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n\_max }\OperatorTok{=} \DecValTok{50}
\NormalTok{ns }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{2}\NormalTok{, n\_max, }\DecValTok{1}\NormalTok{, dtype}\OperatorTok{=}\BuiltInTok{int}\NormalTok{)}
\NormalTok{tr }\OperatorTok{=}\NormalTok{ np.zeros(}\BuiltInTok{len}\NormalTok{(ns))}

\ControlFlowTok{for}\NormalTok{ i, n }\KeywordTok{in} \BuiltInTok{enumerate}\NormalTok{(ns):}
\NormalTok{    xi }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, n)}
\NormalTok{    yi }\OperatorTok{=}\NormalTok{ fkt(xi)}
\NormalTok{    tr[i] }\OperatorTok{=}\NormalTok{ scipy.integrate.trapezoid(yi, xi)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(ns, tr)}
\NormalTok{plt.axhline(y}\OperatorTok{=}\NormalTok{I\_exakt, color}\OperatorTok{=}\StringTok{\textquotesingle{}C3\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.3}\NormalTok{)}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Anzahl der Stützstellen n\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Integralwert\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.grid()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-numerik/skript/intro_integrale_files/figure-pdf/cell-18-output-1.png}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(ns, np.}\BuiltInTok{abs}\NormalTok{(tr}\OperatorTok{{-}}\NormalTok{I\_exakt))}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Anzahl der Stützstellen n\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Differenz zum exakten Wert\textquotesingle{}}\NormalTok{)}

\CommentTok{\# plt.xscale(\textquotesingle{}log\textquotesingle{})}
\NormalTok{plt.yscale(}\StringTok{\textquotesingle{}log\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.grid()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-numerik/skript/intro_integrale_files/figure-pdf/cell-19-output-1.png}}

\subsection{Simpsonregel}\label{simpsonregel}

Die Verwendung eines Polynoms vom zweiten Grad führt zur Simpsonregel.
Hierzu wird die Funktion an einem Zwischenwert, mittig im Teilintervall,
ausgewertet und zusammen mit den Werten an den Stützstellen zur
Bestimmung der Polynomkoeffizienten verwendet.

Anhand des obigen Beispiels wird die Simpsonregel visuell demonstriert.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{=} \DecValTok{5}

\NormalTok{xi }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, n)}
\NormalTok{yi }\OperatorTok{=}\NormalTok{ fkt(xi)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y, label}\OperatorTok{=}\StringTok{\textquotesingle{}Funktion\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.scatter(xi, yi, label}\OperatorTok{=}\StringTok{\textquotesingle{}Stützstellen\textquotesingle{}}\NormalTok{, c}\OperatorTok{=}\StringTok{\textquotesingle{}C3\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Bestimmung und Plotten der Polynome}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n}\OperatorTok{{-}}\DecValTok{1}\NormalTok{):}
\NormalTok{    dx }\OperatorTok{=}\NormalTok{ xi[i}\OperatorTok{+}\DecValTok{1}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ xi[i]}
\NormalTok{    cx }\OperatorTok{=}\NormalTok{ (xi[i] }\OperatorTok{+}\NormalTok{ xi[i}\OperatorTok{+}\DecValTok{1}\NormalTok{]) }\OperatorTok{/} \DecValTok{2}
\NormalTok{    cy }\OperatorTok{=}\NormalTok{ fkt(cx)}

\NormalTok{    P }\OperatorTok{=}\NormalTok{ np.polyfit([xi[i], cx, xi[i}\OperatorTok{+}\DecValTok{1}\NormalTok{]], [yi[i], cy, yi[i}\OperatorTok{+}\DecValTok{1}\NormalTok{]], }\DecValTok{2}\NormalTok{)}
    
\NormalTok{    Px }\OperatorTok{=}\NormalTok{ np.linspace(xi[i], xi[i}\OperatorTok{+}\DecValTok{1}\NormalTok{], }\DecValTok{20}\NormalTok{)}
\NormalTok{    Py }\OperatorTok{=}\NormalTok{ np.polyval(P, Px)}
    
\NormalTok{    label}\OperatorTok{=}\VariableTok{None}
    \ControlFlowTok{if}\NormalTok{ i}\OperatorTok{==}\DecValTok{0}\NormalTok{: }
\NormalTok{        label}\OperatorTok{=}\StringTok{\textquotesingle{}Approximation\textquotesingle{}}
    
\NormalTok{    plt.plot(Px, Py, color}\OperatorTok{=}\StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\NormalTok{label)}

\NormalTok{plt.vlines(xi, ymin}\OperatorTok{=}\DecValTok{0}\NormalTok{, ymax}\OperatorTok{=}\NormalTok{yi, color}\OperatorTok{=}\StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.3}\NormalTok{)}

\NormalTok{plt.grid()}
\NormalTok{plt.legend()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-numerik/skript/intro_integrale_files/figure-pdf/cell-21-output-1.png}}

Die Simpsonregel ist bereits in der
\href{https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.simpson.html\#scipy.integrate.simpson}{Funktion
\texttt{scipy.integrate.simpson}} implementiert. Im Folgenden wird nur
die Differenz zur Trapezregel demonstriert.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n\_max }\OperatorTok{=} \DecValTok{50}
\NormalTok{ns }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{3}\NormalTok{, n\_max, }\DecValTok{2}\NormalTok{, dtype}\OperatorTok{=}\BuiltInTok{int}\NormalTok{)}
\NormalTok{si }\OperatorTok{=}\NormalTok{ np.zeros(}\BuiltInTok{len}\NormalTok{(ns))}
\NormalTok{tr }\OperatorTok{=}\NormalTok{ np.zeros(}\BuiltInTok{len}\NormalTok{(ns))}

\ControlFlowTok{for}\NormalTok{ i, n }\KeywordTok{in} \BuiltInTok{enumerate}\NormalTok{(ns):}
\NormalTok{    xi }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, n)}
\NormalTok{    yi }\OperatorTok{=}\NormalTok{ fkt(xi)}
\NormalTok{    si[i] }\OperatorTok{=}\NormalTok{ scipy.integrate.simpson(yi, xi)}
\NormalTok{    tr[i] }\OperatorTok{=}\NormalTok{ scipy.integrate.trapezoid(yi, xi)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(ns, np.}\BuiltInTok{abs}\NormalTok{(tr}\OperatorTok{{-}}\NormalTok{I\_exakt), label}\OperatorTok{=}\StringTok{\textquotesingle{}Trapezregel\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(ns, np.}\BuiltInTok{abs}\NormalTok{(si}\OperatorTok{{-}}\NormalTok{I\_exakt), label}\OperatorTok{=}\StringTok{\textquotesingle{}Simpsonregel\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Anzahl der Stützstellen n\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Differenz zum exakten Wert\textquotesingle{}}\NormalTok{)}

\CommentTok{\# plt.xscale(\textquotesingle{}log\textquotesingle{})}
\NormalTok{plt.yscale(}\StringTok{\textquotesingle{}log\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.legend()}
\NormalTok{plt.grid()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-numerik/skript/intro_integrale_files/figure-pdf/cell-23-output-1.png}}

\section{Monte-Carlo}\label{monte-carlo}

Ein ganz anderer Ansatz zur Integration wird mit dem
\href{https://de.wikipedia.org/wiki/Monte-Carlo-Algorithmus}{Monte-Carlo-Ansatz}
verfolgt. Hierbei werden Zufallspunkte \(\mathsf{x_i}\) innerhalb der
gesuchten Integralbereichs generiert. Der Mittelwert der dazugehörigen
Summe der Funktionswerte \(\mathsf{f(x_i)}\) nähert das Integral an.
Insbesondere für eine kleine Anzahl von Zufallswerten kann das Ergebnis
deutlich vom exakten Wert abweichen. Der Vorteil des Verfahrens wird bei
hochdimensionalen Integralen deutlich.

Für \(\mathsf{n \gg 1}\) zufällige Stützstellen
\(\mathsf{x_i \in [a, b]}\) gilt folgende Näherung

\[\mathsf{I = \int_a^b f(x)\ dx \approx \frac{b-a}{n}\sum_{i=1}^n f(x_i)} \]

Für das Beispiel aus den vorhergehenden Kapiteln gilt

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ fkt(x):}
    \ControlFlowTok{return}\NormalTok{ np.sin(}\DecValTok{3}\OperatorTok{*}\NormalTok{x) }\OperatorTok{+} \DecValTok{2}\OperatorTok{*}\NormalTok{x}

\CommentTok{\# Daten für die Visualisierung}
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{100}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ fkt(x)}

\CommentTok{\# Exakte Lösung}
\NormalTok{I\_exakt }\OperatorTok{=}\NormalTok{ (}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{/}\DecValTok{3}\OperatorTok{*}\NormalTok{np.cos(}\DecValTok{3}\OperatorTok{*}\DecValTok{2}\NormalTok{) }\OperatorTok{+} \DecValTok{2}\OperatorTok{**}\DecValTok{2}\NormalTok{) }\OperatorTok{{-}}\NormalTok{ (}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{/}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{=} \DecValTok{2000}
\NormalTok{xi }\OperatorTok{=}\NormalTok{ np.random.random(n) }\OperatorTok{*} \DecValTok{2}
\NormalTok{yi }\OperatorTok{=}\NormalTok{ fkt(xi)}
\NormalTok{I }\OperatorTok{=} \DecValTok{2} \OperatorTok{*} \DecValTok{1}\OperatorTok{/}\NormalTok{n }\OperatorTok{*}\NormalTok{ np.}\BuiltInTok{sum}\NormalTok{(yi)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Integralwert für }\SpecialCharTok{\{}\NormalTok{n}\SpecialCharTok{\}}\SpecialStringTok{ Stützstellen: }\SpecialCharTok{\{}\NormalTok{I}\SpecialCharTok{:.4f\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Integralwert für 2000 Stützstellen: 4.0726
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n\_max }\OperatorTok{=} \DecValTok{50000}
\NormalTok{dn }\OperatorTok{=} \DecValTok{250}
\NormalTok{ns }\OperatorTok{=}\NormalTok{ np.arange(dn, n\_max, dn, dtype}\OperatorTok{=}\BuiltInTok{int}\NormalTok{)}
\NormalTok{mc }\OperatorTok{=}\NormalTok{ np.zeros(}\BuiltInTok{len}\NormalTok{(ns))}

\NormalTok{xi }\OperatorTok{=}\NormalTok{ np.zeros(n\_max)}

\ControlFlowTok{for}\NormalTok{ i, n }\KeywordTok{in} \BuiltInTok{enumerate}\NormalTok{(ns):}
\NormalTok{    xi[n}\OperatorTok{{-}}\NormalTok{dn:n] }\OperatorTok{=}\NormalTok{ np.random.random(dn) }\OperatorTok{*} \DecValTok{2}
\NormalTok{    yi }\OperatorTok{=}\NormalTok{ fkt(xi[:n])}
\NormalTok{    mc[i] }\OperatorTok{=} \DecValTok{2} \OperatorTok{*} \DecValTok{1}\OperatorTok{/}\NormalTok{n }\OperatorTok{*}\NormalTok{ np.}\BuiltInTok{sum}\NormalTok{(yi)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(ns, np.}\BuiltInTok{abs}\NormalTok{(mc}\OperatorTok{{-}}\NormalTok{I\_exakt))}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Anzahl der Stützstellen n\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Differenz zum exakten Wert\textquotesingle{}}\NormalTok{)}

\CommentTok{\# plt.xscale(\textquotesingle{}log\textquotesingle{})}
\NormalTok{plt.yscale(}\StringTok{\textquotesingle{}log\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.grid()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-numerik/skript/intro_integrale_files/figure-pdf/cell-28-output-1.png}}

Alternativ kann auch das Flächenverhältnis zwischen der zu
integrierenden Funktion und einer Referenzfläche \(\mathsf{A_r}\)
gebildet werden. Hierzu werden \(\mathsf{n}\) Zufallszahlenpaare
\(\mathsf{(x_i, y_i)}\) generiert und gezählt wieviele davon in der
gesuchten Fläche liegen. Die Annahme ist, dass sich beide Verhältnisse
für große \(\mathsf{n}\) annähern. Im einfachsten Fall, wenn
\(\mathsf{f(x) \ge 0}\), gilt folgende Abschätzung

\[\mathsf {I \approx \frac{A_r \cdot \left|\left\{y_i \ |\  y_i < f(x_i)\right\}\right|}{n}} \]

Im obigen Beispiel kann die Fläche \(\mathsf{[0, 2] \times [0, 4] = 8}\)
als Referenzfläche verwendet werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{=} \DecValTok{2000}
\NormalTok{xi }\OperatorTok{=}\NormalTok{ np.random.random(n) }\OperatorTok{*} \DecValTok{2}
\NormalTok{yi }\OperatorTok{=}\NormalTok{ np.random.random(n) }\OperatorTok{*} \DecValTok{4}

\NormalTok{z }\OperatorTok{=}\NormalTok{ np.}\BuiltInTok{sum}\NormalTok{(yi }\OperatorTok{\textless{}}\NormalTok{ fkt(xi))}

\NormalTok{I }\OperatorTok{=}\NormalTok{ z }\OperatorTok{/}\NormalTok{ n }\OperatorTok{*} \DecValTok{8}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Integralwert für }\SpecialCharTok{\{}\NormalTok{n}\SpecialCharTok{\}}\SpecialStringTok{ Stützstellen: }\SpecialCharTok{\{}\NormalTok{I}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Integralwert für 2000 Stützstellen: 4.0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n\_max }\OperatorTok{=} \DecValTok{50000}
\NormalTok{dn }\OperatorTok{=} \DecValTok{250}
\NormalTok{ns }\OperatorTok{=}\NormalTok{ np.arange(dn, n\_max, dn, dtype}\OperatorTok{=}\BuiltInTok{int}\NormalTok{)}
\NormalTok{mc }\OperatorTok{=}\NormalTok{ np.zeros(}\BuiltInTok{len}\NormalTok{(ns))}

\NormalTok{xi }\OperatorTok{=}\NormalTok{ np.zeros(n\_max)}
\NormalTok{yi }\OperatorTok{=}\NormalTok{ np.zeros(n\_max)}

\ControlFlowTok{for}\NormalTok{ i, n }\KeywordTok{in} \BuiltInTok{enumerate}\NormalTok{(ns):}
\NormalTok{    xi[n}\OperatorTok{{-}}\NormalTok{dn:n] }\OperatorTok{=}\NormalTok{ np.random.random(dn) }\OperatorTok{*} \DecValTok{2}
\NormalTok{    yi[n}\OperatorTok{{-}}\NormalTok{dn:n] }\OperatorTok{=}\NormalTok{ np.random.random(dn) }\OperatorTok{*} \DecValTok{4}
\NormalTok{    z }\OperatorTok{=}\NormalTok{ np.}\BuiltInTok{sum}\NormalTok{(yi[:n] }\OperatorTok{\textless{}}\NormalTok{ fkt(xi[:n]))}
\NormalTok{    mc[i] }\OperatorTok{=}\NormalTok{ z }\OperatorTok{/}\NormalTok{ n }\OperatorTok{*} \DecValTok{8}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(ns, np.}\BuiltInTok{abs}\NormalTok{(mc}\OperatorTok{{-}}\NormalTok{I\_exakt))}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Anzahl der Stützstellen n\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Differenz zum exakten Wert\textquotesingle{}}\NormalTok{)}

\CommentTok{\# plt.xscale(\textquotesingle{}log\textquotesingle{})}
\NormalTok{plt.yscale(}\StringTok{\textquotesingle{}log\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.grid()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-numerik/skript/intro_integrale_files/figure-pdf/cell-31-output-1.png}}

\chapter{Differentiation}\label{differentiation}

Die numerische Bestimmung von Ableitungen wird hier anhand von zwei
Ansätzen demonstriert. Zum Einen als Differenzenquotienten und zum
Anderen über das Polynomfitting. Angewendet werden diese Verfahren z.B.
beim Suchen von Extrema in Experimental- oder Simulationsdaten, beim
Lösen von Differentialgleichungen oder bei Optimierungsverfahren.

Obwohl die analytische Bildung einer Ableitung oft viel einfacher ist
als die Integration, ist dies in den oben genannten Fällen nicht direkt
möglich. Gesucht ist hierbei immer die Ableitung \(\mathsf{f'(x)}\)
einer Funktion \(\mathsf{f(x)}\) oder einer diskreten Punktmenge
\(\mathsf{(x_i, y_i)}\) an einer bestimmten Stelle \(\mathsf{x=x_0}\)
oder auf einem Intervall.

Die Grundidee bei den hier vorgestellten Differenzenquotienten bzw.
Differenzenformeln ist die Annäherung der abzuleitenden Funktion mit
einer Taylor-Entwicklung an mehreren Stellen. Damit kann nach der
gesuchte Ableitung an der entsprechenden Entwicklungsstelle aufgelöst
werden.

\section{Taylor-Entwicklung}\label{taylor-entwicklung}

Mittels der
\href{https://de.wikipedia.org/wiki/Taylorreihe}{Taylor-Entwicklung}
kann jede beliebig oft stetig differenzierbare Funktion
\(\mathsf{f(x)}\) um einem Entwicklungspunkt \(\mathsf{x_0}\) beliebig
genau angenähert werden. Die funktionale Abhängigkeit bezieht sich nun
auf die Variable \(\mathsf{h}\), welche nur in direkter Umgebung um
\(\mathsf{x_0}\) betrachtet wird. Die Taylor-Entwicklung lautet:

\[ \mathsf{f(x_0 + h) = \sum_{i=0}^{\infty}\frac{1}{i!}f^{(i)}(x_0)\cdot h^i} \]
\[ \mathsf{ = f(x_0) + f'(x_0)\cdot h + \frac{1}{2} f''(x_0)\cdot h^2 + \frac{1}{6}f'''(x_0)\cdot h^3 + \cdots} \]

Diese Entwicklung kann auch nur bis zu einer vorgegebenen Ordnung
betrachtet werden. So nimmt die Entwicklung bis zur Ordnung
\(\mathsf{ \mathcal{O}(h^3)}\) folgende Form an:

\[\mathsf{ f(x_0 + h) = f(x_0) + f'(x_0)\cdot h + \frac{1}{2} f''(x_0)\cdot h^2 + \mathcal{O}(h^3)} \]

Hierbei deutet das Landau-Symbol \(\mathsf{\mathcal{O}}\) die Ordnung
an, welche die vernachlässigten Terme, hier ab \(\mathsf{h^3}\), als
Approximationsfehler zusammenfasst. Die Ordnung gibt an wie schnell bzw.
mit welchem funktionalem Zusammenhang der Approximationsfehler gegen
Null läuft für \(\mathsf{h \rightarrow 0}\).

Eine graphische Darstellung der ersten Elemente der Reihe verdeutlichen
nochmals die Grundidee. Das folgende Beispiel entwickelt die Funktion

\[ \mathsf{f(x) = \sin(3x) + 2x} \]

am Punkt \(\mathsf{x_0=0.85}\).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ fkt(x, p}\OperatorTok{=}\DecValTok{0}\NormalTok{):}
    \ControlFlowTok{if}\NormalTok{ p}\OperatorTok{==}\DecValTok{0}\NormalTok{:}
        \ControlFlowTok{return}\NormalTok{ np.sin(}\DecValTok{3}\OperatorTok{*}\NormalTok{x) }\OperatorTok{+} \DecValTok{2}\OperatorTok{*}\NormalTok{x}
    \ControlFlowTok{if}\NormalTok{ p}\OperatorTok{==}\DecValTok{1}\NormalTok{:}
        \ControlFlowTok{return} \DecValTok{3}\OperatorTok{*}\NormalTok{np.cos(}\DecValTok{3}\OperatorTok{*}\NormalTok{x) }\OperatorTok{+} \DecValTok{2}
    \ControlFlowTok{if}\NormalTok{ p}\OperatorTok{==}\DecValTok{2}\NormalTok{:}
        \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{9}\OperatorTok{*}\NormalTok{np.sin(}\DecValTok{3}\OperatorTok{*}\NormalTok{x)}
    \ControlFlowTok{if}\NormalTok{ p}\OperatorTok{==}\DecValTok{3}\NormalTok{:}
        \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{27}\OperatorTok{*}\NormalTok{np.cos(}\DecValTok{3}\OperatorTok{*}\NormalTok{x)}
    \ControlFlowTok{return} \VariableTok{None}

\CommentTok{\# Daten für die Visualisierung}
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{100}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ fkt(x, p}\OperatorTok{=}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x0 }\OperatorTok{=} \FloatTok{0.85}

\CommentTok{\# Taylor{-}Elemente}
\NormalTok{te }\OperatorTok{=}\NormalTok{ []}
\NormalTok{te.append(}\DecValTok{0}\OperatorTok{*}\NormalTok{(x}\OperatorTok{{-}}\NormalTok{x0) }\OperatorTok{+}\NormalTok{ fkt(x0, p}\OperatorTok{=}\DecValTok{0}\NormalTok{))}
\NormalTok{te.append((x}\OperatorTok{{-}}\NormalTok{x0) }\OperatorTok{*}\NormalTok{ fkt(x0, p}\OperatorTok{=}\DecValTok{1}\NormalTok{))}
\NormalTok{te.append((x}\OperatorTok{{-}}\NormalTok{x0)}\OperatorTok{**}\DecValTok{2} \OperatorTok{*}\NormalTok{ fkt(x0, p}\OperatorTok{=}\DecValTok{2}\NormalTok{) }\OperatorTok{*} \DecValTok{1}\OperatorTok{/}\DecValTok{2}\NormalTok{)}
\NormalTok{te.append((x}\OperatorTok{{-}}\NormalTok{x0)}\OperatorTok{**}\DecValTok{3} \OperatorTok{*}\NormalTok{ fkt(x0, p}\OperatorTok{=}\DecValTok{3}\NormalTok{) }\OperatorTok{*} \DecValTok{1}\OperatorTok{/}\DecValTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y, color}\OperatorTok{=}\StringTok{\textquotesingle{}Grey\textquotesingle{}}\NormalTok{, lw}\OperatorTok{=}\DecValTok{3}\NormalTok{, label}\OperatorTok{=}\StringTok{"Funktion"}\NormalTok{)}
\NormalTok{plt.plot(x, te[}\DecValTok{0}\NormalTok{], label}\OperatorTok{=}\StringTok{"$}\ErrorTok{\textbackslash{}}\StringTok{mathsf\{}\ErrorTok{\textbackslash{}}\StringTok{mathcal}\SpecialCharTok{\{O\}}\StringTok{(1)\}$"}\NormalTok{)}
\NormalTok{plt.plot(x, te[}\DecValTok{0}\NormalTok{] }\OperatorTok{+}\NormalTok{ te[}\DecValTok{1}\NormalTok{], label}\OperatorTok{=}\StringTok{"$}\ErrorTok{\textbackslash{}}\StringTok{mathsf\{}\ErrorTok{\textbackslash{}}\StringTok{mathcal}\SpecialCharTok{\{O\}}\StringTok{(h)\}$"}\NormalTok{)}
\NormalTok{plt.plot(x, te[}\DecValTok{0}\NormalTok{] }\OperatorTok{+}\NormalTok{ te[}\DecValTok{1}\NormalTok{] }\OperatorTok{+}\NormalTok{ te[}\DecValTok{2}\NormalTok{], label}\OperatorTok{=}\StringTok{"$}\ErrorTok{\textbackslash{}}\StringTok{mathsf\{}\ErrorTok{\textbackslash{}}\StringTok{mathcal}\SpecialCharTok{\{O\}}\StringTok{(h\^{}2)\}$"}\NormalTok{)}
\NormalTok{plt.plot(x, te[}\DecValTok{0}\NormalTok{] }\OperatorTok{+}\NormalTok{ te[}\DecValTok{1}\NormalTok{] }\OperatorTok{+}\NormalTok{ te[}\DecValTok{2}\NormalTok{] }\OperatorTok{+}\NormalTok{ te[}\DecValTok{3}\NormalTok{], label}\OperatorTok{=}\StringTok{"$}\ErrorTok{\textbackslash{}}\StringTok{mathsf\{}\ErrorTok{\textbackslash{}}\StringTok{mathcal}\SpecialCharTok{\{O\}}\StringTok{(h\^{}3)\}$"}\NormalTok{)}

\NormalTok{plt.vlines(x0, ymin}\OperatorTok{=}\DecValTok{0}\NormalTok{, ymax}\OperatorTok{=}\NormalTok{fkt(x0), color}\OperatorTok{=}\StringTok{\textquotesingle{}Grey\textquotesingle{}}\NormalTok{, ls}\OperatorTok{=}\StringTok{\textquotesingle{}{-}{-}\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.5}\NormalTok{)}

\NormalTok{plt.ylim([}\DecValTok{0}\NormalTok{,}\DecValTok{4}\NormalTok{])}

\NormalTok{plt.legend(bbox\_to\_anchor}\OperatorTok{=}\NormalTok{(}\FloatTok{1.05}\NormalTok{, }\FloatTok{1.0}\NormalTok{), loc}\OperatorTok{=}\StringTok{\textquotesingle{}upper left\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}y\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<>:2: SyntaxWarning: invalid escape sequence '\m'
<>:3: SyntaxWarning: invalid escape sequence '\m'
<>:4: SyntaxWarning: invalid escape sequence '\m'
<>:5: SyntaxWarning: invalid escape sequence '\m'
<>:2: SyntaxWarning: invalid escape sequence '\m'
<>:3: SyntaxWarning: invalid escape sequence '\m'
<>:4: SyntaxWarning: invalid escape sequence '\m'
<>:5: SyntaxWarning: invalid escape sequence '\m'
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_80918/2784086881.py:2: SyntaxWarning: invalid escape sequence '\m'
  plt.plot(x, te[0], label="$\mathsf{\mathcal{O}(1)}$")
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_80918/2784086881.py:3: SyntaxWarning: invalid escape sequence '\m'
  plt.plot(x, te[0] + te[1], label="$\mathsf{\mathcal{O}(h)}$")
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_80918/2784086881.py:4: SyntaxWarning: invalid escape sequence '\m'
  plt.plot(x, te[0] + te[1] + te[2], label="$\mathsf{\mathcal{O}(h^2)}$")
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_80918/2784086881.py:5: SyntaxWarning: invalid escape sequence '\m'
  plt.plot(x, te[0] + te[1] + te[2] + te[3], label="$\mathsf{\mathcal{O}(h^3)}$")
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-numerik/skript/intro_ableitungen_files/figure-pdf/cell-5-output-2.png}}

\section{Differenzenformeln}\label{differenzenformeln}

In diesem Abschnitt werden Berechnungsformeln für die Approximation von
Ableitungen durch Bildung von Funktionswertdifferenzen vorgestellt.
Diese beruhen alle auf der Taylor-Entwicklung und können für beliebige
Ableitungen und Ordnungen formuliert werden. Die einfachsten davon
werden hier vorgestellt.

\subsection{Erste Ableitung erster
Ordnung}\label{erste-ableitung-erster-ordnung}

Die einfachste Differenzenformel ergibt sich aus der Taylor-Reihe bis
\(\mathsf{\mathcal{O}(h^2)}\). Hier kann die Reihe direkt nach der
gesuchten Ableitung an der Stelle \(\mathsf{x_0}\) umgeformt werden.

\[\mathsf{f(x_0 + h) = f(x_0) + f'(x_0)h + \mathcal{O}(h^2)} \]
\[\mathsf{\Rightarrow \quad f'(x_0) = \frac{f(x_0 + h) - f(x_0)}{h} + \mathcal{O}(h)} \]

Dies ist die vorwärtsgerichtete Differenzformel erster Ordnung für die
erste Ableitung. Erste Ordnung bedeutet hierbei, dass im Grenzwert
\(\mathsf{h\rightarrow 0}\) der Approximationsfehler linear mit der
Schrittweite abnimmt.

Nach dieser Formel muss die abzuleitende Funktion an zwei Stellen
\(\mathsf{f(x_0)}\) und \(\mathsf{f(x_0+h)}\) ausgewertet werden, um die
Ableitung numerisch zu bestimmen. Im Grenzwert für eine beliebig kleine
Schrittweite, d.h. \(\mathsf{h \rightarrow 0}\), nähert sich dieser
Quotient der exakten Ableitung an der Stelle \(\mathsf{x_0}\) an.

Das folgende Beispiel demonstriert die Näherung anhand der Funktion

\[ \mathsf{f(x) = \sin(3x) + 2x} \]

Die Ableitung wird an der Stelle \(\mathsf{x_0 = 0.85}\) angenähert.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ fkt(x):}
    \ControlFlowTok{return}\NormalTok{ np.sin(}\DecValTok{3}\OperatorTok{*}\NormalTok{x) }\OperatorTok{+} \DecValTok{2}\OperatorTok{*}\NormalTok{x}

\CommentTok{\# Daten für die Visualisierung}
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{100}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ fkt(x)}

\CommentTok{\# Exakte Lösung bei x=0.85}
\NormalTok{fp\_exakt }\OperatorTok{=} \DecValTok{3}\OperatorTok{*}\NormalTok{np.cos(}\DecValTok{3}\OperatorTok{*}\FloatTok{0.85}\NormalTok{) }\OperatorTok{+} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Entwicklungspunkt und Schrittweite}
\NormalTok{h }\OperatorTok{=} \FloatTok{0.25}
\NormalTok{x0 }\OperatorTok{=} \FloatTok{0.85}

\CommentTok{\# Auswertung an den beiden Stellen}
\NormalTok{f0 }\OperatorTok{=}\NormalTok{ fkt(x0)}
\NormalTok{fh }\OperatorTok{=}\NormalTok{ fkt(x0 }\OperatorTok{+}\NormalTok{ h)}

\CommentTok{\# Bestimmung der Ableitungsnäherung}
\NormalTok{fp }\OperatorTok{=}\NormalTok{ (fh }\OperatorTok{{-}}\NormalTok{ f0) }\OperatorTok{/}\NormalTok{ h}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die numerische Näherung der Ableitung an der Stelle }\SpecialCharTok{\{}\NormalTok{x0}\SpecialCharTok{:.2f\}}\SpecialStringTok{:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Näherung mit Schrittweite }\SpecialCharTok{\{}\NormalTok{h}\SpecialCharTok{:.2f\}}\SpecialStringTok{: }\SpecialCharTok{\{}\NormalTok{fp}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Exakter Wert: }\SpecialCharTok{\{}\NormalTok{fp\_exakt}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die numerische Näherung der Ableitung an der Stelle 0.85:
Näherung mit Schrittweite 0.25: -0.86
Exakter Wert: -0.49
\end{verbatim}

Die Methode kann auch graphisch dargestellt werden. Die gesuchte
Steigung ist die Steigung der eingezeichneten Geraden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y, label}\OperatorTok{=}\StringTok{"Funktion"}\NormalTok{)}
\NormalTok{plt.scatter([x0], [f0], color}\OperatorTok{=}\StringTok{\textquotesingle{}C3\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Entwicklungspunkt\textquotesingle{}}\NormalTok{, zorder}\OperatorTok{=}\DecValTok{3}\NormalTok{)}
\NormalTok{plt.scatter([x0}\OperatorTok{+}\NormalTok{h], [fh], color}\OperatorTok{=}\StringTok{\textquotesingle{}C4\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Auswertepunkte\textquotesingle{}}\NormalTok{, zorder}\OperatorTok{=}\DecValTok{3}\NormalTok{)}

\NormalTok{plt.vlines(x0, ymin}\OperatorTok{=}\DecValTok{0}\NormalTok{, ymax}\OperatorTok{=}\NormalTok{f0, color}\OperatorTok{=}\StringTok{\textquotesingle{}C3\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.5}\NormalTok{)}

\NormalTok{plt.plot(x, f0 }\OperatorTok{+}\NormalTok{ fp}\OperatorTok{*}\NormalTok{(x}\OperatorTok{{-}}\NormalTok{x0), label}\OperatorTok{=}\StringTok{\textquotesingle{}Differenzenformel\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}y\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.legend(bbox\_to\_anchor}\OperatorTok{=}\NormalTok{(}\FloatTok{1.05}\NormalTok{, }\FloatTok{1.0}\NormalTok{), loc}\OperatorTok{=}\StringTok{\textquotesingle{}upper left\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-numerik/skript/intro_ableitungen_files/figure-pdf/cell-10-output-1.png}}

\subsection{Erste Ableitung zweiter
Ordnung}\label{erste-ableitung-zweiter-ordnung}

Mit dem gleichen Ansatz kann auch eine Differenzenformel zweiter Ordnung
gefunden werden. Dazu wird die Funktion an den Stellen
\(\mathsf{x_0-h}\) und \(\mathsf{x_0+h}\) mit der Taylor-Reihe bis zur
Ordnung \(\mathsf{\mathcal{O}(h^3)}\) approximiert.

\[\mathsf{f(x_0+h) = f(x_0) + f'(x_0)\cdot h + \frac{1}{2}f''(x_0)\cdot h^2 + \mathcal{O}(h^3)} \]
\[\mathsf{f(x_0-h) = f(x_0) - f'(x_0)\cdot h + \frac{1}{2}f''(x_0)\cdot h^2 + \mathcal{O}(h^3)} \]

Die Differenz dieser beiden Gleichungen führt zu

\[\mathsf{f(x_0+h) - f(x_0-h) = 2f'(x_0)\cdot h + \mathcal{O}(h^3)} \]

Und die Umformung nach der gesuchten Ableitung an der Stelle
\(\mathsf{x_0}\) ergibt

\[\mathsf{f'(x_0) = \frac{f(x_0+h) - f(x_0-h)}{2h} + \mathcal{O}(h^2)} \]

Dies ist die zentrale Differenzenformel für die erste Ableitung zweiter
Ordnung. Wie bei der vorwärtsgerichteten Formel muss hier die Funktion
an zwei Stellen ausgewertet werden, jedoch nicht mehr am
Entwicklungspunkt selbst. Durch diese Symmetrie bzgl. des
Entwicklungspunkts ergibt sich ein besseres, hier quadratisches,
Konvergenzverhalten.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Auswertung an den beiden Stellen}
\NormalTok{fnh }\OperatorTok{=}\NormalTok{ fkt(x0 }\OperatorTok{{-}}\NormalTok{ h)}
\NormalTok{fph }\OperatorTok{=}\NormalTok{ fkt(x0 }\OperatorTok{+}\NormalTok{ h)}

\CommentTok{\# Bestimmung der Ableitungsnäherung}
\NormalTok{fp }\OperatorTok{=}\NormalTok{ (fph }\OperatorTok{{-}}\NormalTok{ fnh) }\OperatorTok{/}\NormalTok{ (}\DecValTok{2}\OperatorTok{*}\NormalTok{h)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die numerische Näherung der Ableitung an der Stelle }\SpecialCharTok{\{}\NormalTok{x0}\SpecialCharTok{:.2f\}}\SpecialStringTok{:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Näherung mit Schrittweite }\SpecialCharTok{\{}\NormalTok{h}\SpecialCharTok{:.2f\}}\SpecialStringTok{: }\SpecialCharTok{\{}\NormalTok{fp}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Exakter Wert: }\SpecialCharTok{\{}\NormalTok{fp\_exakt}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die numerische Näherung der Ableitung an der Stelle 0.85:
Näherung mit Schrittweite 0.25: -0.26
Exakter Wert: -0.49
\end{verbatim}

Die Methode kann auch graphisch dargestellt werden. Die gesuchte
Steigung ist die Steigung der eingezeichneten Geraden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y, label}\OperatorTok{=}\StringTok{"Funktion"}\NormalTok{)}
\NormalTok{plt.scatter([x0], [f0], color}\OperatorTok{=}\StringTok{\textquotesingle{}C3\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Entwicklungspunkt\textquotesingle{}}\NormalTok{, zorder}\OperatorTok{=}\DecValTok{3}\NormalTok{)}
\NormalTok{plt.scatter([x0}\OperatorTok{{-}}\NormalTok{h, x0}\OperatorTok{+}\NormalTok{h], [fnh, fph], color}\OperatorTok{=}\StringTok{\textquotesingle{}C4\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Auswertepunkte\textquotesingle{}}\NormalTok{, zorder}\OperatorTok{=}\DecValTok{3}\NormalTok{)}

\NormalTok{plt.vlines(x0, ymin}\OperatorTok{=}\DecValTok{0}\NormalTok{, ymax}\OperatorTok{=}\NormalTok{f0, color}\OperatorTok{=}\StringTok{\textquotesingle{}C3\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.5}\NormalTok{)}

\NormalTok{plt.plot(x, fnh }\OperatorTok{+}\NormalTok{ fp}\OperatorTok{*}\NormalTok{(x}\OperatorTok{{-}}\NormalTok{x0}\OperatorTok{+}\NormalTok{h), label}\OperatorTok{=}\StringTok{\textquotesingle{}Differenzenformel\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}y\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.legend(bbox\_to\_anchor}\OperatorTok{=}\NormalTok{(}\FloatTok{1.05}\NormalTok{, }\FloatTok{1.0}\NormalTok{), loc}\OperatorTok{=}\StringTok{\textquotesingle{}upper left\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-numerik/skript/intro_ableitungen_files/figure-pdf/cell-13-output-1.png}}

\section{Zweite Ableitung zweiter
Ordnung}\label{zweite-ableitung-zweiter-ordnung}

Mit dem gleichen Schema wie oben, kann auch die Differenzenformel für
die zweite Ableitung bestimmt werden. Diese lautet

\[\mathsf{f''(x_0) = \frac{f(x_0-h) - 2f(x_0) + f(x_0+h)}{h^2} + \mathcal{O}(h^2)}\]

\section{Fehlerbetrachtung}\label{fehlerbetrachtung}

In diesem Abschnitt werden die Approximationsfehler, d.h. Fehler aus der
Differenzenformeln, und Rundungsfehler, d.h. Fehler durch die endliche
Genauigkeit der digitalen Darstellung von Zahlen, betrachtet.

\subsection{Approximationsfehler}\label{approximationsfehler}

Die Ordnung des Verfahrens kann durch die Betrachtung des Fehlers, hier
zum bekannten exakten Wert, bestimmt werden. Dazu wird die Schrittweite
kontinuierlich verkleinert.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ fkt(x):}
    \ControlFlowTok{return}\NormalTok{ np.sin(}\DecValTok{3}\OperatorTok{*}\NormalTok{x) }\OperatorTok{+} \DecValTok{2}\OperatorTok{*}\NormalTok{x}

\CommentTok{\# Daten für die Visualisierung}
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{100}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ fkt(x)}

\CommentTok{\# Exakte Lösung bei x=1}
\NormalTok{fp\_exakt }\OperatorTok{=} \DecValTok{3}\OperatorTok{*}\NormalTok{np.cos(}\DecValTok{3}\OperatorTok{*}\FloatTok{0.85}\NormalTok{) }\OperatorTok{+} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x0 }\OperatorTok{=} \FloatTok{0.85}

\NormalTok{hs }\OperatorTok{=}\NormalTok{ []}
\NormalTok{fpfs }\OperatorTok{=}\NormalTok{ []}
\NormalTok{fpcs }\OperatorTok{=}\NormalTok{ []}


\NormalTok{h0 }\OperatorTok{=} \DecValTok{1}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{18}\NormalTok{):}
\NormalTok{    h }\OperatorTok{=}\NormalTok{ h0 }\OperatorTok{/} \DecValTok{2}\OperatorTok{**}\NormalTok{i}

\NormalTok{    f0 }\OperatorTok{=}\NormalTok{ fkt(x0)}
\NormalTok{    fnh }\OperatorTok{=}\NormalTok{ fkt(x0 }\OperatorTok{{-}}\NormalTok{ h)}
\NormalTok{    fph }\OperatorTok{=}\NormalTok{ fkt(x0 }\OperatorTok{+}\NormalTok{ h)}

\NormalTok{    fpf }\OperatorTok{=}\NormalTok{ (fph }\OperatorTok{{-}}\NormalTok{ f0) }\OperatorTok{/}\NormalTok{ h}
\NormalTok{    fpc }\OperatorTok{=}\NormalTok{ (fph }\OperatorTok{{-}}\NormalTok{ fnh) }\OperatorTok{/}\NormalTok{ (}\DecValTok{2}\OperatorTok{*}\NormalTok{h)}
    
\NormalTok{    hs.append(h)}
\NormalTok{    fpfs.append(fpf)}
\NormalTok{    fpcs.append(fpc)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(hs, np.}\BuiltInTok{abs}\NormalTok{(fpfs }\OperatorTok{{-}}\NormalTok{ fp\_exakt), label}\OperatorTok{=}\StringTok{\textquotesingle{}vorwärts\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(hs, np.}\BuiltInTok{abs}\NormalTok{(fpcs }\OperatorTok{{-}}\NormalTok{ fp\_exakt), label}\OperatorTok{=}\StringTok{\textquotesingle{}zentral\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.plot([}\FloatTok{1e{-}5}\NormalTok{, }\FloatTok{1e{-}1}\NormalTok{], [}\FloatTok{1e{-}5}\NormalTok{, }\FloatTok{1e{-}1}\NormalTok{], }\StringTok{\textquotesingle{}{-}{-}\textquotesingle{}}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}grey\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Hilfslinien\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot([}\FloatTok{1e{-}5}\NormalTok{, }\FloatTok{1e{-}1}\NormalTok{], [}\FloatTok{1e{-}10}\NormalTok{, }\FloatTok{1e{-}2}\NormalTok{], }\StringTok{\textquotesingle{}{-}{-}\textquotesingle{}}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}grey\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Schrittweite h\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Fehler\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.xscale(}\StringTok{\textquotesingle{}log\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.yscale(}\StringTok{\textquotesingle{}log\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.legend()}
\NormalTok{plt.grid()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-numerik/skript/intro_ableitungen_files/figure-pdf/cell-17-output-1.png}}

In der logiarithmischen Darstellung beider Achsen werden
Potenzfunktionen zu Graden mit dem Potenzgrad als Steigung. Das
bedeutet, dass der Fehler im obigen Plot sich wie eine Potenzfunktion
mit dem Grad eins bzw. zwei verhält. Die eingezeichneten Hilfslinien
haben eine Steigung von eins bzw. zwei. Dies entspricht auch der Ordnung
\(\mathsf{\mathcal{O}(h)}\) bzw. \(\mathsf{\mathcal{O}(h^2)}\) aus der
Differenzenformel.

\subsection{Rundungsfehler}\label{rundungsfehler}

Wird nun die Schrittweiter noch weiter verkleinert, wirkt sich die
Genauigkeit der Darstellung von Zahlen bzw. Rundungsfehler auf die
Approximation aus.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x0 }\OperatorTok{=} \FloatTok{0.85}

\NormalTok{hs }\OperatorTok{=}\NormalTok{ []}
\NormalTok{fpfs }\OperatorTok{=}\NormalTok{ []}
\NormalTok{fpcs }\OperatorTok{=}\NormalTok{ []}


\NormalTok{h0 }\OperatorTok{=} \DecValTok{1}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{35}\NormalTok{):}
\NormalTok{    h }\OperatorTok{=}\NormalTok{ h0 }\OperatorTok{/} \DecValTok{2}\OperatorTok{**}\NormalTok{i}

\NormalTok{    f0 }\OperatorTok{=}\NormalTok{ fkt(x0)}
\NormalTok{    fnh }\OperatorTok{=}\NormalTok{ fkt(x0 }\OperatorTok{{-}}\NormalTok{ h)}
\NormalTok{    fph }\OperatorTok{=}\NormalTok{ fkt(x0 }\OperatorTok{+}\NormalTok{ h)}

\NormalTok{    fpf }\OperatorTok{=}\NormalTok{ (fph }\OperatorTok{{-}}\NormalTok{ f0) }\OperatorTok{/}\NormalTok{ h}
\NormalTok{    fpc }\OperatorTok{=}\NormalTok{ (fph }\OperatorTok{{-}}\NormalTok{ fnh) }\OperatorTok{/}\NormalTok{ (}\DecValTok{2}\OperatorTok{*}\NormalTok{h)}
    
\NormalTok{    hs.append(h)}
\NormalTok{    fpfs.append(fpf)}
\NormalTok{    fpcs.append(fpc)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(hs, np.}\BuiltInTok{abs}\NormalTok{(fpfs }\OperatorTok{{-}}\NormalTok{ fp\_exakt), label}\OperatorTok{=}\StringTok{\textquotesingle{}vorwärts\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(hs, np.}\BuiltInTok{abs}\NormalTok{(fpcs }\OperatorTok{{-}}\NormalTok{ fp\_exakt), label}\OperatorTok{=}\StringTok{\textquotesingle{}zentral\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.plot([}\FloatTok{1e{-}5}\NormalTok{, }\FloatTok{1e{-}1}\NormalTok{], [}\FloatTok{1e{-}5}\NormalTok{, }\FloatTok{1e{-}1}\NormalTok{], }\StringTok{\textquotesingle{}{-}{-}\textquotesingle{}}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}grey\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Hilfslinien\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot([}\FloatTok{1e{-}5}\NormalTok{, }\FloatTok{1e{-}1}\NormalTok{], [}\FloatTok{1e{-}10}\NormalTok{, }\FloatTok{1e{-}2}\NormalTok{], }\StringTok{\textquotesingle{}{-}{-}\textquotesingle{}}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}grey\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Schrittweite h\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Fehler\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.xscale(}\StringTok{\textquotesingle{}log\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.yscale(}\StringTok{\textquotesingle{}log\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.legend()}
\NormalTok{plt.grid()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-numerik/skript/intro_ableitungen_files/figure-pdf/cell-19-output-1.png}}

Wie bereits vorgestellt, können 64-Bit-Zahlen nur mit einer Genauigkeit
von etwa \(\mathsf{\epsilon\approx10^{-16}}\) dargestellt werden. Das
bedeutet, dass z.B. die Differenz von zwei Zahlen nicht genauer als
\(\mathsf{\epsilon}\) berechnet werden kann. Dies ist der sogenannte
Rundungsfehler.

Im konkreten Fall der Vorwärtsdifferenzenformel bedeutet dies:

\[ \mathsf{f'(x_0) = \frac{f(x_0 + h) - f(x_0)}{h} + \mathcal{O}(h)} \]
\[\mathsf{\overset{Rundungsfehler}{\Rightarrow} \frac{f(x_0 + h) - f(x_0) + \mathcal{O}(\epsilon)}{h} + \mathcal{O}(h)} \]
\[ \mathsf{= \frac{f(x_0 + h) - f(x_0)}{h} + \mathcal{O}\left(\frac{\epsilon}{h}\right) + \mathcal{O}(h)} \]

Damit macht eine Verkleinerung von \(\mathsf{h}\) nur Sinn, solange der
Rundungsfehler klein gegenüber \(\mathsf{h}\) ist. Genauer:

\[\mathsf{\frac{\epsilon}{h} \le h }\]
\[\mathsf{\Rightarrow \quad h \ge \sqrt{\epsilon}} \]

Mit \(\mathsf{\epsilon \approx 10^{-16}}\) ist für diese
Differenzenformel ein \(\mathsf{h}\) nur bis etwa \(\mathsf{10^{-8}}\)
angemessen.

\part{m-einlesen-strukturierter-datensaetze}

\chapter*{Methodenbaustein Einlesen strukturierter
Datensätze}\label{methodenbaustein-einlesen-strukturierter-datensuxe4tze}
\addcontentsline{toc}{chapter}{Methodenbaustein Einlesen strukturierter
Datensätze}

\markboth{Methodenbaustein Einlesen strukturierter
Datensätze}{Methodenbaustein Einlesen strukturierter Datensätze}

\phantomsection\label{Lizenz}
\begin{figure}

\begin{minipage}{0.20\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/m-einlesen-strukturierter-datensaetze/skript/00-bilder/CC-BY.pdf}}\end{minipage}%
%
\begin{minipage}{0.80\linewidth}
Bausteine Computergestützter Datenanalyse von Lukas Arnold, Simone
Arnold, Florian Bagemihl, Matthias Baitsch, Marc Fehr, Franca Hollmann,
Maik Poetzsch und Sebastian Seipel. Methodenbaustein Einlesen
strukturierter Datensätze von Maik Poetzsch ist lizensiert unter
\href{https://creativecommons.org/licenses/by/4.0/deed.de}{CC BY 4.0}.
Das Werk ist abrufbar auf
\href{https://github.com/bausteine-der-datenanalyse/m-einlesen-strukturierter-datensaetze}{GitHub}.
Ausgenommen von der Lizenz sind alle Logos Dritter und anders
gekennzeichneten Inhalte. 2025\end{minipage}%

\end{figure}%

Zitiervorschlag

Arnold, Lukas, Simone Arnold, Florian Bagemihl, Matthias Baitsch, Marc
Fehr, Franca Hollmann, Maik Poetzsch, und Sebastian Seipel. 2025.
„Bausteine Computergestützter Datenanalyse. Methodenbaustein Einlesen
strukturierter Datensätze''.
\url{https://github.com/bausteine-der-datenanalyse/m-einlesen-strukturierter-datensaetzee}.

BibTeX-Vorlage

\begin{verbatim}
@misc{BCD-m-esd-2025,
 title={Bausteine Computergestützter Datenanalyse. Methodenbaustein Einlesen strukturierter Datensätze.},
 author={Arnold, Lukas and Arnold, Simone and Bagemihl, Florian and Baitsch, Matthias and Fehr, Marc and Hollmann, Franca and Poetzsch, Maik and Seipel, Sebastian},
 year={2025},
 url={https://github.com/bausteine-der-datenanalyse/m-einlesen-strukturierter-datensaetze}} 
\end{verbatim}

\chapter*{Voraussetzungen}\label{voraussetzungen-7}
\addcontentsline{toc}{chapter}{Voraussetzungen}

\markboth{Voraussetzungen}{Voraussetzungen}

Die Bearbeitungszeit dieses Bausteins beträgt circa 10 Stunden. Für die
Bearbeitung dieses Bausteins werden folgende Bausteine vorausgesetzt und
die genannten Bibliotheken verwendet:

Bausteine:

\begin{itemize}
\tightlist
\item
  Werkzeugbausteine Python, NumPy, Pandas
\end{itemize}

Module:

\begin{itemize}
\item
  Modul os
\item
  Module NumPy, numpy.ma
\item
  Modul Pandas

  \begin{itemize}
  \item
    openpyxl \texttt{pip\ install\ openpyxl}
  \item
    xlrd \texttt{pip\ install\ xlrd}
  \item
    pytables \texttt{pip\ install\ tables}
  \end{itemize}
\item
  Modul h5py \texttt{pip\ install\ h5py}
\item
  Modul netCDF4 \texttt{pip\ install\ netCDF4}
\item
  Modul Matplotlib
\item
  Modul re (optional)
\item
  Module datetime, time, pytz, zoneinfo (optional)
\end{itemize}

Im Baustein werden folgende Daten verwendet:

\begin{itemize}
\item
  Zahnwachstum bei Meerschweinchen
  \href{https://github.com/vincentarelbundock/Rdatasets/blob/master/csv/datasets/ToothGrowth.csv}{CSV-Datei}
\item
  Strommarktdaten der Bundesnetzagentur
  \href{https://www.smard.de/home/downloadcenter/download-marktdaten/}{hier
  verfügbar} und der Austrian Power Grid AG (APG)
  \href{https://markttransparenz.apg.at/de/markt/Markttransparenz/erzeugung/Erzeugung-pro-Typ}{hier
  verfügbar}
\item
  Industriestrompreise in den Mitgliedsländern der Internationalen
  Energieagentur
  \href{https://www.gov.uk/government/uploads/system/uploads/attachment_data/file/670121/table_531.xls}{XLS-Datei}
\item
  Kursdaten des amerikanischen Aktienindexes S\&P500
  \href{https://img1.wsimg.com/blobby/go/e5e77e0b-59d1-44d9-ab25-4763ac982e53/downloads/ie_data.xls?ver=1712069253887}{XLS-Datei}.
\item
  US State Facts and Figures, die in R abgerufen werden können.
\item
  DSB Unfallatlas der
  \href{https://unfallatlas.statistikportal.de/}{statistischen Ämter des
  Bundes und der Länder}
\item
  Europäische Gaspreise von Eurostat
  \href{https://ec.europa.eu/eurostat/statistics-explained/images/3/32/SE_figures_for_Gas_2023S2_v3.xlsx.}{XLSX-Datei}
\item
  Baugenehmigungen, verfügbar beim
  \href{https://www-genesis.destatis.de/datenbank/online/table/31111-0006/sequenz=tabelleErgebnis&selectionname=31111-0006&zeitscheiben=1}{Statistischen
  Bundesamt}
\item
  Eisdicke in der Arktis und Antarktis
  \href{https://nsidc.org/data/ilatm1b/versions/2\#anchor-data-access-tools}{kostenlose
  Registrierung bei NASA Earth erforderlich}
\item
  Blitzdichte
  \href{https://www.earthdata.nasa.gov/data/catalog/ghrc-daac-lohrfc-2.3.2015}{kostenlose
  Registrierung bei NASA Earth erforderlich}
\end{itemize}

\chapter*{Lernziele}\label{lernziele-7}
\addcontentsline{toc}{chapter}{Lernziele}

\markboth{Lernziele}{Lernziele}

In diesem Baustein lernen Sie \ldots{}

\begin{itemize}
\item
  Datensätze unterschiedlicher Struktur und Formate einzulesen, zu
  bearbeiten und zu speichern.
\item
  den Unterschied zwischen identifizierenden und gemessenen Variablen
  kennen sowie Datensätze ins long- und wide-Format zu konvertieren.
\item
  das System tidy data kennen.
\item
  typische Probleme beim Einlesen von Datensätzen und Strategien zu
  deren Lösung kennen.
\end{itemize}

\chapter{Einleitung}\label{einleitung-2}

~

2016 stellte eine Studie fest, dass ein Fünftel aller wissenschaftlichen
Artikel im Bereich der Genetik auf der Grundlage von durch die
Tabellenkalkulation Excel verfälschten Daten durchgeführt wurde
{[}@Ziemann-2016{]}. Genbezeichnungen wie ``MARCH1'' wurden
fälschlicherweise in ein Datumsformat umgewandelt. 2021 wurde diese
Schätzung des Anteils betroffener Arbeiten sogar auf 30 Prozent
angehoben.
(\href{https://www.heise.de/news/Excel-wandelt-Genbezeichnungen-in-Datumsangaben-um-Problem-groesser-als-gedacht-6165902.html}{heise
online})

Am Beginn der computergestützten Datenanalyse steht das Einlesen von
Daten aus Dateien. In der Praxis ist das Einlesen von Daten alles andere
als trivial. Daten werden in einer Vielzahl von Dateiformaten
gespeichert. Deshalb ist es in der Datenanalyse erforderlich, mit
verschiedenen Dateiformaten umgehen zu können: mit wenigen Kilobyte
großen Textdateien, offenen und proprietären Formaten gängiger
Büroanwendungen und mehreren hundert Megabyte großen Dateien in speziell
für den Austausch wissenschaftlicher Daten entwickelten Formaten.
Programmiersprachen wie Python und R bringen verschiedene Werkzeuge zum
Lesen, Bearbeiten und Speichern von verschiedenen Dateiformaten mit.
Spezialisierte Pakete ergänzen den Werkzeugkasten.

Die praktischen Herausforderungen der Datenanalyse beschränken sich
jedoch nicht nur auf technische Aspekte. Oftmals bereitet der innere
Aufbau von Datensätzen die größten Schwierigkeiten. Ein wichtiger
Bestandteil des Einlesens strukturierter Datensätze besteht darin,
Fehler im Datensatz zu suchen und ggf. zu bereinigen. Dasu und Johnson
schreiben:

\begin{figure}

\begin{minipage}{0.05\linewidth}
~\end{minipage}%
%
\begin{minipage}{0.90\linewidth}
``Unfortunately, the data set is usually dirty, composed of many tables,
and has unknown properties. Before any results can be produced, the data
must be cleaned and explored---often a long and difficult task.
{[}\ldots{]} In our experience, the tasks of exploratory data mining and
data cleaning constitute 80\% of the effort that determines 80\% of the
value of the ultimate data mining results.'' (@Dasu-Johnson-2003, S.
ix)\end{minipage}%
%
\begin{minipage}{0.05\linewidth}
~\end{minipage}%

\end{figure}%

~

Das Einlesen strukturierter Datensätze umfasst somit den gesamten
Prozess des technischen Zugriffs auf Dateien, der Organisation,
Fehlersuche und -korrektur sowie des Abspeicherns der Daten in einer für
die weitere Bearbeitung geeigneten Form.

In der praktischen Datenanalyse helfen zwei einfache Tipps beim Einlesen
strukturierter Datensätze:

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-editor}}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-editor} 

\textbf{Schauen Sie sich Ihre Daten an, bevor Sie diese mit Python
einlesen!} Dafür reicht ein Texteditor oder ein
Tabellenkalkulationsprogramm (hier die automatische Erkennung und
Umwandlung von Datumsformaten beachten). Ein kurzer Blick genügt, um die
verwendeten Zeichentrenner, Tausendertrennzeichen, Datumsformate, die
Kodierung fehlender Werte und die Unicode-Kodierung (wie UTF-8) zu
identifizieren.

\end{tcolorbox}

Dies ist aber nicht immer möglich, beispielsweise wenn Ihr Datensatz aus
hunderten Spalten und zehntausenden Zeilen besteht. Dieser Baustein
vermittelt deshalb die Handwerkszeuge, um Datensätze ausschließlich mit
den in Python verfügbaren Mitteln einzulesen.

Es ist nicht erforderlich, die Besonderheiten aller hier vorgestellten
Pakete und Funktionen auswendig zu beherrschen. Dafür ist das Themenfeld
zu komplex und nicht selten ändert sich das Verhalten von Funktionen mit
der Weiterentwicklung der Programmiersprache. Die hier vorgestellten
Besonderheiten von Funktionen dienen jedoch als mentale Ankerpunkte, die
als Anknüpfungspunkt dienen sollen, wenn Sie in der Praxis auf Probleme
stoßen.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-dokumentation}}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-dokumentation} 

\textbf{Benutzen Sie die Dokumentation!} Auf diese Weise erhalten Sie
einen vollständigen Überblick über standardmäßig gesetzte und optional
verfügbare Parameter. Außerdem erkennen Sie Änderungen in der
Programmausführung und vermeiden so unerwartete Fehler.

\begin{figure}[H]

\begin{minipage}{0.50\linewidth}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/m-einlesen-strukturierter-datensaetze/skript/00-bilder/added-in-pyhton.png}}

}

\subcaption{Neuerung in Python}

\end{figure}%

\end{minipage}%
%
\begin{minipage}{0.50\linewidth}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/m-einlesen-strukturierter-datensaetze/skript/00-bilder/deprecated-in-python.png}}

}

\subcaption{Abkündigung in Python}

\end{figure}%

\end{minipage}%

\end{figure}%

\end{tcolorbox}

\chapter{Grundlagen: Merkmale von
Datensätzen}\label{grundlagen-merkmale-von-datensuxe4tzen}

Bevor wir uns mit den praktischen Herausforderungen des Einlesens
strukturierter Datensätze beschäftigten, werden zunächst einige Merkmale
von Datensätzen behandelt, um ein grundlegendes Verständnis der
Begrifflichkeiten zu schaffen und den Umgang der in der Basis von Python
enthaltenen Werkzeuge zu vermitteln. Am Ende dieses Kapitels wird mit
tidy data ein grundlegendes Konzept zur Organisation von Datensätzen
vorgestellt.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-Datensatz}: Datensatz}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-Datensatz} 

Ein Datensatz ist eine Sammlung zusammengehöriger Daten. Datensätze
enthalten einer oder mehreren Variablen zugeordnete Werte. Jeder
Datensatz besitzt ein technisches Format, eine Struktur, mindestens eine
Variable und mindestens einen Wert.

\end{tcolorbox}

\section{Technisches Format}\label{technisches-format}

Das technische Format eines Datensatzes gibt vor, mit welchen Mitteln
Daten eingelesen, bearbeitet und gespeichert werden können. Einige
Beispiele sind:

\begin{itemize}
\item
  Druckerzeugnis, z. B. Telefonbuch: manuelles Ablesen von Name und
  Telefonnummer, irreversible Bearbeitung per Stift
\item
  Lochkarte, z. B. Parkschein: Lesegerät erkennt Lochung und gewährt
  eine Freistunde, irreversible Bearbeitung mit Stanzgerät
\item
  Textdatei, z. B. Einwohnerzahl nach Bundesländern: Kann mit einer
  Vielzahl von Computerprogrammen wie Texteditor,
  Tabellenkalkulationsprogramm oder Programmierumgebung eingelesen,
  bearbeitet und gespeichert werden.
\item
  Hierarchical Data Format HDF5, z. B. räumliche Daten zur Blitzdichte:
  benötigt spezialisierte Programme oder Pakete
\end{itemize}

\section{Struktur}\label{struktur}

Datensätze speichern Daten in einer definierten n-dimensionalen
Struktur.

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/m-einlesen-strukturierter-datensaetze/skript/00-bilder/slicing_mf_mp.png}}

}

\caption{n-dimensionale Datensätze}

\end{figure}%

slicing von Marc Fehr ist lizensiert unter
\href{https://github.com/bausteine-der-datenanalyse/w-python-numpy-grundlagen\#CC-BY-4.0-1-ov-file}{CC-BY-4.0}
und abrufbar auf
\href{https://github.com/bausteine-der-datenanalyse/w-python-numpy-grundlagen}{GitHub}.
2024

\subsection{Eindimensionale
Datensätze}\label{eindimensionale-datensuxe4tze}

Die einfachste Form sind eindimensionale Datensätze, die Werte einer
einzigen Variablen zuordnen. Eindimensionale Datensätze mit Werten des
gleichen Typs (bspw. Zahlen) werden \textbf{Vektor} genannt.
Eindimensionale Datensätze, die unterschiedliche Datentypen enthalten
können, heißen \textbf{Liste}. Eindimensionale Datensätze verfügen
lediglich über eine Achse: den Index, über den Elemente angesprochen
werden können.

\begin{figure}[H]

{\centering \includegraphics[width=0.5\linewidth,height=\textheight,keepaspectratio]{books/m-einlesen-strukturierter-datensaetze/skript/00-bilder/eindimensionaler-datensatz-slicing-mf-mp.png}

}

\caption{eindimensionale Datensätze}

\end{figure}%

slicing von Marc Fehr ist lizensiert unter
\href{https://github.com/bausteine-der-datenanalyse/w-python-numpy-grundlagen\#CC-BY-4.0-1-ov-file}{CC-BY-4.0}
und abrufbar auf
\href{https://github.com/bausteine-der-datenanalyse/w-python-numpy-grundlagen}{GitHub}.
Die Grafik wurde auf den gezeigten Teil beschnitten und die obenstehende
Beschriftung entfernt. 2024

~

Beispiele eindimensionaler Datensätze sind ein Einkaufszettel oder die
Urliste eines Würfelexperiments. Über den Index kann beispielsweise das
Würfelergebnis an der Indexposition 2 ausgegeben werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{( }\OperatorTok{*}\NormalTok{( Augen }\OperatorTok{:=}\NormalTok{ [}\DecValTok{6}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{] ) )}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Das Würfelergebnis an Indexposition 2 lautet: }\SpecialCharTok{\{}\NormalTok{Augen[}\DecValTok{2}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
6 2 1 2
Das Würfelergebnis an Indexposition 2 lautet: 1
\end{verbatim}

\subsection{Eindimensionale Daten einlesen mit
Python}\label{eindimensionale-daten-einlesen-mit-python}

An dieser Stelle eine kleine Wiederholung aus dem
\href{https://bausteine-der-datenanalyse.github.io/w-python/output/book/}{Werkzeugbaustein
Python}:\\
Die Pythonbasis greift über Dateiobjekte auf Dateien zu. Die Funktionen
und Methoden haben Sie im Werkzeugbaustein Python kennengelernt. Der
Zugriff auf Dateien über die Pythonbasis ist eine verlässliche
Rückfalloption und darüber hinaus nützlich, um die Enkodierung einer
Datei zu bestimmen.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-openundco}: Kleine Wiederholung: Funktionen und Methoden der Pythonbasis}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-openundco} 

\begin{itemize}
\tightlist
\item
  Die Funktion \texttt{os.getcwd()} aus dem Modul os gibt das aktuelle
  Arbeitsverzeichnis aus, mit der Funktion \texttt{os.cwd(pfad)} kann es
  gewechselt werden.
\item
  Die Funktion
  \texttt{open(dateipfad,\ mode\ =\ \textquotesingle{}r\textquotesingle{})}
  öffnet eine Datei im Lesemodus und gibt ein Dateiobjekt zurück.
\item
  Informationen zum Dateiobjekt können durch Ausgabe verschiedener
  Attribute abgerufen werden: \texttt{dateiobjekt.name},
  \texttt{os.path.basename(dateiobjekt.name)},
  \texttt{dateiobjekt.closed}, \texttt{dateiobjekt.mode},
  \texttt{dateiobjekt.encoding}
\item
  Das Dateiobjekt kann mit Methoden wie \texttt{dateiobjekt.read()},
  \texttt{dateiobjekt.readline()}, \texttt{dateiobjekt.readlines()} oder
  der Funktion \texttt{list(dateiobjekt)} ausgelesen werden.
\item
  Die Methode \texttt{dateiobjekt.close()} schließt die Datei und gibt
  sie somit wieder für andere Programme frei.
\end{itemize}

\end{tcolorbox}

\textbf{Lesen Sie die Datei ``python.txt'' unter dem dateipfad
``skript/01-daten/'' ein.}

\begin{itemize}
\item
  Bestimmen Sie die Enkodierung der Datei.
\item
  Entfernen Sie die die erste Zeile aus dem Text und geben Sie den Text
  mit Python aus.
\item
  Wie kann der Text korrekt dargestellt werden?
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-pythonbasis}: Musterlösung python.txt}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-pythonbasis} 

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/"} \OperatorTok{+} \StringTok{"python.txt"}
\NormalTok{dateiobjekt }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(dateipfad, mode }\OperatorTok{=} \StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Enkodierung der Datei bestimmen}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Enkodierung der Datei lautet: }\SpecialCharTok{\{}\NormalTok{dateiobjekt}\SpecialCharTok{.}\NormalTok{encoding}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# Text ausgeben}
\NormalTok{text\_als\_liste }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(dateiobjekt)}

\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\BuiltInTok{len}\NormalTok{(text\_als\_liste)):}
  \BuiltInTok{print}\NormalTok{(text\_als\_liste[i])}

\CommentTok{\# Datei schließen.}
\NormalTok{dateiobjekt.close()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Enkodierung der Datei lautet: UTF-8


Python ist eine universell nutzbare, üblicherweise interpretierte, höhere Programmiersprache.[14] Sie hat den Anspruch, einen gut lesbaren, knappen Programmierstil zu fördern.[15] So werden beispielsweise Blöcke nicht durch geschweifte Klammern, sondern durch Einrückungen strukturiert. 

Python wurde mit dem Ziel größter Einfachheit und Übersichtlichkeit entworfen. Dies wird vor allem durch zwei Maßnahmen erreicht. Zum einen kommt die Sprache mit relativ wenigen Schlüsselwörtern aus.[49] Zum anderen ist die Syntax reduziert und auf Übersichtlichkeit optimiert. Dadurch lassen sich Python-basierte Skripte deutlich knapper formulieren als in anderen Sprachen.[50]

Van Rossum legte bei der Entwicklung großen Wert auf eine Standardbibliothek, die überschaubar und leicht erweiterbar ist. Dies war Ergebnis seiner schlechten Erfahrung mit der Sprache ABC, in der das Gegenteil der Fall ist.[51] Dieses Konzept ermöglicht, in Python Module aufzurufen, die in anderen Programmiersprachen geschrieben wurden, etwa um Schwächen von Python auszugleichen. Beispielsweise können für zeitkritische Teile in maschinennäheren Sprachen wie C implementierte Routinen aufgerufen werden.



Auszug aus https://de.wikipedia.org/wiki/Python_(Programmiersprache), abgerufen am 20.02.2025
\end{verbatim}

Enkodierung UTF-8 auswählen.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Mit europäischen Sonderzeichen kompatible Enkodierung UTF{-}8 wählen}
\NormalTok{dateiobjekt }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(dateipfad, mode }\OperatorTok{=} \StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{, encoding }\OperatorTok{=} \StringTok{\textquotesingle{}utf{-}8\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Text ausgeben}
\NormalTok{text\_als\_liste }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(dateiobjekt)}

\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\BuiltInTok{len}\NormalTok{(text\_als\_liste)):}
  \BuiltInTok{print}\NormalTok{(text\_als\_liste[i])}

\CommentTok{\# Datei schließen.}
\NormalTok{dateiobjekt.close()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}


Python ist eine universell nutzbare, üblicherweise interpretierte, höhere Programmiersprache.[14] Sie hat den Anspruch, einen gut lesbaren, knappen Programmierstil zu fördern.[15] So werden beispielsweise Blöcke nicht durch geschweifte Klammern, sondern durch Einrückungen strukturiert. 

Python wurde mit dem Ziel größter Einfachheit und Übersichtlichkeit entworfen. Dies wird vor allem durch zwei Maßnahmen erreicht. Zum einen kommt die Sprache mit relativ wenigen Schlüsselwörtern aus.[49] Zum anderen ist die Syntax reduziert und auf Übersichtlichkeit optimiert. Dadurch lassen sich Python-basierte Skripte deutlich knapper formulieren als in anderen Sprachen.[50]

Van Rossum legte bei der Entwicklung großen Wert auf eine Standardbibliothek, die überschaubar und leicht erweiterbar ist. Dies war Ergebnis seiner schlechten Erfahrung mit der Sprache ABC, in der das Gegenteil der Fall ist.[51] Dieses Konzept ermöglicht, in Python Module aufzurufen, die in anderen Programmiersprachen geschrieben wurden, etwa um Schwächen von Python auszugleichen. Beispielsweise können für zeitkritische Teile in maschinennäheren Sprachen wie C implementierte Routinen aufgerufen werden.



Auszug aus https://de.wikipedia.org/wiki/Python_(Programmiersprache), abgerufen am 20.02.2025
\end{verbatim}

\end{tcolorbox}

\subsection{Zweidimensionale
Datensätze}\label{zweidimensionale-datensuxe4tze}

Zweidimensionale Datensätze organisieren Werte in einer aus Zeilen und
Spalten bestehenden \textbf{Matrix} oder einem \textbf{Dataframe}. Eine
Matrix enthält nur einen Datentyp (bspw. Zahlen), ein Dataframe kann
unterschiedliche Datentypen enthalten (bspw. Zahlen und Wahrheitswerte).
In Python stellt das Modul Pandas die DataFrame-Struktur bereit (siehe
\href{https://bausteine-der-datenanalyse.github.io/w-pandas/output/book/}{Werkzeugbaustein
Pandas}).

\begin{figure}[H]

{\centering \includegraphics[width=0.45\linewidth,height=\textheight,keepaspectratio]{books/m-einlesen-strukturierter-datensaetze/skript/00-bilder/zweidimensionaler-datensatz-slicing-mf-mp.png}

}

\caption{zweidimensionaler Datensatz}

\end{figure}%

slicing von Marc Fehr ist lizensiert unter
\href{https://github.com/bausteine-der-datenanalyse/w-python-numpy-grundlagen\#CC-BY-4.0-1-ov-file}{CC-BY-4.0}
und abrufbar auf
\href{https://github.com/bausteine-der-datenanalyse/w-python-numpy-grundlagen}{GitHub}.
Die Grafik wurde auf den gezeigten Teil beschnitten und die obenstehende
Beschriftung entfernt. 2024

~

Typischerweise entspricht in zweidimensionalen Datensätzen jede Spalte
einer \textbf{Variablen} und jede Zeile einer \textbf{Beobachtung}.
Variablen speichern alle Werte eines Merkmals, zum Beispiel des
Würfelergebnisses. Beobachtungen speichern alle Werte, die für eine
Beobachtungseinheit gemessen wurden, z. B. für eine Person.
{[}@Wickham-2014, S. 3{]}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}

\NormalTok{messung1 }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}Name\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}Hans\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Elke\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Jean\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Maya\textquotesingle{}}\NormalTok{], }\StringTok{\textquotesingle{}Geburtstag\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}26.02.\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}14.03.\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}30.12.\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}07.09.\textquotesingle{}}\NormalTok{], }\StringTok{\textquotesingle{}Würfelfarbe\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}rosa\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}rosa\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}blau\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}gelb\textquotesingle{}}\NormalTok{], }\StringTok{\textquotesingle{}Summe Augen\textquotesingle{}}\NormalTok{: [}\DecValTok{17}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{23}\NormalTok{]\})}

\NormalTok{messung1}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
& Name & Geburtstag & Würfelfarbe & Summe Augen \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & Hans & 26.02. & rosa & 17 \\
1 & Elke & 14.03. & rosa & 12 \\
2 & Jean & 30.12. & blau & 8 \\
3 & Maya & 07.09. & gelb & 23 \\
\end{longtable}

~

Über die Angabe der Indizes entlang der 0. (Zeilen) und der 1. Achse
(Spalten) kann die Summe der gewürfelten Augen einer Person ausgegeben
werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Jean würfelte }\SpecialCharTok{\{}\NormalTok{messung1}\SpecialCharTok{.}\NormalTok{iloc[}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{ Augen"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Jean würfelte 8 Augen
\end{verbatim}

Es ist aber auch möglich, zunächst eine Spalte auszuwählen und dann wie
bei einem eindimensionalen Datensatz den Wert an einer Indexposition
aufzurufen. Dies wird verkettete Indexierung genannt.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Jean würfelte }\SpecialCharTok{\{}\NormalTok{messung1[}\StringTok{\textquotesingle{}Summe Augen\textquotesingle{}}\NormalTok{][}\DecValTok{2}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{ Augen"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Jean würfelte 8 Augen
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-chainedassignment} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-chainedassignment}: Verkettete Indexierung}\vspace{3mm}

Die verkettete Indexierung erzeugt in Pandas abhängig vom Kontext eine
Kopie des Objekts oder greift auf den Speicherbereich des Objekts zu.
Mit Pandas 3.0 wird die verkettete Indexierung nicht mehr unterstützt,
das Anlegen einer Kopie wird zum Standard werden. Weitere Informationen
erhalten Sie im zitierten Link.

\begin{figure}[H]

\begin{minipage}{0.05\linewidth}
~\end{minipage}%
%
\begin{minipage}{0.90\linewidth}
``Whether a copy or a reference is returned for a setting operation, may
depend on the context. This is sometimes called
\texttt{chained\ assignment} and should be avoided. See
\href{https://pandas.pydata.org/docs/user_guide/indexing.html\#indexing-view-versus-copy}{Returning
a View versus Copy}.''\end{minipage}%
%
\begin{minipage}{0.05\linewidth}
~\end{minipage}%

\end{figure}%

(\href{https://pandas.pydata.org/docs/user_guide/indexing.html}{Pandas
Dokumentation})

\end{minipage}%
\end{tcolorbox}

\subsection{long- und wide-Format}\label{long--und-wide-format}

Zweidimensionale Datensätze werden zumeist in einer aus Zeilen und
Spalten bestehenden Matrix dargestellt. Den zeilenweise eingetragenen
Beobachtungen werden Werte für die in den Spalten organisierten
Variablen zugeordnet. Diese Art Daten darzustellen, wird wide-Format
genannt: Mit jeder zusätzlich gemessenen Variablen wird der Datensatz
breiter.

Eine andere Art Daten zu organisieren und über Daten nachzudenken, ist
die Darstellung im long-Format. Einige Programme und Pakete erfordern
Daten im long-Format oder profitieren zumindest davon beispielsweise bei
der Erstellung von Grafiken. Schauen wir uns zunächst noch einmal den
Datensatz messung1 im wide-Format an. Welche Beobachtungseinheiten gibt
es? Welche Variablen wurden erhoben?

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
& Name & Geburtstag & Würfelfarbe & Summe Augen \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & Hans & 26.02. & rosa & 17 \\
1 & Elke & 14.03. & rosa & 12 \\
2 & Jean & 30.12. & blau & 8 \\
3 & Maya & 07.09. & gelb & 23 \\
\end{longtable}

~

Vermutlich werden Sie davon ausgehen, dass die Beobachtungseinheiten
Hans, Elke, Jean und Maya sind und die Variablen Geburtstag, Würfelfarbe
und Summe Augen. Es ist aber auch denkbar, dass die Beobachtungseinheit
Person mit 0, 1, 2 und 3 kodiert wurde (dem Zeilenindex des Datensatzes)
und die Spalte Name ebenfalls eine der erhobenen Variablen ist. Ebenso
könnte es nur zwei Variablen, Würfelfarbe und Summe Augen, geben,
während die Spalten Name und Geburtstag die beobachteten Personen
kodieren. Stellen Sie sich vor, es gäbe eine zweite Person mit dem Namen
Hans. Dann könnten die Würfelergebnisse der Personen mit dem Namen Hans
nur über den Geburtstag am 26.02. oder 11.11. korrekt zugeordnet werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{messung1 }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}Name\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}Hans\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Elke\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Jean\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Maya\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Hans\textquotesingle{}}\NormalTok{], }\StringTok{\textquotesingle{}Geburtstag\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}26.02.\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}14.03.\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}30.12.\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}07.09.\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}11.11.\textquotesingle{}}\NormalTok{], }\StringTok{\textquotesingle{}Würfelfarbe\textquotesingle{}}\NormalTok{: [}\StringTok{\textquotesingle{}rosa\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}rosa\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}blau\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}gelb\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}rosa\textquotesingle{}}\NormalTok{], }\StringTok{\textquotesingle{}Summe Augen\textquotesingle{}}\NormalTok{: [}\DecValTok{12}\NormalTok{, }\DecValTok{17}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{7}\NormalTok{]\})}

\NormalTok{messung1}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
& Name & Geburtstag & Würfelfarbe & Summe Augen \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & Hans & 26.02. & rosa & 12 \\
1 & Elke & 14.03. & rosa & 17 \\
2 & Jean & 30.12. & blau & 8 \\
3 & Maya & 07.09. & gelb & 23 \\
4 & Hans & 11.11. & rosa & 7 \\
\end{longtable}

~

Das long-Format macht diese Überlegungen explizit, indem
identifizierende Variablen (identification variables, kurz: id vars) und
gemessene Variablen (measure variables oder value vars) unterschieden
werden. Die Transformation eines Datensatzes aus dem wide-Format ins
long-Format wird melting (schmelzen) genannt. Das Modul Pandas bietet
die Funktion \texttt{pd.melt(frame,\ id\_vars\ =\ None)}. Diese erwartet
einen DataFrame. Im optionalen Argument \texttt{id\_vars} wird
angegeben, welche Spalten die identifizierenden Variablen sind.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{messung1\_long }\OperatorTok{=}\NormalTok{ pd.melt(messung1, id\_vars }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Name\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Geburtstag\textquotesingle{}}\NormalTok{])}

\NormalTok{messung1\_long}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
& Name & Geburtstag & variable & value \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & Hans & 26.02. & Würfelfarbe & rosa \\
1 & Elke & 14.03. & Würfelfarbe & rosa \\
2 & Jean & 30.12. & Würfelfarbe & blau \\
3 & Maya & 07.09. & Würfelfarbe & gelb \\
4 & Hans & 11.11. & Würfelfarbe & rosa \\
5 & Hans & 26.02. & Summe Augen & 12 \\
6 & Elke & 14.03. & Summe Augen & 17 \\
7 & Jean & 30.12. & Summe Augen & 8 \\
8 & Maya & 07.09. & Summe Augen & 23 \\
9 & Hans & 11.11. & Summe Augen & 7 \\
\end{longtable}

~

Im long-Format werden die gemessenen Variablen in der Spalte variable
aufgeführt und deren Wert in der Spalte value eingetragen. Mit jeder
zusätzlich erhobenen Variablen wird der Datensatz länger.

Wenn Sie die Unterscheidung von identifizierenden und gemessenen
Variablen zu Ende denken, kann der Variablenname selbst als eine
identifizierende Variable für den Wert in der Spalte value aufgefasst
werden. Ein Datensatz kann als eine Struktur verstanden werden, die
genau eine gemessene Variable, nämlich value, und eine Anzahl
identifizierender Variablen besitzt. Dies kann im long-Format wie folgt
dargestellt werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{messung1\_all\_id }\OperatorTok{=}\NormalTok{ pd.melt(messung1, id\_vars }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Name\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Geburtstag\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Würfelfarbe\textquotesingle{}}\NormalTok{])}

\NormalTok{messung1\_all\_id}
\end{Highlighting}
\end{Shaded}

In dieser Darstellung wird beispielsweise der erste Wert 12 durch Name =
Hans, Geburtstag = 26.02., Würfelfarbe = rosa und variable = Summe Augen
identifiziert.

\begin{figure}

\begin{minipage}{0.70\linewidth}

\begin{longtable}[]{@{}llllll@{}}
\toprule\noalign{}
& Name & Geburtstag & Würfelfarbe & variable & value \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & Hans & 26.02. & rosa & Summe Augen & 12 \\
1 & Elke & 14.03. & rosa & Summe Augen & 17 \\
2 & Jean & 30.12. & blau & Summe Augen & 8 \\
3 & Maya & 07.09. & gelb & Summe Augen & 23 \\
4 & Hans & 11.11. & rosa & Summe Augen & 7 \\
\end{longtable}

\end{minipage}%
%
\begin{minipage}{0.30\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{books/m-einlesen-strukturierter-datensaetze/skript/00-bilder/5f489ffabc91dec1ec2192dc4e993e00.jpg}}\end{minipage}%

\end{figure}%

Much wow. Such architecture. von Dmitry Kudryavtsev ist verfügbar unter
\url{https://yieldcode.blog/post/bloat-in-software-engineering/}.

\textbf{Was passiert, wenn auch die Variable \texttt{Summe\ Augen} dem
Argument \texttt{id\_vars} übergeben wird?}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-Antwort-all-id}: Antwort}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-Antwort-all-id} 

Der Befehl
\texttt{messung1\_all\_id\ =\ pd.melt(messung1,\ id\_vars\ =\ {[}\textquotesingle{}Name\textquotesingle{},\ \textquotesingle{}Geburtstag\textquotesingle{},\ \textquotesingle{}Würfelfarbe\textquotesingle{},\ \textquotesingle{}Summe\ Augen\textquotesingle{}{]})}
produziert einen leeren Dataframe, weil keine gemessenen Werte
verbleiben.

\end{tcolorbox}

Auch der umgekehrte Fall ist möglich: Werden beim melting keine id\_vars
angegeben, werden alle Spalten als gemessene Variablen behandelt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{messung1\_no\_id }\OperatorTok{=}\NormalTok{ pd.melt(messung1)}

\NormalTok{messung1\_no\_id}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
& variable & value \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & Name & Hans \\
1 & Name & Elke \\
2 & Name & Jean \\
3 & Name & Maya \\
4 & Name & Hans \\
5 & Geburtstag & 26.02. \\
6 & Geburtstag & 14.03. \\
7 & Geburtstag & 30.12. \\
8 & Geburtstag & 07.09. \\
9 & Geburtstag & 11.11. \\
10 & Würfelfarbe & rosa \\
11 & Würfelfarbe & rosa \\
12 & Würfelfarbe & blau \\
13 & Würfelfarbe & gelb \\
14 & Würfelfarbe & rosa \\
15 & Summe Augen & 12 \\
16 & Summe Augen & 17 \\
17 & Summe Augen & 8 \\
18 & Summe Augen & 23 \\
19 & Summe Augen & 7 \\
\end{longtable}

~

Die Umkehroperation zum melting wird casting (gießen) oder pivoting
(schwenken) genannt. Dabei wird ein im long-Format vorliegender
Datensatz in das wide-Format konvertiert. Die Pandas Funktion
\texttt{pd.pivot(data,\ columns,\ index)} nimmt einen melted DataFrame
entgegen und konveriert diesen aus den einzigartigen Werten in columns
(= Spaltennamen des DataFrame im wide-Format) und den einzigartigen
Werten in index (= Zeilenindex des DataFrame im wide-Format). Wird der
Funktion keine Spalte für index übergeben, wird der bestehende Index des
melted DataFrame verwendet (der mit 20 Zeilen natürlich viel zu lang
ist.) Da das Objekt messung1\_no\_id keine geeignete Indexspalte
besitzt, muss diese vor dem casting erzeugt werden. Dies ist mit der
Methode
\texttt{messung1\_no\_id.groupby(\textquotesingle{}variable\textquotesingle{}).cumcount()}
möglich, die die Anzahl jeder Ausprägung in der übergebenen Spalte bei 0
beginnend durchzählt. (Ein direktes Ersetzen des Index ist auf diese
Weise nicht möglich, da der Index des an
\texttt{pd.pivot(data,\ columns,\ index)} übergebenen DataFrames keine
Doppelungen enthalten darf.)

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# pd.pivot() benötigt einen Index oder benutzt den bestehenden Index, des melted\_df, der zu lang ist}
\CommentTok{\# Deshalb eine zusätzliche Spalte in messung1\_no\_id einfügen}
\CommentTok{\#\# einfach: messung1\_no\_id[\textquotesingle{}new\_index\textquotesingle{}] = list(range(0, 5)) * 4 }
\CommentTok{\#\# allgemein: messung1\_no\_id[\textquotesingle{}new\_index\textquotesingle{}] = messung1\_no\_id.groupby(\textquotesingle{}variable\textquotesingle{}).cumcount()}

\CommentTok{\# Spalte new\_index einfügen}
\NormalTok{messung1\_no\_id[}\StringTok{\textquotesingle{}new\_index\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ messung1\_no\_id.groupby(}\StringTok{\textquotesingle{}variable\textquotesingle{}}\NormalTok{).cumcount()}
\BuiltInTok{print}\NormalTok{ (}\SpecialStringTok{f"Der Datensatz im long{-}Format mit zusätzlicher Spalte new\_index:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{messung1\_no\_id}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# casting}
\NormalTok{messung1\_cast }\OperatorTok{=}\NormalTok{ pd.pivot(messung1\_no\_id, index }\OperatorTok{=} \StringTok{\textquotesingle{}new\_index\textquotesingle{}}\NormalTok{, columns }\OperatorTok{=} \StringTok{\textquotesingle{}variable\textquotesingle{}}\NormalTok{, values }\OperatorTok{=} \StringTok{\textquotesingle{}value\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Der Datensatz im wide{-}Format:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{messung1\_cast}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der Datensatz im long-Format mit zusätzlicher Spalte new_index:
       variable   value  new_index
0          Name    Hans          0
1          Name    Elke          1
2          Name    Jean          2
3          Name    Maya          3
4          Name    Hans          4
5    Geburtstag  26.02.          0
6    Geburtstag  14.03.          1
7    Geburtstag  30.12.          2
8    Geburtstag  07.09.          3
9    Geburtstag  11.11.          4
10  Würfelfarbe    rosa          0
11  Würfelfarbe    rosa          1
12  Würfelfarbe    blau          2
13  Würfelfarbe    gelb          3
14  Würfelfarbe    rosa          4
15  Summe Augen      12          0
16  Summe Augen      17          1
17  Summe Augen       8          2
18  Summe Augen      23          3
19  Summe Augen       7          4

Der Datensatz im wide-Format:
variable  Geburtstag  Name Summe Augen Würfelfarbe
new_index                                         
0             26.02.  Hans          12        rosa
1             14.03.  Elke          17        rosa
2             30.12.  Jean           8        blau
3             07.09.  Maya          23        gelb
4             11.11.  Hans           7        rosa
\end{verbatim}

Das Ergebnis entspricht noch nicht dem ursprünglichen Datensatz im
wide-Format. Um das Ausgangsformat wiederherzustellen, müssen die
Spalten in die ursprüngliche Reihenfolge gebracht sowie der Index und
dessen Beschriftung zurückgesetzt werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Spalten anordnen, Index zurücksetzen}
\NormalTok{messung1\_cast }\OperatorTok{=}\NormalTok{ messung1\_cast[[}\StringTok{\textquotesingle{}Name\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Geburtstag\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Würfelfarbe\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Summe Augen\textquotesingle{}}\NormalTok{]]}
\NormalTok{messung1\_cast.reset\_index(drop }\OperatorTok{=} \VariableTok{True}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{messung1\_cast.rename\_axis(}\VariableTok{None}\NormalTok{, axis }\OperatorTok{=} \DecValTok{1}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Der Datensatz im wide{-}Format mit zurückgesetztem Index:}\CharTok{\textbackslash{}n\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{messung1\_cast}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}

Der Datensatz im wide-Format mit zurückgesetztem Index:

   Name Geburtstag Würfelfarbe Summe Augen
0  Hans     26.02.        rosa          12
1  Elke     14.03.        rosa          17
2  Jean     30.12.        blau           8
3  Maya     07.09.        gelb          23
4  Hans     11.11.        rosa           7
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-idvars}: identifizierende und gemessene Variablen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-idvars} 

Auch wenn Sie mit Datensätzen im wide-Format arbeiten, ist die
Unterscheidung identifizierender und gemessener Variablen nützlich, um
Datensätze zu organisieren. siehe~\ref{sec-tidydata}

\end{tcolorbox}

\subsection{Übung zweidimensionale
Datensätze}\label{uxfcbung-zweidimensionale-datensuxe4tze}

Oben wurde das Objekt messung1\_long mit dem Befehl
\texttt{messung1\_long\ =\ pd.melt(messung1,\ id\_vars\ =\ {[}\textquotesingle{}Name\textquotesingle{},\ \textquotesingle{}Geburtstag\textquotesingle{}{]})}
angelegt.\\
\textbf{Benutzen Sie die Funktion} \texttt{pd.DataFrame.pivot()},
\textbf{um den Datensatz messung1 wieder ins wide-Format zu
transformieren.}

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
& Name & Geburtstag & variable & value \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & Hans & 26.02. & Würfelfarbe & rosa \\
1 & Elke & 14.03. & Würfelfarbe & rosa \\
2 & Jean & 30.12. & Würfelfarbe & blau \\
3 & Maya & 07.09. & Würfelfarbe & gelb \\
4 & Hans & 11.11. & Würfelfarbe & rosa \\
5 & Hans & 26.02. & Summe Augen & 12 \\
6 & Elke & 14.03. & Summe Augen & 17 \\
7 & Jean & 30.12. & Summe Augen & 8 \\
8 & Maya & 07.09. & Summe Augen & 23 \\
9 & Hans & 11.11. & Summe Augen & 7 \\
\end{longtable}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-pivoting}: Musterlösung zweidimensionale Datensätze}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-pivoting} 

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Spalte new\_index einfügen}
\NormalTok{messung1\_long[}\StringTok{\textquotesingle{}new\_index\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ messung1\_long.groupby(}\StringTok{\textquotesingle{}variable\textquotesingle{}}\NormalTok{).cumcount()}

\CommentTok{\# casting}
\NormalTok{messung1\_long\_cast }\OperatorTok{=}\NormalTok{ pd.pivot(messung1\_long, index }\OperatorTok{=} \StringTok{\textquotesingle{}new\_index\textquotesingle{}}\NormalTok{, columns }\OperatorTok{=} \StringTok{\textquotesingle{}variable\textquotesingle{}}\NormalTok{, values }\OperatorTok{=} \StringTok{\textquotesingle{}value\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Spalten anordnen, Index zurücksetzen}
\NormalTok{messung1\_long\_cast }\OperatorTok{=}\NormalTok{ messung1\_cast[[}\StringTok{\textquotesingle{}Name\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Geburtstag\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Würfelfarbe\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Summe Augen\textquotesingle{}}\NormalTok{]]}
\NormalTok{messung1\_long\_cast.reset\_index(drop }\OperatorTok{=} \VariableTok{True}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{messung1\_long\_cast.rename\_axis(}\VariableTok{None}\NormalTok{, axis }\OperatorTok{=} \DecValTok{1}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

\NormalTok{messung1\_long\_cast}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
& Name & Geburtstag & Würfelfarbe & Summe Augen \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & Hans & 26.02. & rosa & 12 \\
1 & Elke & 14.03. & rosa & 17 \\
2 & Jean & 30.12. & blau & 8 \\
3 & Maya & 07.09. & gelb & 23 \\
4 & Hans & 11.11. & rosa & 7 \\
\end{longtable}

\end{tcolorbox}

\subsection{Drei- und mehrdimensionale
Datensätze}\label{drei--und-mehrdimensionale-datensuxe4tze}

Drei- oder mehrdimensionale Datensätze organisieren komplexe
Datenstrukturen in sogenannten \textbf{Arrays}. Arrays sind
n-dimensionale Datenstrukturen und damit zugleich ein Oberbegriff. So
ist eine Liste ein eindimensionales Array, eine Matrix ein
zweidimensionales Array und eine Excel-Datei mit mehreren
Arbeitsblättern für jährlich erhobene Umfragedaten ein 3-dimensionales
Array (Arbeitsblätter, Zeilen, Spalten). Abhängig vom verwendeten Modul
können Arrays ein oder mehrere Datentypen enthalten.

\begin{figure}[H]

{\centering \includegraphics[width=0.5\linewidth,height=\textheight,keepaspectratio]{books/m-einlesen-strukturierter-datensaetze/skript/00-bilder/dreidimensionaler-datensatz-slicing-mf-mp.png}

}

\caption{dreidimensionale Datensätze}

\end{figure}%

slicing von Marc Fehr ist lizensiert unter
\href{https://github.com/bausteine-der-datenanalyse/w-python-numpy-grundlagen\#CC-BY-4.0-1-ov-file}{CC-BY-4.0}
und abrufbar auf
\href{https://github.com/bausteine-der-datenanalyse/w-python-numpy-grundlagen}{GitHub}.
Die Grafik wurde auf den gezeigten Teil beschnitten und die obenstehende
Beschriftung entfernt. 2024

~

Für drei- und mehrdimensionale Datenstrukturen werden häufig
spezialisierte Datenformate verwendet, die im Abschnitt
Chapter~\ref{sec-spezialformate} behandelt werden. Dies hat unter
anderem den Grund, dass so leichter verschiedene Datentypen verarbeitet
und mit Metadaten (siehe Section~\ref{sec-metadaten}) dokumentiert
werden können.

\subsubsection{Bilddaten einlesen}\label{bilddaten-einlesen}

Digitale Bilder liegen in Form eines dreidimensionalen Datensatzes vor.
In Zeilen und Spalten liegen für jeden Pixel Farbwerte (Rot, Grün, Blau)
und gegebenenfalls ein Alphawert vor (Rot, Grün, Blau, Alpha). Die
Farbwerte liegen entweder im Bereich von 0 bis 1 oder von 0 bis 255
(8-Bit).

\begin{verbatim}
# Farbwerte für einen Pixel
[Rotwert, Grünwert, Blauwert]

# Eine Bildzeile mit drei Pixeln
[[Rotwert, Grünwert, Blauwert], [Rotwert, Grünwert, Blauwert], [Rotwert, Grünwert, Blauwert]]

# Ein Bild aus drei Zeilen und Spalten
[[[Rotwert, Grünwert, Blauwert], [Rotwert, Grünwert, Blauwert], [Rotwert, Grünwert, Blauwert]],
[[Rotwert, Grünwert, Blauwert], [Rotwert, Grünwert, Blauwert], [Rotwert, Grünwert, Blauwert]],
[[Rotwert, Grünwert, Blauwert], [Rotwert, Grünwert, Blauwert], [Rotwert, Grünwert, Blauwert]]]
\end{verbatim}

Bilddateien können mit der Funktion \texttt{plt.imread()} aus dem Modul
\texttt{matplotlib.pyplot} eingelesen werden.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{logo }\OperatorTok{=}\NormalTok{ plt.imread(fname }\OperatorTok{=} \StringTok{\textquotesingle{}00{-}bilder/python{-}logo{-}and{-}wordmark{-}cc0{-}tm.png\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.imshow(logo)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-einlesen-strukturierter-datensaetze/skript/einlesen-strukturierter-datensaetze_files/figure-pdf/cell-18-output-1.png}}

Python Logo von Python Software Foundation steht unter der
\href{https://www.gnu.org/licenses/gpl-3.0.html}{GPLv3}. Die
Wort-Bild-Marke ist markenrechtlich geschützt:
\url{https://www.python.org/psf/trademarks/}. Das Werk ist abrufbar auf
\href{https://de.m.wikipedia.org/wiki/Datei:Python_logo_and_wordmark.svg}{wikimedia}.
2008

~

Die Struktur des Datensatzes kann mit dem Attribut \texttt{.shape}
abgerufen werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(logo), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(logo.shape)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'numpy.ndarray'> 

(144, 486, 4)
\end{verbatim}

Die Daten wurden als NumPy.ndarray eingelesen. Das Logo hat 144 Zeilen,
486 Spalten und liegt im RGBA-Farbraum vor. Ein Ausschnitt der Daten
sieht so aus:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(logo[}\DecValTok{50}\NormalTok{:}\DecValTok{52}\NormalTok{, }\DecValTok{50}\NormalTok{:}\DecValTok{52}\NormalTok{, : ])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[[0.21568628 0.44705883 0.63529414 1.        ]
  [0.21568628 0.44705883 0.63529414 1.        ]]

 [[0.21568628 0.44705883 0.63529414 1.        ]
  [0.21176471 0.44313726 0.6313726  1.        ]]]
\end{verbatim}

{[}@Arnold-2023-numpy-dateien{]}

\subsection{Übung dreidimensionale
Datensätze}\label{uxfcbung-dreidimensionale-datensuxe4tze}

Über den Index der dritten Dimension können die Farbkanäle Rot, Grün und
Blau ausgewählt und mit der Funktion
\texttt{plt.imshow(cmap\ =\ \textquotesingle{}Greys\_r\textquotesingle{})}
einzeln dargestellt werden. Das Argument
\texttt{cmap\ =\ \textquotesingle{}Greys\_r\textquotesingle{}} weist die
Funktion an, die invertierte Grauskala benutzen. Dadurch werden hohe
Farbwerte hell und niedrige Farbwerte dunkel dargestellt.
\textbf{Stellen Sie die Farbkanäle Rot, Grün und Blau des Pythonlogos
einzeln mit der Funktion
\texttt{plt.imshow(cmap\ =\ \textquotesingle{}Greys\_r\textquotesingle{})}
dar.}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-logo}: Musterlösung dreidimensionale Datensätze}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-logo} 

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{kanal }\OperatorTok{=}\NormalTok{ [}\StringTok{"Rotkanal"}\NormalTok{, }\StringTok{"Grünkanal"}\NormalTok{, }\StringTok{"Blaukanal"}\NormalTok{]}

\NormalTok{plt.figure(figsize }\OperatorTok{=}\NormalTok{ (}\DecValTok{9}\NormalTok{, }\DecValTok{6}\NormalTok{))}

\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{3}\NormalTok{):}

\NormalTok{  plt.subplot(}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, i }\OperatorTok{+} \DecValTok{1}\NormalTok{)}
\NormalTok{  plt.imshow(logo[ :, :, i], cmap }\OperatorTok{=} \StringTok{\textquotesingle{}Greys\_r\textquotesingle{}}\NormalTok{)}
\NormalTok{  plt.title(label }\OperatorTok{=}\NormalTok{ kanal[i])}

\NormalTok{plt.colorbar(shrink }\OperatorTok{=} \FloatTok{0.15}\NormalTok{)}

\NormalTok{plt.tight\_layout()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/m-einlesen-strukturierter-datensaetze/skript/einlesen-strukturierter-datensaetze_files/figure-pdf/cell-21-output-1.png}}

}

\caption{Farbkanäle des Pythonlogos}

\end{figure}%

Möglicherweise wundern Sie sich, warum der Bildhintergrund in jedem
Farbkanal schwarz ist. Die Ursache finden Sie im nächsten Tipp.

\phantomsection\label{tip-logo}
\begin{quote}
\textbf{Tip~51.6: Erklärung Bildhintergrund}

Der Bildhintergrund hat in allen Kanälen, auch im Alphakanal, den
Farbwert 0. Dieser Teil des Bildes ist deshalb vollständig transparent
und wird vom Hintergrund der Internetseite ausgefüllt. Der
Bildhintergrund des Logos wirkt deshalb weiß.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Alphakanal}
\NormalTok{plt.imshow(logo[ :, :, }\DecValTok{3}\NormalTok{], cmap }\OperatorTok{=} \StringTok{\textquotesingle{}Greys\_r\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(label }\OperatorTok{=} \StringTok{\textquotesingle{}Alphakanal\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.colorbar(shrink }\OperatorTok{=} \FloatTok{0.4}\NormalTok{)}

\NormalTok{plt.show()}

\CommentTok{\# Die ersten zwei Zeilen und Spalten des Logos}
\BuiltInTok{print}\NormalTok{(logo[}\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{, : ])}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/m-einlesen-strukturierter-datensaetze/skript/einlesen-strukturierter-datensaetze_files/figure-pdf/cell-22-output-1.png}}

}

\caption{Alphakanal des Pythonlogos}

\end{figure}%

\begin{verbatim}
[[[0. 0. 0. 0.]
  [0. 0. 0. 0.]]

 [[0. 0. 0. 0.]
  [0. 0. 0. 0.]]]
\end{verbatim}
\end{quote}

\end{tcolorbox}

\section{Datentyp}\label{sec-datentyp}

Der Datentyp gibt an, wie die in einem Datensatz einhaltenen Werte von
Python interpretiert werden sollen. Beispielsweise kann der Wert ``1''
ein Zeichen, eine Ganzzahl, einen Wahrheitswert, den Monat Januar oder
die Ausprägung einer kategorialen Variablen repräsentieren. Python
unterstützt als vielseitig einsetzbare Programmiersprache zahlreiche
Datentypen, die den Kategorien: numerics, sequences, mappings, classes,
instances and exceptions zugeordnet sind. Nähere Informationen dazu
finden Sie in der
\href{https://docs.python.org/3/library/stdtypes.html}{Dokumentation}.

\begin{figure}[H]

{\centering \includegraphics[width=0.6\linewidth,height=\textheight,keepaspectratio]{books/m-einlesen-strukturierter-datensaetze/skript/00-bilder/python3-standard-type-hierarchy.png}

}

\caption{Datentypen in Python}

\end{figure}%

Python 3. The standard type hierarchy. von Максим Пе ist lizensiert
unter \href{https://creativecommons.org/licenses/by-sa/4.0/deed.de}{CC
BY SA 4.0} und abrufbar auf
\href{https://commons.wikimedia.org/wiki/File:Python_3._The_standard_type_hierarchy.png}{wikimedia}.
2018

~

Durch Module werden weitere Datentypen hinzugefügt. In der Datenanalyse
häufig verwendete Datentypen sind:

\begin{itemize}
\item
  Zahlen: Ganzzahl, Fließkommazahlen
\item
  Wahrheitswerte
\item
  Zeichenketten
\item
  Datums- und Uhrzeitangaben
\item
  Kategorie (aus dem Modul
  \href{https://pandas.pydata.org/docs/user_guide/categorical.html}{Pandas})
\end{itemize}

Der Datentyp bestimmt zum einen den zulässigen Wertebereich einer
Variablen. Beispielsweise sind 0 und 13 zulässige Ganzzahlen, aber keine
gültigen Kodierungen des Monats. Zum anderen definiert der Datentyp,
welche Operationen mit den Werten zulässig sind und wie diese von Python
ausgeführt werden. Dies betrifft Operatoren und Funktionen. Python
enthält Funktionen, um den Datentyp eines Werts zu bestimmen und ggf.
umzuwandeln (siehe w-Python).

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-operation-nach-datentyp}: Datentypabhängige Operationen und Funktionen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-operation-nach-datentyp} 

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Der Operator + bewirkt die Addition von Zahlen}
\BuiltInTok{print}\NormalTok{(}\DecValTok{1} \OperatorTok{+} \DecValTok{13}\NormalTok{)}

\CommentTok{\# Der Operator + bewirkt auch das Verketten von strings}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{str}\NormalTok{(}\DecValTok{1}\NormalTok{) }\OperatorTok{+} \BuiltInTok{str}\NormalTok{(}\DecValTok{13}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
14
113
\end{verbatim}

Die Sortierfunktion arbeitet abhängig vom Datentyp.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Liste von Monatskürzeln erstellen}
\NormalTok{dates }\OperatorTok{=}\NormalTok{ pd.Series([ }\StringTok{\textquotesingle{}07.06.2000\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}12.01.2000\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}11.02.2000\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}04.09.2000\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}10.03.2000\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}03.10.2000\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}09.04.2000\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}08.05.2000\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}06.07.2000\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}05.08.2000\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}02.11.2000\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}01.12.2000\textquotesingle{}}\NormalTok{])}
\NormalTok{dates }\OperatorTok{=}\NormalTok{ pd.to\_datetime(dates, }\BuiltInTok{format} \OperatorTok{=} \StringTok{\textquotesingle{}}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Eine unsortierte Liste von Monatskürzeln:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\BuiltInTok{list}\NormalTok{(dates.dt.strftime(}\StringTok{\textquotesingle{}\%b\textquotesingle{}}\NormalTok{))}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Die Liste alphabetisch sortiert:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\BuiltInTok{sorted}\NormalTok{(}\BuiltInTok{list}\NormalTok{(dates.dt.strftime(}\StringTok{\textquotesingle{}\%b\textquotesingle{}}\NormalTok{)))}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Die Liste als datetime{-}Objekt sortiert:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\BuiltInTok{list}\NormalTok{(dates.sort\_values().dt.strftime(}\StringTok{\textquotesingle{}\%b\textquotesingle{}}\NormalTok{))}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Eine unsortierte Liste von Monatskürzeln:
['Jun', 'Jan', 'Feb', 'Sep', 'Mar', 'Oct', 'Apr', 'May', 'Jul', 'Aug', 'Nov', 'Dec']

Die Liste alphabetisch sortiert:
['Apr', 'Aug', 'Dec', 'Feb', 'Jan', 'Jul', 'Jun', 'Mar', 'May', 'Nov', 'Oct', 'Sep']

Die Liste als datetime-Objekt sortiert:
['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
\end{verbatim}

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-datatype}: Datentyp kontollieren und plausibilisieren}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-datatype} 

Beim Einlesen von Datensätzen ist es wichtig, die korrekte Erkennung der
Datentypen zu kontrollieren bzw. aktiv zu steuern. Weitere Methoden für
die formale Prüfung des Datentyps und für die Kontrolle des
Wertebereichs werden in Chapter~\ref{sec-numpypandas} vorgestellt.

\end{tcolorbox}

\subsection{Fehlende Werte}\label{sec-missing}

Ein besonderer Datentyp ist der zur Repräsentation fehlender Werte. In
Python wird zwischen nicht existenten und nicht definierten Werten
unterschieden.

\subsubsection{Nullwert None}\label{nullwert-none}

Der sogenannte Nullwert in Python ist \texttt{None}, das zu den
definierten Schlüsselwörtern in Python gehört.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(}\VariableTok{None}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'NoneType'>
\end{verbatim}

\texttt{None} repräsentiert nicht existente Werte und Objekte. Leere
(aber existente) Objekte gehören nicht zum Datentyp \texttt{None}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{leere\_liste }\OperatorTok{=}\NormalTok{ []}
\NormalTok{leere\_liste }\OperatorTok{==} \VariableTok{None}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
False
\end{verbatim}

\texttt{None} kann Funktionen als Argument übergeben oder von diesen als
Rückgabewert ausgegeben werden. Operationen sind mit \texttt{None}
jedoch nicht möglich.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Operationen mit None führen zu Fehlermeldungen}
\ControlFlowTok{try}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\VariableTok{None} \OperatorTok{+} \DecValTok{1}\NormalTok{)}
\ControlFlowTok{except} \PreprocessorTok{TypeError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Der übergebene Wert führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\VariableTok{None} \OperatorTok{+} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der übergebene Wert führt zu der Fehlermeldung:
 unsupported operand type(s) for +: 'NoneType' and 'int'
\end{verbatim}

Eine Ausnahme ist die Umwandlung in eine Zeichenkette.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Eine Ausnahme ist die Umwandlung in strings}
\NormalTok{a }\OperatorTok{=} \VariableTok{None}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{print(a) gibt den Nullwert zurück:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, a, sep }\OperatorTok{=} \StringTok{""}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{str(a) gibt eine Zeichenkette zurück:"}\NormalTok{)}
\BuiltInTok{str}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}

print(a) gibt den Nullwert zurück:
None

str(a) gibt eine Zeichenkette zurück:
\end{verbatim}

\begin{verbatim}
'None'
\end{verbatim}

\subsubsection{NaN}\label{nan}

Um mit fehlenden Werten innerhalb eines Datensatzes arbeiten zu können,
gibt es den Wert \texttt{NaN}, der zur Klasse der Fließkommazahlen
gehört. \texttt{NaN} steht für Not a Number und repräsentiert
undefinierte oder nicht darstellbare Werte. Beispielsweise berechnet die
Methode \texttt{pd.diff()} die Differenz jedes Werts zu seinem
Vorgänger. Da der erste Wert keinen Vorgänger hat, wird \texttt{NaN}
erzeugt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_series }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{8}\NormalTok{])}
\NormalTok{my\_series.diff()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0    NaN
1    1.0
2    2.0
3    4.0
dtype: float64
\end{verbatim}

Anders als \texttt{None} ist \texttt{NaN} kein Standardschlüsselwort in
Python. Der Wert \texttt{NaN} wird erzeugt mit
\texttt{float(\textquotesingle{}nan\textquotesingle{})} oder
\texttt{float(\textquotesingle{}NaN\textquotesingle{})}, die Groß- und
Kleinschreibung spielt keine Rolle. \texttt{NaN} hat also den Datentyp
Fließkommazahl. Die Module math und NumPy bieten mit \texttt{math.nan}
und \texttt{np.nan} ebenfalls Funktionen, um \texttt{NaN} zu erzeugen.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(}\BuiltInTok{float}\NormalTok{(}\StringTok{\textquotesingle{}NaN\textquotesingle{}}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'float'>
\end{verbatim}

Mit dem Wert `NaN' können Operationen ausgeführt werden. Das Ergebnis
ist immer \texttt{NaN}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{float}\NormalTok{(}\StringTok{\textquotesingle{}NaN\textquotesingle{}}\NormalTok{) }\OperatorTok{+} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
nan
\end{verbatim}

Einige Funktionen können mit \texttt{NaN} als Platzhalter für fehlende
Werte umgehen.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Python{-}Basis}
\BuiltInTok{print}\NormalTok{(}\StringTok{"sum():"}\NormalTok{, }\BuiltInTok{sum}\NormalTok{([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\BuiltInTok{float}\NormalTok{(}\StringTok{\textquotesingle{}NaN\textquotesingle{}}\NormalTok{), }\DecValTok{4}\NormalTok{]), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"max():"}\NormalTok{, }\BuiltInTok{max}\NormalTok{([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\BuiltInTok{float}\NormalTok{(}\StringTok{\textquotesingle{}NaN\textquotesingle{}}\NormalTok{), }\DecValTok{4}\NormalTok{]), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"any():"}\NormalTok{, }\BuiltInTok{any}\NormalTok{([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\BuiltInTok{float}\NormalTok{(}\StringTok{\textquotesingle{}NaN\textquotesingle{}}\NormalTok{), }\DecValTok{4}\NormalTok{]), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# Pandas}
\NormalTok{daten\_mit\_nan }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\BuiltInTok{float}\NormalTok{(}\StringTok{\textquotesingle{}NaN\textquotesingle{}}\NormalTok{), }\DecValTok{4}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(daten\_mit\_nan }\OperatorTok{+} \DecValTok{1}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Summe des Datensates:"}\NormalTok{, daten\_mit\_nan.}\BuiltInTok{sum}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
sum(): nan 

max(): 4 

any(): True 

0    2.0
1    3.0
2    NaN
3    5.0
dtype: float64

Summe des Datensates: 7.0
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-logicbasepython} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-logicbasepython}: Achtung Logik!}\vspace{3mm}

Die logische Abfrage fehlender Werte unterscheidet sich für
\texttt{None} und \texttt{NaN}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bool\_values }\OperatorTok{=}\NormalTok{ [}\VariableTok{None}\NormalTok{, }\BuiltInTok{float}\NormalTok{(}\StringTok{\textquotesingle{}NaN\textquotesingle{}}\NormalTok{)]}

\ControlFlowTok{for}\NormalTok{ element }\KeywordTok{in}\NormalTok{ bool\_values:}
\NormalTok{  bool\_value }\OperatorTok{=} \BuiltInTok{bool}\NormalTok{(element)}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Wahrheitswert von"}\NormalTok{, element, }\StringTok{"ist"}\NormalTok{, bool\_value)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Wahrheitswert von None ist False
Wahrheitswert von nan ist True
\end{verbatim}

Dies gilt auch für die Wertgleichheit.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ element }\KeywordTok{in}\NormalTok{ bool\_values:}
\NormalTok{  result }\OperatorTok{=}\NormalTok{ element }\OperatorTok{==}\NormalTok{ element}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Wertgleichheit von"}\NormalTok{, element, }\StringTok{"ist"}\NormalTok{, result)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Wertgleichheit von None ist True
Wertgleichheit von nan ist False
\end{verbatim}

\end{minipage}%
\end{tcolorbox}

\subsection{Fehlende Werte in der
Praxis}\label{fehlende-werte-in-der-praxis}

\texttt{None} und \texttt{NaN} sind pythonspezifische Repräsentationen
für nicht existente oder nicht definierte Werte. In der Praxis werden
fehlende Werte in Datensätzen auf unterschiedliche Weise gekennzeichnet.

In Datensätzen übliche Werte sind:

\begin{itemize}
\item
  kein Eintrag, beispielsweise in kommaseparierten Dateien eine leere
  Zeichenkette \texttt{""}
\item
  definierte Zeichenfolge: \texttt{NA} in der Programmiersprache R,
  \texttt{NULL} in der Datenbanksprache SQL, \texttt{.} in der
  Statistik-Software Stata
\item
  (mehrere) manuell gewählte Zeichen oder Ziffern außerhalb des
  zulässigen Wertebereichs wie -1, -88, -99 (häufig bei Umfragedaten)
\end{itemize}

Die Art der Kennzeichnung ist jeweils mit Vor- und Nachteilen verbunden.
Eine definierte Zeichenfolge für fehlende Werte hilft dabei, Lücken im
Datensatz von Fehlern bei der Datenerfassung zu unterscheiden. Dazu ist
eine definierte Zeichenfolge wie ``NA'' besser als eine leere
Zeichenkette geeignet. Manuell gewählte Werte erlauben es, bei der
automatischen Auswertung eines Datensatzes abhängig von der Situation
ein bestimmtes Verhalten für jede Variable festzulegen (z. B.
Unterscheidung von nicht zutreffend, Aussage verweigert, weiß nicht,
Interview abgebrochen keine Antwort).

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-missingvalues}: fehlende Werte}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-missingvalues} 

Die Identifizierung und ggf. Bereinigung fehlender Werte ist ein
wichtiger Schritt beim Einlesen strukturierter Datensätze. Dabei hilft
es, die gängigen Kennzeichnungen für fehlende Werte zu kennen und sich
über die Konventionen des jeweiligen Dateiformats bzw. der jeweiligen
Disziplin zu informieren. Dennoch ist manchmal ein gewisser Spürsinn
unerlässlich. Geeignete Funktionen zur Identifizierung fehlender Werte
werden in Chapter~\ref{sec-numpypandas} vorgestellt.

\end{tcolorbox}

\section{Metadaten}\label{sec-metadaten}

Metadaten sind beschreibende Informationen eines Datensatzes. Metadaten
geben beispielsweise an:

\begin{itemize}
\item
  welche Datentypen ein Datensatz enthält,
\item
  verwendete Kodierschemen, Skalen oder mimimal und maximal zulässige
  Werte,
\item
  die Bedingungen, unter denen die Daten erhoben wurden,
\item
  Herkunft der Daten,
\item
  Beziehungen zwischen Variablen und Datensätzen,
\item
  urheberrechtliche Informationen und Lizenzhinweise.
\end{itemize}

(vgl.
\href{https://docs.hdfgroup.org/archive/support/HDF5/doc/Advanced/HDF5_Metadata/index.html}{The
HDF Group Help Desk})

Spezialisierte Dateiformate wie netCDF oder HDF deklarieren Metadaten
explizit in dafür vorgesehenen Feldern. Vielen Dateiformaten fehlt eine
solche Funktion. Relevante Metadaten stehen deshalb häufig im
Dateinamen, in Spaltenbeschriftungen, in zusätzlichen Tabellenblättern
oder in separaten Dokumenten (die nicht immer zur Verfügung stehen).

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-metadata}: Metadaten}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-metadata} 

Insbesondere vor dem Einlesen komplexer Datensätze sollten
Begleitmaterialien, sofern vorhanden, studiert werden.

\end{tcolorbox}

\section{Tidy data}\label{sec-tidydata}

Datensätze werden mit verschiedenen Zielstellungen angelegt, etwa dass
eine bequeme Dateneingabe möglich ist. Dies führt aber häufig dazu, dass
Datensätze für die skriptbasierte Datenanalyse zunächst aufwändig
aufgeräumt werden müssen.

\begin{figure}

\begin{minipage}{0.05\linewidth}
~\end{minipage}%
%
\begin{minipage}{0.90\linewidth}
``Tidy datasets are all alike, but every messy dataset is messy in its
own way.'' {[}@R-for-Data-Science, Kapitel 5 Data
tidying{]}\end{minipage}%
%
\begin{minipage}{0.05\linewidth}
~\end{minipage}%

\end{figure}%

Tidy data ist ein System von Hadley Wickham, das dabei hilft, Datensätze
in ein aufgeräumtes (tidy) Format zu bringen. Das Aufräumen von
Datensätzen ist eine vorbereitende Tätigkeit mit dem Ziel, während der
eigentlichen Datenanlyse möglichst wenig Zeit für das Umformen von
Datenstrukturen aufwenden zu müssen. Dadurch soll ein größerer Fokus auf
den inhaltlichen Aspekt der Datenanalyse ermöglicht werden.
{[}@R-for-Data-Science, Kapitel 5 Data tidying{]}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-tidy-data}: tidy data}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-tidy-data} 

\begin{figure}[H]

\begin{minipage}{0.05\linewidth}
~\end{minipage}%
%
\begin{minipage}{0.90\linewidth}
``Das System tidy data besteht aus drei Regeln:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Jede Variable ist eine Spalte; jede Spalte ist eine Variabe.
\item
  Jede Beobachtung ist eine Zeile; jede Zeile ist eine Beobachtung.
\item
  Jeder Wert ist eine Zelle; jede Zelle ist ein einzelner Wert.''
\end{enumerate}

\end{minipage}%
%
\begin{minipage}{0.05\linewidth}
~\end{minipage}%
\newline
\begin{minipage}{\linewidth}
{[}@R-for-Data-Science, Kapitel 5 Data tidying, eigene
Übersetzung{]}\end{minipage}%

\end{figure}%

\end{tcolorbox}

Tidy data bezieht sich auf zweidimensionale Datensätze, bietet aber auch
darüber hinaus eine Orientierung, um unterschiedlich aufgebaute
Datensätze strukturiert einzulesen und für die Datenanalyse
vorzubereiten. Tidy data ist kein strikt zu befolgendes Regelwerk. Es
ist völlig in Ordnung, eine andere Struktur zu wählen, wenn die
Datenanalyse damit leichter durchgeführt werden kann.

\chapter{Die Module NumPy und Pandas}\label{sec-numpypandas}

Die Module NumPy und Pandas erlauben ein effizientes Arbeiten mit
Datensätzen. Insbesondere das Lesen- und Schreiben von Dateien und die
Verwaltung von Datentypen ist erheblich einfacher als mit der
Python-Basis. Außerdem sind die vektorisierten Operationen vielfach
schneller als Operationen mit Python. Das Modul Pandas basiert auf
NumPy. In den folgenden Abschnitten werden beide Module behandelt.

Eine kurze Übersicht der Vor- und Nachteile:

\begin{itemize}
\item
  \href{https://bausteine-der-datenanalyse.github.io/w-python-numpy-grundlagen/output/book/}{NumPy}:
  n-dimensionale Array-Struktur mit Unterstützung der am häufigsten
  verwendeten Datentypen sowie zahlreicher numerischer Formate für
  spezialisierte wissenschaftliche Berechnungen
  (\href{https://numpy.org/devdocs/reference/arrays.scalars.html}{siehe
  Dokumentation}). Ein Array kann immer nur einen Datentyp haben und die
  Größe von Arrays ist unveränderlich. Dafür werden Operationen etwas
  schneller als in der DataFrame-Struktur von Pandas ausgeführt.

  \begin{itemize}
  \tightlist
  \item
    Spaltennamen sind mit einem strukturierten dtype möglich
    (\href{https://numpy.org/doc/stable/user/basics.io.genfromtxt.html\#setting-the-names}{siehe
    Dokumentation})
  \end{itemize}
\item
  \href{https://bausteine-der-datenanalyse.github.io/w-pandas/output/book/}{Pandas}:
  2-dimensionale DataFrame-Struktur im long- und wide-Format. DataFrames
  können mehrere Datentypen enthalten und die Größe von DataFrames ist
  veränderlich. Unterstützung von alphanummerischen Spalten- und
  Indexbeschriftungen. Direktes Abrufen von Dateien aus dem Internet
  möglich.

  \begin{itemize}
  \tightlist
  \item
    dreidimensionale DataFrames sind mit einem Multiindex möglich
    --\textgreater{} das widerspricht aber dem Konzept von Tidy Data
  \end{itemize}
\end{itemize}

Für beide Module haben sich diese Kürzel etabliert:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}

\CommentTok{\# Deklarieren der Anzahl der Nachkommastellen}
\NormalTok{pd.set\_option(}\StringTok{"display.precision"}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-pypandas}: Arbeiten mit NumPy und Pandas}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-pypandas} 

Ob Sie mit NumPy oder mit Pandas arbeiten, hängt von dem vorliegenden
Datensatz und persönlichen Präferenzen ab.

Das Paket Pandas erlaubt es, Daten aus verschiedenen Quellen wie
CSV-Dateien oder Excel-Tabellen und mit unterschiedlichen Datentypen in
einen DataFrame zu laden. Anschließend können diese mit wenigen Befehlen
untersucht und umstrukturiert werden. Komplexe Operationen wie das
Umformen von Datensätzen, das Gruppieren und Aggregieren von Daten sowie
das Filtern und Sortieren sind effizient möglich.

Bis auf wenige Ausnahmen sind Pandas und NumPy zueinander kompatibel. Es
spricht nichts dagegen, Ihre Daten mit Pandas vorzubereiten und
anschließend mit NumPy auszuwerten.

\end{tcolorbox}

\section{Datentypen}\label{datentypen-2}

NumPy unterstützt folgende Datentypen:

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Datentyp NumPy-Array & Datentyp in Python \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
int\_ & int \\
double & float \\
cdouble & complex \\
bytes\_ & bytes \\
str\_ & str \\
bool\_ & bool \\
datetime64 & datetime.datetime \\
timedelta64 & datetime.timedelta \\
\end{longtable}

\href{https://numpy.org/devdocs/reference/arrays.scalars.html}{Dokumentation
NumPy}

In den meisten Fällen verwendet das Modul Pandas die NumPy-Datentypen.
Pandas führt aber auch einige zusätzliche Datentypen ein. Eine
vollständige Liste finden Sie in der
\href{https://pandas.pydata.org/docs/reference/arrays.html}{Pandas
Dokumentation}. Die wichtigsten zusätzlichen Datentypen sind:

\begin{itemize}
\item
  \href{https://pandas.pydata.org/docs/user_guide/categorical.html}{Kategorie}
  \texttt{dtype\ =\ \textquotesingle{}category\textquotesingle{}}
\item
  \href{https://pandas.pydata.org/docs/reference/api/pandas.Timestamp.html\#pandas.Timestamp}{Zeitzonenbewusstes
  Datumsformat}
  \texttt{dtype\ =\ \textquotesingle{}datetime64{[}ns,\ US/Eastern{]}\textquotesingle{}}
\end{itemize}

\section{Dateien lesen und
schreiben}\label{dateien-lesen-und-schreiben-2}

In den Werkzeugbausteinen NumPy und Pandas haben Sie die Funktionen zum
Lesen und Schreiben von Dateien kennengelernt.

\section{NumPy}

In NumPy können Dateien mit der Funktion \texttt{np.loadtxt()} gelesen
und mit der Funktion \texttt{np.savetxt()} geschrieben werden.

\begin{itemize}
\item
  \texttt{np.loadtxt(fname\ =\ data.txt,\ delimiter\ =\ ";",\ skiprows=\ \#Reihen)}
\item
  \texttt{np.savetxt(fname\ =\ dateipfad,\ X\ =\ daten,\ header\ =\ kommentar,\ fmt=\textquotesingle{}\%5.2f\textquotesingle{})}
\end{itemize}

\section{Pandas}

In Pandas werden Dateien mit einer Reihe spezialisierter Funktionen
gelesen und geschrieben, die einem einheitlichen Schema folgen.
Funktionen zum Lesen von Dateien werden in der Form
\texttt{pd.read\_csv} und Funktionen zum Schreiben in der Form
\texttt{pd.to\_csv} aufgerufen. Mit Pandas können auch Dateien aus dem
Internet abgerufen werden \texttt{pd.read\_csv(URL)}.

\begin{longtable}[]{@{}cccc@{}}
\toprule\noalign{}
Format Type & Data Description & Reader & Writer \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
text & CSV & read\_csv & to\_csv \\
text & Fixed-Width Text File & read\_fwf & NA \\
text & JSON & read\_json & to\_json \\
text & HTML & read\_html & to\_html \\
text & LaTeX & Styler.to\_latex & NA \\
text & XML & read\_xml & to\_xml \\
text & Local clipboard & read\_clipboard & to\_clipboard \\
binary & MS Excel & read\_excel & to\_excel \\
binary & OpenDocument & read\_excel & NA \\
binary & HDF5 Format & read\_hdf & to\_hdf \\
binary & Feather Format & read\_feather & to\_feather \\
binary & Parquet Format & read\_parquet & to\_parquet \\
binary & ORC Format & read\_orc & to\_orc \\
binary & Stata & read\_stata & to\_stata \\
binary & SAS & read\_sas & NA \\
binary & SPSS & read\_spss & NA \\
binary & Python Pickle Format & read\_pickle & to\_pickle \\
SQL & SQL & read\_sql & to\_sql \\
\end{longtable}

(\href{https://pandas.pydata.org/docs/user_guide/io.html}{Pandas
Dokumentation})

\section{Datentypen erkennen und
festlegen}\label{datentypen-erkennen-und-festlegen}

Der Datentyp bestimmt, wie bereits ausgeführt, den zulässigen
Wertebereich einer Variablen, zulässige Operationen und die Ausführung
von Operatoren und Funktionen in Python. Die Module NumPy und Pandas
bieten eine Reihe von Funktionen, um den Datentyp von Variablen zu
kontrollieren und festzulegen.

\emph{Hinweis: Der Datentyp datetime wird in
Chapter~\ref{sec-zeitreihen} behandelt.}

\subsection{NumPy}\label{numpy-1}

Mit NumPy kann der Datentyp eines Arrays beim Einlesen einer Datei mit
dem Argument \texttt{dtype} festgelegt werden
\texttt{np.loadtxt(fname\ =\ data.txt,\ dtype\ =\ \textquotesingle{}float\textquotesingle{})}.
Das Argument \texttt{dtype} akzeptiert die Angabe eines Datentyps,
Schlüsselwörter oder Kürzel. Weiter Informationen erhalten Sie in der
\href{https://numpy.org/doc/stable/reference/arrays.dtypes.html}{NumPy
Dokumentation}.

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Datentyp & Schlüsselwort & Kürzel & dtype \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Fließkommazahl & float & f8 & float64 \\
Ganzzahl & int & i & int32 \\
Wahrheitswert & bool & ? & bool \\
Datum & datetime64 & M & datetime64 \\
Zeichenkette & str & U & U + Ziffer zur Angabe der benötigten Bytes \\
\end{longtable}

Der Datentyp eines Arrays kann mit dem Attribut \texttt{np.dtype}
bestimmt werden. Der Datentyp eines Objekts kann mit der Methode
\texttt{np.array\ =\ np.array.astype()} geändert werden.

Folgende Datei ist Ihnen aus dem w-NumPy bekannt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/TC01.csv\textquotesingle{}}
\NormalTok{daten }\OperatorTok{=}\NormalTok{ np.loadtxt(dateipfad)}
\end{Highlighting}
\end{Shaded}

\textbf{Prüfen Sie den dtype der Datei und legen Sie eine Kopie des
Objekts mit Datentyp Ganzzahl an. Wie kann überprüft werden, ob bei der
Umwandlung in Ganzzahlen Nachkommastellen abgeschnitten wurden?}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-numpydatentyp}: Musterlösung Datentypumwandlung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-numpydatentyp} 

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ausgabe des Datentyps}
\BuiltInTok{print}\NormalTok{(daten.dtype)}

\CommentTok{\# Umwandlung in Ganzzahl}
\NormalTok{daten\_int }\OperatorTok{=}\NormalTok{ daten.astype(}\StringTok{\textquotesingle{}int\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Prüfen auf Datenverlust}
\NormalTok{prüfsumme }\OperatorTok{=}\NormalTok{ daten }\OperatorTok{{-}}\NormalTok{ daten\_int}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Differenz daten {-} daten\_int: }\SpecialCharTok{\{}\NormalTok{pr}\SpecialCharTok{ü}\NormalTok{fsumme}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
float64
Differenz daten - daten_int: 664.0
\end{verbatim}

\end{tcolorbox}

\subsection{Pandas}\label{pandas-1}

Das Modul Pandas ist auf den Umgang mit unterschiedlichen Datentypen
spezialisiert. Den Funktionen zum Einlesen von Daten kann mit dem
Argument \texttt{dtype} der Datentyp übergeben werden. Für mehrere
Spalten ist dies in Form eines Dictionaries in der Form
\texttt{\{\textquotesingle{}Spaltenname\textquotesingle{}:\ \textquotesingle{}dtype\textquotesingle{}\}}
möglich.\\
Das Atrribut zur Ausgabe des Datentyps heißt passenderweise
\texttt{pd.DataFrame.dtypes} (angefügtes s beachten). Der Datentyp eines
Pandas-Datenobjekts kann analog zu NumPy mit
\texttt{pd.Series\ =\ pd.Series.astype()} geändert werden.

\subsubsection{Zahnwachstum bei
Meerschweinchen}\label{zahnwachstum-bei-meerschweinchen}

In einer Gruppe von 60 Meerschweinchen (\textbf{1. Spalte ohne
Beschriftung}) wurde die Länge der zahnbildenden Zellen (Odontoblasten)
in Micron gemessen (\textbf{len}). Den Tieren wurde zuvor Vitamin C in
Form von Ascorbinsäure (VC) oder Orangensaft (VC) verabreicht
(\textbf{supp}). Die Meerschweinchen erhielten Dosen von 0.5, 1 oder 2
Milligramm Vitamin C pro Tag (\textbf{dose}). Die Messdaten sind in der
Datei ToothGrowth.csv gespeichert (Crampton 1947.)

Crampton, E. W. 1947. „THE GROWTH OF THE ODONTOBLASTS OF THE INCISOR
TOOTH AS A CRITERION OF THE VITAMIN C INTAKE OF THE GUINEA PIG``. The
Journal of Nutrition 33 (5): 491--504.
\url{https://doi.org/10.1093/jn/33.5.491}

~

\textbf{Lesen Sie die Datei wie folgt ein:}

\begin{itemize}
\item
  Die Spaltenbeschriftung der 1. Spalte soll mit der Beschriftung `ID'
  ersetzt werden (ohne Anführungszeichen).
\item
  Die Spalten len und dose sollen mit geeigneten numerischen Datentypen,
  die Spalte supp als Kategorie eingelesen werden.
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-meerschweinchen}: Musterlösung Meerschweinchen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-meerschweinchen} 

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/ToothGrowth.csv"}
\NormalTok{meerschweinchen }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ dateipfad, sep }\OperatorTok{=} \StringTok{\textquotesingle{},\textquotesingle{}}\NormalTok{, header }\OperatorTok{=} \DecValTok{0}\NormalTok{, }\OperatorTok{\textbackslash{}}
\NormalTok{  names }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}ID\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}supp\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{], dtype }\OperatorTok{=}\NormalTok{ \{}\StringTok{\textquotesingle{}ID\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}int\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}float\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}float\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}supp\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}category\textquotesingle{}}\NormalTok{\})}

\CommentTok{\# Ausgabe jedes sechsten Werts}
\NormalTok{meerschweinchen.iloc[meerschweinchen.index }\OperatorTok{\%} \DecValTok{6} \OperatorTok{==} \DecValTok{0}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
& ID & len & supp & dose \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 1 & 4.2 & VC & 0.5 \\
6 & 7 & 11.2 & VC & 0.5 \\
12 & 13 & 15.2 & VC & 1.0 \\
18 & 19 & 18.8 & VC & 1.0 \\
24 & 25 & 26.4 & VC & 2.0 \\
30 & 31 & 15.2 & OJ & 0.5 \\
36 & 37 & 8.2 & OJ & 0.5 \\
42 & 43 & 23.6 & OJ & 1.0 \\
48 & 49 & 14.5 & OJ & 1.0 \\
54 & 55 & 24.8 & OJ & 2.0 \\
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(meerschweinchen.dtypes)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ID         int64
len      float64
supp    category
dose     float64
dtype: object
\end{verbatim}

\end{tcolorbox}

\subsubsection{Nützliche Funktionen für die deskriptive
Datenanalyse}\label{nuxfctzliche-funktionen-fuxfcr-die-deskriptive-datenanalyse}

Pandas bietet einige praktische Funktionen, um den Aufbau eines
Datensatzes zu beschreiben.

Das Attribut \texttt{.columns} gibt die Spaltenbeschriftungen als Liste
zurück. Ebenfalls ist darüber ein Schreibzugriff möglich.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(meerschweinchen.columns)}
\NormalTok{meerschweinchen.columns }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}ID\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Länge\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Verabreichung\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Dosis\textquotesingle{}}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(meerschweinchen.columns)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Index(['ID', 'len', 'supp', 'dose'], dtype='object')
Index(['ID', 'Länge', 'Verabreichung', 'Dosis'], dtype='object')
\end{verbatim}

Die Methode \texttt{pd.DataFrame.describe()} erzeugt eine beschreibende
Statistik für einen DataFrame. Standardmäßig werden alle numerischen
Spalten berücksichtigt. Mit dem Argument \texttt{include} können die zu
berücksichtigenden Spalten vorgegeben werden. \texttt{include\ =\ all}
berücksichtigt alle Spalten, was nicht unbedingt sinnvoll ist.
Alternativ kann eine Liste zu berücksichtigender Datentypen übergeben
werden. Das Argument \texttt{exclude} schließt auf die gleiche Weise
Datentypen von der Ausgabe aus.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(meerschweinchen.describe(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(meerschweinchen.describe(include }\OperatorTok{=} \StringTok{\textquotesingle{}all\textquotesingle{}}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(meerschweinchen.describe(include }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}float\textquotesingle{}}\NormalTok{]), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
          ID  Länge  Dosis
count  60.00  60.00  60.00
mean   30.50  18.81   1.17
std    17.46   7.65   0.63
min     1.00   4.20   0.50
25%    15.75  13.07   0.50
50%    30.50  19.25   1.00
75%    45.25  25.27   2.00
max    60.00  33.90   2.00 

           ID  Länge Verabreichung  Dosis
count   60.00  60.00            60  60.00
unique    NaN    NaN             2    NaN
top       NaN    NaN            OJ    NaN
freq      NaN    NaN            30    NaN
mean    30.50  18.81           NaN   1.17
std     17.46   7.65           NaN   0.63
min      1.00   4.20           NaN   0.50
25%     15.75  13.07           NaN   0.50
50%     30.50  19.25           NaN   1.00
75%     45.25  25.27           NaN   2.00
max     60.00  33.90           NaN   2.00 

       Länge  Dosis
count  60.00  60.00
mean   18.81   1.17
std     7.65   0.63
min     4.20   0.50
25%    13.07   0.50
50%    19.25   1.00
75%    25.27   2.00
max    33.90   2.00 
\end{verbatim}

Die Methode \texttt{pd.DataFrame.count()} zählt alle vorhandenen Werte
in jeder Spalte oder mit
\texttt{pd.DataFrame.count(axis\ =\ \textquotesingle{}columns\textquotesingle{})}
in jeder Zeile.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{meerschweinchen.count(axis }\OperatorTok{=} \StringTok{\textquotesingle{}rows\textquotesingle{}}\NormalTok{) }\CommentTok{\# der Standardwert von axis ist \textquotesingle{}rows\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ID               60
Länge            60
Verabreichung    60
Dosis            60
dtype: int64
\end{verbatim}

Die Methode \texttt{pd.DataFrame.info()} erzeugt eine Beschreibung des
Datensatzes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{meerschweinchen.info()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 60 entries, 0 to 59
Data columns (total 4 columns):
 #   Column         Non-Null Count  Dtype   
---  ------         --------------  -----   
 0   ID             60 non-null     int64   
 1   Länge          60 non-null     float64 
 2   Verabreichung  60 non-null     category
 3   Dosis          60 non-null     float64 
dtypes: category(1), float64(2), int64(1)
memory usage: 1.7 KB
\end{verbatim}

Die Methode \texttt{pd.unique()} listet alle einzigartigen Werte auf.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{meerschweinchen[}\StringTok{\textquotesingle{}Dosis\textquotesingle{}}\NormalTok{].unique()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([0.5, 1. , 2. ])
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-pandasinfo}: Nützliche Funktionen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-pandasinfo} 

Pandas bietet einige praktische Funktionen, um eine eingelesene Datei zu
kontrollieren. Machen Sie sich die Verwendung von \texttt{pd.dtypes}
oder \texttt{pd.DataFrame.info()} zur Angewohnheit.

\end{tcolorbox}

\subsection{Aufgabe Datentypen}\label{aufgabe-datentypen}

Das britische Energieministerium veröffentlicht Daten zu den
Industriestrompreisen in den Mitgliedsändern der Internationalen
Energieagentur.\\
\textbf{Lesen Sie Tabellenblatt ``5.3.1 (excl. taxes)'' aus der
Excel-Datei `skript/01-daten/table\_531.xlsx' mit Pandas ein. Schauen
Sie in der Dokumentation der Funktion
\href{https://pandas.pydata.org/docs/reference/api/pandas.read_excel.html}{pd.read\_excel}
nach, wie Sie das korrekte Tabellenblatt auswählen können. Stellen Sie
sicher, dass alle Spalten mit einem numerischen Datentyp eingelesen
werden.}

Department for Energy Security \& Net Zero. 2024. Energy Prices
International Comparisons. Industrial electricity prices in the IEA.
\url{https://www.gov.uk/government/uploads/system/uploads/attachment_data/file/670121/table_531.xls}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-taxes}: Musterlösung 5.3.1 (excl. taxes)}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-taxes} 

Überspringen der führenden Zeilen mit dem Argument
\texttt{header\ =\ 8}. Auswahl des Tabellenblatts mit
\texttt{sheet\_name\ =\ "5.3.1\ (excl.\ taxes)"} und Kontrolle der
erkannten Datentypen mit \texttt{taxes.dtypes}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/table\_531.xlsx\textquotesingle{}}

\NormalTok{taxes }\OperatorTok{=}\NormalTok{ pd.read\_excel(io }\OperatorTok{=}\NormalTok{ dateipfad, sheet\_name }\OperatorTok{=} \StringTok{"5.3.1 (excl. taxes)"}\NormalTok{, }\OperatorTok{\textbackslash{}}
\NormalTok{  header }\OperatorTok{=} \DecValTok{8}\NormalTok{)}

\NormalTok{taxes.dtypes}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Year                            int64
Austria                       float64
Belgium                       float64
Denmark                       float64
Finland                       float64
France                        float64
Germany                       float64
Greece                        float64
Ireland                       float64
Italy                         float64
Luxembourg                    float64
Netherlands                   float64
Portugal                      float64
Spain                         float64
Sweden                        float64
United Kingdom                float64
Australia                     float64
Canada                        float64
Czech Republic                float64
Hungary                       float64
Japan                         float64
Korea                         float64
New Zealand                   float64
Norway                        float64
Poland                        float64
Slovakia                      float64
Switzerland                   float64
Republic of Türkiye            object
USA                           float64
IEA median                    float64
UK relative to IEA median%    float64
UK relative to IEA rank         int64
UK relative to G7 rank          int64
dtype: object
\end{verbatim}

Werte in Spalte `Republic of Türkiye' mit \texttt{pd.unique()} ansehen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{taxes[}\StringTok{\textquotesingle{}Republic of Türkiye\textquotesingle{}}\NormalTok{].unique()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array(['..', 2.0436081749999997, 3.3248584439999993, 3.2947581129644483,
       3.5628243387317866, 3.998334312, 3.838962582401693,
       4.2138469457789975, 3.775503630575527, 3.2804905218375238,
       3.783413840344277, 4.139259596071514, 4.196890742949158,
       4.658509330911754, 5.552842625063031, 4.316920402166109,
       4.1586205264300675, 4.765321921741988, 4.060617948410105,
       3.9191433658651307, 4.223710389549368, 4.481407237836746,
       4.629981488840797, 5.2657882806931235, 5.109009847145703,
       4.585007793872617, 4.769921255774284, 4.419433670846949,
       4.428906151745361, 6.171573537217762, 7.192920543071899,
       7.962417550086158, 7.035941949054445, 7.622058781522502,
       7.644892388451444, 6.47006818181818, 5.968380462724936,
       6.379514692256784, 5.537541821623266, 5.248709303933227,
       6.9100519994521274, 6.670900808798327, 5.864171132090749,
       13.928251887312259, 11.123594768114717], dtype=object)
\end{verbatim}

Zeichenkette `..' entfernen und Datentyp mit Methode
\texttt{pd.astype(\textquotesingle{}float64\textquotesingle{})} ändern.

\begin{itemize}
\item
  Variante 1: als fehlenden Wert beim Einlesen deklarieren.
\item
  Variante 2: Nach dem Einlesen Indexposition bestimmen und Wert
  ersetzen. Das verkettete Slicing
  \texttt{df{[}"col"{]}{[}row\_indexer{]}\ =\ value} wird mit der Pandas
  Version 3.0 nicht mehr unterstützt und gibt deshalb eine Fehlermeldung
  aus. Künftig ist folgende Syntax zu verwenden:
  \texttt{df.loc{[}row\_indexer,\ "col"{]}\ =\ value}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Variante 1: \textquotesingle{}..\textquotesingle{} als fehlenden Wert deklarieren}
\CommentTok{\# taxes = pd.read\_excel(io = dateipfad, sheet\_name = "5.3.1 (excl. taxes)", \textbackslash{}}
\CommentTok{\#   header = 8, na\_values = [\textquotesingle{}..\textquotesingle{}])}

\CommentTok{\# Variante 2: Index des Werts bestimmen und mit np.nan überschreiben}
\NormalTok{indexposition }\OperatorTok{=}\NormalTok{ taxes[}\StringTok{\textquotesingle{}Republic of Türkiye\textquotesingle{}}\NormalTok{] }\OperatorTok{==} \StringTok{\textquotesingle{}..\textquotesingle{}}

\NormalTok{taxes.loc[indexposition, }\StringTok{\textquotesingle{}Republic of Türkiye\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ np.nan}
\NormalTok{taxes[}\StringTok{\textquotesingle{}Republic of Türkiye\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ taxes[}\StringTok{\textquotesingle{}Republic of Türkiye\textquotesingle{}}\NormalTok{].astype(}\StringTok{\textquotesingle{}float64\textquotesingle{}}\NormalTok{)}

\NormalTok{taxes.dtypes}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Year                            int64
Austria                       float64
Belgium                       float64
Denmark                       float64
Finland                       float64
France                        float64
Germany                       float64
Greece                        float64
Ireland                       float64
Italy                         float64
Luxembourg                    float64
Netherlands                   float64
Portugal                      float64
Spain                         float64
Sweden                        float64
United Kingdom                float64
Australia                     float64
Canada                        float64
Czech Republic                float64
Hungary                       float64
Japan                         float64
Korea                         float64
New Zealand                   float64
Norway                        float64
Poland                        float64
Slovakia                      float64
Switzerland                   float64
Republic of Türkiye           float64
USA                           float64
IEA median                    float64
UK relative to IEA median%    float64
UK relative to IEA rank         int64
UK relative to G7 rank          int64
dtype: object
\end{verbatim}

\end{tcolorbox}

\section{Umgang mit fehlenden Werten}\label{umgang-mit-fehlenden-werten}

Eine unerwartet als string oder object eingelesene Spalte weist häufig
auf fehlende Werte hin, die durch Sonderzeichen gekennzeichnet sind. Die
Module NumPy und Pandas bieten Funktionen, um fehlende Werte bereits
beim Einlesen zu erkennen und umzuwandeln.

\emph{Hinweis: Maskierte NumPy-Arrays werden in Chapter~\ref{sec-ma}
behandelt.}

\subsection{NumPy}\label{numpy-2}

Die NumPy-Funktion \texttt{np.loadtxt()} wird verwendet, um vollständige
Datensätze einzulesen. Fehlende Werte im Datensatz können problematisch
sein, da diese entweder zu Fehlermeldungen bezüglich des Datentyps
führen oder übersprungen werden, sodass das NumPy-Array kürzer als der
eingelesene Datensatz ist. Da NumPy-Arrays immer nur einen Datentyp und
eine feste Länge haben, kann das bei der Durchführung von Operationen
mit mehreren Arrays zu Fehlern führen.

Folgende Datei ist Ihnen aus dem w-NumPy bekannt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/TC01.csv\textquotesingle{}}
\NormalTok{daten\_ohne\_fehlende\_werte }\OperatorTok{=}\NormalTok{ np.loadtxt(dateipfad)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Daten:"}\NormalTok{, daten\_ohne\_fehlende\_werte)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Struktur:"}\NormalTok{, daten\_ohne\_fehlende\_werte.shape, }\StringTok{"dtype:"}\NormalTok{, daten\_ohne\_fehlende\_werte.dtype)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Daten: [20.1 20.1 20.1 ... 24.3 24.2 24.2]
Struktur: (1513,) dtype: float64
\end{verbatim}

Angenommen, Sie haben eine zweite Messung durchgeführt und möchten die
Differenz beider Datensätze berechnen. In der zweiten Messung haben
Sensorfehler zu fehlenden Werten geführt, die mit \texttt{-\/-} markiert
sind. Die Funktion \texttt{np.loadtxt()} kann jedoch mit fehlenden
Werten nicht umgehen und gibt eine Fehlermeldung zurück.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/TC01\_double\_hyphen.csv\textquotesingle{}}

\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  daten\_double\_hypen }\OperatorTok{=}\NormalTok{ np.loadtxt(dateipfad)}
\ControlFlowTok{except} \PreprocessorTok{ValueError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Die Eingabe führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Daten mit fehlenden Werten \textquotesingle{}{-}{-}\textquotesingle{}:"}\NormalTok{, daten\_double\_hypen, }\StringTok{"dtype:"}\NormalTok{, daten\_double\_hypen.dtype) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Eingabe führt zu der Fehlermeldung:
 could not convert string '--' to float64 at row 1, column 1.
\end{verbatim}

\subsubsection{Die Funktion
np.genfromtxt()}\label{die-funktion-np.genfromtxt}

Um Datensätze mit fehlenden Werten einzulesen, wird die Funktion
\texttt{np.genfromtxt(fname,\ delimiter\ =\ None,\ missing\_values\ =\ None,\ filling\_values\ =\ None)}
verwendet. Dieses durchläuft den Datensatz \texttt{fname} in zwei
Schleifen, weshalb die Funktion langsamer als \texttt{np.loadtxt()} ist.
Die erste Schleife teilt den Datensatz zeilenweise am optional
übergebenen Trennzeichen \texttt{delimiter} in eine Zeichenkette auf.
Die zweite Schleife konvertiert jede Zeichenkette in den passenden
Datentyp. Mit den optionalen Argumenten \texttt{missing\_values} und
\texttt{filling\_values} können der Funktion Zeichenfolgen übergeben
werden, mit der fehlende Werte markiert sind bzw. ersetzt werden sollen.
(\href{https://numpy.org/doc/stable/user/basics.io.genfromtxt.html}{NumPy
Dokumentation})

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/TC01\_double\_hyphen.csv\textquotesingle{}}
\NormalTok{daten\_double\_hypen }\OperatorTok{=}\NormalTok{ np.genfromtxt(dateipfad, missing\_values }\OperatorTok{=} \StringTok{\textquotesingle{}{-}{-}\textquotesingle{}}\NormalTok{, filling\_values }\OperatorTok{=}\NormalTok{ np.nan)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Daten mit fehlenden Werten \textquotesingle{}{-}{-}\textquotesingle{}:"}\NormalTok{, daten\_double\_hypen)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Struktur:"}\NormalTok{, daten\_double\_hypen.shape, }\StringTok{"dtype:"}\NormalTok{, daten\_double\_hypen.dtype)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}

Daten mit fehlenden Werten '--': [20.1  nan 20.1 ... 24.3 24.2 24.2]
Struktur: (1513,) dtype: float64
\end{verbatim}

Durch die Umwandlung fehlender Werte in \texttt{nan}, sind Operationen
mit gleichlangen NumPy-Arrays möglich.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{daten\_differenz }\OperatorTok{=}\NormalTok{ daten\_ohne\_fehlende\_werte }\OperatorTok{{-}}\NormalTok{ daten\_double\_hypen}
\BuiltInTok{print}\NormalTok{(daten\_differenz)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[ 0. nan  0. ...  0.  0.  0.]
\end{verbatim}

Die Funktion \texttt{np.genfromtxt()} kann beliebige Zeichenketten als
fehlenden Wert verarbeiten. Lediglich leere Zellen können problematisch
sein, da deren Inhalt
\texttt{\textquotesingle{}\textbackslash{}n\textquotesingle{}} als
Zeilentrenner verarbeitet wird.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-npgenfromtxt}: Leere Zellen mit np.genfromtxt()}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-npgenfromtxt} 

Enthält eine Datei leere Zellen, können diese nicht eingelesen werden,
da diese automatisch übersprungen werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Datei ohne Markierung fehlender Werte}
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/TC01\_empty\_lines.csv\textquotesingle{}}
\NormalTok{daten\_empty\_lines }\OperatorTok{=}\NormalTok{ np.genfromtxt(dateipfad, missing\_values }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{, filling\_values }\OperatorTok{=}\NormalTok{ np.nan) }

\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Daten mit fehlenden Werten \textquotesingle{}\textquotesingle{}:"}\NormalTok{, daten\_empty\_lines)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Struktur:"}\NormalTok{, daten\_empty\_lines.shape, }\StringTok{"dtype:"}\NormalTok{, daten\_empty\_lines.dtype)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}

Daten mit fehlenden Werten '': [20.1 20.1 20.1 ... 24.3 24.2 24.2]
Struktur: (1511,) dtype: float64
\end{verbatim}

Das Array ist zwei Elemente kürzer. Die Subtraktion von einem längeren
NumPy-Array scheitert mit einer Fehlermeldung.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  result }\OperatorTok{=}\NormalTok{ daten\_ohne\_fehlende\_werte }\OperatorTok{{-}}\NormalTok{ daten\_empty\_lines}
\ControlFlowTok{except} \PreprocessorTok{ValueError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Die Eingabe führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(result)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Eingabe führt zu der Fehlermeldung:
 operands could not be broadcast together with shapes (1513,) (1511,) 
\end{verbatim}

In diesem Fall muss auf die Stringbearbeitung aus der Python-Basis
zurückgegriffen werden. Die bearbeitete Liste kann wie gewohnt mit
\texttt{np.genfromtxt()} eingelesen werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Einlesen über Datenobjekt}
\NormalTok{datenobjekt\_empty\_lines }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(dateipfad, }\StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{, encoding }\OperatorTok{=} \StringTok{\textquotesingle{}utf{-}8\textquotesingle{}}\NormalTok{)}
\NormalTok{daten\_empty\_lines }\OperatorTok{=}\NormalTok{ datenobjekt\_empty\_lines.readlines()}
\NormalTok{datenobjekt\_empty\_lines.close()}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Das ausgelesene Datenobjekt (Ausschnitt):}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, daten\_empty\_lines[}\DecValTok{0}\NormalTok{:}\DecValTok{10}\NormalTok{])}

\CommentTok{\# Stringbearbeitung mit replace(\textquotesingle{}\textbackslash{}n\textquotesingle{}, \textquotesingle{}\textquotesingle{})}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(daten\_empty\_lines)):}

  \ControlFlowTok{if}\NormalTok{ daten\_empty\_lines[i] }\OperatorTok{==} \StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{:}
\NormalTok{    daten\_empty\_lines[i] }\OperatorTok{=} \StringTok{\textquotesingle{}platzhalter\textquotesingle{}}
  \ControlFlowTok{else}\NormalTok{:}
\NormalTok{    daten\_empty\_lines[i] }\OperatorTok{=}\NormalTok{ daten\_empty\_lines[i].replace(}\StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Nach der Stringbearbeitung (Ausschnitt):}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, daten\_empty\_lines[}\DecValTok{0}\NormalTok{:}\DecValTok{10}\NormalTok{])}

\CommentTok{\# Einlesen mit np.genfromtxt}
\NormalTok{daten\_empty\_lines }\OperatorTok{=}\NormalTok{ np.genfromtxt(daten\_empty\_lines, missing\_values }\OperatorTok{=} \StringTok{\textquotesingle{}platzhalter\textquotesingle{}}\NormalTok{, filling\_values }\OperatorTok{=}\NormalTok{ np.nan)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Daten mit fehlenden Werten \textquotesingle{}\textquotesingle{}:"}\NormalTok{, daten\_empty\_lines)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Struktur:"}\NormalTok{, daten\_empty\_lines.shape, }\StringTok{"dtype:"}\NormalTok{, daten\_empty\_lines.dtype)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Das ausgelesene Datenobjekt (Ausschnitt):
 ['# Temperatur in C\n', '20.1\n', '\n', '20.1\n', '20.1\n', '20.1\n', '\n', '20.1\n', '20.1\n', '20.1\n']

Nach der Stringbearbeitung (Ausschnitt):
 ['# Temperatur in C', '20.1', 'platzhalter', '20.1', '20.1', '20.1', 'platzhalter', '20.1', '20.1', '20.1']

Daten mit fehlenden Werten '': [20.1  nan 20.1 ... 24.3 24.2 24.2]
Struktur: (1513,) dtype: float64
\end{verbatim}

\end{tcolorbox}

Besonders bei Dateien mit mehreren Spalten führen leere Zellen schnell
zu Fehlern. Hier ist es erforderlich, den Zeichentrenner mit dem
Argument \texttt{delimiter} zu spezifizieren. Aus der Dokumentation:\\
``When spaces are used as delimiters, or when no delimiter has been
given as input, there should not be any missing data between two
fields.''
(\href{https://numpy.org/doc/stable/reference/generated/numpy.genfromtxt.html}{NumPy
Dokumentation})

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-npgenfromtxt}: Leere Zellen in mehreren Spalten mit np.genfromtxt()}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-npgenfromtxt} 

Ohne Spezifikation des Arguments \texttt{delimiter} wird nur eine Spalte
eingelesen, die ausschließlich \texttt{np.nan} enthält.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# ohne Spezifikation von delimiter}
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/TC01\_missing\_values\_multi\_column.csv\textquotesingle{}}
\NormalTok{daten\_empty\_lines2 }\OperatorTok{=}\NormalTok{ np.genfromtxt(dateipfad, missing\_values }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{, filling\_values }\OperatorTok{=}\NormalTok{ np.nan, ndmin }\OperatorTok{=} \DecValTok{2}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Struktur:"}\NormalTok{, daten\_empty\_lines2.shape, }\StringTok{"dtype:"}\NormalTok{, daten\_empty\_lines2.dtype)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Die ersten drei Zeilen:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, daten\_empty\_lines2[}\DecValTok{0}\NormalTok{:}\DecValTok{3}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Struktur: (1513, 1) dtype: float64
Die ersten drei Zeilen:
 [[nan]
 [nan]
 [nan]]
\end{verbatim}

Wird das Argument
\texttt{delimiter\ =\ \textquotesingle{},\textquotesingle{}} übergeben,
wird die Datei korrekt eingelesen.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# mit Spezifikation von delimiter}
\NormalTok{daten\_empty\_lines2 }\OperatorTok{=}\NormalTok{ np.genfromtxt(dateipfad, delimiter }\OperatorTok{=} \StringTok{\textquotesingle{},\textquotesingle{}}\NormalTok{, missing\_values }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{, filling\_values }\OperatorTok{=}\NormalTok{ np.nan, ndmin }\OperatorTok{=} \DecValTok{2}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Struktur:"}\NormalTok{, daten\_empty\_lines2.shape, }\StringTok{"dtype:"}\NormalTok{, daten\_empty\_lines2.dtype)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Daten mit fehlenden Werten \textquotesingle{}\textquotesingle{}:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, daten\_empty\_lines2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Struktur: (1513, 2) dtype: float64

Daten mit fehlenden Werten '':
 [[20.1 20.1]
 [ nan  nan]
 [20.1 20.1]
 ...
 [24.3 24.3]
 [24.2 24.2]
 [24.2 24.2]]
\end{verbatim}

\end{tcolorbox}

\subsubsection{Fehlende Werte in NumPy erzeugen, prüfen, finden,
ersetzen,
löschen}\label{fehlende-werte-in-numpy-erzeugen-pruxfcfen-finden-ersetzen-luxf6schen}

Das Modul NumPy bietet Funktionen, um mit fehlenden Werten zu arbeiten.

\begin{itemize}
\item
  \texttt{np.nan} erzeugt einen fehlenden Wert.
\item
  \texttt{np.isnan()} prüft auf einen fehlenden Wert und gibt einen
  Wahrheitswert bzw. ein NumPy-Array mit dtype bool zurück.
\item
  \texttt{np.nonzero(np.isnan(array))} gibt ein Tuple zurück, das ein
  Array mit den Indexpositionen der Elemente mit dem Wert `nan' enthält.
  Auf das Array kann mit \texttt{np.nonzero(np.isnan(array)){[}0{]}}
  zugegriffen werden. Je nach Situation kann die Umwandlung in eine
  Liste nützlich sein
  \texttt{np.nonzero(np.isnan(array)){[}0{]}.tolist()}.\\
  Eine ähnliche Funktion ist \texttt{np.argwhere(np.isnan(array))},
  deren Ausgabe aber nicht für das Slicing mehrdimensionaler Arrays
  geeignet ist (siehe folgendes Beispiel).
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-npargwhere}: Die Funktion np.argwhere()}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-npargwhere} 

Eine andere Funktion, um die Indexposition eines Werts zu bestimmen, ist
die Funktion \texttt{np.argwhere()}. Der Aufruf der Funktion
\texttt{np.argwhere(np.isnan(array))} gibt ein NumPy-Array mit den
Indexposition Elemente mit dem Wert \texttt{nan} zurück.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{array }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{1}\NormalTok{, np.nan, np.nan], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, np.nan]])}
\BuiltInTok{print}\NormalTok{(array)}

\NormalTok{np.argwhere(np.isnan(array))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[ 1. nan nan]
 [ 4.  5. nan]]
\end{verbatim}

\begin{verbatim}
array([[0, 1],
       [0, 2],
       [1, 2]])
\end{verbatim}

Das mit \texttt{np.argwhere()} erzeugte Array ist aber nicht geeignet,
um Arraybereiche auszuwählen.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  array[np.argwhere(np.isnan(array))]}
\ControlFlowTok{except} \PreprocessorTok{IndexError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Die Eingabe führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(array[np.argwhere(np.isnan(array))]) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Eingabe führt zu der Fehlermeldung:
 index 2 is out of bounds for axis 0 with size 2
\end{verbatim}

Zum Vergleich mit \texttt{np.nonzero()}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  array[np.nonzero(np.isnan(array))]}
\ControlFlowTok{except} \PreprocessorTok{IndexError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Die Eingabe führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(array[np.nonzero(np.isnan(array))]) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[nan nan nan]
\end{verbatim}

\phantomsection\label{wrn-npargwhere}
\begin{quote}
\textbf{Warning~52.1: Die Funktion np.arghwhere()}

Die Auswahl von Array-Bereichen mit \texttt{np.argwhere()} funktioniert
für eindimensionale Arrays.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{array }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, np.nan, np.nan, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{])}

\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  array[np.argwhere(np.isnan(array))]}
\ControlFlowTok{except} \PreprocessorTok{IndexError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Die Eingabe führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(array[np.argwhere(np.isnan(array))]) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[nan]
 [nan]]
\end{verbatim}
\end{quote}

\end{tcolorbox}

\begin{itemize}
\tightlist
\item
  \texttt{nan\_to\_num(x\ =\ array,\ nan\ =\ 0.0)} ersetzt im Array x
  \texttt{nan} durch den Wert 0.0 oder durch den im Argument
  \texttt{nan} übergebenen Wert. (Hinweis: \texttt{nan\_to\_num()}
  ersetzt standardmäßig auch \texttt{np.inf} durch große positive sowie
  \texttt{-np.inf} durch große negative Zahlen.)\\
  Die Ersetzung eines bestimmten Werts ist auch mit einem logischen
  Vektor möglich (siehe folgendes Beispiel).
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-vectorslicing}: Wertzuweisung mit logischem Vektor}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-vectorslicing} 

Die Ersetzung eines bestimmten Werts ist auch durch die Auswahl
bestimmter Array-Bereiche durch einen logischen Vektor möglich.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, np.nan, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, np.nan])}

\NormalTok{b }\OperatorTok{=}\NormalTok{ np.isnan(a)}

\BuiltInTok{print}\NormalTok{(b)}

\NormalTok{a[b] }\OperatorTok{=} \DecValTok{0}

\BuiltInTok{print}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[False False False  True False False  True]
[1. 2. 3. 0. 5. 6. 0.]
\end{verbatim}

Dabei können mehrere Bedingungen mit der Funktion
\texttt{np.logical\_or(x1,\ x2)} als logisches ODER kombiniert werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, np.nan, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, np.nan])}

\NormalTok{bedingung1 }\OperatorTok{=}\NormalTok{ np.isnan(a)}

\NormalTok{bedingung2 }\OperatorTok{=}\NormalTok{ a }\OperatorTok{\textgreater{}=} \DecValTok{5}

\NormalTok{bedingung }\OperatorTok{=}\NormalTok{ np.logical\_or(bedingung1, bedingung2)}

\NormalTok{a[bedingung] }\OperatorTok{=} \DecValTok{0}

\BuiltInTok{print}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1. 2. 3. 0. 0. 0. 0.]
\end{verbatim}

Auch ein logisches UND ist möglich (aber in Verbindung mit np.nan nicht
sinnvoll). Der Operator * bewirkt das gleiche wie der logische Operator
\texttt{and} oder die Funktion \texttt{np.logical\_and(x1,\ x2)}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, np.nan, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, np.nan])}

\NormalTok{bedingung1 }\OperatorTok{=}\NormalTok{ a }\OperatorTok{\textless{}} \DecValTok{4}

\NormalTok{bedingung2 }\OperatorTok{=}\NormalTok{ a }\OperatorTok{\textgreater{}=} \DecValTok{1}

\NormalTok{bedingung }\OperatorTok{=}\NormalTok{ bedingung1 }\OperatorTok{*}\NormalTok{ bedingung2}

\NormalTok{a[bedingung] }\OperatorTok{=} \DecValTok{0}

\BuiltInTok{print}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[ 0.  0.  0. nan  5.  6. nan]
\end{verbatim}

\end{tcolorbox}

\begin{itemize}
\tightlist
\item
  \texttt{np.delete(arr\ =\ array,\ obj)} gibt ein neues (kürzeres)
  Array ohne die im Parameter obj spezifizierten Array-Bereiche zurück.
  Alle Elemente mit dem Wert \texttt{nan} werden so gelöscht:
  \texttt{np.delete(array,\ obj\ =\ np.nonzero(np.isnan(array)))}
\end{itemize}

NumPy wandelt \texttt{None} nicht automatisch in \texttt{nan} um. NumPy
kann den Datentyp des Objekts deshalb nicht bestimmen und gibt
\texttt{dtype=object} aus:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np\_array\_with\_none }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\VariableTok{None}\NormalTok{, }\DecValTok{4}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(np\_array\_with\_none, np\_array\_with\_none.dtype)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1 2 None 4] object
\end{verbatim}

\textbf{Aufgabe: Wie kann im Array np\_array\_with\_none \texttt{None}
durch \texttt{np.nan} ersetzt werden?}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-numpynone}: Lösung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-numpynone} 

Eine logische Abfrage von \texttt{None} ist möglich. Auf diese Weise
kann ein logisches Array erzeugt werden, das zur Auswahl der
Indexpositionen verwendet wird, deren Werte ersetzt werden sollen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np\_array\_with\_none }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\VariableTok{None}\NormalTok{, }\DecValTok{4}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(np\_array\_with\_none)}

\NormalTok{np\_array\_with\_nan }\OperatorTok{=}\NormalTok{ np\_array\_with\_none.copy()}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Array mit logischer Abfrage von None:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{np\_array\_with\_none }\OperatorTok{==} \VariableTok{None}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\NormalTok{np\_array\_with\_nan[np\_array\_with\_none }\OperatorTok{==} \VariableTok{None}\NormalTok{] }\OperatorTok{=}\NormalTok{ np.nan}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Array mit None ersetzt durch nan:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{np\_array\_with\_nan}\SpecialCharTok{,}\NormalTok{ np\_array\_with\_nan}\SpecialCharTok{.}\NormalTok{dtype}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1 2 None 4]

Array mit logischer Abfrage von None:
[False False  True False]

Array mit None ersetzt durch nan:
(array([1, 2, nan, 4], dtype=object), dtype('O'))
\end{verbatim}

\end{tcolorbox}

~

\subsubsection{Operationen mit fehlenden
Werten}\label{operationen-mit-fehlenden-werten}

Operationen mit \texttt{nan} ergeben immer \texttt{nan}. Deshalb gibt es
in NumPy viele Funktionen, die \texttt{nan} automatisch ignorieren bzw.
durch einen geeigneten Wert ersetzen. Diese sind bereits am
Funktionsnamen erkennbar. Beispielsweise liefern \texttt{np.nansum()}
und \texttt{np.nancumsum()} die Summe bzw. die kumulierte Summe eines
Arrays. In der kumulierten Summe werden \texttt{nan} durch das laufende
Ergebnis ersetzt. Eine vollständige Liste der NumPy-Funktionen finden
Sie in der
\href{https://numpy.org/doc/stable/reference/routines.html}{Dokumentation}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Array mit nan:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{np\_array\_with\_nan}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Summe des Arrays:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{(np\_array\_with\_nan)}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"nan{-}Summe des Arrays:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\NormalTok{nansum(np\_array\_with\_nan)}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"kumulierte Summe des Arrays:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\NormalTok{cumsum(np\_array\_with\_nan)}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"kumulierte nan{-}Summe des Arrays:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\NormalTok{nancumsum(np\_array\_with\_nan)}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Array mit nan:
[1 2 nan 4]

Summe des Arrays:
nan

nan-Summe des Arrays:
7

kumulierte Summe des Arrays:
[1 3 nan nan]

kumulierte nan-Summe des Arrays:
[1 3 3 7]
\end{verbatim}

\subsection{Pandas}\label{pandas-2}

Die Pandas-Funktionen zum Lesen von Dateien können mit fehlenden Werten
umgehen. Standardmäßig werden folgende Werte als fehlende Werte
erkannt:\\
\texttt{{[}\textquotesingle{}-1.\#IND\textquotesingle{},\ \textquotesingle{}1.\#QNAN\textquotesingle{},\ \textquotesingle{}1.\#IND\textquotesingle{},\ \textquotesingle{}-1.\#QNAN\textquotesingle{},\ \textquotesingle{}\#N/A\ N/A\textquotesingle{},\ \textquotesingle{}\#N/A\textquotesingle{},\ \textquotesingle{}N/A\textquotesingle{},\ \textquotesingle{}n/a\textquotesingle{},\ \textquotesingle{}NA\textquotesingle{},\ \textquotesingle{}\textless{}NA\textgreater{}\textquotesingle{},\ \textquotesingle{}\#NA\textquotesingle{},\ \textquotesingle{}NULL\textquotesingle{},\ \textquotesingle{}null\textquotesingle{},\ \textquotesingle{}NaN\textquotesingle{},\ \textquotesingle{}-NaN\textquotesingle{},\ \textquotesingle{}nan\textquotesingle{},\ \textquotesingle{}-nan\textquotesingle{},\ \textquotesingle{}None\textquotesingle{},\ \textquotesingle{}\textquotesingle{}{]}}

Weitere Werte können mit dem Argument \texttt{na\_values\ =\ {[}{]}} als
fehlende Werte definiert werden. Mit dem Argument
\texttt{keep\_default\_na\ =\ False} kann festgelegt werden, dass
ausschließlich die in \texttt{na\_values\ =\ {[}{]}} übergebenen Werte
als fehlende Werte interpretiert werden sollen. Standardmäßig werden mit
dem Argument \texttt{na\_filter\ =\ True} auch leere Zellen als NA
eingelesen. Vollständig leere Zeilen werden jedoch standardmäßig
übersprungen. Dies kann mit dem Argument
\texttt{skip\_blank\_lines\ =\ False} geändert werden.
(\href{https://pandas.pydata.org/docs/user_guide/io.html\#io-navaluesconst}{Pandas
Dokumentation})

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/TC01\_double\_hyphen.csv\textquotesingle{}}

\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  daten\_double\_hypen }\OperatorTok{=}\NormalTok{ pd.read\_csv(dateipfad, na\_values }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}{-}{-}\textquotesingle{}}\NormalTok{])}
\ControlFlowTok{except} \PreprocessorTok{ValueError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Die Eingabe führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Daten mit fehlenden Werten \textquotesingle{}{-}{-}\textquotesingle{}:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, daten\_double\_hypen, daten\_double\_hypen.shape) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Daten mit fehlenden Werten '--':
       # Temperatur in C
0                  20.1
1                   NaN
2                  20.1
3                  20.1
4                  20.1
...                 ...
1508               24.3
1509               24.3
1510               24.3
1511               24.2
1512               24.2

[1513 rows x 1 columns] (1513, 1)
\end{verbatim}

Mit dem Argument \texttt{skip\_blank\_lines\ =\ False} werden leere
Zeilen ebenfalls eingelesen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/TC01\_empty\_lines.csv\textquotesingle{}}

\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  daten\_empty\_lines }\OperatorTok{=}\NormalTok{ pd.read\_csv(dateipfad, skip\_blank\_lines }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\ControlFlowTok{except} \PreprocessorTok{ValueError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Die Eingabe führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Daten mit fehlenden Werten \textquotesingle{}\textquotesingle{}:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, daten\_empty\_lines, daten\_empty\_lines.shape) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Daten mit fehlenden Werten '':
       # Temperatur in C
0                  20.1
1                   NaN
2                  20.1
3                  20.1
4                  20.1
...                 ...
1508               24.3
1509               24.3
1510               24.3
1511               24.2
1512               24.2

[1513 rows x 1 columns] (1513, 1)
\end{verbatim}

Pandas verwendet abhängig vom Datentyp verschiedene Werte zur
Kennzeichnung fehlender Werte.

\begin{itemize}
\item
  \texttt{numpy.nan} für NumPy-Datentypen. Hierbei wird der Datentyp
  automatisch in \texttt{np.float64} oder \texttt{object} konvertiert.
\item
  \texttt{pd.NA} für Zeichenketten und Ganzzahlen. Der Datentyp bleibt
  erhalten.
\end{itemize}

Einlesen der Datei TC01\_empty\_lines.csv als string:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/TC01\_empty\_lines.csv\textquotesingle{}}

\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  daten\_empty\_lines }\OperatorTok{=}\NormalTok{ pd.read\_csv(dateipfad, skip\_blank\_lines }\OperatorTok{=} \VariableTok{False}\NormalTok{, dtype }\OperatorTok{=} \StringTok{\textquotesingle{}string\textquotesingle{}}\NormalTok{)}
\ControlFlowTok{except} \PreprocessorTok{ValueError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Die Eingabe führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Daten mit fehlenden Werten \textquotesingle{}\textquotesingle{}:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, daten\_empty\_lines, daten\_empty\_lines.shape) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Daten mit fehlenden Werten '':
      # Temperatur in C
0                 20.1
1                 <NA>
2                 20.1
3                 20.1
4                 20.1
...                ...
1508              24.3
1509              24.3
1510              24.3
1511              24.2
1512              24.2

[1513 rows x 1 columns] (1513, 1)
\end{verbatim}

\texttt{NA} kann zwar auch als fehlender Wert für Gleitkommazahlen und
andere NumPy Datentypen verwendet werden. Allerdings wird dafür ein
Pandas-Datentyp benötigt (siehe das folgende Beispiel).

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-pdNA}: pd.Series mit np.nan und pd.NA}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-pdNA} 

Eine pd.Series mit \texttt{np.nan} wird automatisch in
\texttt{dtype:\ float64} umgewandelt:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  test }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, np.nan])}
\ControlFlowTok{except} \PreprocessorTok{TypeError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Die Eingabe führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(test) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0    1.0
1    2.0
2    NaN
dtype: float64
\end{verbatim}

Eine pd.Series mit \texttt{pd.NA} wird als \texttt{dtype:\ object}
eingelesen:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  test }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, pd.NA])}
\ControlFlowTok{except} \PreprocessorTok{TypeError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Die Eingabe führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(test) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0       1
1       2
2    <NA>
dtype: object
\end{verbatim}

Der \texttt{dtype} kann für eine Series mit \texttt{pd.NA} festgelegt
werden:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  test }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, pd.NA], dtype }\OperatorTok{=} \StringTok{\textquotesingle{}Int32\textquotesingle{}}\NormalTok{)}
\ControlFlowTok{except} \PreprocessorTok{TypeError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Die Eingabe führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(test) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0       1
1       2
2    <NA>
dtype: Int32
\end{verbatim}

Abhängig vom Datentyp kommt es auf den korrekten \texttt{dtype} (NumPy
oder Pandas) an, erkennbar an der Groß- und Kleinschreibung.
\texttt{pd.NA} mit Numpy-Fließkommazahl:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  test }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, pd.NA], dtype }\OperatorTok{=} \StringTok{\textquotesingle{}float64\textquotesingle{}}\NormalTok{)}
\ControlFlowTok{except} \PreprocessorTok{TypeError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Die Eingabe führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(test) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Eingabe führt zu der Fehlermeldung:
 float() argument must be a string or a real number, not 'NAType'
\end{verbatim}

\texttt{pd.NA} mit Pandas-Fließkommazahl:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  test }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, pd.NA], dtype }\OperatorTok{=} \StringTok{\textquotesingle{}Float64\textquotesingle{}}\NormalTok{)}
\ControlFlowTok{except} \PreprocessorTok{TypeError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Die Eingabe führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(test) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0     1.0
1     2.0
2    <NA>
dtype: Float64
\end{verbatim}

\texttt{np.nan} mit Numpy-Fließkommazahl:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  test }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, np.nan], dtype }\OperatorTok{=} \StringTok{\textquotesingle{}float64\textquotesingle{}}\NormalTok{)}
\ControlFlowTok{except} \PreprocessorTok{TypeError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Die Eingabe führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(test) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0    1.0
1    2.0
2    NaN
dtype: float64
\end{verbatim}

\texttt{np.nan} mit Pandas-Fließkommazahl:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  test }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, np.nan], dtype }\OperatorTok{=} \StringTok{\textquotesingle{}Float64\textquotesingle{}}\NormalTok{)}
\ControlFlowTok{except} \PreprocessorTok{TypeError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Die Eingabe führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(test) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0     1.0
1     2.0
2    <NA>
dtype: Float64
\end{verbatim}

\end{tcolorbox}

~

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-logicpandas} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-logicpandas}: Achtung Logik!}\vspace{3mm}

Die logische Abfrage fehlender Werte unterscheidet sich für
\texttt{None}, \texttt{np.nan} und \texttt{pd.NA}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bool\_values }\OperatorTok{=}\NormalTok{ [}\VariableTok{None}\NormalTok{, }\BuiltInTok{float}\NormalTok{(}\StringTok{\textquotesingle{}nan\textquotesingle{}}\NormalTok{), pd.NA]}

\ControlFlowTok{for}\NormalTok{ element }\KeywordTok{in}\NormalTok{ bool\_values:}
  \ControlFlowTok{try}\NormalTok{:}
\NormalTok{    bool\_value }\OperatorTok{=} \BuiltInTok{bool}\NormalTok{(element)}
  \ControlFlowTok{except} \PreprocessorTok{TypeError} \ImportTok{as}\NormalTok{ error:}
      \BuiltInTok{print}\NormalTok{(error)}
  \ControlFlowTok{else}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Wahrheitswert von"}\NormalTok{, element, }\StringTok{"ist"}\NormalTok{, bool\_value)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Wahrheitswert von None ist False
Wahrheitswert von nan ist True
boolean value of NA is ambiguous
\end{verbatim}

Dies gilt auch für die Wertgleichheit.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bool\_values }\OperatorTok{=}\NormalTok{ [}\VariableTok{None}\NormalTok{, }\BuiltInTok{float}\NormalTok{(}\StringTok{\textquotesingle{}nan\textquotesingle{}}\NormalTok{), pd.NA]}

\ControlFlowTok{for}\NormalTok{ element }\KeywordTok{in}\NormalTok{ bool\_values:}
  \ControlFlowTok{try}\NormalTok{:}
\NormalTok{    result }\OperatorTok{=}\NormalTok{ element }\OperatorTok{==}\NormalTok{ element}
  \ControlFlowTok{except} \PreprocessorTok{TypeError} \ImportTok{as}\NormalTok{ error:}
      \BuiltInTok{print}\NormalTok{(error)}
  \ControlFlowTok{else}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Wertgleichheit von"}\NormalTok{, element, }\StringTok{"ist"}\NormalTok{, result)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Wertgleichheit von None ist True
Wertgleichheit von nan ist False
Wertgleichheit von <NA> ist <NA>
\end{verbatim}

\end{minipage}%
\end{tcolorbox}

(\href{https://pandas.pydata.org/docs/user_guide/missing_data.html}{Pandas
Dokumentation})

\subsubsection{Fehlende Werte in Pandas erzeugen, prüfen, finden,
ersetzen,
löschen}\label{fehlende-werte-in-pandas-erzeugen-pruxfcfen-finden-ersetzen-luxf6schen}

Das Modul Pandas wandelt \texttt{None} automatisch in \texttt{nan} um.
Das Modul Pandas bietet wie das Modul NumPy verschiedene Funktionen, um
mit fehlenden Werten zu arbeiten.

\begin{itemize}
\item
  \texttt{pd.NA} erzeugt einen fehlenden Wert (Groß- und Kleinschreibung
  beachten: \texttt{pd.na} funktioniert nicht)
\item
  Die Funktionen \texttt{pd.isnull()} und \texttt{pd.isna()} prüfen auf
  einen fehlenden Wert und geben einen Wahrheitswert bzw. ein
  NumPy-Array mit dtype bool zurück. Die Funktionen \texttt{pd.notna()}
  und \texttt{pd.notnull()} prüfen den umgekehrten Fall.
\item
  Die Funktion \texttt{np.nonzero(pd.isna())} verwendet die
  NumPy-Funktion \texttt{np.nonzero()} und gibt ein Array mit den
  Indexpositionen der Elemente mit fehlenden Werten zurück (die
  Pandas-Funktion pd.nonzero() wird nicht mehr unterstützt).
\item
  \texttt{pd.Series.fillna(value\ =\ 0)} ersetzt fehlende Werte mit dem
  im Argument \texttt{value} übergebenen Wert. Die Methoden
  \texttt{pd.ffill()} und \texttt{pd.bfill()} ersetzen fehlende Werte
  mit dem letzten bzw. dem nächsten gültigen Wert. Die Methode
  \texttt{pd.Series.interpolate()} ersetzt fehlende Werte durch
  Interpolation, wofür ein Datentyp definiert sein muss
  (\texttt{dtype\ =\ object} funktioniert nicht). Standardmäßig wird
  linear interpoliert, es stehen aber verschiedene Methoden zur
  Verfügung (siehe
  \href{https://pandas.pydata.org/docs/reference/api/pandas.Series.interpolate.html}{Pandas
  Dokumentation})
\item
  Die Methode \texttt{pd.Series.dropna()} gibt eine neue (kürzere)
  Series ohne fehlende Wert zurück.
\end{itemize}

\subsubsection{Operationen mit fehlenden
Werten}\label{operationen-mit-fehlenden-werten-1}

Operationen mit \texttt{pd.NA} ergeben in der Regel \texttt{pd.NA}. Es
gibt jedoch einige Ausnahmen:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.NA }\OperatorTok{**} \DecValTok{0}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\DecValTok{1} \OperatorTok{**}\NormalTok{ pd.NA)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
1
\end{verbatim}

Die Methode \texttt{pd.Series.sum()} behandelt \texttt{pd.NA} als 0, die
Methode \texttt{pd.Series.prod()} als 1.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.Series([pd.NA]).}\BuiltInTok{sum}\NormalTok{())}
\BuiltInTok{print}\NormalTok{(pd.Series([pd.NA]).prod())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0
1
\end{verbatim}

Reduzierende Methoden wie \texttt{pd.Series.min()} oder
\texttt{pd.Series.mean()} sowie zusammenfassende Methoden wie
\texttt{pd.Series.cumsum()} oder \texttt{pd.Series.cumprod()}
überspringen \texttt{pd.NA}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.Series([pd.NA]).}\BuiltInTok{min}\NormalTok{())}
\BuiltInTok{print}\NormalTok{(pd.Series([pd.NA]).mean())}
\BuiltInTok{print}\NormalTok{(pd.Series([pd.NA]).cumsum())}
\BuiltInTok{print}\NormalTok{(pd.Series([pd.NA]).cumprod())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
nan
nan
0    NaN
dtype: object
0    NaN
dtype: object
\end{verbatim}

Das Verhalten von Methoden wie \texttt{pd.Series.sum()} und von Methoden
wie \texttt{pd.Series.min()} hat für Datenreihen einen vergleichbaren
Effekt, produziert für einzelne Werte jedoch unterschiedliche
Ergebnisse.

\subsection{Aufgabe fehlende Werte}\label{aufgabe-fehlende-werte}

Der Deutsche Wetterdienst misst deutschlandweit verschiedene
Wetterdaten. In der Datei
`produkt\_st\_stunde\_20230831\_20240630\_01303.txt' sind stündliche
Stationsmessungen der Solarstrahlung in Essen-Bredeney gespeichert.

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Spaltenname & Beschreibung \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
STATIONS\_ID & Stationsnummer \\
QN\_592 & Qualitätsniveau der Daten \\
ATMO\_LBERG & Stundensumme der atmosphärischen Gegenstrahlung \\
FD\_LBERG & Stundensumme der diffusen solaren Strahlung \\
FG\_LBERG & Stundensumme der Globalstrahlung \\
SD\_LBERG & Stundensumme der Sonnenscheindauer \\
ZENIT & Zenitwinkel der Sonne 0 - 180 Grad \\
\end{longtable}

Deutscher Wetterdienst. 2024. Stündliche Stationsmessung der
Solarstrahlung (global/diffus) und der atmosphärischen Gegenstrahlung
für Deutschland.
\url{https://opendata.dwd.de/climate_environment/CDC/observations_germany/climate/hourly/solar/stundenwerte_ST_01303_row.zip}
Die Spalten MESS\_DATUM, MESS\_DATUM\_WOZ und eor wurden entfernt.

~

\textbf{Bestimmen Sie die Kodierung fehlender Werte und ersetzen Sie
diese durch \texttt{np.nan} bzw. \texttt{pd.NA}. Wie viele Werte wurden
ersetzt?}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-musterlösungfehlendewerte}: Musterlösung fehlende Werte}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-musterlösungfehlendewerte} 

Mit der Methode \texttt{df.info()} ist erkennbar, dass der Datensatz
vollständig ist.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/produkt\_st\_stunde\_20230831\_20240630\_01303.txt"}
\NormalTok{solar }\OperatorTok{=}\NormalTok{ pd.read\_csv(dateipfad, sep }\OperatorTok{=} \StringTok{";"}\NormalTok{)}

\NormalTok{solar.info()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 7296 entries, 0 to 7295
Data columns (total 7 columns):
 #   Column       Non-Null Count  Dtype  
---  ------       --------------  -----  
 0   STATIONS_ID  7296 non-null   int64  
 1   QN_592       7296 non-null   int64  
 2   ATMO_LBERG   7296 non-null   float64
 3   FD_LBERG     7296 non-null   float64
 4   FG_LBERG     7296 non-null   float64
 5   SD_LBERG     7296 non-null   int64  
 6   ZENIT        7296 non-null   float64
dtypes: float64(4), int64(3)
memory usage: 399.1 KB
\end{verbatim}

Mit der Methode \texttt{df.describe()} wird die deskriptive Statistik
für numerische Spalten erstellt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{solar.describe()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllll@{}}
\toprule\noalign{}
& STATIONS\_ID & QN\_592 & ATMO\_LBERG & FD\_LBERG & FG\_LBERG &
SD\_LBERG & ZENIT \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
count & 7296.0 & 7296.0 & 7296.00 & 7296.00 & 7296.00 & 7296.00 &
7296.00 \\
mean & 1303.0 & 1.0 & 111.80 & -31.23 & -16.46 & 9.00 & 92.65 \\
std & 0.0 & 0.0 & 89.42 & 222.34 & 229.74 & 18.66 & 30.02 \\
min & 1303.0 & 1.0 & -999.00 & -999.00 & -999.00 & 0.00 & 28.56 \\
25\% & 1303.0 & 1.0 & 112.00 & 0.00 & 0.00 & 0.00 & 70.61 \\
50\% & 1303.0 & 1.0 & 121.00 & 0.00 & 0.00 & 0.00 & 92.40 \\
75\% & 1303.0 & 1.0 & 127.25 & 25.00 & 33.00 & 3.00 & 115.97 \\
max & 1303.0 & 1.0 & 150.00 & 182.00 & 348.00 & 60.00 & 151.44 \\
\end{longtable}

Drei Spalten weisen als minimalen Wert -999 auf, der inhaltlich nicht
sinnvoll ist. Wie oft kommt der Wert -999 in den Spalten vor?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{counting\_df }\OperatorTok{=}\NormalTok{ solar[[}\StringTok{\textquotesingle{}ATMO\_LBERG\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}FD\_LBERG\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}FG\_LBERG\textquotesingle{}}\NormalTok{]] }\OperatorTok{==} \OperatorTok{{-}}\DecValTok{999}
\BuiltInTok{print}\NormalTok{(counting\_df.}\BuiltInTok{sum}\NormalTok{())}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Summe:}\CharTok{\textbackslash{}t\textbackslash{}t}\StringTok{ "}\NormalTok{, counting\_df.}\BuiltInTok{sum}\NormalTok{().}\BuiltInTok{sum}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ATMO_LBERG     46
FD_LBERG      359
FG_LBERG      353
dtype: int64
Summe:        758
\end{verbatim}

\end{tcolorbox}

\chapter{Zeitreihen}\label{sec-zeitreihen}

\section{Datum und Zeit in NumPy und
Pandas}\label{datum-und-zeit-in-numpy-und-pandas}

Die Module NumPy und Pandas nutzen den Datentyp \texttt{datetime64}, um
Datums- und Zeitinformationen zu verarbeiten.

\section{NumPy}

\texttt{datetime64}-Objekte werden mit der Funktion
\texttt{np.datetime64()} angelegt, der Datentyp wird in der Ausgabe von
Python auch durch den Buchstaben M repräsentiert.
\texttt{datetime64}-Objekte können auf zwei Arten angelegt werden:

\begin{itemize}
\tightlist
\item
  Eine Zeichenkette nach
  \href{https://www.iso.org/iso-8601-date-and-time-format.html}{ISO
  8601} als Repräsentation eines Datums in der festgelegten Reihenfolge
  Jahr, Monat, Tag, Stunde, Minute, Sekunde, Millisekunde im Format
  \texttt{YYYY-MM-DD\ 12:00:00.000}. Als Zeichentrenner zwischen Datum
  und Uhrzeit sind ein Leerzeichen oder der Buchstabe T zulässig. Der
  Datentyp und die kleinste verwendete Einheit werden im Attribut
  \texttt{dtype} gespeichert.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(np.datetime64(}\StringTok{\textquotesingle{}2024\textquotesingle{}}\NormalTok{), np.datetime64(}\StringTok{\textquotesingle{}2024\textquotesingle{}}\NormalTok{).dtype)}
\BuiltInTok{print}\NormalTok{(np.datetime64(}\StringTok{\textquotesingle{}2024{-}10{-}31\textquotesingle{}}\NormalTok{), np.datetime64(}\StringTok{\textquotesingle{}2024{-}10{-}31\textquotesingle{}}\NormalTok{).dtype)}
\BuiltInTok{print}\NormalTok{(np.datetime64(}\StringTok{\textquotesingle{}2024{-}10{-}31T12:24:59.999\textquotesingle{}}\NormalTok{), np.datetime64(}\StringTok{\textquotesingle{}2024{-}10{-}31T12:24:59.999\textquotesingle{}}\NormalTok{).dtype)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2024 datetime64[Y]
2024-10-31 datetime64[D]
2024-10-31T12:24:59.999 datetime64[ms]
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Als Zahl relativ zur Epoche und unter Angabe einer Zeiteinheit. Die
  verfügbaren Zeiteinheiten sind years (`Y'), months (`M'), weeks (`W'),
  days (`D') sowie hours (`h'), minutes (`m'), seconds (`s'),
  milliseconds (`ms') und weitere sekundenbasierte Einheiten bis zur
  Attosekunde (siehe
  \href{https://numpy.org/doc/stable/reference/arrays.datetime.html\#datetime-units}{NumPy
  Dokumentation}).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(np.datetime64(}\DecValTok{10} \OperatorTok{*} \DecValTok{1000}\NormalTok{, }\StringTok{\textquotesingle{}D\textquotesingle{}}\NormalTok{), np.datetime64(}\DecValTok{10} \OperatorTok{*} \DecValTok{1000}\NormalTok{, }\StringTok{\textquotesingle{}D\textquotesingle{}}\NormalTok{).dtype)}
\BuiltInTok{print}\NormalTok{(np.datetime64(}\DecValTok{1000} \OperatorTok{*} \DecValTok{1000}\NormalTok{, }\StringTok{\textquotesingle{}h\textquotesingle{}}\NormalTok{), np.datetime64(}\DecValTok{1000} \OperatorTok{*} \DecValTok{1000}\NormalTok{, }\StringTok{\textquotesingle{}h\textquotesingle{}}\NormalTok{).dtype)}
\BuiltInTok{print}\NormalTok{(np.datetime64(}\DecValTok{1000} \OperatorTok{*} \DecValTok{1000} \OperatorTok{*} \DecValTok{1000}\NormalTok{, }\StringTok{\textquotesingle{}s\textquotesingle{}}\NormalTok{), np.datetime64(}\DecValTok{1000} \OperatorTok{*} \DecValTok{1000} \OperatorTok{*} \DecValTok{1000}\NormalTok{, }\StringTok{\textquotesingle{}s\textquotesingle{}}\NormalTok{).dtype)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1997-05-19 datetime64[D]
2084-01-29T16 datetime64[h]
2001-09-09T01:46:40 datetime64[s]
\end{verbatim}

Außerdem können Datetime-Formate anderer Module in
\texttt{np.datetime64()} umgewandelt werden.

Beim Anlegen eines Arrays, kann die Zeiteinheit gewählt werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_array }\OperatorTok{=}\NormalTok{ np.array([}\StringTok{\textquotesingle{}2007{-}07{-}13\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}2006{-}01{-}13\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}2010{-}08{-}13\textquotesingle{}}\NormalTok{], dtype }\OperatorTok{=} \StringTok{\textquotesingle{}datetime64[s]\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(my\_array, my\_array.dtype)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['2007-07-13T00:00:00' '2006-01-13T00:00:00' '2010-08-13T00:00:00'] datetime64[s]
\end{verbatim}

Der Datentyp \texttt{datetime64} ist mit den meisten NumPy-Funktionen
kompatibel.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.arange(}\StringTok{\textquotesingle{}2005{-}02\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}2005{-}03\textquotesingle{}}\NormalTok{, dtype }\OperatorTok{=} \StringTok{\textquotesingle{}datetime64[D]\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array(['2005-02-01', '2005-02-02', '2005-02-03', '2005-02-04',
       '2005-02-05', '2005-02-06', '2005-02-07', '2005-02-08',
       '2005-02-09', '2005-02-10', '2005-02-11', '2005-02-12',
       '2005-02-13', '2005-02-14', '2005-02-15', '2005-02-16',
       '2005-02-17', '2005-02-18', '2005-02-19', '2005-02-20',
       '2005-02-21', '2005-02-22', '2005-02-23', '2005-02-24',
       '2005-02-25', '2005-02-26', '2005-02-27', '2005-02-28'],
      dtype='datetime64[D]')
\end{verbatim}

(\href{https://numpy.org/doc/stable/reference/arrays.datetime.html}{NumPy
Dokumentation})

\section{Pandas}

In Pandas werden \texttt{datetime64}-Objekte mit den Funktionen
\texttt{pd.to\_datetime()} oder \texttt{pd.date\_range()} angelegt.\\
\emph{Hinweis: Eine weitere Möglichkeit ist die Funktion
\texttt{pd.Timestamp()}, die umfangreichere Möglichkeiten zur Erzeugung
eines Zeitpunkts bietet, aber kein string-parsing unterstützt.}

\texttt{pd.to\_datetime()} erzeugt Werte des Datentyps
\texttt{datetime64{[}ns{]}} (mit \texttt{pd.to\_datetime()} erzeugte
Skalare (Einzelwerte) werden als Timestamp (Zeitpunkt) ausgegeben, die
kein Attribut \texttt{dtype} haben). Die Funktion
\texttt{pd.to\_datetime()} akzeptiert als Eingabewerte:

\begin{itemize}
\item
  datetime-Objekte anderer Module.
\item
  Zahlen und eine Zeiteinheit
  \texttt{pd.to\_datetime(1,\ unit\ =\ None)} (Standard sind
  Nanosekunden). Das Argument \texttt{unit} nimmt die Werte `ns', `ms',
  `s', `m', `h', `D', `W' für Nanosekunde, Millisekunde, Sekunde,
  Minute, Stunde, Tag, Woche und `MS' oder `ME' für einen Monat (für
  Monatsanfang oder Monatsende) sowie für das Jahr `YS' oder `YE' (für
  Jahresanfang oder Jahresende) entgegen. Erzeugt wird ein Zeitpunkt
  relativ zur Epoche.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(}\DecValTok{1000}\NormalTok{, unit }\OperatorTok{=} \StringTok{\textquotesingle{}D\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(}\DecValTok{1000} \OperatorTok{*} \DecValTok{1000}\NormalTok{, unit }\OperatorTok{=} \StringTok{\textquotesingle{}h\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(}\DecValTok{1000} \OperatorTok{*} \DecValTok{1000} \OperatorTok{*} \DecValTok{1000}\NormalTok{, unit }\OperatorTok{=} \StringTok{\textquotesingle{}s\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1972-09-27 00:00:00
2084-01-29 16:00:00
2001-09-09 01:46:40
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Zeichenketten, die ein Datum oder ein Datum mit Uhrzeit ausdrücken,
  formatiert nach
  \href{https://www.iso.org/iso-8601-date-and-time-format.html}{ISO
  8601}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(}\StringTok{\textquotesingle{}2017\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(}\StringTok{\textquotesingle{}2017{-}01{-}01T00\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(}\StringTok{\textquotesingle{}2017{-}01{-}01 00:00:00\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2017-01-01 00:00:00
2017-01-01 00:00:00
2017-01-01 00:00:00
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Anders formatierte Zeichenketten mit dem Argument format =
  \texttt{"\%d/\%m/\%Y"} (siehe
  \href{https://docs.python.org/3/library/datetime.html\#strftime-and-strptime-behavior}{Dokumentation
  strftime zur string-Formatierung}).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(}\StringTok{\textquotesingle{}Monday, 12. August \textasciigrave{}24\textquotesingle{}}\NormalTok{, }\BuiltInTok{format} \OperatorTok{=} \StringTok{"\%A, }\SpecialCharTok{\%d}\StringTok{. \%B \textasciigrave{}\%y"}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(}\StringTok{\textquotesingle{}Monday, 12. August 2024, 12:15 Uhr CET\textquotesingle{}}\NormalTok{, }\BuiltInTok{format} \OperatorTok{=} \StringTok{"\%A, }\SpecialCharTok{\%d}\StringTok{. \%B \%Y, \%H:\%M Uhr \%Z"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2024-08-12 00:00:00
2024-08-12 12:15:00+02:00
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Dictionary oder DataFrame.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(\{}\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{:[}\DecValTok{2020}\NormalTok{, }\DecValTok{2024}\NormalTok{], }\StringTok{\textquotesingle{}month\textquotesingle{}}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{], }\StringTok{\textquotesingle{}day\textquotesingle{}}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{21}\NormalTok{]\}), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(pd.to\_datetime(pd.DataFrame(\{}\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{:[}\DecValTok{2020}\NormalTok{, }\DecValTok{2024}\NormalTok{], }\StringTok{\textquotesingle{}month\textquotesingle{}}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{], }\StringTok{\textquotesingle{}day\textquotesingle{}}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{21}\NormalTok{]\})))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0   2020-01-01
1   2024-11-21
dtype: datetime64[ns] 

0   2020-01-01
1   2024-11-21
dtype: datetime64[ns]
\end{verbatim}

Die Funktion \texttt{pd.date\_range()} erzeugt ein Array vom Typ
\texttt{DatetimeIndex} mit dtype \texttt{datetime64}. Genau drei der
folgenden vier Argumente sind für die Erzeugung erforderlich:

\begin{itemize}
\item
  start: Beginn der Reihe.
\item
  end: Ende der Reihe (inklusiv)
\item
  freq: Schrittweite (bspw. Jahr, Tag, Geschäftstag, Stunde oder
  Vielfache wie `6h' - siehe
  \href{https://pandas.pydata.org/docs/user_guide/timeseries.html\#timeseries-offset-aliases}{Liste
  verfügbarer strings})
\item
  periods: Anzahl der zu erzeugenden Werte.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.date\_range(start }\OperatorTok{=} \StringTok{\textquotesingle{}2017\textquotesingle{}}\NormalTok{, end }\OperatorTok{=} \StringTok{\textquotesingle{}2024\textquotesingle{}}\NormalTok{, periods }\OperatorTok{=} \DecValTok{3}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(pd.date\_range(start }\OperatorTok{=} \StringTok{\textquotesingle{}2017\textquotesingle{}}\NormalTok{, end }\OperatorTok{=} \StringTok{\textquotesingle{}2024\textquotesingle{}}\NormalTok{, freq }\OperatorTok{=} \StringTok{\textquotesingle{}YE\textquotesingle{}}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(pd.date\_range(end }\OperatorTok{=} \StringTok{\textquotesingle{}2024\textquotesingle{}}\NormalTok{, freq }\OperatorTok{=} \StringTok{\textquotesingle{}h\textquotesingle{}}\NormalTok{, periods }\OperatorTok{=} \DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
DatetimeIndex(['2017-01-01', '2020-07-02', '2024-01-01'], dtype='datetime64[ns]', freq=None) 

DatetimeIndex(['2017-12-31', '2018-12-31', '2019-12-31', '2020-12-31',
               '2021-12-31', '2022-12-31', '2023-12-31'],
              dtype='datetime64[ns]', freq='YE-DEC') 

DatetimeIndex(['2023-12-31 22:00:00', '2023-12-31 23:00:00',
               '2024-01-01 00:00:00'],
              dtype='datetime64[ns]', freq='h')
\end{verbatim}

Zeitdifferenzen werden über einen eigenen Datentyp dargestellt (siehe
folgendes Beispiel).\\

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Zeitdifferenzen in NumPy und Pandas}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\section{NumPy}

Zeitdifferenzen werden mit dem Datentyp \texttt{timedelta64} abgebildet.
Dieser wird wie \texttt{datetime64} durch Angabe einer Ganzzahl und
einer Zeiteinheit angelegt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{np.timedelta64(}\DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}D\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
np.timedelta64(1,'D')
\end{verbatim}

Objekte der Typen \texttt{datetime64} und \texttt{timedelta64}
ermöglichen es, Operationen mit Datum und Zeit durchzuführen (weitere
Beispiele in der
\href{https://numpy.org/doc/stable/reference/arrays.datetime.html\#datetime-and-timedelta-arithmetic}{NumPy-Dokumentation}).

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(np.datetime64(}\StringTok{\textquotesingle{}today\textquotesingle{}}\NormalTok{) }\OperatorTok{{-}}\NormalTok{ np.datetime64(}\StringTok{\textquotesingle{}2000{-}01{-}01\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}D\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(np.datetime64(}\StringTok{\textquotesingle{}now\textquotesingle{}}\NormalTok{) }\OperatorTok{{-}}\NormalTok{ np.datetime64(}\StringTok{\textquotesingle{}2000{-}01{-}01\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}h\textquotesingle{}}\NormalTok{))}

\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n\textbackslash{}n}\StringTok{Eine einfache Zeitverschiebung:"}\NormalTok{, np.datetime64(}\StringTok{\textquotesingle{}now\textquotesingle{}}\NormalTok{) }\OperatorTok{{-}}\NormalTok{ np.timedelta64(}\DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}h\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Wie viele Tage hat die Woche?"}\NormalTok{, np.timedelta64(}\DecValTok{1}\NormalTok{,}\StringTok{\textquotesingle{}W\textquotesingle{}}\NormalTok{) }\OperatorTok{/}\NormalTok{ np.timedelta64(}\DecValTok{1}\NormalTok{,}\StringTok{\textquotesingle{}D\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
9552 days
825328125 seconds


Eine einfache Zeitverschiebung: 2026-02-25T08:48:45
Wie viele Tage hat die Woche? 7.0
\end{verbatim}

\section{Pandas}

Zeitdifferenzen können zum einen wie in NumPy durch Angabe einer
Ganzzahl und einer Zeiteinheit angelegt werden. Außerdem ist die
Übergabe mit Argumenten möglich (zulässige Argumente sind: weeks, days,
hours, minutes, seconds, milliseconds, microseconds, nanoseconds).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pd.Timedelta(}\DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}D\textquotesingle{}}\NormalTok{)}
\NormalTok{pd.Timedelta(days }\OperatorTok{=} \DecValTok{1}\NormalTok{, hours }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Timedelta('1 days 01:00:00')
\end{verbatim}

\textbf{Wichtig:} Anders als in NumPy werden Zeitdifferenzen in Monaten
und Jahren nicht mehr von Pandas unterstützt.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{( pd.Timedelta(}\DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}YE\textquotesingle{}}\NormalTok{))}
\ControlFlowTok{except} \PreprocessorTok{ValueError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(error)}
\ControlFlowTok{else}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{( pd.Timedelta(}\DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}YE\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
invalid unit abbreviation: YE
\end{verbatim}

Zum anderen können Zeitdifferenzen mit einer Zeichenkette erzeugt
werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(pd.Timedelta(}\StringTok{\textquotesingle{}10sec\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(pd.Timedelta(}\StringTok{\textquotesingle{}10min\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(pd.Timedelta(}\StringTok{\textquotesingle{}10hours\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(pd.Timedelta(}\StringTok{\textquotesingle{}10days\textquotesingle{}}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(pd.Timedelta(}\StringTok{\textquotesingle{}10w\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0 days 00:00:10
0 days 00:10:00
0 days 10:00:00
10 days 00:00:00
70 days 00:00:00
\end{verbatim}

Mit Hilfe einer Zeitdifferenz können Zeitreihen leicht verschoben
werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pd.date\_range(start }\OperatorTok{=} \StringTok{\textquotesingle{}2024{-}01{-}01T00:00\textquotesingle{}}\NormalTok{, end }\OperatorTok{=} \StringTok{\textquotesingle{}2024{-}01{-}01T02:00\textquotesingle{}}\NormalTok{, freq }\OperatorTok{=} \StringTok{\textquotesingle{}15min\textquotesingle{}}\NormalTok{) }\OperatorTok{+}\NormalTok{ pd.Timedelta(}\StringTok{\textquotesingle{}30min\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
DatetimeIndex(['2024-01-01 00:30:00', '2024-01-01 00:45:00',
               '2024-01-01 01:00:00', '2024-01-01 01:15:00',
               '2024-01-01 01:30:00', '2024-01-01 01:45:00',
               '2024-01-01 02:00:00', '2024-01-01 02:15:00',
               '2024-01-01 02:30:00'],
              dtype='datetime64[ns]', freq='15min')
\end{verbatim}

~

\textbf{Wie alt sind Sie in Tagen? Wie alt in Sekunden? Rechnen Sie mit
NumPy oder Pandas.}

\phantomsection\label{tip-alter}
\begin{quote}
\textbf{Tip~53.2: Tipp Pandas und Musterlösung Alter}

Für eine elegante Lösung in Pandas schauen Sie sich die verfügbaren
Methoden und Attribute von Timedelta-Objekten an.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dir(pd.Timedelta(0))}
\end{Highlighting}
\end{Shaded}

\phantomsection\label{tip-loesungalter}
\begin{quote}
\textbf{Tip~53.1: Musterlösung}

Ersetzen sie in der Lösung die Zeichenkette `YYYY-MM-DD' bzw., wenn Sie
die Uhrzeit Ihrer Geburt kennen, die Zeichenkette `YYYY-MM-DDTHH:MM'
durch ihren Geburtstag.

\subsubsection{NumPy}\label{numpy-5}

In NumPy können die Schlüsselwörter
\texttt{np.datetime64(\textquotesingle{}today\textquotesingle{})} und
\texttt{np.datetime64(\textquotesingle{}now\textquotesingle{})}
verwendet werden. Die Ausgabe ist in Tagen bzw. in Sekunden aufgelöst.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{print(np.datetime64(\textquotesingle{}today\textquotesingle{}) {-} np.datetime64(\textquotesingle{}YYYY{-}MM{-}DD\textquotesingle{}, \textquotesingle{}D\textquotesingle{}))}
\NormalTok{print(np.datetime64(\textquotesingle{}now\textquotesingle{}) {-} np.datetime64(\textquotesingle{}YYYY{-}MM{-}DDTHH:MM\textquotesingle{}, \textquotesingle{}s\textquotesingle{}))}
\end{Highlighting}
\end{Shaded}

\subsubsection{Pandas}\label{pandas-5}

In Pandas werden die Schlüsselwörter
\texttt{pd.to\_datetime(\textquotesingle{}today\textquotesingle{})} und
\texttt{pd.to\_datetime(\textquotesingle{}now\textquotesingle{})} in
Nanosekunden aufgelöst.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(pd.to\_datetime(\textquotesingle{}today\textquotesingle{}) {-} pd.to\_datetime(\textquotesingle{}YYYY{-}MM{-}DD\textquotesingle{})).days}
\NormalTok{(pd.to\_datetime(\textquotesingle{}now\textquotesingle{}) {-} pd.to\_datetime(\textquotesingle{}YYYY{-}MM{-}DDTHH:MM\textquotesingle{})).total\_seconds()}
\end{Highlighting}
\end{Shaded}
\end{quote}
\end{quote}

\end{tcolorbox}

\section{Zeitreihen einlesen}\label{zeitreihen-einlesen-1}

Insbesondere das Modul Pandas bietet effiziente Möglichkeiten, um
Datumsformate korrekt einzulesen. Im Folgenden wird das Einlesen von
Zeitreihen mit NumPy und Pandas anhand von Strommarktdaten demonstriert.
In Section~\ref{sec-übungenzeitreihen} stehen verschiedene
Übungsaufgaben zur Verfügung.

Die Bundesnetzagentur veröffentlicht verschiedene Strommarktdaten,
darunter die Großhandelspreise. Die Strommarktdaten der
Bundesnetzagentur müssen manuell auf
\href{https://www.smard.de/home/downloadcenter/download-marktdaten/}{https://www.smard.de/}
heruntergeladen werden. In diesem Skript werden Daten für das Jahr 2023
benutzt.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Daten
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Dateiname
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Großhandelspreise 2023 &
Gro\_handelspreise\_202301010000\_202401010000\_Stunde.csv \\
Großhandelspreise 2023 (Englisch) &
Day-ahead\_prices\_202301010000\_202401010000\_Hour.csv \\
\end{longtable}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-SMARD} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-SMARD}: SMARD Daten herunterladen}\vspace{3mm}

\begin{figure}[H]

\begin{minipage}{0.50\linewidth}
Beim der Auswahl des Zeitraums auf Akzeptieren klicken.\end{minipage}%
%
\begin{minipage}{0.50\linewidth}
Daten in Originalauflösung auswählen und auf Download
klicken.\end{minipage}%
\newline
\begin{minipage}{0.50\linewidth}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/m-einlesen-strukturierter-datensaetze/skript/00-bilder/smard-accept.png}}

}

\subcaption{~}

\end{figure}%

\end{minipage}%
%
\begin{minipage}{0.50\linewidth}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/m-einlesen-strukturierter-datensaetze/skript/00-bilder/smard-day-ahead-prices.png}}

}

\subcaption{~}

\end{figure}%

\end{minipage}%
\newline
\begin{minipage}{\linewidth}
Das Datumsformat der Dateien ist abhängig von der auf der Internetseite
eingestellten Sprache (Deutsch/English).\end{minipage}%

\end{figure}%

\end{minipage}%
\end{tcolorbox}

\subsection{NumPy}

Der Versuch, die Datei mit \texttt{np.loadtxt()} einzulesen, führt zu
verschiedenen Fehlermeldungen (Datentyp ist nicht numerisch, Spaltenzahl
kann nicht ermittelt werden). Diesen wird durch Spezifizierung des
Datentyps \texttt{dtype\ =\ str} und der Beschränkung auf die erste
Zeile \texttt{max\_rows\ =\ 1} begegnet.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/Gro\_handelspreise\_202301010000\_202401010000\_Stunde.csv"}
\NormalTok{preise }\OperatorTok{=}\NormalTok{ np.loadtxt(fname }\OperatorTok{=}\NormalTok{ dateipfad, dtype }\OperatorTok{=} \StringTok{\textquotesingle{}str\textquotesingle{}}\NormalTok{, max\_rows }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{preise}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array(['\ufeffDatum', 'von;Datum', 'bis;Deutschland/Luxemburg', '[€/MWh]',
       'Originalauflösungen;∅', 'Anrainer', 'DE/LU', '[€/MWh]',
       'Originalauflösungen;Belgien', '[€/MWh]',
       'Originalauflösungen;Dänemark', '1', '[€/MWh]',
       'Originalauflösungen;Dänemark', '2', '[€/MWh]',
       'Originalauflösungen;Frankreich', '[€/MWh]',
       'Originalauflösungen;Niederlande', '[€/MWh]',
       'Originalauflösungen;Norwegen', '2', '[€/MWh]',
       'Originalauflösungen;Österreich', '[€/MWh]',
       'Originalauflösungen;Polen', '[€/MWh]',
       'Originalauflösungen;Schweden', '4', '[€/MWh]',
       'Originalauflösungen;Schweiz', '[€/MWh]',
       'Originalauflösungen;Tschechien', '[€/MWh]',
       'Originalauflösungen;DE/AT/LU', '[€/MWh]',
       'Originalauflösungen;Italien', '(Nord)', '[€/MWh]',
       'Originalauflösungen;Slowenien', '[€/MWh]',
       'Originalauflösungen;Ungarn', '[€/MWh]', 'Originalauflösungen'],
      dtype='<U31')
\end{verbatim}

Auf diese Weise kann die erste Zeile eingelesen und das Semikolon als
Zeichentrenner identifiziert werden. Außerdem sind Fehler mit der
Zeichenkodierung auffällig. Deshalb werden der Zeichentrenner mit
\texttt{delimiter\ =\ \textquotesingle{};\textquotesingle{}} und die
Kodierung der Datei mit
\texttt{encoding\ =\ \textquotesingle{}UTF-8\textquotesingle{}}
übergeben.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/Gro\_handelspreise\_202301010000\_202401010000\_Stunde.csv"}
\NormalTok{preise }\OperatorTok{=}\NormalTok{ np.loadtxt(fname }\OperatorTok{=}\NormalTok{ dateipfad, dtype }\OperatorTok{=} \StringTok{\textquotesingle{}str\textquotesingle{}}\NormalTok{, max\_rows }\OperatorTok{=} \DecValTok{1}\NormalTok{, delimiter }\OperatorTok{=} \StringTok{\textquotesingle{};\textquotesingle{}}\NormalTok{, encoding }\OperatorTok{=} \StringTok{\textquotesingle{}UTF{-}8\textquotesingle{}}\NormalTok{)}
\NormalTok{preise}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array(['\ufeffDatum von', 'Datum bis',
       'Deutschland/Luxemburg [€/MWh] Originalauflösungen',
       '∅ Anrainer DE/LU [€/MWh] Originalauflösungen',
       'Belgien [€/MWh] Originalauflösungen',
       'Dänemark 1 [€/MWh] Originalauflösungen',
       'Dänemark 2 [€/MWh] Originalauflösungen',
       'Frankreich [€/MWh] Originalauflösungen',
       'Niederlande [€/MWh] Originalauflösungen',
       'Norwegen 2 [€/MWh] Originalauflösungen',
       'Österreich [€/MWh] Originalauflösungen',
       'Polen [€/MWh] Originalauflösungen',
       'Schweden 4 [€/MWh] Originalauflösungen',
       'Schweiz [€/MWh] Originalauflösungen',
       'Tschechien [€/MWh] Originalauflösungen',
       'DE/AT/LU [€/MWh] Originalauflösungen',
       'Italien (Nord) [€/MWh] Originalauflösungen',
       'Slowenien [€/MWh] Originalauflösungen',
       'Ungarn [€/MWh] Originalauflösungen'], dtype='<U49')
\end{verbatim}

Es verbleibt die Zeichenkette ``\textbackslash ufeff'' am Beginn des
Arrays. Diese kennzeichnet die
\href{https://de.wikipedia.org/wiki/Byte-Reihenfolge}{Byte-Reihenfolge}
der Datei. Diese kann mit der Übergabe der Kodierung
\texttt{encoding\ =\ \textquotesingle{}UTF-8-sig\textquotesingle{}}
übersprungen werden (\href{https://stackoverflow.com/a/72466627}{Mark
Tolonen auf stackoverflow.com},
\href{https://docs.python.org/3/library/codecs.html}{Python
Dokumentation}). Auf diese Weise wird die erste Zeile korrekt
eingelesen, sodass die Anzahl der einzulesenden Zeilen mit
\texttt{max\_rows\ =\ 2} erweitert werden kann, um die Datentypen zu
identifizieren.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{preise }\OperatorTok{=}\NormalTok{ np.loadtxt(fname }\OperatorTok{=}\NormalTok{ dateipfad, dtype }\OperatorTok{=} \StringTok{\textquotesingle{}str\textquotesingle{}}\NormalTok{, max\_rows }\OperatorTok{=} \DecValTok{2}\NormalTok{, delimiter }\OperatorTok{=} \StringTok{\textquotesingle{};\textquotesingle{}}\NormalTok{, encoding }\OperatorTok{=} \StringTok{\textquotesingle{}UTF{-}8{-}sig\textquotesingle{}}\NormalTok{)}
\NormalTok{preise}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([['Datum von', 'Datum bis',
        'Deutschland/Luxemburg [€/MWh] Originalauflösungen',
        '∅ Anrainer DE/LU [€/MWh] Originalauflösungen',
        'Belgien [€/MWh] Originalauflösungen',
        'Dänemark 1 [€/MWh] Originalauflösungen',
        'Dänemark 2 [€/MWh] Originalauflösungen',
        'Frankreich [€/MWh] Originalauflösungen',
        'Niederlande [€/MWh] Originalauflösungen',
        'Norwegen 2 [€/MWh] Originalauflösungen',
        'Österreich [€/MWh] Originalauflösungen',
        'Polen [€/MWh] Originalauflösungen',
        'Schweden 4 [€/MWh] Originalauflösungen',
        'Schweiz [€/MWh] Originalauflösungen',
        'Tschechien [€/MWh] Originalauflösungen',
        'DE/AT/LU [€/MWh] Originalauflösungen',
        'Italien (Nord) [€/MWh] Originalauflösungen',
        'Slowenien [€/MWh] Originalauflösungen',
        'Ungarn [€/MWh] Originalauflösungen'],
       ['01.01.2023 00:00', '01.01.2023 01:00', '-5,17', '13,85',
        '-4,39', '2,01', '2,01', '0,00', '-3,61', '119,32', '12,06',
        '18,09', '2,01', '0,03', '4,84', '-', '195,90', '13,31', '19,76']],
      dtype='<U49')
\end{verbatim}

Die ersten beiden Spalten enthalten Datums- und Zeitinformationen, die
folgenden numerische Werte, wobei eine Spalte mit `-' kodierte fehlende
Werte enthält. Als Dezimaltrennzeichen wird das Komma verwendet. Da
NumPy-Arrays immer nur einen Datentyp enthalten können, muss der
Datensatz entsprechend aufgeteilt werden. Für die viertletzte Spalte ist
zu prüfen, ob diese ausschließlich fehlende Werte enthält.

Zunächst wird der Datensatz vollständig als string eingelesen, die
Spaltenbeschriftungen werden mit \texttt{skiprows\ =\ 1} übersprungen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{preise }\OperatorTok{=}\NormalTok{ np.loadtxt(fname }\OperatorTok{=}\NormalTok{ dateipfad, dtype }\OperatorTok{=} \StringTok{\textquotesingle{}str\textquotesingle{}}\NormalTok{, delimiter }\OperatorTok{=} \StringTok{\textquotesingle{};\textquotesingle{}}\NormalTok{, encoding }\OperatorTok{=} \StringTok{\textquotesingle{}UTF{-}8{-}sig\textquotesingle{}}\NormalTok{, skiprows }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Anschließend werden im ersten Schritt die Datumsspalten isoliert. NumPy
unterstützt keine String-Formatierung, die Zeitstempel müssen deshalb
manuell von `01.01.2023 00:00' in die Formatierung nach ISO 8601
`YYYY-MM-DDThh:mm' konvertiert werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Datumsspalten isolieren}
\NormalTok{preise\_date }\OperatorTok{=}\NormalTok{ preise[ : , }\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{]}

\CommentTok{\# Zeichenkette manuell ins Format ISO 8601 bringen}
\CommentTok{\#\# Spalte 0}
\CommentTok{\#\#\# neues Array anlegen}
\NormalTok{preise\_datumvon }\OperatorTok{=}\NormalTok{ np.array([], dtype }\OperatorTok{=} \StringTok{\textquotesingle{}datetime64\textquotesingle{}}\NormalTok{)}

\ControlFlowTok{for}\NormalTok{ element }\KeywordTok{in}\NormalTok{ preise\_date[ : , }\DecValTok{0}\NormalTok{]:}

  \CommentTok{\# string umstellen}
\NormalTok{  neues\_element }\OperatorTok{=}\NormalTok{ element[}\DecValTok{6}\NormalTok{:}\DecValTok{10}\NormalTok{] }\OperatorTok{+} \StringTok{\textquotesingle{}{-}\textquotesingle{}} \OperatorTok{+} \OperatorTok{\textbackslash{}}
\NormalTok{  element[}\DecValTok{3}\NormalTok{:}\DecValTok{5}\NormalTok{] }\OperatorTok{+} \StringTok{\textquotesingle{}{-}\textquotesingle{}} \OperatorTok{+} \OperatorTok{\textbackslash{}}
\NormalTok{  element[}\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{] }\OperatorTok{+} \StringTok{\textquotesingle{}T\textquotesingle{}} \OperatorTok{+} \OperatorTok{\textbackslash{}}
\NormalTok{  element[}\DecValTok{11}\NormalTok{:}\DecValTok{13}\NormalTok{] }\OperatorTok{+}  \StringTok{\textquotesingle{}:\textquotesingle{}} \OperatorTok{+} \OperatorTok{\textbackslash{}}
\NormalTok{  element[}\DecValTok{14}\NormalTok{:]}

  \CommentTok{\# in datetime64 konvertieren}
\NormalTok{  neues\_element }\OperatorTok{=}\NormalTok{ np.datetime64(neues\_element)}

  \CommentTok{\# anhängen}
\NormalTok{  preise\_datumvon }\OperatorTok{=}\NormalTok{ np.append(preise\_datumvon, neues\_element)}

\CommentTok{\#\# Spalte 1}
\CommentTok{\#\#\# neues Array anlegen}
\NormalTok{preise\_datumbis }\OperatorTok{=}\NormalTok{ np.array([], dtype }\OperatorTok{=} \StringTok{\textquotesingle{}datetime64\textquotesingle{}}\NormalTok{)}

\ControlFlowTok{for}\NormalTok{ element }\KeywordTok{in}\NormalTok{ preise\_date[ : , }\DecValTok{1}\NormalTok{]:}

  \CommentTok{\# string umstellen}
\NormalTok{  neues\_element }\OperatorTok{=}\NormalTok{ element[}\DecValTok{6}\NormalTok{:}\DecValTok{10}\NormalTok{] }\OperatorTok{+} \StringTok{\textquotesingle{}{-}\textquotesingle{}} \OperatorTok{+} \OperatorTok{\textbackslash{}}
\NormalTok{  element[}\DecValTok{3}\NormalTok{:}\DecValTok{5}\NormalTok{] }\OperatorTok{+} \StringTok{\textquotesingle{}{-}\textquotesingle{}} \OperatorTok{+} \OperatorTok{\textbackslash{}}
\NormalTok{  element[}\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{] }\OperatorTok{+} \StringTok{\textquotesingle{}T\textquotesingle{}} \OperatorTok{+} \OperatorTok{\textbackslash{}}
\NormalTok{  element[}\DecValTok{11}\NormalTok{:}\DecValTok{13}\NormalTok{] }\OperatorTok{+}  \StringTok{\textquotesingle{}:\textquotesingle{}} \OperatorTok{+} \OperatorTok{\textbackslash{}}
\NormalTok{  element[}\DecValTok{14}\NormalTok{:]}

  \CommentTok{\# in datetime64 konvertieren}
\NormalTok{  neues\_element }\OperatorTok{=}\NormalTok{ np.datetime64(neues\_element)}

  \CommentTok{\# anhängen}
\NormalTok{  preise\_datumbis }\OperatorTok{=}\NormalTok{ np.append(preise\_datumbis, neues\_element)}

\CommentTok{\# die letzten 4 Elemente angucken}
\BuiltInTok{print}\NormalTok{(preise\_datumvon[}\OperatorTok{{-}}\DecValTok{4}\NormalTok{:], preise\_datumvon.dtype)}
\BuiltInTok{print}\NormalTok{(preise\_datumbis[}\OperatorTok{{-}}\DecValTok{4}\NormalTok{:], preise\_datumbis.dtype)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['2023-12-31T20:00' '2023-12-31T21:00' '2023-12-31T22:00'
 '2023-12-31T23:00'] datetime64[m]
['2023-12-31T21:00' '2023-12-31T22:00' '2023-12-31T23:00'
 '2024-01-01T00:00'] datetime64[m]
\end{verbatim}

Im zweiten Schritt wird geprüft, ob die viertletzte Spalte
ausschließlich fehlende Werte enthält. Die Position der Spalte ist zwar
bekannt, wird aber dennoch mit der Funktion \texttt{np.argwhere()}
ermittelt. Mit der Funktion \texttt{len(np.unique())} werden die
einzigartigen Werte abgezählt.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# numerische Spalten isolieren}
\NormalTok{preise\_numeric }\OperatorTok{=}\NormalTok{ preise[ : , }\DecValTok{2}\NormalTok{:]}

\CommentTok{\# Position der Spalte mit fehlendem Wert \textquotesingle{}{-}\textquotesingle{} in der nullten Zeile finden}
\NormalTok{position }\OperatorTok{=}\NormalTok{ np.argwhere(preise\_numeric[}\DecValTok{0}\NormalTok{, : ] }\OperatorTok{==} \StringTok{\textquotesingle{}{-}\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Spaltenindex:"}\NormalTok{, position)}

\CommentTok{\# prüfen, welche Werte in der Spalte vorkommen}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Anzahl einzigartiger Werte:"}\NormalTok{, }\BuiltInTok{len}\NormalTok{(np.unique(preise\_numeric[:, position])))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Spaltenindex: [[13]]
Anzahl einzigartiger Werte: 1
\end{verbatim}

Da die viertletzte Spalte ausschließlich das Zeichen `-' enthält, kann
die Spalte entfernt werden. Anschließend kann der Datentyp als
Fließkommazahl deklariert werden. Dazu ist es erforderlich, mit
\texttt{np.char.replace(preise\_numeric,\ \textquotesingle{},\textquotesingle{},\ \textquotesingle{}.\textquotesingle{})}
das Dezimaltrennzeichen Komma durch den Punkt zu ersetzen. Die
Spaltennamen müssen separat gespeichert werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Spalte mit fehlenden Werten entfernen}
\NormalTok{preise\_numeric }\OperatorTok{=}\NormalTok{ np.delete(arr }\OperatorTok{=}\NormalTok{ preise\_numeric, obj }\OperatorTok{=}\NormalTok{ position, axis }\OperatorTok{=} \DecValTok{1}\NormalTok{) }\CommentTok{\# axis 1 = columns}

\CommentTok{\# Dezimaltrennzeichen ersetzen}
\NormalTok{preise\_numeric }\OperatorTok{=}\NormalTok{ np.char.replace(preise\_numeric, }\StringTok{\textquotesingle{},\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}.\textquotesingle{}}\NormalTok{)}
\NormalTok{preise\_numeric }\OperatorTok{=}\NormalTok{ preise\_numeric.astype(}\StringTok{\textquotesingle{}float64\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Spaltennamen speichern}
\NormalTok{preise\_numeric\_colnames }\OperatorTok{=}\NormalTok{ np.loadtxt(fname }\OperatorTok{=}\NormalTok{ dateipfad, dtype }\OperatorTok{=} \StringTok{\textquotesingle{}str\textquotesingle{}}\NormalTok{, delimiter }\OperatorTok{=} \StringTok{\textquotesingle{};\textquotesingle{}}\NormalTok{, encoding }\OperatorTok{=} \StringTok{\textquotesingle{}UTF{-}8{-}sig\textquotesingle{}}\NormalTok{, max\_rows }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{preise\_numeric\_colnames }\OperatorTok{=}\NormalTok{ preise\_numeric\_colnames[}\DecValTok{2}\NormalTok{:] }\CommentTok{\# Datumsspalten entfernen}
\NormalTok{preise\_numeric\_colnames }\OperatorTok{=}\NormalTok{ np.delete(arr }\OperatorTok{=}\NormalTok{ preise\_numeric\_colnames, obj }\OperatorTok{=}\NormalTok{ position)}

\BuiltInTok{print}\NormalTok{(preise\_numeric\_colnames, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(preise\_numeric[}\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{, :], preise\_numeric.dtype)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['Deutschland/Luxemburg [€/MWh] Originalauflösungen'
 '∅ Anrainer DE/LU [€/MWh] Originalauflösungen'
 'Belgien [€/MWh] Originalauflösungen'
 'Dänemark 1 [€/MWh] Originalauflösungen'
 'Dänemark 2 [€/MWh] Originalauflösungen'
 'Frankreich [€/MWh] Originalauflösungen'
 'Niederlande [€/MWh] Originalauflösungen'
 'Norwegen 2 [€/MWh] Originalauflösungen'
 'Österreich [€/MWh] Originalauflösungen'
 'Polen [€/MWh] Originalauflösungen'
 'Schweden 4 [€/MWh] Originalauflösungen'
 'Schweiz [€/MWh] Originalauflösungen'
 'Tschechien [€/MWh] Originalauflösungen'
 'Italien (Nord) [€/MWh] Originalauflösungen'
 'Slowenien [€/MWh] Originalauflösungen'
 'Ungarn [€/MWh] Originalauflösungen'] 

[[-5.1700e+00  1.3850e+01 -4.3900e+00  2.0100e+00  2.0100e+00  0.0000e+00
  -3.6100e+00  1.1932e+02  1.2060e+01  1.8090e+01  2.0100e+00  3.0000e-02
   4.8400e+00  1.9590e+02  1.3310e+01  1.9760e+01]
 [-1.0700e+00  9.7900e+00 -1.7500e+00  1.3800e+00  1.3800e+00 -1.0000e-01
  -1.4600e+00  1.0883e+02 -1.0000e-01  5.7500e+00  1.3800e+00 -7.2500e+00
  -3.5000e-01  1.9109e+02 -7.0000e-02  1.9000e-01]] float64
\end{verbatim}

\subsection{Pandas}

Zunächst wird die Datei der Großhandelspreise mit der Funktion
\texttt{pd.read\_csv()} eingelesen und der Erfolg durch Aufruf der
Funktionen \texttt{pd.info()} kontrolliert.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/Gro\_handelspreise\_202301010000\_202401010000\_Stunde.csv"}
\NormalTok{preise }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ dateipfad)}
\BuiltInTok{print}\NormalTok{(preise.info())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
MultiIndex: 8760 entries, ('01.01.2023 00:00;01.01.2023 01:00;-5', '17;13', '85;-4', '39;2', '01;2', '01;0', '00;-3', '61;119', '32;12', '06;18', '09;2', '01;0', '03;4', '84;-;195', '90;13', '31;19') to ('31.12.2023 23:00;01.01.2024 00:00;2', '44;19', '26;3', '17;26', '87;26', '87;3', '64;3', '17;59', '31;9', '35;35', '70;26', '87;9', '51;7', '44;-;106', '12;11', '02;14')
Data columns (total 1 columns):
 #   Column                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Non-Null Count  Dtype
---  ------                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          --------------  -----
 0   Datum von;Datum bis;Deutschland/Luxemburg [€/MWh] Originalauflösungen;∅ Anrainer DE/LU [€/MWh] Originalauflösungen;Belgien [€/MWh] Originalauflösungen;Dänemark 1 [€/MWh] Originalauflösungen;Dänemark 2 [€/MWh] Originalauflösungen;Frankreich [€/MWh] Originalauflösungen;Niederlande [€/MWh] Originalauflösungen;Norwegen 2 [€/MWh] Originalauflösungen;Österreich [€/MWh] Originalauflösungen;Polen [€/MWh] Originalauflösungen;Schweden 4 [€/MWh] Originalauflösungen;Schweiz [€/MWh] Originalauflösungen;Tschechien [€/MWh] Originalauflösungen;DE/AT/LU [€/MWh] Originalauflösungen;Italien (Nord) [€/MWh] Originalauflösungen;Slowenien [€/MWh] Originalauflösungen;Ungarn [€/MWh] Originalauflösungen  8760 non-null   int64
dtypes: int64(1)
memory usage: 4.3+ MB
None
\end{verbatim}

Es wird nur eine Spalte erkannt, da im Datensatz das Semikolon als
Zeichentrenner verwendet wird, das nun mit dem Argument
\texttt{sep\ =\ \textquotesingle{};\textquotesingle{}} übergeben wird
(Standardwert ist das Komma). Durch Aufruf der Funktionen
\texttt{pd.info()} und \texttt{pd.head()} wird der Erfolg kontrolliert.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/Gro\_handelspreise\_202301010000\_202401010000\_Stunde.csv"}
\NormalTok{preise }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ dateipfad, sep }\OperatorTok{=} \StringTok{\textquotesingle{};\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(preise.info())}
\NormalTok{preise.head()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 8760 entries, 0 to 8759
Data columns (total 19 columns):
 #   Column                                             Non-Null Count  Dtype 
---  ------                                             --------------  ----- 
 0   Datum von                                          8760 non-null   object
 1   Datum bis                                          8760 non-null   object
 2   Deutschland/Luxemburg [€/MWh] Originalauflösungen  8760 non-null   object
 3   ∅ Anrainer DE/LU [€/MWh] Originalauflösungen       8760 non-null   object
 4   Belgien [€/MWh] Originalauflösungen                8760 non-null   object
 5   Dänemark 1 [€/MWh] Originalauflösungen             8760 non-null   object
 6   Dänemark 2 [€/MWh] Originalauflösungen             8760 non-null   object
 7   Frankreich [€/MWh] Originalauflösungen             8760 non-null   object
 8   Niederlande [€/MWh] Originalauflösungen            8760 non-null   object
 9   Norwegen 2 [€/MWh] Originalauflösungen             8760 non-null   object
 10  Österreich [€/MWh] Originalauflösungen             8760 non-null   object
 11  Polen [€/MWh] Originalauflösungen                  8760 non-null   object
 12  Schweden 4 [€/MWh] Originalauflösungen             8760 non-null   object
 13  Schweiz [€/MWh] Originalauflösungen                8760 non-null   object
 14  Tschechien [€/MWh] Originalauflösungen             8760 non-null   object
 15  DE/AT/LU [€/MWh] Originalauflösungen               8760 non-null   object
 16  Italien (Nord) [€/MWh] Originalauflösungen         8760 non-null   object
 17  Slowenien [€/MWh] Originalauflösungen              8760 non-null   object
 18  Ungarn [€/MWh] Originalauflösungen                 8760 non-null   object
dtypes: object(19)
memory usage: 1.3+ MB
None
\end{verbatim}

\begin{longtable}[]{@{}llllllllllllllllllll@{}}
\toprule\noalign{}
& Datum von & Datum bis & Deutschland/Luxemburg {[}€/MWh{]}
Originalauflösungen & ∅ Anrainer DE/LU {[}€/MWh{]} Originalauflösungen &
Belgien {[}€/MWh{]} Originalauflösungen & Dänemark 1 {[}€/MWh{]}
Originalauflösungen & Dänemark 2 {[}€/MWh{]} Originalauflösungen &
Frankreich {[}€/MWh{]} Originalauflösungen & Niederlande {[}€/MWh{]}
Originalauflösungen & Norwegen 2 {[}€/MWh{]} Originalauflösungen &
Österreich {[}€/MWh{]} Originalauflösungen & Polen {[}€/MWh{]}
Originalauflösungen & Schweden 4 {[}€/MWh{]} Originalauflösungen &
Schweiz {[}€/MWh{]} Originalauflösungen & Tschechien {[}€/MWh{]}
Originalauflösungen & DE/AT/LU {[}€/MWh{]} Originalauflösungen & Italien
(Nord) {[}€/MWh{]} Originalauflösungen & Slowenien {[}€/MWh{]}
Originalauflösungen & Ungarn {[}€/MWh{]} Originalauflösungen \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 01.01.2023 00:00 & 01.01.2023 01:00 & -5,17 & 13,85 & -4,39 & 2,01 &
2,01 & 0,00 & -3,61 & 119,32 & 12,06 & 18,09 & 2,01 & 0,03 & 4,84 & - &
195,90 & 13,31 & 19,76 \\
1 & 01.01.2023 01:00 & 01.01.2023 02:00 & -1,07 & 9,79 & -1,75 & 1,38 &
1,38 & -0,10 & -1,46 & 108,83 & -0,10 & 5,75 & 1,38 & -7,25 & -0,35 & -
& 191,09 & -0,07 & 0,19 \\
2 & 01.01.2023 02:00 & 01.01.2023 03:00 & -1,47 & 8,91 & -1,46 & 0,09 &
0,09 & -1,33 & -1,52 & 102,39 & -0,66 & 5,27 & 0,09 & -3,99 & -0,97 & -
& 187,95 & -0,47 & 0,07 \\
3 & 01.01.2023 03:00 & 01.01.2023 04:00 & -5,08 & 6,58 & -5,27 & 0,08 &
0,08 & -4,08 & -5,00 & 92,36 & -1,99 & 5,74 & 0,08 & -7,71 & -1,93 & - &
187,82 & -1,56 & 0,01 \\
4 & 01.01.2023 04:00 & 01.01.2023 05:00 & -4,49 & 5,42 & -4,41 & 0,05 &
0,05 & -4,16 & -4,60 & 82,66 & -2,42 & 5,22 & 0,05 & -9,71 & -3,07 & - &
187,74 & -1,94 & -0,77 \\
\end{longtable}

~

In der Ausgabe ist am Datentyp object erkennbar, dass für keine Spalte
der Datentyp erkannt wurde. In der Darstellung der ersten Zeilen des
Datensatzes ist das Komma als Dezimaltrennzeichen zu sehen, der
Standardwert der Funktion \texttt{pd.read\_csv()} ist aber der Punkt.
Nach Übergabe des Dezimaltrennzeichens sollten die numerischen Spalten
korrekt erkannt werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{preise }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ dateipfad, sep }\OperatorTok{=} \StringTok{\textquotesingle{};\textquotesingle{}}\NormalTok{, decimal }\OperatorTok{=} \StringTok{\textquotesingle{},\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(preise.info())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 8760 entries, 0 to 8759
Data columns (total 19 columns):
 #   Column                                             Non-Null Count  Dtype  
---  ------                                             --------------  -----  
 0   Datum von                                          8760 non-null   object 
 1   Datum bis                                          8760 non-null   object 
 2   Deutschland/Luxemburg [€/MWh] Originalauflösungen  8760 non-null   float64
 3   ∅ Anrainer DE/LU [€/MWh] Originalauflösungen       8760 non-null   float64
 4   Belgien [€/MWh] Originalauflösungen                8760 non-null   float64
 5   Dänemark 1 [€/MWh] Originalauflösungen             8760 non-null   float64
 6   Dänemark 2 [€/MWh] Originalauflösungen             8760 non-null   float64
 7   Frankreich [€/MWh] Originalauflösungen             8760 non-null   float64
 8   Niederlande [€/MWh] Originalauflösungen            8760 non-null   float64
 9   Norwegen 2 [€/MWh] Originalauflösungen             8760 non-null   float64
 10  Österreich [€/MWh] Originalauflösungen             8760 non-null   float64
 11  Polen [€/MWh] Originalauflösungen                  8760 non-null   float64
 12  Schweden 4 [€/MWh] Originalauflösungen             8760 non-null   float64
 13  Schweiz [€/MWh] Originalauflösungen                8760 non-null   float64
 14  Tschechien [€/MWh] Originalauflösungen             8760 non-null   float64
 15  DE/AT/LU [€/MWh] Originalauflösungen               8760 non-null   object 
 16  Italien (Nord) [€/MWh] Originalauflösungen         8760 non-null   float64
 17  Slowenien [€/MWh] Originalauflösungen              8760 non-null   float64
 18  Ungarn [€/MWh] Originalauflösungen                 8760 non-null   float64
dtypes: float64(16), object(3)
memory usage: 1.3+ MB
None
\end{verbatim}

Der Datentyp der Spalte DE/AT/LU {[}€/MWh{]} Originalauflösungen wird
nicht als float64 erkannt. In der Ausgabe ist zu sehen, dass wenigstens
in den ersten Zeilen fehlende Werte durch `-' markiert sind. Mittels der
Methode \texttt{.describe()} kann überprüft werden, ob die Spalte
überhaupt numerische Werte enthält.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{preise[}\StringTok{\textquotesingle{}DE/AT/LU [€/MWh] Originalauflösungen\textquotesingle{}}\NormalTok{].describe()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
count     8760
unique       1
top          -
freq      8760
Name: DE/AT/LU [€/MWh] Originalauflösungen, dtype: object
\end{verbatim}

Da dies nicht der Fall ist, kann die Spalte entfernt werden.
Anschließend können die ersten beiden Spalten mit der Funktion
\texttt{pd.to\_datetime()} in ein Datumsformat konvertiert werden. Eine
Zelle enthält Zeichenketten im Schema `01.01.2023 00:00'. Mit Hilfe der
\href{https://docs.python.org/3/library/datetime.html\#strftime-and-strptime-behavior}{strftime-Dokumentation}
kann der Funktion das Datumsformat übergeben werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{preise.drop(labels }\OperatorTok{=} \StringTok{\textquotesingle{}DE/AT/LU [€/MWh] Originalauflösungen\textquotesingle{}}\NormalTok{, axis }\OperatorTok{=} \StringTok{\textquotesingle{}columns\textquotesingle{}}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

\CommentTok{\#\# Datumsspalten konvertieren}
\NormalTok{preise[}\StringTok{\textquotesingle{}Datum von\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ pd.to\_datetime(preise[}\StringTok{\textquotesingle{}Datum von\textquotesingle{}}\NormalTok{], }\BuiltInTok{format} \OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y \%H:\%M"}\NormalTok{)}
\NormalTok{preise[}\StringTok{\textquotesingle{}Datum bis\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ pd.to\_datetime(preise[}\StringTok{\textquotesingle{}Datum bis\textquotesingle{}}\NormalTok{], }\BuiltInTok{format} \OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y \%H:\%M"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(preise.info())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 8760 entries, 0 to 8759
Data columns (total 18 columns):
 #   Column                                             Non-Null Count  Dtype         
---  ------                                             --------------  -----         
 0   Datum von                                          8760 non-null   datetime64[ns]
 1   Datum bis                                          8760 non-null   datetime64[ns]
 2   Deutschland/Luxemburg [€/MWh] Originalauflösungen  8760 non-null   float64       
 3   ∅ Anrainer DE/LU [€/MWh] Originalauflösungen       8760 non-null   float64       
 4   Belgien [€/MWh] Originalauflösungen                8760 non-null   float64       
 5   Dänemark 1 [€/MWh] Originalauflösungen             8760 non-null   float64       
 6   Dänemark 2 [€/MWh] Originalauflösungen             8760 non-null   float64       
 7   Frankreich [€/MWh] Originalauflösungen             8760 non-null   float64       
 8   Niederlande [€/MWh] Originalauflösungen            8760 non-null   float64       
 9   Norwegen 2 [€/MWh] Originalauflösungen             8760 non-null   float64       
 10  Österreich [€/MWh] Originalauflösungen             8760 non-null   float64       
 11  Polen [€/MWh] Originalauflösungen                  8760 non-null   float64       
 12  Schweden 4 [€/MWh] Originalauflösungen             8760 non-null   float64       
 13  Schweiz [€/MWh] Originalauflösungen                8760 non-null   float64       
 14  Tschechien [€/MWh] Originalauflösungen             8760 non-null   float64       
 15  Italien (Nord) [€/MWh] Originalauflösungen         8760 non-null   float64       
 16  Slowenien [€/MWh] Originalauflösungen              8760 non-null   float64       
 17  Ungarn [€/MWh] Originalauflösungen                 8760 non-null   float64       
dtypes: datetime64[ns](2), float64(16)
memory usage: 1.2 MB
None
\end{verbatim}

Wenn der innere Aufbau einer Datei bekannt ist, können die notwendigen
Parameter auch direkt beim Einlesen mit \texttt{pd.read\_csv} übergeben
werden (Argumente \texttt{usecols}, \texttt{parse\_dates} und
\texttt{date\_format}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{preise }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ dateipfad, sep }\OperatorTok{=} \StringTok{\textquotesingle{};\textquotesingle{}}\NormalTok{, decimal }\OperatorTok{=} \StringTok{\textquotesingle{},\textquotesingle{}}\NormalTok{,}
\NormalTok{                     usecols }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{15}\NormalTok{)) }\OperatorTok{+} \BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{16}\NormalTok{, }\DecValTok{19}\NormalTok{)), }\CommentTok{\# Auswahl der einzulesenden Spalten}
\NormalTok{                     parse\_dates }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Datum von\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Datum bis\textquotesingle{}}\NormalTok{], date\_format }\OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y \%H:\%M"}\NormalTok{) }\CommentTok{\# Formatierung des Datums}
\BuiltInTok{print}\NormalTok{(preise.info())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 8760 entries, 0 to 8759
Data columns (total 18 columns):
 #   Column                                             Non-Null Count  Dtype         
---  ------                                             --------------  -----         
 0   Datum von                                          8760 non-null   datetime64[ns]
 1   Datum bis                                          8760 non-null   datetime64[ns]
 2   Deutschland/Luxemburg [€/MWh] Originalauflösungen  8760 non-null   float64       
 3   ∅ Anrainer DE/LU [€/MWh] Originalauflösungen       8760 non-null   float64       
 4   Belgien [€/MWh] Originalauflösungen                8760 non-null   float64       
 5   Dänemark 1 [€/MWh] Originalauflösungen             8760 non-null   float64       
 6   Dänemark 2 [€/MWh] Originalauflösungen             8760 non-null   float64       
 7   Frankreich [€/MWh] Originalauflösungen             8760 non-null   float64       
 8   Niederlande [€/MWh] Originalauflösungen            8760 non-null   float64       
 9   Norwegen 2 [€/MWh] Originalauflösungen             8760 non-null   float64       
 10  Österreich [€/MWh] Originalauflösungen             8760 non-null   float64       
 11  Polen [€/MWh] Originalauflösungen                  8760 non-null   float64       
 12  Schweden 4 [€/MWh] Originalauflösungen             8760 non-null   float64       
 13  Schweiz [€/MWh] Originalauflösungen                8760 non-null   float64       
 14  Tschechien [€/MWh] Originalauflösungen             8760 non-null   float64       
 15  Italien (Nord) [€/MWh] Originalauflösungen         8760 non-null   float64       
 16  Slowenien [€/MWh] Originalauflösungen              8760 non-null   float64       
 17  Ungarn [€/MWh] Originalauflösungen                 8760 non-null   float64       
dtypes: datetime64[ns](2), float64(16)
memory usage: 1.2 MB
None
\end{verbatim}

\section{Zugriff auf Zeitreihen}\label{zugriff-auf-zeitreihen-1}

Pandas bietet zahlreiche Attribute und Methoden, um Informationen aus
\texttt{datetime64}-Objekten auszulesen. NumPy unterstützt vergleichbare
Funktionen derzeit nicht nativ. Eine Übersicht aller verfügbaren
Attribute und Methoden liefert \texttt{dir(pd.to\_datetime(0))}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Attribute}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Jahr:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).year)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Monat:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).month)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Tag:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).day)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Stunde:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).hour)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Minute:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).minute)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Sekunde:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).second)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Tag des Jahres:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).dayofyear)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Wochentag:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).dayofweek)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Tage im Monat:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).days\_in\_month)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Schaltjahr:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).is\_leap\_year)}

\CommentTok{\# Methoden}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Datum:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).date())}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Zeit:"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).time())}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Wochentag (0{-}6):"}\NormalTok{, pd.to\_datetime(}\DecValTok{0}\NormalTok{).weekday())}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Monatsname:"}\NormalTok{,  pd.to\_datetime(}\DecValTok{0}\NormalTok{).month\_name())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Jahr: 1970
Monat: 1
Tag: 1
Stunde: 0
Minute: 0
Sekunde: 0
Tag des Jahres: 1
Wochentag: 3
Tage im Monat: 31
Schaltjahr: False

Datum: 1970-01-01
Zeit: 00:00:00
Wochentag (0-6): 3
Monatsname: January
\end{verbatim}

Für \texttt{pd.Series} erfolgt der Zugriff über den .dt-Operator (siehe
\href{https://pandas.pydata.org/docs/user_guide/basics.html\#basics-dt-accessors}{.dt
accessor}). Der Zugriff auf verschiedene Informationen über ein Attribut
(ohne Klammern) oder über eine Methode (mit Klammern) unterscheidet sich
jedoch teilweise (siehe folgendes Beispiel).

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Der dt-Operator}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Attribute}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Datum:"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.date) }\CommentTok{\# Unterschied}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Zeit:"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.time) }\CommentTok{\# Unterschied}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Jahr"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.year)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Monat"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.month)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Tag"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.day)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Stunde"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.hour)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Minute"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.minute)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Sekunde"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.second)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Tag des Jahres"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.dayofyear)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Wochentag:"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.dayofweek)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Wochentag:"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.weekday) }\CommentTok{\# Unterschied}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Tage im Monat:"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.days\_in\_month)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Schaltjahr:"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.is\_leap\_year)}

\CommentTok{\# Methoden}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Name des Monats:"}\NormalTok{, pd.Series(pd.to\_datetime(}\DecValTok{0}\NormalTok{)).dt.month\_name())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Datum: 0    1970-01-01
dtype: object
Zeit: 0    00:00:00
dtype: object
Jahr 0    1970
dtype: int32
Monat 0    1
dtype: int32
Tag 0    1
dtype: int32
Stunde 0    0
dtype: int32
Minute 0    0
dtype: int32
Sekunde 0    0
dtype: int32

Tag des Jahres 0    1
dtype: int32
Wochentag: 0    3
dtype: int32
Wochentag: 0    3
dtype: int32
Tage im Monat: 0    31
dtype: int32
Schaltjahr: 0    False
dtype: bool

Name des Monats: 0    January
dtype: object
\end{verbatim}

\end{tcolorbox}

Die im vorherigen Abschnitt eingelesenen Großhandelspreise für Strom
2023 sollen auf die Unterschiede an Werktagen und am Wochenende
untersucht werden. \textbf{Vergleichen Sie den durchschnittlichen
Strompreis im Gebiet Deutschland/Luxemburg an Werktagen (Montag -
Freitag) mit dem durchschnittlichen Strompreis am Wochenende.}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-Durchschnittspreis}: Musterlösung Strompreisvergleich}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-Durchschnittspreis} 

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\# Zugriff mit .dt für pd.Series}
\CommentTok{\# Werktage und Wochenende unterscheiden}
\NormalTok{werktags }\OperatorTok{=}\NormalTok{ preise[}\StringTok{\textquotesingle{}Datum von\textquotesingle{}}\NormalTok{].dt.weekday.isin(}\BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{5}\NormalTok{)))}
\NormalTok{wochenende }\OperatorTok{=}\NormalTok{ preise[}\StringTok{\textquotesingle{}Datum von\textquotesingle{}}\NormalTok{].dt.weekday.isin(}\BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{)))}

\BuiltInTok{print}\NormalTok{(werktags.head())}
\BuiltInTok{print}\NormalTok{(wochenende.head())}

\CommentTok{\# Preise vergleichen}
\NormalTok{preis\_werktags }\OperatorTok{=}\NormalTok{ preise.loc[werktags, }\StringTok{\textquotesingle{}Deutschland/Luxemburg [€/MWh] Originalauflösungen\textquotesingle{}}\NormalTok{].mean()}
\NormalTok{preis\_wochenende }\OperatorTok{=}\NormalTok{ preise.loc[wochenende, }\StringTok{\textquotesingle{}Deutschland/Luxemburg [€/MWh] Originalauflösungen\textquotesingle{}}\NormalTok{].mean()}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Durchschnittspreis werktags: }\SpecialCharTok{\{}\NormalTok{preis\_werktags}\SpecialCharTok{:.2f\}}\SpecialStringTok{ [€/MWh]}\CharTok{\textbackslash{}n}\SpecialStringTok{Durchschnittspreis am Wochenende: }\SpecialCharTok{\{}\NormalTok{preis\_wochenende}\SpecialCharTok{:.2f\}}\SpecialStringTok{ [€/MWh]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0    False
1    False
2    False
3    False
4    False
Name: Datum von, dtype: bool
0    True
1    True
2    True
3    True
4    True
Name: Datum von, dtype: bool

Durchschnittspreis werktags: 103.18 [€/MWh]
Durchschnittspreis am Wochenende: 75.34 [€/MWh]
\end{verbatim}

\end{tcolorbox}

\section{Fehlende Werte in
Zeitreihen}\label{fehlende-werte-in-zeitreihen}

NumPy und Pandas unterstützen \texttt{NaT} für \texttt{np.datetime64},
\texttt{np.timedelta64}

\begin{itemize}
\item
  NumPy:
  \url{https://numpy.org/doc/stable/reference/arrays.datetime.html}\\
  \texttt{NAT}, in any combination of lowercase/uppercase letters, for a
  ``Not A Time''
\item
  Pandas:
  \url{https://pandas.pydata.org/docs/user_guide/missing_data.html}
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-logicNaT} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-logicNaT}: Achtung Logik!}\vspace{3mm}

Die logische Abfrage fehlender Werte unterscheidet sich für
\texttt{None}, \texttt{np.nan} und \texttt{pd.NA} und \texttt{pd.NaT}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bool\_values }\OperatorTok{=}\NormalTok{ [}\VariableTok{None}\NormalTok{, }\BuiltInTok{float}\NormalTok{(}\StringTok{\textquotesingle{}nan\textquotesingle{}}\NormalTok{), pd.NA, pd.NaT]}

\ControlFlowTok{for}\NormalTok{ element }\KeywordTok{in}\NormalTok{ bool\_values:}
  \ControlFlowTok{try}\NormalTok{:}
\NormalTok{    bool\_value }\OperatorTok{=} \BuiltInTok{bool}\NormalTok{(element)}
  \ControlFlowTok{except} \PreprocessorTok{TypeError} \ImportTok{as}\NormalTok{ error:}
      \BuiltInTok{print}\NormalTok{(error)}
  \ControlFlowTok{else}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Wahrheitswert von"}\NormalTok{, element, }\StringTok{"ist"}\NormalTok{, bool\_value)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Wahrheitswert von None ist False
Wahrheitswert von nan ist True
boolean value of NA is ambiguous
Wahrheitswert von NaT ist True
\end{verbatim}

Dies gilt auch für die Wertgleichheit.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ element }\KeywordTok{in}\NormalTok{ bool\_values:}
  \ControlFlowTok{try}\NormalTok{:}
\NormalTok{    result }\OperatorTok{=}\NormalTok{ element }\OperatorTok{==}\NormalTok{ element}
  \ControlFlowTok{except} \PreprocessorTok{TypeError} \ImportTok{as}\NormalTok{ error:}
      \BuiltInTok{print}\NormalTok{(error)}
  \ControlFlowTok{else}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Wertgleichheit von"}\NormalTok{, element, }\StringTok{"ist"}\NormalTok{, result)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Wertgleichheit von None ist True
Wertgleichheit von nan ist False
Wertgleichheit von <NA> ist <NA>
Wertgleichheit von NaT ist False
\end{verbatim}

\end{minipage}%
\end{tcolorbox}

\section{Übungen: Zeitreihen einlesen}\label{sec-uxfcbungenzeitreihen}

\begin{figure}

\begin{minipage}{0.05\linewidth}
~\end{minipage}%
%
\begin{minipage}{0.90\linewidth}
``everybody I know has war stories about cleaning up lousy datasets''\\
Nicholas J. Cox\end{minipage}%
%
\begin{minipage}{0.05\linewidth}
~\end{minipage}%
\newline
\begin{minipage}{\linewidth}
~\end{minipage}%
\newline
\begin{minipage}{\linewidth}
Cox, Nicholas J. 2004: Exploratory Data Mining and Data Cleaning. Book
Review 9. In: Journal of Statistical Software 2004, Volume 11.
\url{https://www.jstatsoft.org/article/view/v011b09/30}\end{minipage}%

\end{figure}%

Die folgenden Übungen trainieren die Anwendung der in diesem Kapitel
vorgestellten Werkzeuge und können mit NumPy oder mit Pandas gelöst
werden.

\subsubsection{Leicht: Englisches Datumsformat
einlesen}\label{leicht-englisches-datumsformat-einlesen}

\textbf{Aufgabe: Lesen Sie die Datei Dateipfad:
`01-daten/Day-ahead\_prices\_202301010000\_202401010000\_Hour.csv' so
ein, dass die Datentypen korrekt erkannt werden. (Hinweise zur Datei
siehe Warning~\ref{wrn-SMARD}, siehe
\href{https://docs.python.org/3/library/datetime.html\#strftime-and-strptime-behavior}{Dokumentation
strftime zur string-Formatierung})}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-strompreise}: Musterlösung Strompreise}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-strompreise} 

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}

\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/Day{-}ahead\_prices\_202301010000\_202401010000\_Hour.csv"}

\NormalTok{data }\OperatorTok{=}\NormalTok{ pd.read\_csv(dateipfad, sep}\OperatorTok{=}\StringTok{";"}\NormalTok{)   }\CommentTok{\# Semikolon als Trennzeichen muss angegeben werden}
\NormalTok{data.info() }\CommentTok{\# {-}\textgreater{} man sieht, dass Spalten 0 "Start date" und 1 "End date" als Dtype "object" erkannt werden}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(data.iloc[}\DecValTok{0}\NormalTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{], }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{) }\CommentTok{\# anzeigen von ein paar Zeilen, um zu schauen wie die ersten beiden "Object" Spalten aufgebaut sind}
\CommentTok{\# Ausgabe lautet:}
\CommentTok{\# Start date: Jan 1, 2023 12:00 AM}
\CommentTok{\# End date Jan 1, 2023 1:00 AM}
\CommentTok{\# also bieten sich zwei Varianten an:}

\CommentTok{\# 1. Variante: beim Einlesen schon Datumsformat angeben:}
\NormalTok{data }\OperatorTok{=}\NormalTok{ pd.read\_csv(dateipfad, sep}\OperatorTok{=}\StringTok{";"}\NormalTok{ , parse\_dates}\OperatorTok{=}\NormalTok{[}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{], date\_format}\OperatorTok{=}\StringTok{"\%b }\SpecialCharTok{\%d}\StringTok{, \%Y \%I:\%M \%p"}\NormalTok{)   }\CommentTok{\# Parameter heißt hier date\_format, bei 2. Variante heißt er nur "format"}

\CommentTok{\# 2. Variante: Die beiden Spalten zu Anfang, die dtype object haben, seperat ändern nachdem die Datei schon eingelesen wurde:}
\NormalTok{data[}\StringTok{"Start date"}\NormalTok{] }\OperatorTok{=}\NormalTok{ pd.to\_datetime(data[}\StringTok{"Start date"}\NormalTok{], }\BuiltInTok{format}\OperatorTok{=}\StringTok{"\%b }\SpecialCharTok{\%d}\StringTok{, \%Y \%I:\%M \%p"}\NormalTok{)  }\CommentTok{\#\%b für Monatsangabe als Kürzel, \%I für Stunde im AM/PM Format, \%p für AM/PM}
\NormalTok{data[}\StringTok{"End date"}\NormalTok{] }\OperatorTok{=}\NormalTok{ pd.to\_datetime(data[}\StringTok{"End date"}\NormalTok{], }\BuiltInTok{format}\OperatorTok{=}\StringTok{"\%b }\SpecialCharTok{\%d}\StringTok{, \%Y \%I:\%M \%p"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(data.iloc[}\DecValTok{0}\NormalTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{], }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{data.info()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 8760 entries, 0 to 8759
Data columns (total 19 columns):
 #   Column                                           Non-Null Count  Dtype  
---  ------                                           --------------  -----  
 0   Start date                                       8760 non-null   object 
 1   End date                                         8760 non-null   object 
 2   Germany/Luxembourg [€/MWh] Original resolutions  8760 non-null   float64
 3   ∅ DE/LU neighbours [€/MWh] Original resolutions  8760 non-null   float64
 4   Belgium [€/MWh] Original resolutions             8760 non-null   float64
 5   Denmark 1 [€/MWh] Original resolutions           8760 non-null   float64
 6   Denmark 2 [€/MWh] Original resolutions           8760 non-null   float64
 7   France [€/MWh] Original resolutions              8760 non-null   float64
 8   Netherlands [€/MWh] Original resolutions         8760 non-null   float64
 9   Norway 2 [€/MWh] Original resolutions            8760 non-null   float64
 10  Austria [€/MWh] Original resolutions             8760 non-null   float64
 11  Poland [€/MWh] Original resolutions              8760 non-null   float64
 12  Sweden 4 [€/MWh] Original resolutions            8760 non-null   float64
 13  Switzerland [€/MWh] Original resolutions         8760 non-null   float64
 14  Czech Republic [€/MWh] Original resolutions      8760 non-null   float64
 15  DE/AT/LU [€/MWh] Original resolutions            8760 non-null   object 
 16  Northern Italy [€/MWh] Original resolutions      8760 non-null   float64
 17  Slovenia [€/MWh] Original resolutions            8760 non-null   float64
 18  Hungary [€/MWh] Original resolutions             8760 non-null   float64
dtypes: float64(16), object(3)
memory usage: 1.3+ MB


             Start date              End date
0  Jan 1, 2023 12:00 AM   Jan 1, 2023 1:00 AM
1   Jan 1, 2023 1:00 AM   Jan 1, 2023 2:00 AM
2   Jan 1, 2023 2:00 AM   Jan 1, 2023 3:00 AM
3   Jan 1, 2023 3:00 AM   Jan 1, 2023 4:00 AM
4   Jan 1, 2023 4:00 AM   Jan 1, 2023 5:00 AM
5   Jan 1, 2023 5:00 AM   Jan 1, 2023 6:00 AM
6   Jan 1, 2023 6:00 AM   Jan 1, 2023 7:00 AM
7   Jan 1, 2023 7:00 AM   Jan 1, 2023 8:00 AM
8   Jan 1, 2023 8:00 AM   Jan 1, 2023 9:00 AM
9   Jan 1, 2023 9:00 AM  Jan 1, 2023 10:00 AM 

           Start date            End date
0 2023-01-01 00:00:00 2023-01-01 01:00:00
1 2023-01-01 01:00:00 2023-01-01 02:00:00
2 2023-01-01 02:00:00 2023-01-01 03:00:00
3 2023-01-01 03:00:00 2023-01-01 04:00:00
4 2023-01-01 04:00:00 2023-01-01 05:00:00
5 2023-01-01 05:00:00 2023-01-01 06:00:00
6 2023-01-01 06:00:00 2023-01-01 07:00:00
7 2023-01-01 07:00:00 2023-01-01 08:00:00
8 2023-01-01 08:00:00 2023-01-01 09:00:00
9 2023-01-01 09:00:00 2023-01-01 10:00:00 

<class 'pandas.core.frame.DataFrame'>
RangeIndex: 8760 entries, 0 to 8759
Data columns (total 19 columns):
 #   Column                                           Non-Null Count  Dtype         
---  ------                                           --------------  -----         
 0   Start date                                       8760 non-null   datetime64[ns]
 1   End date                                         8760 non-null   datetime64[ns]
 2   Germany/Luxembourg [€/MWh] Original resolutions  8760 non-null   float64       
 3   ∅ DE/LU neighbours [€/MWh] Original resolutions  8760 non-null   float64       
 4   Belgium [€/MWh] Original resolutions             8760 non-null   float64       
 5   Denmark 1 [€/MWh] Original resolutions           8760 non-null   float64       
 6   Denmark 2 [€/MWh] Original resolutions           8760 non-null   float64       
 7   France [€/MWh] Original resolutions              8760 non-null   float64       
 8   Netherlands [€/MWh] Original resolutions         8760 non-null   float64       
 9   Norway 2 [€/MWh] Original resolutions            8760 non-null   float64       
 10  Austria [€/MWh] Original resolutions             8760 non-null   float64       
 11  Poland [€/MWh] Original resolutions              8760 non-null   float64       
 12  Sweden 4 [€/MWh] Original resolutions            8760 non-null   float64       
 13  Switzerland [€/MWh] Original resolutions         8760 non-null   float64       
 14  Czech Republic [€/MWh] Original resolutions      8760 non-null   float64       
 15  DE/AT/LU [€/MWh] Original resolutions            8760 non-null   object        
 16  Northern Italy [€/MWh] Original resolutions      8760 non-null   float64       
 17  Slovenia [€/MWh] Original resolutions            8760 non-null   float64       
 18  Hungary [€/MWh] Original resolutions             8760 non-null   float64       
dtypes: datetime64[ns](2), float64(16), object(1)
memory usage: 1.3+ MB
\end{verbatim}

Musterlösung von Marc Sönnecken. Zur Verbesserung der Lesbarkeit wurde
die Ausgabe mit \texttt{print(data.head(10))} ersetzt durch
\texttt{print(data.iloc{[}0:10,\ 0:2{]},\ "\textbackslash{}n")}. Um sich
einen Überblick über einen Datensatz zu verschaffen, ist die Methode
\texttt{.head()} jedoch besser geeignet

\end{tcolorbox}

\subsubsection{Mittel: Strommarktdaten
Österreich}\label{mittel-strommarktdaten-uxf6sterreich}

Die Austrian Power Grid AG (APG) veröffentlicht Strommarktdaten unter
\href{https://markttransparenz.apg.at/de/markt/Markttransparenz/erzeugung/Erzeugung-pro-Typ}{https://markttransparenz.apg.at/}.
Unter dem Link können Erzeugungsdaten für das Jahr 2023 heruntergeladen
werden.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-Strommarkt-Austria} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-Strommarkt-Austria}: Markttranzparenzdaten Österreich herunterladen}\vspace{3mm}

Nach der Auswahl des Zeitraums auf Exportieren klicken, dann erscheint
die Schaltfläche Download.

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/m-einlesen-strukturierter-datensaetze/skript/00-bilder/APG-erzeugungsdaten-2023-de.png}}

}

\caption{~}

\end{figure}%

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/m-einlesen-strukturierter-datensaetze/skript/00-bilder/english/APG-generation-data-2023-en.png}}

}

\caption{~}

\end{figure}%

Das Datumsformat der Dateien ist abhängig von der auf der Internetseite
eingestellten Sprache (Deutsch/English).

\end{minipage}%
\end{tcolorbox}

~

Diesem Skript ist folgende Datei angefügt.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Daten
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Dateiname
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Realisierte Stromerzeugung 2023 &
AGPT\_2022-12-31T23\_00\_00Z\_2023-12-31T23\_00\_00Z\_15M\_de\_2024-06-10T09\_32\_38Z.csv \\
\end{longtable}

In dem Datensatz wird durch die Umstellung von Sommer- auf Winterzeit am
letzten Sonntag im Oktober die Stunde 2 Uhr morgens doppelt eingetragen
(dafür fehlt eine Stunde bei der Umstellung von Winter- auf Sommerzeit
am letzten Sonntag im März). Die doppelte Stunde wird im Datensatz mit
2A bzw. 2B gekennzeichnet. (Mitteilung Austrian Power Grid AG vom
13.08.2024)

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/m-einlesen-strukturierter-datensaetze/skript/00-bilder/erzeugung-aut-zeitumstellung.png}}

}

\caption{Zeitumstellung im österreichischen Datensatz}

\end{figure}%

\textbf{Lesen Sie die Datei so ein, dass die Spalten mit Datums- und
Zeitinformationen als datetime erkannt werden. Lösen Sie die
Zeitumstellung so auf, dass jeder Tag 24 Stunden hat.}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-Austria}: Musterlösung Strommarktdaten Österreich}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-Austria} 

\begin{quote}
\textbf{einfache Variante}

Die einfachste Lösung ist es, Zeitreihen zu generieren und die Spalten
`Zeit von {[}CET/CEST{]}' und `Zeit bis {[}CET/CEST{]}' damit zu
ersetzen.

\begin{verbatim}
von = pd.date_range(start = "2023-01-01T00:00", end = "2023-12-31T23:45", freq = '15min')
bis = pd.date_range(start = "2023-01-01T00:15", end = "2024-01-01T00:00", freq = '15min')

print(von[8070:8078], "\n")
print(bis[8070:8078], "\n")
\end{verbatim}
\end{quote}

\textbf{Datei einlesen und String-Manipulation}

Zunächst wird die Datei eingelesen. Die Zellen, die sich nicht in
datetime umwandeln lassen, können mit Python ausgegeben werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Datei einlesen}
\NormalTok{erzeugung\_austria }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=} \StringTok{"01{-}daten/AGPT\_2022{-}12{-}31T23\_00\_00Z\_2023{-}12{-}31T23\_00\_00Z\_15M\_de\_2024{-}06{-}10T09\_32\_38Z.csv"}\NormalTok{,}
\NormalTok{                                sep }\OperatorTok{=} \StringTok{";"}\NormalTok{, decimal }\OperatorTok{=} \StringTok{","}\NormalTok{, thousands }\OperatorTok{=} \StringTok{"."}\NormalTok{)}

\CommentTok{\# Zellen mit fehlerhaften datetime strings identifizieren}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Spalte \textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}"}\NormalTok{)}
\NormalTok{i }\OperatorTok{=} \DecValTok{0}
\NormalTok{position\_element }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ element }\KeywordTok{in}\NormalTok{ erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{]:}
  \ControlFlowTok{try}\NormalTok{:}
\NormalTok{    pd.to\_datetime(element, }\BuiltInTok{format} \OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y \%H:\%M:\%S"}\NormalTok{)}
  \ControlFlowTok{except}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(element)}
\NormalTok{    position\_element.append(i)}
\NormalTok{  i }\OperatorTok{+=} \DecValTok{1}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Die Zellen haben den Zeilenindex: "}\NormalTok{, position\_element, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Spalte \textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}"}\NormalTok{)}
\NormalTok{i }\OperatorTok{=} \DecValTok{0}
\NormalTok{position\_element }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ element }\KeywordTok{in}\NormalTok{ erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{]:}
  \ControlFlowTok{try}\NormalTok{:}
\NormalTok{    pd.to\_datetime(element, }\BuiltInTok{format} \OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y \%H:\%M:\%S"}\NormalTok{)}
  \ControlFlowTok{except}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(element)}
\NormalTok{    position\_element.append(i)}
\NormalTok{  i }\OperatorTok{+=} \DecValTok{1}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Die Zellen haben den Zeilenindex: "}\NormalTok{, position\_element, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Spalte 'Zeit von [CET/CEST]'
29.10.2023 2A:00:00
29.10.2023 2A:15:00
29.10.2023 2A:30:00
29.10.2023 2A:45:00
29.10.2023 2B:00:00
29.10.2023 2B:15:00
29.10.2023 2B:30:00
29.10.2023 2B:45:00

Die Zellen haben den Zeilenindex:  [28900, 28901, 28902, 28903, 28904, 28905, 28906, 28907] 

Spalte 'Zeit bis [CET/CEST]'
29.10.2023 2A:00:00
29.10.2023 2A:15:00
29.10.2023 2A:30:00
29.10.2023 2A:45:00
29.10.2023 2B:00:00
29.10.2023 2B:15:00
29.10.2023 2B:30:00
29.10.2023 2B:45:00

Die Zellen haben den Zeilenindex:  [28899, 28900, 28901, 28902, 28903, 28904, 28905, 28906] 
\end{verbatim}

Damit die Datumsspalten korrekt eingelesen werden können, werden die
Zeichenfolgen ``2A'' und ``2B'' mit der Methode \texttt{str.replace()}
durch ``02'' ersetzt. Dadurch wird eine Dublette im Datensatz erzeugt.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# string replace \& als Datum einlesen}
\CommentTok{\#\# Spalte Zeit von [CET/CEST]}
\NormalTok{erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{].}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{\textquotesingle{}2A\textquotesingle{}}\NormalTok{, repl }\OperatorTok{=} \StringTok{\textquotesingle{}02\textquotesingle{}}\NormalTok{)}
\NormalTok{erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{].}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{\textquotesingle{}2B\textquotesingle{}}\NormalTok{, repl }\OperatorTok{=} \StringTok{\textquotesingle{}02\textquotesingle{}}\NormalTok{)}

\NormalTok{erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ pd.to\_datetime(erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{], }\BuiltInTok{format} \OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y \%H:\%M:\%S"}\NormalTok{)}

\CommentTok{\#\# Spalte Zeit bis [CET/CEST]}
\NormalTok{erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{].}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{\textquotesingle{}2A\textquotesingle{}}\NormalTok{, repl }\OperatorTok{=} \StringTok{\textquotesingle{}02\textquotesingle{}}\NormalTok{)}
\NormalTok{erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{].}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{\textquotesingle{}2B\textquotesingle{}}\NormalTok{, repl }\OperatorTok{=} \StringTok{\textquotesingle{}02\textquotesingle{}}\NormalTok{)}

\NormalTok{erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ pd.to\_datetime(erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{], }\BuiltInTok{format} \OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y \%H:\%M:\%S"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(erzeugung\_austria.info())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 35040 entries, 0 to 35039
Data columns (total 15 columns):
 #   Column                        Non-Null Count  Dtype         
---  ------                        --------------  -----         
 0   Zeit von [CET/CEST]           35040 non-null  datetime64[ns]
 1   Zeit bis [CET/CEST]           35040 non-null  datetime64[ns]
 2   Wind [MW]                     35040 non-null  float64       
 3   Solar [MW]                    35040 non-null  float64       
 4   Biomasse [MW]                 35040 non-null  float64       
 5   Gas [MW]                      35040 non-null  float64       
 6   Kohle [MW]                    35040 non-null  float64       
 7   Öl [MW]                       35040 non-null  float64       
 8   Geothermie [MW]               35040 non-null  float64       
 9   Pumpspeicher [MW]             35040 non-null  float64       
 10  Lauf- und Schwellwasser [MW]  35040 non-null  float64       
 11  Speicher [MW]                 35040 non-null  float64       
 12  Sonstige Erneuerbare [MW]     35040 non-null  float64       
 13  Müll [MW]                     35040 non-null  float64       
 14  Andere [MW]                   35040 non-null  float64       
dtypes: datetime64[ns](2), float64(13)
memory usage: 4.0 MB
None
\end{verbatim}

\textbf{Indexpositionen der doppelten und der fehlenden Stunde
bestimmen}

Im nächsten Schritt werden die Indexposition der doppelten und der
fehlenden Stunde bestimmt. Dazu wird ein neues Objekt angelegt, das auf
den Speicherbereich der Datumsspalten zugreift (was nicht zwingend
erforderlich ist). Die Position der doppelten Stunde wird mit der
Methode \texttt{pd.Series.duplicated()} bestimmt, die einen logischen
Vektor zurückgibt. Dieser wird zum Slicing und der Ausgabe der
Indexposition verwendet. Durch die Subtraktion von 4 wird der Index der
ersten Stunde ausgegeben (der Datensatz ist auf Viertelstundenbasis).

\emph{doppelte Stunde}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# neues Objekt anlegen}
\NormalTok{austria\_dates }\OperatorTok{=}\NormalTok{ erzeugung\_austria[[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{]].copy()}

\CommentTok{\# Indexposition der doppelten Stunde bestimmen}
\CommentTok{\#\# Zeit von}
\NormalTok{position\_doppelte\_stunde\_von }\OperatorTok{=}\NormalTok{ austria\_dates[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{][austria\_dates[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{].duplicated()].index }\OperatorTok{{-}} \DecValTok{4}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die doppelte Stunde (Zeit von):}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{austria\_dates}\SpecialCharTok{.}\NormalTok{loc[position\_doppelte\_stunde\_von, }\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{]}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{steht an Indexposition}\CharTok{\textbackslash{}n}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{position\_doppelte\_stunde\_von}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Die nächste Stunde lautet:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{austria\_dates}\SpecialCharTok{.}\NormalTok{loc[position\_doppelte\_stunde\_von }\OperatorTok{+} \DecValTok{4}\NormalTok{, }\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{"}
\SpecialStringTok{f"}\CharTok{\textbackslash{}n\textbackslash{}n}\SpecialStringTok{Beide Stunden sind identisch."}\NormalTok{)}

\CommentTok{\#\#\# Ende der Verschiebung in Spalte Zeit von}
\NormalTok{ende\_verschiebung\_von }\OperatorTok{=}\NormalTok{ position\_doppelte\_stunde\_von[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Die Zeitverschiebung in der Spalte Zeit von endet bei Indexposition: }\SpecialCharTok{\{}\NormalTok{ende\_verschiebung\_von}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\#\# Zeit bis}
\NormalTok{position\_doppelte\_stunde\_bis }\OperatorTok{=}\NormalTok{ austria\_dates[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{][austria\_dates[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{].duplicated()].index }\OperatorTok{{-}} \DecValTok{4}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n\textbackslash{}n}\SpecialStringTok{Die doppelte Stunde (Zeit bis):}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{austria\_dates}\SpecialCharTok{.}\NormalTok{loc[position\_doppelte\_stunde\_bis, }\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{]}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{steht an Indexposition}\CharTok{\textbackslash{}n}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{position\_doppelte\_stunde\_bis}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Die nächste Stunde lautet:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{austria\_dates}\SpecialCharTok{.}\NormalTok{loc[position\_doppelte\_stunde\_bis }\OperatorTok{+} \DecValTok{4}\NormalTok{, }\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{"}
\SpecialStringTok{f"}\CharTok{\textbackslash{}n\textbackslash{}n}\SpecialStringTok{Beide Stunden sind identisch."}\NormalTok{)}

\CommentTok{\#\#\# Ende der Verschiebung in Spalte Zeit bis}
\NormalTok{ende\_verschiebung\_bis }\OperatorTok{=}\NormalTok{ position\_doppelte\_stunde\_bis[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Die Zeitverschiebung in der Spalte Zeit bis endet bei Indexposition: }\SpecialCharTok{\{}\NormalTok{ende\_verschiebung\_bis}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die doppelte Stunde (Zeit von):
28900   2023-10-29 02:00:00
28901   2023-10-29 02:15:00
28902   2023-10-29 02:30:00
28903   2023-10-29 02:45:00
Name: Zeit von [CET/CEST], dtype: datetime64[ns]
steht an Indexposition
 Index([28900, 28901, 28902, 28903], dtype='int64')

Die nächste Stunde lautet:
28904   2023-10-29 02:00:00
28905   2023-10-29 02:15:00
28906   2023-10-29 02:30:00
28907   2023-10-29 02:45:00
Name: Zeit von [CET/CEST], dtype: datetime64[ns]

Beide Stunden sind identisch.

Die Zeitverschiebung in der Spalte Zeit von endet bei Indexposition: 28903


Die doppelte Stunde (Zeit bis):
28899   2023-10-29 02:00:00
28900   2023-10-29 02:15:00
28901   2023-10-29 02:30:00
28902   2023-10-29 02:45:00
Name: Zeit bis [CET/CEST], dtype: datetime64[ns]
steht an Indexposition
 Index([28899, 28900, 28901, 28902], dtype='int64')

Die nächste Stunde lautet:
28903   2023-10-29 02:00:00
28904   2023-10-29 02:15:00
28905   2023-10-29 02:30:00
28906   2023-10-29 02:45:00
Name: Zeit bis [CET/CEST], dtype: datetime64[ns]

Beide Stunden sind identisch.

Die Zeitverschiebung in der Spalte Zeit bis endet bei Indexposition: 28902
\end{verbatim}

\emph{fehlende Stunde}

Die Sommerzeit beginnt am letzen Sonntag im März. Die Stunde liegt nicht
in range(0, 24). Diese Bedingung kann in vier Schritten kontrolliert
werden:

\begin{itemize}
\item
  Monat März:
  \texttt{march\ =\ pd.Series{[}pd.Series.dt.month\ ==\ 3{]}}
\item
  Sonntage im März:
  \texttt{sundays\ =\ march{[}march.dt.dayofweek\ ==\ 6{]}}
\item
  letzter Sonntag im März: Die letzten 23*4 Einträge sind der letzte
  Sonntag des Monats (23 weil eine Stunde fehlt).\\
  \texttt{last\_sunday\ =\ sundays{[}-23*4:{]}}
\item
  fehlende Stunde:
  \texttt{np.argwhere(np.invert(pd.Series(range(0,24)).isin(last\_sunday.dt.hour)))}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Indexposition der fehlenden Stunde bestimmen}
\CommentTok{\#\# Zeit von}
\CommentTok{\#\#\# Monat März}
\NormalTok{maske\_märz\_von }\OperatorTok{=}\NormalTok{ austria\_dates[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{].dt.month }\OperatorTok{==} \DecValTok{3}
\NormalTok{austria\_dates\_march\_von }\OperatorTok{=}\NormalTok{ austria\_dates.loc[maske\_märz\_von, }\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Monat März (Zeit von):}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{austria\_dates\_march\_von}\SpecialCharTok{.}\NormalTok{head}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}\OperatorTok{;}

\CommentTok{\#\#\# letzter Sonntag}
\NormalTok{maske\_sonntag\_von }\OperatorTok{=}\NormalTok{ (austria\_dates\_march\_von.dt.dayofweek }\OperatorTok{==} \DecValTok{6}\NormalTok{)}
\NormalTok{letzter\_sonntag\_von }\OperatorTok{=}\NormalTok{ (austria\_dates\_march\_von[maske\_sonntag\_von]) [}\OperatorTok{{-}}\DecValTok{23}\OperatorTok{*}\DecValTok{4}\NormalTok{ :]}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der letzte Sonntag im März:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{letzter\_sonntag\_von}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\#\#\# fehlende Stunde}
\BuiltInTok{print}\NormalTok{(letzter\_sonntag\_von.dt.hour)}
\NormalTok{fehlende\_stunde\_von }\OperatorTok{=}\NormalTok{ np.argwhere(np.invert(pd.Series(}\BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{24}\NormalTok{)).isin(letzter\_sonntag\_von.dt.hour))).item() }
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Es fehlt die Stunde:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{fehlende\_stunde\_von}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(letzter\_sonntag\_von[letzter\_sonntag\_von.dt.hour }\OperatorTok{==}\NormalTok{ (fehlende\_stunde\_von }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)], letzter\_sonntag\_von[letzter\_sonntag\_von.dt.hour }\OperatorTok{==}\NormalTok{ (fehlende\_stunde\_von }\OperatorTok{+} \DecValTok{1}\NormalTok{)], sep }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\#\#\# Beginn der Verschiebung in Spalte Zeit von}
\NormalTok{beginn\_verschiebung\_von }\OperatorTok{=}\NormalTok{ letzter\_sonntag\_von[letzter\_sonntag\_von.dt.hour }\OperatorTok{==}\NormalTok{ (fehlende\_stunde\_von }\OperatorTok{+} \DecValTok{1}\NormalTok{)].index[}\DecValTok{0}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Die Zeitverschiebung in der Spalte Zeit von beginnt bei Indexposition: }\SpecialCharTok{\{}\NormalTok{beginn\_verschiebung\_von}\SpecialCharTok{\}}\CharTok{\textbackslash{}n\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\#\# Zeit bis}
\CommentTok{\#\#\# Monat März}
\NormalTok{maske\_märz\_bis }\OperatorTok{=}\NormalTok{ austria\_dates[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{].dt.month }\OperatorTok{==} \DecValTok{3}
\NormalTok{austria\_dates\_march\_bis }\OperatorTok{=}\NormalTok{ austria\_dates.loc[maske\_märz\_bis, }\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Monat März (Zeit bis):}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{austria\_dates\_march\_bis}\SpecialCharTok{.}\NormalTok{head}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}\OperatorTok{;}

\CommentTok{\#\#\# letzter Sonntag}
\NormalTok{maske\_sonntag\_bis }\OperatorTok{=}\NormalTok{ (austria\_dates\_march\_bis.dt.dayofweek }\OperatorTok{==} \DecValTok{6}\NormalTok{)}
\NormalTok{letzter\_sonntag\_bis }\OperatorTok{=}\NormalTok{ (austria\_dates\_march\_bis[maske\_sonntag\_bis]) [}\OperatorTok{{-}}\DecValTok{23}\OperatorTok{*}\DecValTok{4}\NormalTok{ :]}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der letzte Sonntag im März:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{letzter\_sonntag\_bis}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\#\#\# fehlende Stunde}
\BuiltInTok{print}\NormalTok{(letzter\_sonntag\_bis.dt.hour)}
\NormalTok{fehlende\_stunde\_bis }\OperatorTok{=}\NormalTok{ np.argwhere(np.invert(pd.Series(}\BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{24}\NormalTok{)).isin(letzter\_sonntag\_bis.dt.hour))).item() }
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Es fehlt die Stunde:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{fehlende\_stunde\_bis}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(letzter\_sonntag\_bis[letzter\_sonntag\_bis.dt.hour }\OperatorTok{==}\NormalTok{ (fehlende\_stunde\_bis }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)], letzter\_sonntag\_bis[letzter\_sonntag\_bis.dt.hour }\OperatorTok{==}\NormalTok{ (fehlende\_stunde\_bis }\OperatorTok{+} \DecValTok{1}\NormalTok{)], sep }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\#\#\# Beginn der Verschiebung in Spalte Zeit bis}
\NormalTok{beginn\_verschiebung\_bis }\OperatorTok{=}\NormalTok{ letzter\_sonntag\_bis[letzter\_sonntag\_bis.dt.hour }\OperatorTok{==}\NormalTok{ (fehlende\_stunde\_bis }\OperatorTok{+} \DecValTok{1}\NormalTok{)].index[}\DecValTok{0}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Die Zeitverschiebung in der Spalte Zeit bis beginnt bei Indexposition: }\SpecialCharTok{\{}\NormalTok{beginn\_verschiebung\_bis}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der Monat März (Zeit von):
<bound method NDFrame.head of 5664   2023-03-01 00:00:00
5665   2023-03-01 00:15:00
5666   2023-03-01 00:30:00
5667   2023-03-01 00:45:00
5668   2023-03-01 01:00:00
               ...        
8631   2023-03-31 22:45:00
8632   2023-03-31 23:00:00
8633   2023-03-31 23:15:00
8634   2023-03-31 23:30:00
8635   2023-03-31 23:45:00
Name: Zeit von [CET/CEST], Length: 2972, dtype: datetime64[ns]>

Der letzte Sonntag im März:
8064   2023-03-26 00:00:00
8065   2023-03-26 00:15:00
8066   2023-03-26 00:30:00
8067   2023-03-26 00:45:00
8068   2023-03-26 01:00:00
               ...        
8151   2023-03-26 22:45:00
8152   2023-03-26 23:00:00
8153   2023-03-26 23:15:00
8154   2023-03-26 23:30:00
8155   2023-03-26 23:45:00
Name: Zeit von [CET/CEST], Length: 92, dtype: datetime64[ns]

8064     0
8065     0
8066     0
8067     0
8068     1
        ..
8151    22
8152    23
8153    23
8154    23
8155    23
Name: Zeit von [CET/CEST], Length: 92, dtype: int32

Es fehlt die Stunde:
2

8068   2023-03-26 01:00:00
8069   2023-03-26 01:15:00
8070   2023-03-26 01:30:00
8071   2023-03-26 01:45:00
Name: Zeit von [CET/CEST], dtype: datetime64[ns]
8072   2023-03-26 03:00:00
8073   2023-03-26 03:15:00
8074   2023-03-26 03:30:00
8075   2023-03-26 03:45:00
Name: Zeit von [CET/CEST], dtype: datetime64[ns]

Die Zeitverschiebung in der Spalte Zeit von beginnt bei Indexposition: 8072


Der Monat März (Zeit bis):
<bound method NDFrame.head of 5663   2023-03-01 00:00:00
5664   2023-03-01 00:15:00
5665   2023-03-01 00:30:00
5666   2023-03-01 00:45:00
5667   2023-03-01 01:00:00
               ...        
8630   2023-03-31 22:45:00
8631   2023-03-31 23:00:00
8632   2023-03-31 23:15:00
8633   2023-03-31 23:30:00
8634   2023-03-31 23:45:00
Name: Zeit bis [CET/CEST], Length: 2972, dtype: datetime64[ns]>

Der letzte Sonntag im März:
8063   2023-03-26 00:00:00
8064   2023-03-26 00:15:00
8065   2023-03-26 00:30:00
8066   2023-03-26 00:45:00
8067   2023-03-26 01:00:00
               ...        
8150   2023-03-26 22:45:00
8151   2023-03-26 23:00:00
8152   2023-03-26 23:15:00
8153   2023-03-26 23:30:00
8154   2023-03-26 23:45:00
Name: Zeit bis [CET/CEST], Length: 92, dtype: datetime64[ns]

8063     0
8064     0
8065     0
8066     0
8067     1
        ..
8150    22
8151    23
8152    23
8153    23
8154    23
Name: Zeit bis [CET/CEST], Length: 92, dtype: int32

Es fehlt die Stunde:
2

8067   2023-03-26 01:00:00
8068   2023-03-26 01:15:00
8069   2023-03-26 01:30:00
8070   2023-03-26 01:45:00
Name: Zeit bis [CET/CEST], dtype: datetime64[ns]
8071   2023-03-26 03:00:00
8072   2023-03-26 03:15:00
8073   2023-03-26 03:30:00
8074   2023-03-26 03:45:00
Name: Zeit bis [CET/CEST], dtype: datetime64[ns]

Die Zeitverschiebung in der Spalte Zeit bis beginnt bei Indexposition: 8071
\end{verbatim}

Mit den gespeicherten Indexpositionen können die betreffenden
Zeitstempel verschoben werden:

\begin{itemize}
\item
  Spalte Zeit von: 8072 (Objekt beginn\_verschiebung\_von) bis 28903
  (Objekt ende\_verschiebung\_von)
\item
  Spalte Zeit bis: 8071 (Objekt beginn\_verschiebung\_bis) bis 28902
  (Objekt ende\_verschiebung\_bis)
\end{itemize}

Für das Slicing wird die Methode \texttt{pd.Series.iloc{[}{]}}
verwendet, die exklusiv indexiert, d.~h. die Endpositionen müssen um 1
erhöht werden. Durch Subtraktion von pd.Timedelta(1, unit = `h') wird
die Zeitverschiebung aus dem Datensatz entfernt.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Zeitverschiebung korrigieren}
\CommentTok{\#\# Zeit von}
\NormalTok{austria\_dates[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{].iloc[beginn\_verschiebung\_von : ende\_verschiebung\_von }\OperatorTok{+} \DecValTok{1}\NormalTok{] }\OperatorTok{=}\NormalTok{ austria\_dates[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{].iloc[beginn\_verschiebung\_von : ende\_verschiebung\_von }\OperatorTok{+} \DecValTok{1}\NormalTok{].subtract(pd.Timedelta(}\DecValTok{1}\NormalTok{, unit }\OperatorTok{=} \StringTok{\textquotesingle{}h\textquotesingle{}}\NormalTok{))}

\NormalTok{erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ austria\_dates[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{]}

\CommentTok{\#\# Zeit bis}
\NormalTok{austria\_dates[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{].iloc[beginn\_verschiebung\_bis : ende\_verschiebung\_bis }\OperatorTok{+} \DecValTok{1}\NormalTok{] }\OperatorTok{=}\NormalTok{ austria\_dates[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{].iloc[beginn\_verschiebung\_bis : ende\_verschiebung\_bis }\OperatorTok{+} \DecValTok{1}\NormalTok{].subtract(pd.Timedelta(}\DecValTok{1}\NormalTok{, unit }\OperatorTok{=} \StringTok{\textquotesingle{}h\textquotesingle{}}\NormalTok{))}

\NormalTok{erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ austria\_dates[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{]}

\CommentTok{\# Kontrolle}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Kontrolle im Datensatz +/{-} eine Viertelstunde}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Die Spalte Zeit von"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{].iloc[beginn\_verschiebung\_von }\OperatorTok{{-}}\DecValTok{1}\NormalTok{ : ende\_verschiebung\_von }\OperatorTok{+} \DecValTok{2}\NormalTok{], }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Die Spalte Zeit bis"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{].iloc[beginn\_verschiebung\_bis }\OperatorTok{{-}}\DecValTok{1}\NormalTok{ : ende\_verschiebung\_bis }\OperatorTok{+} \DecValTok{2}\NormalTok{], }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Kontrolle im Datensatz +/- eine Viertelstunde

Die Spalte Zeit von
8071    2023-03-26 01:45:00
8072    2023-03-26 02:00:00
8073    2023-03-26 02:15:00
8074    2023-03-26 02:30:00
8075    2023-03-26 02:45:00
                ...        
28900   2023-10-29 01:00:00
28901   2023-10-29 01:15:00
28902   2023-10-29 01:30:00
28903   2023-10-29 01:45:00
28904   2023-10-29 02:00:00
Name: Zeit von [CET/CEST], Length: 20834, dtype: datetime64[ns] 

Die Spalte Zeit bis
8070    2023-03-26 01:45:00
8071    2023-03-26 02:00:00
8072    2023-03-26 02:15:00
8073    2023-03-26 02:30:00
8074    2023-03-26 02:45:00
                ...        
28899   2023-10-29 01:00:00
28900   2023-10-29 01:15:00
28901   2023-10-29 01:30:00
28902   2023-10-29 01:45:00
28903   2023-10-29 02:00:00
Name: Zeit bis [CET/CEST], Length: 20834, dtype: datetime64[ns] 
\end{verbatim}

\end{tcolorbox}

\subsubsection{Schwer: CAPE Ratio - ein Datensatz voller
Tücken}\label{schwer-cape-ratio---ein-datensatz-voller-tuxfccken}

Der Nobelpreisgewinner für Wirtschaftswissenschaften von 2013 Robert
Shiller pflegt einen Datensatz mit monatlichen Kursdaten des
amerikanischen Aktienindexes S\&P500 und weiteren Wirtschaftsindikatoren
zur Berechnung des inflationsbereinigten Kurs-Gewinn-Verhältnisses (CAPE
Ratio). Der Datensatz ist auf der
\href{https://shillerdata.com/}{Webseite} von Robert Shiller verfügbar
(\href{https://img1.wsimg.com/blobby/go/e5e77e0b-59d1-44d9-ab25-4763ac982e53/downloads/ie_data.xls?ver=1712069253887}{Direktlink
zur XLS-Datei}). \textbf{Lesen Sie den Datensatz ein.}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Daten & Dateiname \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
monatliche Kursdaten S\&P500 & shiller\_data.xls \\
\end{longtable}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-shiller-data1}: Hinweise und Musterlösung Shiller data}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-shiller-data1} 

Schauen Sie sich den Datensatz zunächst mit einem
Tabellenkalkulationsprogramm an. Bemerkenswerte Auffälligkeiten sind:

\begin{itemize}
\item
  Metadaten in den Zeilen 2 und 3, in denen teilweise auch
  Spaltenbeschriftungen eingetragen sind, sowie am Ende des Datensatzes,
\item
  mehrzeilige Spaltenbeschriftungen,
\item
  Leerspalten P und N,
\item
  Kennzeichnung fehlender Werte durch `NA' und leere Zellen '\,' sowie
\item
  abweichende Formatierung des Monats Oktober in der Spalte Date
  `YYYY-M'.
\end{itemize}

\phantomsection\label{tip-shiller-data2}
\begin{quote}
\textbf{Tip~53.7: Lösungshilfe}

Aufgrund der zahlreichen Auffälligkeiten ist es hilfreich, die Daten und
die Kopfzeilen getrennt einzulesen. Den korrekten Zeilenindex können Sie
entweder der ersten Betrachtung mit einem Tabellenkalkulationsprogramm
entnehmen oder indem Sie einfach die ersten 10 oder 20 Zeilen des
Datensatzes in Python einlesen. Dadurch können die Daten einfacher
überblickt und mit Methoden der String-Bearbeitung manipuliert werden.
In der Praxis ist es einfacher, die Spaltenbeschriftungen manuell mit
dem Argument \texttt{names\ =\ Sequence\ of\ column\ labels\ to\ apply}
einzutragen bzw. dies mit Hilfe eines Tabellenkalkulationsprogramms zu
erledigen.

Außerdem empfiehlt es sich, schrittweise vorzugehen und für jedes
Problem eine separate Lösung, mit Ausschnitten des Datensatzes bzw. mit
dafür generierten Testdaten, zu entwickeln.

\phantomsection\label{tip-shiller-data3}
\begin{quote}
\textbf{Tip~53.6: Vollständige Musterlösung}

Zum Einlesen wird die Funktion \texttt{pd.read\_excel()} verwendet. Mit
dem Argument \texttt{sheet\_name} kann das Tabellenblatt Data ausgewählt
werden. Über die Methode pd.head(n = 10) kann der Zeilenindex bestimmt
werden, an dem der Tabellenkopf endet und die Daten beginnen. Es handelt
sich um die achte Zeile, die in Python den Zeilenindex 7 hat.

\textbf{Kopf einlesen}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/shiller\_data.xls\textquotesingle{}}
\NormalTok{shiller }\OperatorTok{=}\NormalTok{ pd.read\_excel(io }\OperatorTok{=}\NormalTok{ dateipfad, sheet\_name }\OperatorTok{=} \StringTok{\textquotesingle{}Data\textquotesingle{}}\NormalTok{)}

\CommentTok{\# manuell Ende des Kopfs und Beginn der Daten identifizieren (auskommentiert)}
\CommentTok{\# print(shiller.head(n = 10), "\textbackslash{}n")}

\CommentTok{\# Kopf einlesen}
\NormalTok{shiller\_head }\OperatorTok{=}\NormalTok{ pd.read\_excel(io }\OperatorTok{=}\NormalTok{ dateipfad, sheet\_name }\OperatorTok{=} \StringTok{\textquotesingle{}Data\textquotesingle{}}\NormalTok{, skiprows }\OperatorTok{=} \DecValTok{1}\NormalTok{, nrows }\OperatorTok{=} \DecValTok{7}\NormalTok{, header }\OperatorTok{=} \VariableTok{None}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(shiller\_head, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(shiller\_head.info()) }\CommentTok{\# die leeren Spalten werden als numerisch erkannt}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
                                                  0      1         2   \
0  Stock Market Data Used in "Irrational Exuberan...    NaN       NaN   
1                                 Robert J. Shiller     NaN       NaN   
2                                                NaN    NaN       NaN   
3                                                NaN    NaN       NaN   
4                                                NaN    S&P       NaN   
5                                                NaN  Comp.  Dividend   
6                                               Date      P         D   

         3           4         5          6      7         8       9   ...  \
0       NaN         NaN       NaN        NaN    NaN       NaN     NaN  ...   
1       NaN         NaN       NaN        NaN    NaN       NaN     NaN  ...   
2       NaN         NaN       NaN        NaN    NaN       NaN     NaN  ...   
3       NaN    Consumer       NaN        NaN    NaN       NaN    Real  ...   
4       NaN       Price       NaN       Long    NaN       NaN   Total  ...   
5  Earnings       Index    Date     Interest   Real      Real  Return  ...   
6         E         CPI  Fraction  Rate GS10  Price  Dividend   Price  ...   

           12  13                  14  15      16       17       18  \
0  Cyclically NaN         Cyclically  NaN     NaN      NaN      NaN   
1    Adjusted NaN            Adjusted NaN     NaN      NaN      NaN   
2       Price NaN  Total Return Price NaN     NaN      NaN      NaN   
3    Earnings NaN            Earnings NaN     NaN  Monthly     Real   
4       Ratio NaN               Ratio NaN  Excess    Total    Total   
5    P/E10 or NaN         TR P/E10 or NaN    CAPE     Bond     Bond   
6        CAPE NaN             TR CAPE NaN   Yield  Returns  Returns   

                 19                 20                  21  
0               NaN                NaN                 NaN  
1               NaN                NaN                 NaN  
2               NaN                NaN                 NaN  
3               NaN                NaN                 NaN  
4           10 Year            10 Year        Real 10 Year  
5  Annualized Stock  Annualized Bonds   Excess Annualized   
6       Real Return        Real Return             Returns  

[7 rows x 22 columns] 

<class 'pandas.core.frame.DataFrame'>
RangeIndex: 7 entries, 0 to 6
Data columns (total 22 columns):
 #   Column  Non-Null Count  Dtype  
---  ------  --------------  -----  
 0   0       3 non-null      object 
 1   1       3 non-null      object 
 2   2       2 non-null      object 
 3   3       2 non-null      object 
 4   4       4 non-null      object 
 5   5       2 non-null      object 
 6   6       3 non-null      object 
 7   7       2 non-null      object 
 8   8       2 non-null      object 
 9   9       4 non-null      object 
 10  10      2 non-null      object 
 11  11      4 non-null      object 
 12  12      7 non-null      object 
 13  13      0 non-null      float64
 14  14      7 non-null      object 
 15  15      0 non-null      float64
 16  16      3 non-null      object 
 17  17      4 non-null      object 
 18  18      4 non-null      object 
 19  19      3 non-null      object 
 20  20      3 non-null      object 
 21  21      3 non-null      object 
dtypes: float64(2), object(20)
memory usage: 1.3+ KB
None
\end{verbatim}

\textbf{Spaltenbeschriftungen isolieren}\\
Anschließend kann der Kopf weiter bearbeitet werden, um die
Spaltenbeschriftungen zu isolieren. Dafür gibt es verschiedene
Möglichkeiten. Weitere Alternativen zur folgenden Variante finden Sie im
nachfolgenden Beispiel. Spaltenweise erfolgt die Verkettung der
Zeichenketten mit der Methode \texttt{pd.Series.str.cat()}, die nur für
\texttt{pd.Series} verfügbar ist (weshalb mit einer Schleife die Spalten
einzeln durchlaufen werden) und nur mit dem Datentyp `string' verfügbar
ist, was durch die Methode
\texttt{astype(\textquotesingle{}string\textquotesingle{})}
sichergestellt wird.

Anschließend werden nicht zur Spaltenbeschriftung gehörende
Zeichenketten mit der Methode \texttt{str.replace()} entfernt. Dabei
erweist sich das Argument \texttt{regex\ =\ True} als nützlich.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Spaltenbeschriftung mit Schleife erzeugen}
\NormalTok{shiller\_column\_labels }\OperatorTok{=}\NormalTok{ pd.Series()}

\ControlFlowTok{for}\NormalTok{ column }\KeywordTok{in}\NormalTok{ shiller\_head:}
\NormalTok{  shiller\_column\_labels }\OperatorTok{=}\NormalTok{ pd.concat([shiller\_column\_labels, pd.Series(shiller\_head[column].astype(}\StringTok{\textquotesingle{}string\textquotesingle{}}\NormalTok{).}\BuiltInTok{str}\NormalTok{.cat())])}

\CommentTok{\# Zeichenketten säubern}
\CommentTok{\#\# erste Zelle entfernen Stock Market Data Used in "Irrational Exuberan...}
\NormalTok{shiller\_column\_labels }\OperatorTok{=}\NormalTok{ shiller\_column\_labels.astype(}\StringTok{\textquotesingle{}str\textquotesingle{}}\NormalTok{).replace(shiller\_head.loc[}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{], }\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{, regex }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

\CommentTok{\#\# \textquotesingle{}Robert J. Shiller\textquotesingle{} entfernen }
\NormalTok{shiller\_column\_labels }\OperatorTok{=}\NormalTok{ shiller\_column\_labels.astype(}\StringTok{\textquotesingle{}str\textquotesingle{}}\NormalTok{).replace(shiller\_head.loc[}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{], }\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{, regex }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

\CommentTok{\#\# Leerzeichen entfernen}
\CommentTok{\#\# regex = True um Leerzeichen innerhalb von Strings zu entfernen}
\NormalTok{shiller\_column\_labels }\OperatorTok{=}\NormalTok{ shiller\_column\_labels.astype(}\StringTok{\textquotesingle{}str\textquotesingle{}}\NormalTok{).replace(}\StringTok{\textquotesingle{} \textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{, regex }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

\CommentTok{\#\# sehr lange strings ersetzen}
\NormalTok{shiller\_column\_labels }\OperatorTok{=}\NormalTok{ shiller\_column\_labels.astype(}\StringTok{\textquotesingle{}str\textquotesingle{}}\NormalTok{).replace(}\StringTok{\textquotesingle{}CyclicallyAdjustedPriceEarningsRatioP/E10or\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{, regex }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{shiller\_column\_labels }\OperatorTok{=}\NormalTok{ shiller\_column\_labels.astype(}\StringTok{\textquotesingle{}str\textquotesingle{}}\NormalTok{).replace(}\StringTok{\textquotesingle{}CyclicallyAdjustedTotalReturnPriceEarningsRatioTRP/E10or\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{, regex }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

\CommentTok{\#\# Index zurücksetzen}
\NormalTok{shiller\_column\_labels.reset\_index(inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{, drop }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(shiller\_column\_labels)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0                                  Date
1                             S&PComp.P
2                             DividendD
3                             EarningsE
4                 ConsumerPriceIndexCPI
5                          DateFraction
6                  LongInterestRateGS10
7                             RealPrice
8                          RealDividend
9                  RealTotalReturnPrice
10                         RealEarnings
11                 RealTRScaledEarnings
12                                 CAPE
13                                     
14                               TRCAPE
15                                     
16                      ExcessCAPEYield
17              MonthlyTotalBondReturns
18                 RealTotalBondReturns
19      10YearAnnualizedStockRealReturn
20      10YearAnnualizedBondsRealReturn
21    Real10YearExcessAnnualizedReturns
dtype: object
\end{verbatim}

\begin{quote}
\textbf{Alternative Vorgehensweisen zur String-Manipulation des
Dateikopfs}

\subsubsection{Verwendung des NumPy-Datentyps
`str'}\label{verwendung-des-numpy-datentyps-str}

Die Angabe von dtype = `str' führt zur Verwendung des NumPy-Datentyps
string (dtype = `str'), der veränderlich (mutable) ist. Nur damit
funktioniert die Verkettung von Strings mit der Methode
\texttt{PD.df.sum()}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Der NumPy{-}Datentyp string ist veränderlich}
\NormalTok{my\_array }\OperatorTok{=}\NormalTok{ np.array([[}\StringTok{\textquotesingle{}1\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}2\textquotesingle{}}\NormalTok{], [}\StringTok{\textquotesingle{}3\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}4\textquotesingle{}}\NormalTok{]])}
\NormalTok{my\_array[}\DecValTok{0}\NormalTok{] }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{]}
\NormalTok{my\_array}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([['a', 'b'],
       ['3', '4']], dtype='<U1')
\end{verbatim}

Mit den Pandas-Datentypen `string' und `object' funktioniert das
gezeigte Vorgehen nicht. Denn Pandas nutzt den Python-Datentyp `string',
der unveränderlich ist. Das bedeutet, es gibt keine Methoden, die eine
angelegte Zeichenkette verändern können. Stattdessen geben Methoden wie
str.replace() neue strings zurück.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\#\# mit NumPy{-}Datentyp string}
\NormalTok{shiller\_head = pd.read\_excel(io = dateipfad, sheet\_name = \textquotesingle{}Data\textquotesingle{}, skiprows = 1, nrows = 7, header = None)}

\NormalTok{\# Kopf mit NumPy{-}Datentyp string mit pd.sum() verketten}
\NormalTok{\# print(shiller\_head.astype(\textquotesingle{}str\textquotesingle{}).sum(skipna = True, axis = 0))}

\NormalTok{\#\# Bereinigung des Datensatzes}
\NormalTok{\#\#\# nan entfernen}
\NormalTok{shiller\_head = shiller\_head.astype(\textquotesingle{}str\textquotesingle{}).replace(\textquotesingle{}nan\textquotesingle{}, \textquotesingle{}\textquotesingle{})}

\NormalTok{\#\#\# erste Zelle entfernen Stock Market Data Used in "Irrational Exuberan...}
\NormalTok{shiller\_head = shiller\_head.astype(\textquotesingle{}str\textquotesingle{}).replace(shiller\_head.loc[0, 0], \textquotesingle{}\textquotesingle{})}

\NormalTok{\#\#\# \textquotesingle{}Robert J. Shiller\textquotesingle{} entfernen }
\NormalTok{shiller\_head = shiller\_head.astype(\textquotesingle{}str\textquotesingle{}).replace(shiller\_head.loc[1, 0], \textquotesingle{}\textquotesingle{})}

\NormalTok{\#\#\# Leerzeichen entfernen}
\NormalTok{\#\#\# regex = True um Leerzeichen innerhalb von Strings zu entfernen}
\NormalTok{shiller\_head = shiller\_head.astype(\textquotesingle{}str\textquotesingle{}).replace(\textquotesingle{} \textquotesingle{}, \textquotesingle{}\textquotesingle{}, regex = True)}

\NormalTok{\#\#\# sehr lange strings ersetzen}
\NormalTok{shiller\_head = shiller\_head.astype(\textquotesingle{}str\textquotesingle{}).replace(\textquotesingle{}CyclicallyAdjustedPriceEarningsRatioP/E10or\textquotesingle{}, \textquotesingle{}\textquotesingle{}, regex = True)}
\NormalTok{shiller\_head = shiller\_head.astype(\textquotesingle{}str\textquotesingle{}).replace(\textquotesingle{}CyclicallyAdjustedTotalReturnPriceEarningsRatioTRP/E10or\textquotesingle{}, \textquotesingle{}\textquotesingle{}, regex = True)}

\NormalTok{\#\#\# spaltenweise Zeilen verketten}
\NormalTok{shiller\_head = shiller\_head.astype(\textquotesingle{}str\textquotesingle{}).sum(skipna = True, axis = 0)}

\NormalTok{print("\textbackslash{}nzusammengeführte Spaltennamen\textbackslash{}n", shiller\_head)}
\end{Highlighting}
\end{Shaded}

\subsubsection{Verwendung von DF.agg() oder
DF.apply()}\label{verwendung-von-df.agg-oder-df.apply}

Die Pandas-Methode \texttt{DF.agg()} aggregiert einen DataFrame zeilen-
oder spaltenweise durch eine spezifizierbare Funktion. Die
Pandas-Methode \texttt{DF.apply()} wendet eine Funktion zeilen- oder
spaltenweise auf einen DataFrame an. Die Methoden machen also das selbe.
Details zur Verwendung des
\href{https://docs.python.org/3/reference/expressions.html\#lambda}{Lambda-Ausdrucks}
und der Methode \texttt{join} aus der
\href{https://www.w3schools.com/python/ref_string_join.asp}{Pythonbasis}
finden Sie in den angegebenen Links.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{shiller\_head = pd.read\_excel(io = dateipfad, sheet\_name = \textquotesingle{}Data\textquotesingle{}, skiprows = 1, nrows = 7, header = None)}
\NormalTok{\# DF.agg()}
\NormalTok{print(shiller\_head.agg(lambda x: \textquotesingle{}\textquotesingle{}.join(x.astype(str))))}

\NormalTok{\# DF.apply}
\NormalTok{print(shiller\_head.apply(lambda x: \textquotesingle{}\textquotesingle{}.join(x.astype(str))))}
\end{Highlighting}
\end{Shaded}
\end{quote}

\textbf{Daten einlesen}

Beim Einlesen der Daten wird der Kopf kontrolliert sowie mit der Methode
\texttt{.tail()} das Ende der Datenreihe bestimmt, an dem weitere
Metadaten vermerkt sind. Diese Metadaten werden anschließend mit dem
Argument \texttt{skipfooter\ =\ 1} übersprungen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/shiller\_data.xls\textquotesingle{}}

\CommentTok{\# Daten einlesen}
\NormalTok{shiller\_data }\OperatorTok{=}\NormalTok{ pd.read\_excel(io }\OperatorTok{=}\NormalTok{ dateipfad, sheet\_name }\OperatorTok{=} \StringTok{\textquotesingle{}Data\textquotesingle{}}\NormalTok{, skiprows }\OperatorTok{=} \DecValTok{8}\NormalTok{, header }\OperatorTok{=} \VariableTok{None}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(shiller\_data.head(n }\OperatorTok{=} \DecValTok{2}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{shiller\_data.tail(n }\OperatorTok{=} \DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
        0     1     2    3      4        5     6       7     8       9   ...  \
0  1871.01  4.44  0.26  0.4  12.46  1871.04  5.32  111.06  6.50  111.06  ...   
1  1871.02   4.5  0.26  0.4  12.84  1871.12  5.32  109.22  6.31  109.75  ...   

   12  13  14  15  16   17    18    19    20    21  
0 NaN NaN NaN NaN NaN  1.0  1.00  0.13  0.09  0.04  
1 NaN NaN NaN NaN NaN  1.0  0.97  0.13  0.09  0.04  

[2 rows x 22 columns] 
\end{verbatim}

\begin{longtable}[]{@{}llllllllllllllllllllll@{}}
\toprule\noalign{}
& 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & ... & 12 & 13 & 14 & 15 & 16 &
17 & 18 & 19 & 20 & 21 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1836 & 2024.01 & 4815.61 & 70.48 & NaN & 308.42 & 2024.04 & 4.06 &
4867.78 & 71.24 & 3.22e+06 & ... & 32.05 & NaN & 34.62 & NaN & 0.02 &
0.99 & 39.84 & NaN & NaN & NaN \\
1837 & 2024.02 & 5011.96 & 70.65 & NaN & 310.33 & 2024.12 & 4.21 &
5035.09 & 70.98 & 3.34e+06 & ... & 33.11 & NaN & 35.79 & NaN & 0.02 &
1.00 & 39.25 & NaN & NaN & NaN \\
1838 & 2024.03 & 5170.57 & 70.82 & NaN & 311.28 & 2024.21 & 4.21 &
5178.50 & 70.93 & 3.43e+06 & ... & 34.02 & NaN & 36.79 & NaN & 0.02 &
1.00 & 39.27 & NaN & NaN & NaN \\
1839 & 2024.04 & 5243.77 & NaN & NaN & 311.76 & 2024.29 & 4.2 & 5243.77
& NaN & 3.48e+06 & ... & 34.41 & NaN & 37.18 & NaN & 0.01 & NaN & 39.37
& NaN & NaN & NaN \\
1840 & NaN & Apr price is Apr 1st close & NaN & NaN & Mar/Apr CPI
estimated & NaN & Apr GS10 is Mar 29th value & NaN & NaN & NaN & ... &
NaN & NaN & NaN & NaN & NaN & NaN & NaN & NaN & NaN & NaN \\
\end{longtable}

~

Nachdem die Metadaten entfernt wurden, werden die erkannten Datentypen
mit der Methode \texttt{.info()} kontrolliert.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{shiller\_data }\OperatorTok{=}\NormalTok{ pd.read\_excel(io }\OperatorTok{=}\NormalTok{ dateipfad, sheet\_name }\OperatorTok{=} \StringTok{\textquotesingle{}Data\textquotesingle{}}\NormalTok{, skiprows }\OperatorTok{=} \DecValTok{8}\NormalTok{, header }\OperatorTok{=} \VariableTok{None}\NormalTok{, skipfooter }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(shiller\_data.head(n }\OperatorTok{=} \DecValTok{2}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(shiller\_data.tail(n }\OperatorTok{=} \DecValTok{2}\NormalTok{))}

\CommentTok{\# Datentypen bestimmen}
\NormalTok{shiller\_data.info()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
        0     1     2    3      4        5     6       7     8       9   ...  \
0  1871.01  4.44  0.26  0.4  12.46  1871.04  5.32  111.06  6.50  111.06  ...   
1  1871.02  4.50  0.26  0.4  12.84  1871.12  5.32  109.22  6.31  109.75  ...   

   12  13  14  15  16   17    18    19    20    21  
0 NaN NaN NaN NaN NaN  1.0  1.00  0.13  0.09  0.04  
1 NaN NaN NaN NaN NaN  1.0  0.97  0.13  0.09  0.04  

[2 rows x 22 columns] 

           0        1      2   3       4        5     6        7      8   \
1838  2024.03  5170.57  70.82 NaN  311.28  2024.21  4.21  5178.50  70.93   
1839  2024.04  5243.77    NaN NaN  311.76  2024.29  4.20  5243.77    NaN   

            9   ...     12  13     14  15    16   17     18  19  20  21  
1838  3.43e+06  ...  34.02 NaN  36.79 NaN  0.02  1.0  39.27 NaN NaN NaN  
1839  3.48e+06  ...  34.41 NaN  37.18 NaN  0.01  NaN  39.37 NaN NaN NaN  

[2 rows x 22 columns]
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 1840 entries, 0 to 1839
Data columns (total 22 columns):
 #   Column  Non-Null Count  Dtype  
---  ------  --------------  -----  
 0   0       1840 non-null   float64
 1   1       1840 non-null   float64
 2   2       1839 non-null   float64
 3   3       1836 non-null   float64
 4   4       1840 non-null   float64
 5   5       1840 non-null   float64
 6   6       1840 non-null   float64
 7   7       1840 non-null   float64
 8   8       1839 non-null   float64
 9   9       1840 non-null   float64
 10  10      1836 non-null   float64
 11  11      1836 non-null   float64
 12  12      1720 non-null   float64
 13  13      0 non-null      float64
 14  14      1720 non-null   float64
 15  15      0 non-null      float64
 16  16      1720 non-null   float64
 17  17      1839 non-null   float64
 18  18      1840 non-null   float64
 19  19      1720 non-null   float64
 20  20      1720 non-null   float64
 21  21      1720 non-null   float64
dtypes: float64(22)
memory usage: 316.4 KB
\end{verbatim}

\textbf{Kopf und Daten zusammenführen}

Die Spalten mit dem Index 13 (Spalte N) und 15 (Spalte P) sind leer,
diese werden aus dem Kopf und den Daten entfernt. Alle Spalten werden
als Fließkommazahl erkannt. Das bedeutet, die Prozentzeichen in den
Spalten mit den Indizes 16 und 19 bis 21 (Q, T:V) wurden durch eine
Division durch 100 verarbeitet. Mit Ausnahme der Spalte Date wurde somit
alle Datentypen korrekt erkannt.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# \# leere Spalten entfernen}
\NormalTok{shiller\_column\_labels }\OperatorTok{=}\NormalTok{ shiller\_column\_labels.drop(labels }\OperatorTok{=}\NormalTok{ [}\DecValTok{13}\NormalTok{, }\DecValTok{15}\NormalTok{])}
\NormalTok{shiller\_data }\OperatorTok{=}\NormalTok{ shiller\_data.drop(labels }\OperatorTok{=}\NormalTok{ [}\DecValTok{13}\NormalTok{, }\DecValTok{15}\NormalTok{], axis }\OperatorTok{=} \StringTok{\textquotesingle{}columns\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Spaltennamen eintragen}
\NormalTok{shiller\_data.columns }\OperatorTok{=}\NormalTok{ shiller\_column\_labels}
\NormalTok{shiller\_data.info()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 1840 entries, 0 to 1839
Data columns (total 20 columns):
 #   Column                             Non-Null Count  Dtype  
---  ------                             --------------  -----  
 0   Date                               1840 non-null   float64
 1   S&PComp.P                          1840 non-null   float64
 2   DividendD                          1839 non-null   float64
 3   EarningsE                          1836 non-null   float64
 4   ConsumerPriceIndexCPI              1840 non-null   float64
 5   DateFraction                       1840 non-null   float64
 6   LongInterestRateGS10               1840 non-null   float64
 7   RealPrice                          1840 non-null   float64
 8   RealDividend                       1839 non-null   float64
 9   RealTotalReturnPrice               1840 non-null   float64
 10  RealEarnings                       1836 non-null   float64
 11  RealTRScaledEarnings               1836 non-null   float64
 12  CAPE                               1720 non-null   float64
 13  TRCAPE                             1720 non-null   float64
 14  ExcessCAPEYield                    1720 non-null   float64
 15  MonthlyTotalBondReturns            1839 non-null   float64
 16  RealTotalBondReturns               1840 non-null   float64
 17  10YearAnnualizedStockRealReturn    1720 non-null   float64
 18  10YearAnnualizedBondsRealReturn    1720 non-null   float64
 19  Real10YearExcessAnnualizedReturns  1720 non-null   float64
dtypes: float64(20)
memory usage: 287.6 KB
\end{verbatim}

\textbf{Datumsformat korrigieren}

Im nächsten Schritt wird das Datumsformat korrigiert. Die Spalte Date
enthält Zeichenketten im Format `YYYY,MM'. Eine Ausnahme ist der Monat
Oktober, der im Format `YYYY.M' kodiert ist. In der Ausgabe mit
\texttt{print()} ist dies nicht zu sehen, da die Darstellung von 2
Dezimalstellen mit dem Befehl
\texttt{pd.set\_option("display.precision",\ 2)} eingestellt wurde. Die
unterschiedliche Länge der Zeichketten kann mit dem Befehl
\texttt{shiller\_data.loc{[}0:12,\ \textquotesingle{}Date\textquotesingle{}{]}.astype(\textquotesingle{}str\textquotesingle{}).str.len()}
verdeutlicht werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(shiller\_data.loc[}\DecValTok{0}\NormalTok{:}\DecValTok{12}\NormalTok{, }\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{], }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  pd.to\_datetime(shiller\_data.loc[}\DecValTok{0}\NormalTok{:}\DecValTok{12}\NormalTok{, }\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{], }\BuiltInTok{format} \OperatorTok{=} \StringTok{"\%Y.\%m"}\NormalTok{)}
\ControlFlowTok{except} \PreprocessorTok{ValueError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(error, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\ControlFlowTok{else}\NormalTok{:}
\NormalTok{  pd.to\_datetime(shiller\_data.loc[}\DecValTok{0}\NormalTok{:}\DecValTok{12}\NormalTok{, }\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{], }\BuiltInTok{format} \OperatorTok{=} \StringTok{"\%Y.\%m"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(shiller\_data.loc[}\DecValTok{0}\NormalTok{:}\DecValTok{12}\NormalTok{, }\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{].astype(}\StringTok{\textquotesingle{}str\textquotesingle{}}\NormalTok{).}\BuiltInTok{str}\NormalTok{.}\BuiltInTok{len}\NormalTok{(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0     1871.01
1     1871.02
2     1871.03
3     1871.04
4     1871.05
5     1871.06
6     1871.07
7     1871.08
8     1871.09
9     1871.10
10    1871.11
11    1871.12
12    1872.01
Name: Date, dtype: float64 

time data "1871" doesn't match format "%Y.%m", at position 0. You might want to try:
    - passing `format` if your strings have a consistent format;
    - passing `format='ISO8601'` if your strings are all ISO8601 but not necessarily in exactly the same format;
    - passing `format='mixed'`, and the format will be inferred for each element individually. You might want to use `dayfirst` alongside this. 

0     7
1     7
2     7
3     7
4     7
5     7
6     7
7     7
8     7
9     6
10    7
11    7
12    7
Name: Date, dtype: int64 
\end{verbatim}

Der Datentyp der Spalte `Date' wird als String deklariert. Mit einer
Maske werden die Zeichenketten mit Länge 6 bestimmt. An die
Zeichenketten mit der Länge 6 wird eine 0 angehängt, um das Datumsformat
anzugleichen. Anschließend wird die Spalte mit der Funktion
\texttt{pd.to\_datetime(format\ =\ "\%Y.\%m")} als datetime eingelesen.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Datentyp Spalte Date als String setzen }
\CommentTok{\# führt zu einer Fehlermeldung:}
\NormalTok{shiller\_data[}\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ shiller\_data[}\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{].astype(}\StringTok{\textquotesingle{}str\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\NormalTok{maske }\OperatorTok{=}\NormalTok{ shiller\_data[}\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{].}\BuiltInTok{str}\NormalTok{.}\BuiltInTok{len}\NormalTok{() }\OperatorTok{==} \DecValTok{6}
\NormalTok{shiller\_data.loc[maske, }\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ shiller\_data.loc[maske, }\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{] }\OperatorTok{+} \StringTok{\textquotesingle{}0\textquotesingle{}}

\CommentTok{\# Ausgabe Länge Zeichenkette}
\BuiltInTok{print}\NormalTok{(shiller\_data.loc[}\DecValTok{0}\NormalTok{:}\DecValTok{12}\NormalTok{, }\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{].}\BuiltInTok{str}\NormalTok{.}\BuiltInTok{len}\NormalTok{())}
\BuiltInTok{print}\NormalTok{(shiller\_data.loc[}\DecValTok{0}\NormalTok{:}\DecValTok{12}\NormalTok{, }\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{])}

\CommentTok{\# Datentyp Spalte Date als datetime setzen}
\NormalTok{shiller\_data[}\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ pd.to\_datetime(shiller\_data[}\StringTok{\textquotesingle{}Date\textquotesingle{}}\NormalTok{], }\BuiltInTok{format} \OperatorTok{=} \StringTok{"\%Y.\%m"}\NormalTok{)}\OperatorTok{;}
\NormalTok{shiller\_data.info()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0     7
1     7
2     7
3     7
4     7
5     7
6     7
7     7
8     7
9     7
10    7
11    7
12    7
Name: Date, dtype: int64
0     1871.01
1     1871.02
2     1871.03
3     1871.04
4     1871.05
5     1871.06
6     1871.07
7     1871.08
8     1871.09
9     1871.10
10    1871.11
11    1871.12
12    1872.01
Name: Date, dtype: object
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 1840 entries, 0 to 1839
Data columns (total 20 columns):
 #   Column                             Non-Null Count  Dtype         
---  ------                             --------------  -----         
 0   Date                               1840 non-null   datetime64[ns]
 1   S&PComp.P                          1840 non-null   float64       
 2   DividendD                          1839 non-null   float64       
 3   EarningsE                          1836 non-null   float64       
 4   ConsumerPriceIndexCPI              1840 non-null   float64       
 5   DateFraction                       1840 non-null   float64       
 6   LongInterestRateGS10               1840 non-null   float64       
 7   RealPrice                          1840 non-null   float64       
 8   RealDividend                       1839 non-null   float64       
 9   RealTotalReturnPrice               1840 non-null   float64       
 10  RealEarnings                       1836 non-null   float64       
 11  RealTRScaledEarnings               1836 non-null   float64       
 12  CAPE                               1720 non-null   float64       
 13  TRCAPE                             1720 non-null   float64       
 14  ExcessCAPEYield                    1720 non-null   float64       
 15  MonthlyTotalBondReturns            1839 non-null   float64       
 16  RealTotalBondReturns               1840 non-null   float64       
 17  10YearAnnualizedStockRealReturn    1720 non-null   float64       
 18  10YearAnnualizedBondsRealReturn    1720 non-null   float64       
 19  Real10YearExcessAnnualizedReturns  1720 non-null   float64       
dtypes: datetime64[ns](1), float64(19)
memory usage: 287.6 KB
\end{verbatim}
\end{quote}
\end{quote}

\end{tcolorbox}

\chapter{Zugriff auf mehrere lokale Dateien: Modul
glob}\label{zugriff-auf-mehrere-lokale-dateien-modul-glob}

Das Modul
\href{https://docs.python.org/3/library/glob.html\#module-glob}{glob}
erlaubt es, mit der Funktion
\texttt{glob.glob(pathname,\ *,\ root\_dir\ =\ None,\ recursive\ =\ False)}
aus einem Ordner alle Dateipfade, die dem im Argument \texttt{pathname}
spezifizierten Muster entsprechen zurückzugeben. Das Argument
\texttt{pathname} kann als Schlüsselwort oder positional übergeben
werden, die übrigen Argumente müssen als Schlüsselwort übergeben werden
(dies signalisiert das Zeichen \texttt{*}). Die Speicheradresse des
Ordners wird mit dem Argument \texttt{root\_dir} übergeben, dessen
Standardwert das aktuelle Arbeitsverzeichnis ist. Im Argument
\texttt{pathname} können Platzhalter, sogenannte Wildcards, verwendet
werden, um beliebige Zeichen und Zeichenfolgen zu spezifizieren.

\begin{longtable}[]{@{}
  >{\centering\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.2222}}
  >{\centering\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.7778}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\centering
Wildcard
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Funktion
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{*} & beliebige Zeichenfolge außer Dateipfadelemente wie
\texttt{/} oder \texttt{.} \\
\texttt{?} & genau ein beliebiges Zeichen \\
\texttt{{[}{]}} & alle in den Klammern eingeschlossenen Zeichen
inklusive der Wildcards \texttt{*} \texttt{?} \\
\texttt{{[}0-9{]}} & alle Ziffern 0 bis 9 \\
\end{longtable}

~

Unter dem Pfad `01-daten/glob' liegen, teils in einem Unterordner,
verschiedene Dateien.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ glob}
\NormalTok{ordnerpfad }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/glob\textquotesingle{}} 

\NormalTok{pfadliste }\OperatorTok{=}\NormalTok{ glob.glob(pathname }\OperatorTok{=} \StringTok{\textquotesingle{}*\textquotesingle{}}\NormalTok{, root\_dir }\OperatorTok{=}\NormalTok{ ordnerpfad, recursive }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(pfadliste)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['ToothGrowth.csv', 'Unfallorte2020_LinRef.csv', 'Unfallorte2022_LinRef.csv', 'Unterordner glob', 'hintergrund.png']
\end{verbatim}

Das Argument \texttt{recursive} steuert, ob auch Unterordner durchsucht
werden. Um auch Unterordner zu durchsuchen, muss es auf True gesetzt und
im pathname \texttt{**} spezifiziert werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pfadliste }\OperatorTok{=}\NormalTok{ glob.glob(pathname }\OperatorTok{=} \StringTok{\textquotesingle{}**\textquotesingle{}}\NormalTok{, root\_dir }\OperatorTok{=}\NormalTok{ ordnerpfad, recursive }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(pfadliste)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['ToothGrowth.csv', 'Unfallorte2020_LinRef.csv', 'Unfallorte2022_LinRef.csv', 'Unterordner glob', 'Unterordner glob/Unfallorte2021_LinRef.csv', 'Unterordner glob/Unfallorte2023_LinRef.csv', 'hintergrund.png']
\end{verbatim}

Im angegebenen Pfad `01-daten/glob' liegen die Dateien
`hintergrund.png', `ToothGrowth.csv', `Unfallorte2020\_LinRef.csv',
`Unfallorte2022\_LinRef.csv' sowie der Unterordner `Unterordner glob'.
In diesem Unterordner liegen die Dateien `Unfallorte2021\_LinRef.csv'
und `Unfallorte2023\_LinRef.csv'.

Um die Suchergebnisse auf die Dateien `Unfallorte2020\_LinRef.csv',
`Unfallorte2021\_LinRef.csv', `Unfallorte2022\_LinRef.csv' und
`Unfallorte2023\_LinRef.csv' zu beschränken, muss der im Argument
\texttt{pathname} übergebene Dateipfad angepasst werden. \textbf{Schauen
Sie in die
\href{https://docs.python.org/3/library/glob.html\#module-glob}{Dokumentation
des Moduls glob} und übergeben einen geeigneten Dateipfad.}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-glob}: Tipp und Musterlösung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-glob} 

Tipp: Die gesuchten Dateien beginnen mit dem Buchstaben `U' und enden
mit der Dateiendung `.csv'. Wie Sie Dateien aus einem Ordner und aus
einem Unterordner auslesen, sehen Sie in der verlinkten Dokumentation
unter Examples.

\phantomsection\label{tip-glob}
\begin{quote}
\textbf{Tip~54.1: Musterlösung glob}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pfadliste }\OperatorTok{=}\NormalTok{ glob.glob(pathname }\OperatorTok{=} \StringTok{\textquotesingle{}**/U*.csv\textquotesingle{}}\NormalTok{, root\_dir }\OperatorTok{=}\NormalTok{ ordnerpfad, recursive }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(pfadliste)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['Unfallorte2020_LinRef.csv', 'Unfallorte2022_LinRef.csv', 'Unterordner glob/Unfallorte2021_LinRef.csv', 'Unterordner glob/Unfallorte2023_LinRef.csv']
\end{verbatim}
\end{quote}

\end{tcolorbox}

Mit den Dateipfaden können die Dateien mit Hilfe einer Schleife in eine
Liste eingelesen werden (aus Gründen der Lesbarkeit jeweils 3 Zeilen und
3 Spalten).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list\_of\_files }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ pfad }\KeywordTok{in}\NormalTok{ pfadliste:}
\NormalTok{  zwischenspeicher }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ ordnerpfad }\OperatorTok{+} \StringTok{\textquotesingle{}/\textquotesingle{}} \OperatorTok{+}\NormalTok{ pfad, }
\NormalTok{  delimiter }\OperatorTok{=} \StringTok{\textquotesingle{};\textquotesingle{}}\NormalTok{, nrows }\OperatorTok{=} \DecValTok{3}\NormalTok{, usecols }\OperatorTok{=}\NormalTok{ [}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{])}
\NormalTok{  list\_of\_files.append(zwischenspeicher)}
  \BuiltInTok{print}\NormalTok{(pfad, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, zwischenspeicher, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Unfallorte2020_LinRef.csv 
    OBJECTID           UIDENTSTLAE  ULAND
0         1  12200116471201851100     12
1         2  12200106642131830700     12
2         3  12200109522101836720     12 

Unfallorte2022_LinRef.csv 
    OBJECTID          UIDENTSTLAE  ULAND
0         1  1220204125013262022      1
1         2  1220529134013152022      1
2         3  1220508125013982022      1 

Unterordner glob/Unfallorte2021_LinRef.csv 
    OBJECTID          UIDENTSTLAE  ULAND
0         1  1210308125013512021      1
1         2  1210608134013112021      1
2         3  1210610181013902021      1 

Unterordner glob/Unfallorte2023_LinRef.csv 
    OID_          UIDENTSTLAE  ULAND
0     1  1230519134013042023      1
1     2  1230519134013022023      1
2     3  1230519125013522023      1 
\end{verbatim}

Aus der Liste können die Datensätze dann eigenen Objekten zugewiesen
werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unfalldaten2020 }\OperatorTok{=}\NormalTok{ list\_of\_files[}\DecValTok{0}\NormalTok{] }
\NormalTok{unfalldaten2021 }\OperatorTok{=}\NormalTok{ list\_of\_files[}\DecValTok{2}\NormalTok{] }
\NormalTok{unfalldaten2022 }\OperatorTok{=}\NormalTok{ list\_of\_files[}\DecValTok{1}\NormalTok{] }
\NormalTok{unfalldaten2023 }\OperatorTok{=}\NormalTok{ list\_of\_files[}\DecValTok{3}\NormalTok{] }

\BuiltInTok{print}\NormalTok{(unfalldaten2020, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(unfalldaten2020.dtypes)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   OBJECTID           UIDENTSTLAE  ULAND
0         1  12200116471201851100     12
1         2  12200106642131830700     12
2         3  12200109522101836720     12 

OBJECTID        int64
UIDENTSTLAE    uint64
ULAND           int64
dtype: object
\end{verbatim}

Die Objekte könnten auch in einem DataFrame zusammengeführt werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Spalte OID\_ / OBJECTID vereinheitlichen}
\NormalTok{unfalldaten }\OperatorTok{=}\NormalTok{ pd.concat([unfalldaten2020.iloc[: , }\DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{], unfalldaten2022.iloc[: , }\DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{], unfalldaten2023.iloc[: , }\DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{] ], ignore\_index }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{unfalldaten.insert(loc }\OperatorTok{=} \DecValTok{0}\NormalTok{, column }\OperatorTok{=} \StringTok{\textquotesingle{}OBJECTID\textquotesingle{}}\NormalTok{, value }\OperatorTok{=}\NormalTok{ pd.Series(}\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, unfalldaten.shape[}\DecValTok{0}\NormalTok{] }\OperatorTok{+} \DecValTok{1}\NormalTok{)))}
\NormalTok{unfalldaten }\OperatorTok{=}\NormalTok{ unfalldaten.astype(}\StringTok{\textquotesingle{}uint64\textquotesingle{}}\NormalTok{)}

\NormalTok{unfalldaten}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
& OBJECTID & UIDENTSTLAE & ULAND \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 1 & 12200116471201851392 & 12 \\
1 & 2 & 12200106642131830784 & 12 \\
2 & 3 & 12200109522101835776 & 12 \\
3 & 4 & 1220204125013262080 & 1 \\
4 & 5 & 1220529134013152000 & 1 \\
5 & 6 & 1220508125013981952 & 1 \\
6 & 7 & 1230519134013041920 & 1 \\
7 & 8 & 1230519134013021952 & 1 \\
8 & 9 & 1230519125013521920 & 1 \\
\end{longtable}

{[}@Arnold-2023-funktionen-module-dateien{]}

\section{Übungen Modul glob}\label{uxfcbungen-modul-glob}

\subsubsection{Leicht: US State Facts and
Figures}\label{leicht-us-state-facts-and-figures}

Im Ordner ``01-daten/glob leicht'' liegen verschiedene .CSV-Dateien mit
Daten zu den US-Bundesstaaten. \textbf{Lesen Sie die Dateien in einen
neuen Datensatz ein.}

\begin{itemize}
\item
  Wie heißen die Dateien?
\item
  Welche Regionen werden in den Datensätzen unterschieden?
\item
  Wie viele Staaten gehören zu jeder Region?
\item
  Welche Region ist flächenmäßig die größte?
\end{itemize}

US State Facts and Figures von Becker, R. A., Chambers, J. M. and Wilks,
A. R. (1988) The New S Language. Wadsworth \& Brooks/Cole.
\href{https://www.rdocumentation.org/packages/datasets/versions/3.6.2/topics/state}{rdocumentation.org}.
Datensätze:

\begin{itemize}
\item
  state.abb
\item
  state.area
\item
  state.name
\item
  state.region
\end{itemize}

Die Datensätze können in R durch Eingabe des Datensatznamens in der
Konsole aufgerufen werden.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-musterloesung-glob}: Musterlösung US State Facts and Figures}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-musterloesung-glob} 

Mit dem Modul glob werden die Pfade der im Ordner liegenden Dateien in
einer Liste gespeichert. In einer Schleife wird mit der Funktion
\texttt{open()} jede Datei als Dateiobjekt geöffnet, aus dem der
Dateiname und der Dateiinhalte ausgelesen werden, um diese zu
betrachten.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ os}
\NormalTok{ordnerpfad }\OperatorTok{=} \StringTok{"01{-}daten/glob leicht"} 
\NormalTok{pfadliste }\OperatorTok{=}\NormalTok{ glob.glob(pathname }\OperatorTok{=} \StringTok{\textquotesingle{}*\textquotesingle{}}\NormalTok{, root\_dir }\OperatorTok{=}\NormalTok{ ordnerpfad, recursive }\OperatorTok{=} \VariableTok{False}\NormalTok{)}

\NormalTok{list\_of\_files }\OperatorTok{=}\NormalTok{ []}
\NormalTok{names\_of\_files }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ pfad }\KeywordTok{in}\NormalTok{ pfadliste:}

  \CommentTok{\# Dateiobjekt öffnen}
\NormalTok{  zwischenspeicher }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(ordnerpfad }\OperatorTok{+} \StringTok{\textquotesingle{}/\textquotesingle{}} \OperatorTok{+}\NormalTok{ pfad, }\StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}
  
  \CommentTok{\# Dateinamen extrahieren}
\NormalTok{  name }\OperatorTok{=}\NormalTok{ os.path.basename(zwischenspeicher.name)}
\NormalTok{  names\_of\_files.append(name)}

  \CommentTok{\# Datei auslesen}
\NormalTok{  datei }\OperatorTok{=}\NormalTok{ zwischenspeicher.read()}
\NormalTok{  list\_of\_files.append(datei)}

  \CommentTok{\# Ausgabe}
  \BuiltInTok{print}\NormalTok{(name, }\StringTok{"Encoding:"}\NormalTok{, zwischenspeicher.encoding)}
  \BuiltInTok{print}\NormalTok{(datei[}\DecValTok{0}\NormalTok{:}\DecValTok{40}\NormalTok{], }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

  \CommentTok{\# Dateiobjekt schließen}
\NormalTok{  zwischenspeicher.close()}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Dateien heißen:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{names\_of\_files}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
state region.csv Encoding: UTF-8
"x"
"1" "South"
"2" "West"
"3" "West"
"4 

state name.csv Encoding: UTF-8
"x"
"1" "Alabama"
"2" "Alaska"
"3" "Ariz 

state area.csv Encoding: UTF-8
"x"
"1" 51609
"2" 589757
"3" 113909
"4"  

state abb.csv Encoding: UTF-8
"x"
"1" "AL"
"2" "AK"
"3" "AZ"
"4" "AR"
 

Die Dateien heißen:
['state region.csv', 'state name.csv', 'state area.csv', 'state abb.csv']
\end{verbatim}

Als nächstes werden die Daten in einem Datensatz `states' gespeichert.
Als Spaltennamen bieten sich die Dateinamen ohne Dateiendung an.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Spaltennamen vorbereiten}
\NormalTok{i }\OperatorTok{=} \DecValTok{0}
\ControlFlowTok{for}\NormalTok{ name }\KeywordTok{in}\NormalTok{ names\_of\_files:}
\NormalTok{  names\_of\_files[i] }\OperatorTok{=}\NormalTok{ name[}\DecValTok{0}\NormalTok{:}\OperatorTok{{-}}\DecValTok{4}\NormalTok{]}
\NormalTok{  i}\OperatorTok{+=} \DecValTok{1}

\CommentTok{\# DataFrame erstellen}
\NormalTok{states }\OperatorTok{=}\NormalTok{ pd.DataFrame()}
\NormalTok{i }\OperatorTok{=} \DecValTok{0}
\NormalTok{list\_of\_files }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ pfad }\KeywordTok{in}\NormalTok{ pfadliste:}
\NormalTok{  zwischenspeicher }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(ordnerpfad }\OperatorTok{+} \StringTok{\textquotesingle{}/\textquotesingle{}} \OperatorTok{+}\NormalTok{ pfad, }\StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}
\NormalTok{  states[i] }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ zwischenspeicher, sep }\OperatorTok{=} \StringTok{\textquotesingle{} \textquotesingle{}}\NormalTok{, usecols }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{]) }\CommentTok{\# skiprows = 1 überspringt den ersten Staat}
\NormalTok{  zwischenspeicher.close()}
\NormalTok{  i}\OperatorTok{+=} \DecValTok{1}

\CommentTok{\# Spaltennamen eintragen}
\NormalTok{states.columns }\OperatorTok{=}\NormalTok{ names\_of\_files}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Es gibt die Regionen:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{states[}\StringTok{\textquotesingle{}state region\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{unique()}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{states.head()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Es gibt die Regionen:
['South' 'West' 'Northeast' 'North Central']
\end{verbatim}

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
& state region & state name & state area & state abb \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & South & Alabama & 51609 & AL \\
1 & West & Alaska & 589757 & AK \\
2 & West & Arizona & 113909 & AZ \\
3 & South & Arkansas & 53104 & AR \\
4 & West & California & 158693 & CA \\
\end{longtable}

Im nächsten Schritt können die Anzahl der Staaten und die Fläche je
Region bestimmt werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Anzahl der Staaten je Region beträgt:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{states}\SpecialCharTok{.}\NormalTok{groupby(}\StringTok{\textquotesingle{}state region\textquotesingle{}}\NormalTok{)[}\StringTok{\textquotesingle{}state name\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\BuiltInTok{apply}\NormalTok{(}\BuiltInTok{len}\NormalTok{)}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Fläche der Regionen beträgt:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{states}\SpecialCharTok{.}\NormalTok{groupby(}\StringTok{\textquotesingle{}state region\textquotesingle{}}\NormalTok{)[}\StringTok{\textquotesingle{}state area\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\BuiltInTok{apply}\NormalTok{(}\BuiltInTok{sum}\NormalTok{)}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Anzahl der Staaten je Region beträgt:
state region
North Central    12
Northeast         9
South            16
West             13
Name: state name, dtype: int64

Die Fläche der Regionen beträgt:
state region
North Central     765530
Northeast         169353
South             899556
West             1783960
Name: state area, dtype: int64
\end{verbatim}

\begin{verbatim}
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_86667/3346728540.py:2: FutureWarning: The provided callable <built-in function sum> is currently using np.sum. In a future version of pandas, the provided callable will be used directly. To keep current behavior pass the string np.sum instead.
  print(f"Die Fläche der Regionen beträgt:\n{states.groupby('state region')['state area'].apply(sum)}\n")
\end{verbatim}

\end{tcolorbox}

\subsubsection{Schwer: DSB Unfallatlas}\label{schwer-dsb-unfallatlas}

Im Skript wurden bereits Daten aus dem DSB Unfallatlas eingelesen. Aus
Gründen der Lesbarkeit wurden jedoch nur die ersten drei Zeilen und
Spalten eingelesen. Für diese Aufgabe sollen nun die Dateien im
Dateipfad `01-daten/glob schwer' vollständig eingelesen und zu einem
Datensatz zusammengeführt werden. Ein Problem dabei ist, dass die
Spaltenbeschriftungen für den Straßenzustand und die ID-Variable nicht
einheitlich sind.

Unfallatlas Deutschland. von Statistische Ämter des Bundes und der
Länder steht unter der Lizenz
\href{https://creativecommons.org/licenses/by/4.0/deed.de}{CC BY 4.0}
und ist verfügbar auf dem
\href{https://unfallatlas.statistikportal.de/}{Statistikportal des
Bundes und der Länder}. 2024

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-musterloesung-unfallatlas}: Musterlösung Unfallatlas}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-musterloesung-unfallatlas} 

Das Erhebungsjahr ist eine Variable im Datensatz. Dennoch wird gezeigt,
wie dieses aus dem Dateinamen ausgelesen werden kann.

Zuerst werden der Inhalt des Ordners und anschließend die Dateipfade
ausgelesen.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Inhalt Ordner auslesen}
\NormalTok{ordnerpfad }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/glob schwer\textquotesingle{}}
\NormalTok{pfadliste }\OperatorTok{=}\NormalTok{ glob.glob(pathname }\OperatorTok{=} \StringTok{\textquotesingle{}**\textquotesingle{}}\NormalTok{, root\_dir }\OperatorTok{=}\NormalTok{ ordnerpfad, recursive }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Im Suchpfad liegen }\SpecialCharTok{\{}\BuiltInTok{len}\NormalTok{(pfadliste)}\SpecialCharTok{\}}\SpecialStringTok{ Elemente. Die Bezeichnungen lauten:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{pfadliste}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# Dateipfade auslesen}
\NormalTok{pfadliste }\OperatorTok{=}\NormalTok{ glob.glob(pathname }\OperatorTok{=} \StringTok{\textquotesingle{}**/U*.csv\textquotesingle{}}\NormalTok{, root\_dir }\OperatorTok{=}\NormalTok{ ordnerpfad, recursive }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Im Suchpfad liegen }\SpecialCharTok{\{}\BuiltInTok{len}\NormalTok{(pfadliste)}\SpecialCharTok{\}}\SpecialStringTok{ CSV{-}Dateien. Die Dateinamen lauten:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{pfadliste}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Im Suchpfad liegen 6 Elemente. Die Bezeichnungen lauten:
['Unfallorte2020_LinRef.csv', 'Unfallorte2022_LinRef.csv', 'DSB_Unfallatlas Metadaten.pdf', 'Unterordner glob', 'Unterordner glob/Unfallorte2021_LinRef.csv', 'Unterordner glob/Unfallorte2023_LinRef.csv']

Im Suchpfad liegen 4 CSV-Dateien. Die Dateinamen lauten:
['Unfallorte2020_LinRef.csv', 'Unfallorte2022_LinRef.csv', 'Unterordner glob/Unfallorte2021_LinRef.csv', 'Unterordner glob/Unfallorte2023_LinRef.csv']
\end{verbatim}

Als nächstes werden die Jahreszahlen aus den Pfadnamen extrahiert sowie
die Spaltennamen ausgelesen.

Um die Jahreszahlen aus den Dateinamen zu extrahieren, können die
Zeichenketten manuell beschnitten werden (Die Jahreszahl steht an den
Indexpositionen 10 bis exklusiv 14). Alternativ kann ein regulärer
Ausdruck verwendet werden. Reguläre Ausdrücke werden mit dem Modul re
verarbeitet. Die Funktion
\texttt{re.search(string\ =\ x,\ pattern\ =\ \textquotesingle{}{[}0-9{]}+\textquotesingle{})}
sucht im Objekt x nach dem im Argument \texttt{pattern} spezifizierten
Ausdruck, hier nach einer Zahl von 0 bis 9 \texttt{{[}0-9{]}} und jeder
darauf folgenden Zahl \texttt{+}. Die Funktion \texttt{re.search()}
erzeugt ein Match-Objekt, dessen Inhalt mit der Methode
\texttt{Match.group()} ausgegeben werden kann, die einen string
zurückgibt. (siehe
\href{https://docs.python.org/3/library/re.html\#match-objects}{Dokumentation
Modul re})

Um die Spaltennamen auszulesen, wird die Funktion
\texttt{pd.read\_csv()} mit den Argumenten
\texttt{nrows\ =\ 1,\ header\ =\ 0} angewiesen, die erste Zeile
auszulesen. Anschließend können die Spaltennamen visuell abgeglichen
werden - dies ist im Reiter DataFrame der Spaltennamen umgesetzt. Für
größere Datensätze ist dies aber nicht mehr praktikabel. Eine
algorithmische Lösung ist im Reiter Spaltennamen finden umgesetzt. Dazu
wird jede Spalte des DataFrames gegen alle anderen Spalten mit der
Methode \texttt{pd.Series.isin(df)} abgeglichen.

\section{Jahreszahlen und Spaltennamen auslesen}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Die Jahreszahlen auslesen}
\ImportTok{import}\NormalTok{ re}

\NormalTok{jahreszahlen }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ pfad }\KeywordTok{in}\NormalTok{ pfadliste:}
\NormalTok{  zwischenspeicher }\OperatorTok{=}\NormalTok{ re.search(string }\OperatorTok{=}\NormalTok{ pfad, pattern }\OperatorTok{=} \StringTok{\textquotesingle{}[0{-}9]+\textquotesingle{}}\NormalTok{).group()}
\NormalTok{  jahreszahlen.append(}\BuiltInTok{int}\NormalTok{(zwischenspeicher))}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Aus den Dateinamen extrahierte Jahreszahlen:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{jahreszahlen}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# Spaltennamen durch Einlesen der ersten Zeile extrahieren, header = None}
\NormalTok{i }\OperatorTok{=} \DecValTok{0}
\NormalTok{list\_of\_columns }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ pfad }\KeywordTok{in}\NormalTok{ pfadliste:}

\NormalTok{  zwischenspeicher }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ ordnerpfad }\OperatorTok{+} \StringTok{\textquotesingle{}/\textquotesingle{}} \OperatorTok{+}\NormalTok{ pfad, }
\NormalTok{  delimiter }\OperatorTok{=} \StringTok{\textquotesingle{};\textquotesingle{}}\NormalTok{, nrows }\OperatorTok{=} \DecValTok{1}\NormalTok{, header }\OperatorTok{=} \VariableTok{None}\NormalTok{).transpose()}

\NormalTok{  list\_of\_columns.append(zwischenspeicher)}
\NormalTok{  i }\OperatorTok{+=} \DecValTok{1}

\NormalTok{df\_of\_columns }\OperatorTok{=}\NormalTok{ pd.concat(list\_of\_columns, axis }\OperatorTok{=} \DecValTok{1}\NormalTok{, ignore\_index }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{df\_of\_columns.columns }\OperatorTok{=}\NormalTok{ jahreszahlen}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Aus den Dateinamen extrahierte Jahreszahlen:    [2020, 2022, 2021, 2023]
\end{verbatim}

Die Spaltennamen werden im nächsten Reiter ausgegeben.

\section{DataFrame der Spaltennamen}

Mit der Ausgabe des DataFrames können die ungleichen Spaltennamen
visuell identifiziert werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Ein DataFrame der Spaltennamen:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{df\_of\_columns}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Ein DataFrame der Spaltennamen:
           2020                2022         2021                2023
0      OBJECTID            OBJECTID     OBJECTID                OID_
1   UIDENTSTLAE         UIDENTSTLAE  UIDENTSTLAE         UIDENTSTLAE
2         ULAND               ULAND        ULAND               ULAND
3       UREGBEZ             UREGBEZ      UREGBEZ             UREGBEZ
4        UKREIS              UKREIS       UKREIS              UKREIS
5     UGEMEINDE           UGEMEINDE    UGEMEINDE           UGEMEINDE
6         UJAHR               UJAHR        UJAHR               UJAHR
7        UMONAT              UMONAT       UMONAT              UMONAT
8       USTUNDE             USTUNDE      USTUNDE             USTUNDE
9    UWOCHENTAG          UWOCHENTAG   UWOCHENTAG          UWOCHENTAG
10   UKATEGORIE          UKATEGORIE   UKATEGORIE          UKATEGORIE
11         UART                UART         UART                UART
12        UTYP1               UTYP1        UTYP1               UTYP1
13   ULICHTVERH          ULICHTVERH   ULICHTVERH          ULICHTVERH
14       IstRad  IstStrassenzustand  USTRZUSTAND  IstStrassenzustand
15       IstPKW              IstRad       IstRad              IstRad
16      IstFuss              IstPKW       IstPKW              IstPKW
17      IstKrad             IstFuss      IstFuss             IstFuss
18      IstGkfz             IstKrad      IstKrad             IstKrad
19  IstSonstige             IstGkfz      IstGkfz             IstGkfz
20      LINREFX         IstSonstige  IstSonstige         IstSonstige
21      LINREFY             LINREFX      LINREFX             LINREFX
22    XGCSWGS84             LINREFY      LINREFY             LINREFY
23    YGCSWGS84           XGCSWGS84    XGCSWGS84           XGCSWGS84
24   STRZUSTAND           YGCSWGS84    YGCSWGS84           YGCSWGS84
25          NaN                 NaN          NaN                PLST
\end{verbatim}

\section{Spaltennamen finden}

Der Abgleich der ungleichen Spaltennamen kann auch algorithmisch gelöst
werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Spaltennamen algorithmisch abgleichen}
\NormalTok{ungleiche\_spaltennamen }\OperatorTok{=}\NormalTok{ pd.Series()}

\CommentTok{\#\# vergleiche jede Spalte gegen alle anderen Spalten}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, df\_of\_columns.shape[}\DecValTok{1}\NormalTok{]):}

\NormalTok{  aktuelle\_spalte }\OperatorTok{=}\NormalTok{ df\_of\_columns.iloc[:, i]}

\NormalTok{  vergleichs\_df }\OperatorTok{=}\NormalTok{ df\_of\_columns.drop(df\_of\_columns.columns[i], axis }\OperatorTok{=} \DecValTok{1}\NormalTok{)}

\NormalTok{  j }\OperatorTok{=} \DecValTok{0}
  \ControlFlowTok{for}\NormalTok{ vergleichsspalte }\KeywordTok{in}\NormalTok{ vergleichs\_df: }\CommentTok{\# vergleichsspalte ist der Spaltenname (als int) 2020, 2021 usw.}
    
    \CommentTok{\# print(vergleichsspalte)}
\NormalTok{    maske\_fehlender\_spaltennamen }\OperatorTok{=}\NormalTok{ aktuelle\_spalte.isin(vergleichs\_df.loc[:, vergleichsspalte])}
\NormalTok{    maske\_fehlender\_spaltennamen }\OperatorTok{=}\NormalTok{ np.invert(maske\_fehlender\_spaltennamen) }\CommentTok{\# pandas hat keine Methode .invert()}
    
    \CommentTok{\# WENN Spaltennamen fehlen DANN}
    \ControlFlowTok{if}\NormalTok{ maske\_fehlender\_spaltennamen.}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{:}

      \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"In den Unfalldaten }\SpecialCharTok{\{}\NormalTok{df\_of\_columns}\SpecialCharTok{.}\NormalTok{columns[i]}\SpecialCharTok{\}}\SpecialStringTok{ treten die Spaltennamen }\SpecialCharTok{\{}\NormalTok{aktuelle\_spalte[maske\_fehlender\_spaltennamen]}\SpecialCharTok{.}\NormalTok{values}\SpecialCharTok{\}}\SpecialStringTok{ auf, die nicht in den Unfalldaten }\SpecialCharTok{\{}\NormalTok{vergleichs\_df}\SpecialCharTok{.}\NormalTok{columns[j]}\SpecialCharTok{\}}\SpecialStringTok{ enthalten sind.}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{      ungleiche\_spaltennamen }\OperatorTok{=}\NormalTok{ pd.concat([ungleiche\_spaltennamen, pd.Series(aktuelle\_spalte[maske\_fehlender\_spaltennamen].values)])}

\NormalTok{    j }\OperatorTok{+=}\DecValTok{1}

\NormalTok{ungleiche\_spaltennamen }\OperatorTok{=}\NormalTok{ ungleiche\_spaltennamen.dropna().unique()}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Folgende Spaltennamen müssen vereinheitlicht werden:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{ungleiche\_spaltennamen}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
In den Unfalldaten 2020 treten die Spaltennamen ['STRZUSTAND'] auf, die nicht in den Unfalldaten 2022 enthalten sind.

In den Unfalldaten 2020 treten die Spaltennamen ['STRZUSTAND'] auf, die nicht in den Unfalldaten 2021 enthalten sind.

In den Unfalldaten 2020 treten die Spaltennamen ['OBJECTID' 'STRZUSTAND' nan] auf, die nicht in den Unfalldaten 2023 enthalten sind.

In den Unfalldaten 2022 treten die Spaltennamen ['IstStrassenzustand'] auf, die nicht in den Unfalldaten 2020 enthalten sind.

In den Unfalldaten 2022 treten die Spaltennamen ['IstStrassenzustand'] auf, die nicht in den Unfalldaten 2021 enthalten sind.

In den Unfalldaten 2022 treten die Spaltennamen ['OBJECTID' nan] auf, die nicht in den Unfalldaten 2023 enthalten sind.

In den Unfalldaten 2021 treten die Spaltennamen ['USTRZUSTAND'] auf, die nicht in den Unfalldaten 2020 enthalten sind.

In den Unfalldaten 2021 treten die Spaltennamen ['USTRZUSTAND'] auf, die nicht in den Unfalldaten 2022 enthalten sind.

In den Unfalldaten 2021 treten die Spaltennamen ['OBJECTID' 'USTRZUSTAND' nan] auf, die nicht in den Unfalldaten 2023 enthalten sind.

In den Unfalldaten 2023 treten die Spaltennamen ['OID_' 'IstStrassenzustand' 'PLST'] auf, die nicht in den Unfalldaten 2020 enthalten sind.

In den Unfalldaten 2023 treten die Spaltennamen ['OID_' 'PLST'] auf, die nicht in den Unfalldaten 2022 enthalten sind.

In den Unfalldaten 2023 treten die Spaltennamen ['OID_' 'IstStrassenzustand' 'PLST'] auf, die nicht in den Unfalldaten 2021 enthalten sind.

Folgende Spaltennamen müssen vereinheitlicht werden:
['STRZUSTAND' 'OBJECTID' 'IstStrassenzustand' 'USTRZUSTAND' 'OID_' 'PLST']
\end{verbatim}

~

Die Spaltennamen `STRZUSTAND', `IstStrassenzustand' und `USTRZUSTAND'
sowie `OBJECTID', und `OID\_' müssen beim Einlesen der Daten
vereinheitlicht werden. Die Spalte `PLST' wurde nur im Jahr 2023 erhoben
und kann entfallen (siehe Unfallatlas Metadaten). Dafür wird der Methode
\texttt{pd.DataFrame.drop()} das Argument
\texttt{errors\ =\ \textquotesingle{}ignore\textquotesingle{}}
übergeben, da in einem Datensatz nicht vorhandene Spalten andernfalls zu
einer Fehlermeldung führen.

Die Spalte `UIDENTSTLAE' enthält sehr große Ganzzahlen, weshalb diese
als String eingelesen wird.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\# Dateien einlesen}
\NormalTok{unfallatlas }\OperatorTok{=}\NormalTok{ pd.DataFrame()}

\ControlFlowTok{for}\NormalTok{ pfad }\KeywordTok{in}\NormalTok{ pfadliste:}

  \CommentTok{\#\#\# Datei einlesen}
\NormalTok{  zwischenspeicher }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ ordnerpfad }\OperatorTok{+} \StringTok{\textquotesingle{}/\textquotesingle{}} \OperatorTok{+}\NormalTok{ pfad, }
\NormalTok{  delimiter }\OperatorTok{=} \StringTok{\textquotesingle{};\textquotesingle{}}\NormalTok{, dtype }\OperatorTok{=}\NormalTok{ \{}\StringTok{\textquotesingle{}UIDENTSTLAE\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}string\textquotesingle{}}\NormalTok{\})}

  \CommentTok{\#\#\# Spaltennamen vereinheitlichen}
\NormalTok{  zwischenspeicher.rename(columns }\OperatorTok{=}\NormalTok{ \{}\StringTok{"IstStrassenzustand"}\NormalTok{: }\StringTok{"STRZUSTAND"}\NormalTok{, }\StringTok{"USTRZUSTAND"}\NormalTok{: }\StringTok{"STRZUSTAND"}\NormalTok{, }\StringTok{"OID\_"}\NormalTok{: }\StringTok{"OBJECTID"}\NormalTok{\}, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{  zwischenspeicher.drop(columns }\OperatorTok{=} \StringTok{"PLST"}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{, errors }\OperatorTok{=} \StringTok{\textquotesingle{}ignore\textquotesingle{}}\NormalTok{)}
  
\NormalTok{  unfallatlas }\OperatorTok{=}\NormalTok{ pd.concat([unfallatlas, zwischenspeicher])}

\CommentTok{\# Ausgabe}
\BuiltInTok{print}\NormalTok{(unfallatlas.info(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{unfallatlas.head()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
Index: 996742 entries, 0 to 269047
Data columns (total 25 columns):
 #   Column       Non-Null Count   Dtype 
---  ------       --------------   ----- 
 0   OBJECTID     996742 non-null  int64 
 1   UIDENTSTLAE  996742 non-null  string
 2   ULAND        996742 non-null  int64 
 3   UREGBEZ      996742 non-null  int64 
 4   UKREIS       996742 non-null  int64 
 5   UGEMEINDE    996742 non-null  int64 
 6   UJAHR        996742 non-null  int64 
 7   UMONAT       996742 non-null  int64 
 8   USTUNDE      996742 non-null  int64 
 9   UWOCHENTAG   996742 non-null  int64 
 10  UKATEGORIE   996742 non-null  int64 
 11  UART         996742 non-null  int64 
 12  UTYP1        996742 non-null  int64 
 13  ULICHTVERH   996742 non-null  int64 
 14  IstRad       996742 non-null  int64 
 15  IstPKW       996742 non-null  int64 
 16  IstFuss      996742 non-null  int64 
 17  IstKrad      996742 non-null  int64 
 18  IstGkfz      996742 non-null  int64 
 19  IstSonstige  996742 non-null  int64 
 20  LINREFX      996742 non-null  object
 21  LINREFY      996742 non-null  object
 22  XGCSWGS84    996742 non-null  object
 23  YGCSWGS84    996742 non-null  object
 24  STRZUSTAND   996742 non-null  int64 
dtypes: int64(20), object(4), string(1)
memory usage: 197.7+ MB
None 
\end{verbatim}

\begin{longtable}[]{@{}llllllllllllllllllllll@{}}
\toprule\noalign{}
& OBJECTID & UIDENTSTLAE & ULAND & UREGBEZ & UKREIS & UGEMEINDE & UJAHR
& UMONAT & USTUNDE & UWOCHENTAG & ... & IstPKW & IstFuss & IstKrad &
IstGkfz & IstSonstige & LINREFX & LINREFY & XGCSWGS84 & YGCSWGS84 &
STRZUSTAND \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 1 & 12200116471201851100 & 12 & 0 & 68 & 468 & 2020 & 1 & 11 & 5 &
... & 0 & 0 & 0 & 1 & 0 & 735840,436700000430000 &
5887204,801599999900000 & 12,521519179000052 & 53,082132832000070 & 0 \\
1 & 2 & 12200106642131830700 & 12 & 0 & 61 & 112 & 2020 & 1 & 17 & 2 &
... & 1 & 1 & 0 & 0 & 0 & 814106,991899999790000 &
5811960,550300000200000 & 13,614608653000062 & 52,367677682000078 & 0 \\
2 & 3 & 12200109522101836720 & 12 & 0 & 67 & 144 & 2020 & 1 & 16 & 5 &
... & 1 & 0 & 0 & 0 & 0 & 845207,375699999740000 &
5811964,177100000900000 & 14,069661201000031 & 52,349021128000061 & 1 \\
3 & 4 & 12200131722601877310 & 12 & 0 & 69 & 76 & 2020 & 1 & 11 & 6 &
... & 1 & 0 & 0 & 0 & 0 & 756844,833999999800000 &
5787696,062999999200000 & 12,757074839000040 & 52,179829995000034 & 1 \\
4 & 5 & 12200124632322878920 & 12 & 0 & 62 & 224 & 2020 & 1 & 16 & 6 &
... & 1 & 0 & 0 & 0 & 0 & 793616,489599999970000 &
5735748,046199999700000 & 13,249132448000069 & 51,695730215000026 & 0 \\
\end{longtable}

~

Abschließend kann der Datensatz aufgeräumt werden:

\begin{itemize}
\item
  der Datensatz wird nach dem Jahr sortiert (wichtig: als erstes
  ausführen),
\item
  der Index wird zurückgesetzt (wichtig: als zweites),
\item
  die Spalte `OBJECTID' wird neu erstellt, um die beim Einlesen
  erzeugten Duplikate zu entfernen und
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Datensatz nach Jahr sortieren}
\NormalTok{unfallatlas.sort\_values(by }\OperatorTok{=} \StringTok{\textquotesingle{}UJAHR\textquotesingle{}}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

\CommentTok{\# Index zurücksetzen}
\NormalTok{unfallatlas.reset\_index(drop }\OperatorTok{=} \VariableTok{True}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

\CommentTok{\# Spalte \textquotesingle{}OBJECTID\textquotesingle{} neu generieren}
\NormalTok{unfallatlas[}\StringTok{\textquotesingle{}OBJECTID\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ pd.Series(}\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, unfallatlas.shape[}\DecValTok{0}\NormalTok{] }\OperatorTok{+} \DecValTok{1}\NormalTok{))}

\BuiltInTok{print}\NormalTok{(unfallatlas.info(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{unfallatlas.head()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 996742 entries, 0 to 996741
Data columns (total 25 columns):
 #   Column       Non-Null Count   Dtype 
---  ------       --------------   ----- 
 0   OBJECTID     996742 non-null  int64 
 1   UIDENTSTLAE  996742 non-null  string
 2   ULAND        996742 non-null  int64 
 3   UREGBEZ      996742 non-null  int64 
 4   UKREIS       996742 non-null  int64 
 5   UGEMEINDE    996742 non-null  int64 
 6   UJAHR        996742 non-null  int64 
 7   UMONAT       996742 non-null  int64 
 8   USTUNDE      996742 non-null  int64 
 9   UWOCHENTAG   996742 non-null  int64 
 10  UKATEGORIE   996742 non-null  int64 
 11  UART         996742 non-null  int64 
 12  UTYP1        996742 non-null  int64 
 13  ULICHTVERH   996742 non-null  int64 
 14  IstRad       996742 non-null  int64 
 15  IstPKW       996742 non-null  int64 
 16  IstFuss      996742 non-null  int64 
 17  IstKrad      996742 non-null  int64 
 18  IstGkfz      996742 non-null  int64 
 19  IstSonstige  996742 non-null  int64 
 20  LINREFX      996742 non-null  object
 21  LINREFY      996742 non-null  object
 22  XGCSWGS84    996742 non-null  object
 23  YGCSWGS84    996742 non-null  object
 24  STRZUSTAND   996742 non-null  int64 
dtypes: int64(20), object(4), string(1)
memory usage: 190.1+ MB
None 
\end{verbatim}

\begin{longtable}[]{@{}llllllllllllllllllllll@{}}
\toprule\noalign{}
& OBJECTID & UIDENTSTLAE & ULAND & UREGBEZ & UKREIS & UGEMEINDE & UJAHR
& UMONAT & USTUNDE & UWOCHENTAG & ... & IstPKW & IstFuss & IstKrad &
IstGkfz & IstSonstige & LINREFX & LINREFY & XGCSWGS84 & YGCSWGS84 &
STRZUSTAND \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 1 & 12200116471201851100 & 12 & 0 & 68 & 468 & 2020 & 1 & 11 & 5 &
... & 0 & 0 & 0 & 1 & 0 & 735840,436700000430000 &
5887204,801599999900000 & 12,521519179000052 & 53,082132832000070 & 0 \\
1 & 2 & 09200116005123027960 & 9 & 5 & 77 & 177 & 2020 & 1 & 16 & 5 &
... & 1 & 1 & 0 & 0 & 0 & 643651,871799999850000 &
5431630,146999999900000 & 10,964871918000028 & 49,020820015000027 & 0 \\
2 & 3 & 09200119006203025660 & 9 & 6 & 72 & 114 & 2020 & 1 & 15 & 1 &
... & 1 & 1 & 0 & 0 & 0 & 577166,822800000200000 &
5561461,695399999600000 & 10,081250780000062 & 50,200308086000064 & 0 \\
3 & 4 & 09200116004301008520 & 9 & 4 & 73 & 120 & 2020 & 1 & 16 & 5 &
... & 1 & 0 & 0 & 0 & 0 & 641867,597000000070000 &
5572120,551000000900000 & 10,991370639000024 & 50,284142850000080 & 0 \\
4 & 5 & 09200119001515007880 & 9 & 1 & 83 & 128 & 2020 & 1 & 10 & 1 &
... & 1 & 0 & 0 & 0 & 0 & 760977,136500000020000 &
5349657,038400000000000 & 12,515579712000033 & 48,246339794000050 & 1 \\
\end{longtable}

\end{tcolorbox}

\chapter{Maskierte Arrays}\label{sec-ma}

Maskierte Arrays sind eine Erweiterung für NumPy, um Probleme mit
fehlenden Werten insbesondere bei Ganzzahlen zu umgehen.

\begin{figure}

\begin{minipage}{0.05\linewidth}
~\end{minipage}%
%
\begin{minipage}{0.90\linewidth}
``\textbf{nan}, short for `not a number' {[}\ldots{]} was specifically
designed to address the problem of missing values, but the reality is
that different platforms behave differently, making life more difficult.
On some platforms, the presence of \textbf{nan} slows calculations
10-100 times. For integer data, no \textbf{nan} value exists.
{[}\ldots{]} Those wishing to avoid potential headaches will be
interested in an alternative solution which has a long history in
NumPy's predecessors -- \textbf{masked arrays}. {[}\ldots{]} Despite
their additional memory requirement, masked arrays are faster than nans
on many floating point units.'' (SciPy.org Frequently Askend Questions,
Zugriff via
\href{https://web.archive.org/web/20191007223944/https://scipy.org/scipylib/faq.html\#does-numpy-support-nan}{waybackmachine})\end{minipage}%
%
\begin{minipage}{0.05\linewidth}
~\end{minipage}%

\end{figure}%

~

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Fehlende Werte für Ganzzahlen sind in Pandas kein Problem}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Eine pd.Series vom dtype Int64 mit einem fehlenden Wert:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(pd.Series([}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, np.nan], dtype }\OperatorTok{=} \StringTok{\textquotesingle{}Int64\textquotesingle{}}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# In NumPy ist das anders}
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  np.array([}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, np.nan], dtype }\OperatorTok{=} \StringTok{\textquotesingle{}int\textquotesingle{}}\NormalTok{)}
\ControlFlowTok{except} \PreprocessorTok{ValueError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Da np.nan vom Datentyp float ist, haben Integer{-}Arrays keinen fehlenden Wert.}\CharTok{\textbackslash{}n}\StringTok{ Die Eingabe np.array([0, 1, np.nan], dtype = \textquotesingle{}int\textquotesingle{}) führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}
\ControlFlowTok{else}\NormalTok{:}
\NormalTok{  np.array([}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, np.nan], dtype }\OperatorTok{=} \StringTok{\textquotesingle{}int\textquotesingle{}}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Ursache ist der Datentyp von nan: type(np.nan)}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\BuiltInTok{type}\NormalTok{(np.nan)}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Eine pd.Series vom dtype Int64 mit einem fehlenden Wert:
0       0
1       1
2    <NA>
dtype: Int64 

Da np.nan vom Datentyp float ist, haben Integer-Arrays keinen fehlenden Wert.
 Die Eingabe np.array([0, 1, np.nan], dtype = 'int') führt zu der Fehlermeldung:
 cannot convert float NaN to integer
Die Ursache ist der Datentyp von nan: type(np.nan)
<class 'float'>
\end{verbatim}

Maskierte Arrays (masked arrays) werden durch das Modul
\texttt{numpy.ma} bereitgestellt und erlauben es, Werte als ungültig
oder fehlend zu markieren, ohne diese zu ersetzen oder zu löschen. Ein
maskiertes Array besteht aus drei Elementen:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  einem normalen NumPy-Array, das die Daten enthält.
\item
  einer Maske, die entweder den Wert \texttt{numpy.ma.nomask} hat, wenn
  kein Wert ungültig ist oder fehlt, oder aus einem NumPy-Array mit
  Wahrheitswerten für jedes Element des datentragenden NumPy-Arrays
  besteht: \texttt{True} kennzeichnet einen ungültigen/fehlenden Wert,
  \texttt{False} einen gülten Wert.
\item
  dem Füllwert, mit dem in der Maske mit \texttt{True} markierte Werte
  ersetzt werden. Standardmäßig ist dies die Zeichenkette
  \texttt{\textquotesingle{}-\/-\textquotesingle{}}.
\end{enumerate}

Über die Attribute \texttt{.data} und \texttt{.mask} kann auf das
zugrundeliegende NumPy-Array und die Maske zugegriffen werden. Ebenfalls
können die Funktionen \texttt{ma.getmask(maskiertes\_array)} und
\texttt{ma.getdata(maskiertes\_array)} genutzt werden. Der Füllwert wird
mit der Methode \texttt{maskiertes\_array.filled()} eingesetzt. Dies
gibt eine Kopie des datentragenden Arrays zurück, die Daten selbst
bleiben unverändert.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy.ma }\ImportTok{as}\NormalTok{ ma}

\NormalTok{maskiertes\_array }\OperatorTok{=}\NormalTok{ ma.masked\_array(data }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{]), mask }\OperatorTok{=}\NormalTok{ [}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"maskiertes Array:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{maskiertes\_array}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Daten:}\CharTok{\textbackslash{}t\textbackslash{}t\textbackslash{}t\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{maskiertes\_array}\SpecialCharTok{.}\NormalTok{data}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Maske:}\CharTok{\textbackslash{}t\textbackslash{}t\textbackslash{}t\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{maskiertes\_array}\SpecialCharTok{.}\NormalTok{mask}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Zugriff über Funktionen ma.getdata() und ma.getmask():}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{ma}\SpecialCharTok{.}\NormalTok{getdata(maskiertes\_array)}\SpecialCharTok{,}\NormalTok{ ma}\SpecialCharTok{.}\NormalTok{getmask(maskiertes\_array)}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"gefülltes Array:}\CharTok{\textbackslash{}t\textbackslash{}t\textbackslash{}t\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{maskiertes\_array}\SpecialCharTok{.}\NormalTok{filled()}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Das maskierte Array bleibt unverändert: }\SpecialCharTok{\{}\NormalTok{maskiertes\_array}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
maskiertes Array:   [1 2 -- --]
Daten:              [1 2 3 4]
Maske:              [False False  True  True]
Zugriff über Funktionen ma.getdata() und ma.getmask():
(array([1, 2, 3, 4]), array([False, False,  True,  True]))

gefülltes Array:                [     1      2 999999 999999]
Das maskierte Array bleibt unverändert: [1 2 -- --]
\end{verbatim}

Der Standardfüllwert ist abhängig vom Datentyp des NumPy-Arrays.

\begin{longtable}[]{@{}cc@{}}
\toprule\noalign{}
Datentyp & Standardfüllwert \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
bool & True \\
int & 999999 \\
float & 1.e20 \\
complex & 1.e20+0j \\
object & `?' \\
string & `N/A' \\
\end{longtable}

Der Standarfüllwert kann mit der Funktion
\texttt{np.ma.default\_fill\_value()} ausgegeben werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(np.ma.default\_fill\_value(}\DecValTok{1}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(np.ma.default\_fill\_value(}\StringTok{\textquotesingle{}1\textquotesingle{}}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
999999
N/A
\end{verbatim}

(\href{https://numpy.org/doc/2.1/reference/generated/numpy.ma.default_fill_value.html}{NumPy
Dokumentation})

Der Füllwert kann über das Attribut
\texttt{maskiertes\_array.fill\_value} geändert werden. Die Übergabe von
\texttt{maskiertes\_array.fill\_value\ =\ None} setzt den Füllwert auf
den Standardwert zurück.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Anlegen eines maskierten Arrays vom Datentyp Integer mit einem ganzzahligen Füllwert}
\NormalTok{maskiertes\_array }\OperatorTok{=}\NormalTok{ ma.masked\_array(data }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{0}\NormalTok{, }\DecValTok{4}\NormalTok{), mask }\OperatorTok{=}\NormalTok{ [}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{], fill\_value }\OperatorTok{=} \DecValTok{42}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Gefülltes Array vom Datentyp integer mit ganzzahligem Füllwert:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{maskiertes\_array}\SpecialCharTok{.}\NormalTok{filled()}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# Ändern des Füllwerts mit Datentyp float}
\NormalTok{maskiertes\_array.fill\_value }\OperatorTok{=} \FloatTok{1.5}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Wird einem maskierten Array vom Datentyp integer ein Füllwert vom Datentyp float übergeben,}\CharTok{\textbackslash{}n}\SpecialStringTok{ wird nur der ganzzahlige Teil eingesetzt:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{maskiertes\_array}\SpecialCharTok{.}\NormalTok{filled()}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Wird einem maskierten Array vom Datentyp integer ein Füllwert vom Datentyp string übergeben,}\CharTok{\textbackslash{}n}\SpecialStringTok{ folgt eine Fehlermeldung:}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  maskiertes\_array.fill\_value }\OperatorTok{=} \StringTok{\textquotesingle{}1.5\textquotesingle{}}
  \BuiltInTok{print}\NormalTok{(maskiertes\_array.filled())}
\ControlFlowTok{except} \PreprocessorTok{TypeError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(error)}
\ControlFlowTok{else}\NormalTok{:}
\NormalTok{  maskiertes\_array.fill\_value }\OperatorTok{=} \StringTok{\textquotesingle{}1.5\textquotesingle{}}
  \BuiltInTok{print}\NormalTok{(maskiertes\_array.filled())}

\CommentTok{\# Füllwert None}
\NormalTok{maskiertes\_array.fill\_value }\OperatorTok{=} \VariableTok{None}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Der Füllwert None bewirkt den Rückgriff auf einen datentypabhängigen Standardwert:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{maskiertes\_array}\SpecialCharTok{.}\NormalTok{filled()}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Gefülltes Array vom Datentyp integer mit ganzzahligem Füllwert:
[ 0  1 42 42]

Wird einem maskierten Array vom Datentyp integer ein Füllwert vom Datentyp float übergeben,
 wird nur der ganzzahlige Teil eingesetzt:
[0 1 1 1]

Wird einem maskierten Array vom Datentyp integer ein Füllwert vom Datentyp string übergeben,
 folgt eine Fehlermeldung:

Cannot set fill value of string with array of dtype int64

Der Füllwert None bewirkt den Rückgriff auf einen datentypabhängigen Standardwert:
[     0      1 999999 999999]
\end{verbatim}

\section{Maskierte Arrays erzeugen}\label{maskierte-arrays-erzeugen}

Maskierte Arrays können auf zahlreichen Wegen erzeugt werden. Eine
vollständige Übersicht erhalten Sie in der
\href{https://numpy.org/doc/stable/reference/maskedarray.generic.html\#constructing-masked-arrays}{Dokumentation}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{1000}\NormalTok{])}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Methode ma.asanyarray(array, dtype = ) legt den Datentyp des maskierten Arrays fest.}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"ma.asanyarray(a, dtype = \textquotesingle{}float64\textquotesingle{}):}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{ma}\SpecialCharTok{.}\NormalTok{asanyarray(a, dtype }\OperatorTok{=} \StringTok{\textquotesingle{}float64\textquotesingle{}}\NormalTok{)}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Methode ma.masked\_equal(x = array, value) maskiert alle Werte value.}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"ma.masked\_equal(a, 100):}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{ma}\SpecialCharTok{.}\NormalTok{masked\_equal(a, }\DecValTok{100}\NormalTok{)}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Methode ma.masked\_greater(x = array, value) maskiert alle Werte größer als value.}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"ma.masked\_greater(a, 100):}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{ma}\SpecialCharTok{.}\NormalTok{masked\_greater(a, }\DecValTok{100}\NormalTok{)}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Methode ma.masked\_inside(x = array, v1, v2) maskiert alle Werte im Intervall v1 bis v2.}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"ma.masked\_inside(a, 5, 100):}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{ma}\SpecialCharTok{.}\NormalTok{masked\_inside(a, }\DecValTok{5}\NormalTok{, }\DecValTok{100}\NormalTok{)}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Methode ma.masked\_where(condition, a = array) maskiert alle Werte, für die die Bedingung condition gilt.}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"ma.masked\_where(a \% 2 != 0, a):}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{ma}\SpecialCharTok{.}\NormalTok{masked\_where(a }\OperatorTok{\%} \DecValTok{2} \OperatorTok{!=} \DecValTok{0}\NormalTok{, a)}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Methode ma.asanyarray(array, dtype = ) legt den Datentyp des maskierten Arrays fest.
ma.asanyarray(a, dtype = 'float64'):
[   1.   10.  100. 1000.]

Die Methode ma.masked_equal(x = array, value) maskiert alle Werte value.
ma.masked_equal(a, 100):
[1 10 -- 1000]

Die Methode ma.masked_greater(x = array, value) maskiert alle Werte größer als value.
ma.masked_greater(a, 100):
[1 10 100 --]

Die Methode ma.masked_inside(x = array, v1, v2) maskiert alle Werte im Intervall v1 bis v2.
ma.masked_inside(a, 5, 100):
[1 -- -- 1000]

Die Methode ma.masked_where(condition, a = array) maskiert alle Werte, für die die Bedingung condition gilt.
ma.masked_where(a % 2 != 0, a):
[-- 10 100 1000]
\end{verbatim}

Die NumPy-Funktion \texttt{genfromtxt(usemask\ =\ True)} erzeugt mit dem
entsprechenden Argument ein maskiertes Array.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/TC01\_double\_hyphen.csv\textquotesingle{}}
\NormalTok{daten\_double\_hypen }\OperatorTok{=}\NormalTok{ np.genfromtxt(dateipfad, missing\_values }\OperatorTok{=} \StringTok{\textquotesingle{}{-}{-}\textquotesingle{}}\NormalTok{, usemask }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{daten\_double\_hypen}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
masked_array(data=[20.1, --, 20.1, ..., 24.3, 24.2, 24.2],
             mask=[False,  True, False, ..., False, False, False],
       fill_value=1e+20)
\end{verbatim}

Eine weitere Möglichkeit, Arraybereiche zu maskieren, ist es, einzelnen
Werten oder einem Wertebereich eines maskierten Arrays den Wert
\texttt{ma.masked} zuzuweisen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{maskiertes\_array }\OperatorTok{=}\NormalTok{ ma.masked\_array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{])}

\NormalTok{maskiertes\_array[}\DecValTok{1}\NormalTok{] }\OperatorTok{=}\NormalTok{ ma.masked}
\BuiltInTok{print}\NormalTok{(maskiertes\_array)}

\NormalTok{maskiertes\_array[}\DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{] }\OperatorTok{=}\NormalTok{ ma.masked}
\BuiltInTok{print}\NormalTok{(maskiertes\_array)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1 -- 3 4]
[1 -- -- 4]
\end{verbatim}

\section{Übung maskierte Arrays
erzeugen}\label{uxfcbung-maskierte-arrays-erzeugen}

Gegegben sei das NumPy-Array
\texttt{np.linspace(1,\ 1000,\ 18,\ dtype\ =\ \textquotesingle{}int\textquotesingle{})}.
\textbf{Erzeugen Sie mit dem NumPy-Array ein maskiertes Array.}

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\item
  Maskieren Sie jeden Wert im Intervall 250 bis 750. Wie viele Werte
  sind maskiert?
\item
  Maskieren Sie jeden zweiten Wert. Wie lautet die Summe des maskierten
  Arrays?
\item
  Maskieren Sie jeden geraden Wert.
\item
  Maskieren Sie jeden Wert, der mindestens 3 Stellen hat.
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-ma}: Musterlösung maskierte Arrays erzeugen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-ma} 

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Array erzeugen}
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{1}\NormalTok{, }\DecValTok{1000}\NormalTok{, }\DecValTok{18}\NormalTok{, dtype }\OperatorTok{=} \StringTok{\textquotesingle{}int\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Maske im Intervall 250{-}750}
\NormalTok{my\_ma }\OperatorTok{=}\NormalTok{ ma.masked\_inside(x }\OperatorTok{=}\NormalTok{ a, v1 }\OperatorTok{=} \DecValTok{250}\NormalTok{, v2 }\OperatorTok{=} \DecValTok{750}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Maske im Intervall 250{-}750:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(my\_ma, }\StringTok{"Anzahl maskierter Werte:"}\NormalTok{, my\_ma.mask.}\BuiltInTok{sum}\NormalTok{(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# jeder 2. Wert maskiert}
\NormalTok{my\_ma }\OperatorTok{=}\NormalTok{ ma.masked\_array(a)}
\NormalTok{my\_ma[::}\DecValTok{2}\NormalTok{] }\OperatorTok{=}\NormalTok{ ma.masked}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Jeder 2. Wert maskiert:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(my\_ma, }\StringTok{"Summe nicht maskierter Werte:"}\NormalTok{, my\_ma.}\BuiltInTok{sum}\NormalTok{(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# jeder gerade Wert maskiert}
\NormalTok{my\_ma }\OperatorTok{=}\NormalTok{ ma.masked\_where(a }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\NormalTok{, a)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Jeder gerade Wert maskiert:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(my\_ma, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# jeder mindestens dreistellige Wert maskiert}
\NormalTok{my\_ma }\OperatorTok{=}\NormalTok{ ma.masked\_where(a }\OperatorTok{/} \DecValTok{100} \OperatorTok{\textgreater{}=} \DecValTok{1}\NormalTok{, a)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Jeder mindestens dreistellige Wert maskiert:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(my\_ma)}

\CommentTok{\#\# eine Alternative}
\NormalTok{my\_mask }\OperatorTok{=}\NormalTok{ [}\BuiltInTok{len}\NormalTok{(}\BuiltInTok{str}\NormalTok{(i)) }\OperatorTok{\textgreater{}=} \DecValTok{3} \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ a]}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"ma.masked\_array(data = a, mask = my\_mask"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Maske im Intervall 250-750:
[1 59 118 177 236 -- -- -- -- -- -- -- -- 764 823 882 941 1000] Anzahl maskierter Werte: 8 

Jeder 2. Wert maskiert:
[-- 59 -- 177 -- 294 -- 412 -- 529 -- 647 -- 764 -- 882 -- 1000] Summe nicht maskierter Werte: 4764 

Jeder gerade Wert maskiert:
[1 59 -- 177 -- -- 353 -- 471 529 -- 647 -- -- 823 -- 941 --] 

Jeder mindestens dreistellige Wert maskiert:
[1 59 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --]
ma.masked_array(data = a, mask = my_mask
\end{verbatim}

\end{tcolorbox}

\section{unmasking, soft und hard
masks}\label{unmasking-soft-und-hard-masks}

Ein maskiertes Array kann auf verschiedene Weise demaskiert werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unmask\_me }\OperatorTok{=}\NormalTok{ my\_ma.copy()}
\NormalTok{unmask\_me.mask }\OperatorTok{=}\NormalTok{ ma.nomask}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Maske kann auf ma.nomask oder False gesetzt werden.}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"unmask\_me.mask = ma.nomask: }\SpecialCharTok{\{}\NormalTok{unmask\_me}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{unmask\_me }\OperatorTok{=}\NormalTok{ my\_ma.copy()}
\NormalTok{unmask\_me.mask }\OperatorTok{=} \VariableTok{False}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"unmask\_me.mask = False: }\SpecialCharTok{\{}\NormalTok{unmask\_me}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{unmask\_me }\OperatorTok{=}\NormalTok{ my\_ma.copy()}
\NormalTok{unmask\_me }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{1}\NormalTok{, }\DecValTok{1000}\NormalTok{, }\DecValTok{18}\NormalTok{, dtype }\OperatorTok{=} \StringTok{\textquotesingle{}int\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Maskierung wird auch durch eine Wertzuweisung aufgehoben.}\CharTok{\textbackslash{}n}\SpecialStringTok{Das Objekt wird neu angelegt."}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"unmask\_me = np.linspace(1, 1000, 18, dtype = \textquotesingle{}int\textquotesingle{}):}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{unmask\_me}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Maske kann auf ma.nomask oder False gesetzt werden.
unmask_me.mask = ma.nomask: [1 59 118 177 236 294 353 412 471 529 588 647 706 764 823 882 941 1000]

unmask_me.mask = False: [1 59 118 177 236 294 353 412 471 529 588 647 706 764 823 882 941 1000]

Die Maskierung wird auch durch eine Wertzuweisung aufgehoben.
Das Objekt wird neu angelegt.
unmask_me = np.linspace(1, 1000, 18, dtype = 'int'):
[   1   59  118  177  236  294  353  412  471  529  588  647  706  764
  823  882  941 1000]
\end{verbatim}

Die Demaskierung ist auch für Indexbereiche möglich.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unmask\_me }\OperatorTok{=}\NormalTok{ my\_ma.copy()}
\NormalTok{unmask\_me[}\DecValTok{6}\NormalTok{:}\DecValTok{10}\NormalTok{].mask }\OperatorTok{=}\NormalTok{ ma.nomask}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Maske kann auf ma.nomask oder False gesetzt werden.}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"unmask\_me[6:10].mask = ma.nomask: }\SpecialCharTok{\{}\NormalTok{unmask\_me}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{unmask\_me }\OperatorTok{=}\NormalTok{ my\_ma.copy()}
\NormalTok{unmask\_me[}\DecValTok{6}\NormalTok{:}\DecValTok{10}\NormalTok{].mask }\OperatorTok{=} \VariableTok{False}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"unmask\_me[6:10].mask = False: }\SpecialCharTok{\{}\NormalTok{unmask\_me}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{unmask\_me }\OperatorTok{=}\NormalTok{ my\_ma.copy()}
\NormalTok{unmask\_me[}\DecValTok{6}\NormalTok{:}\DecValTok{10}\NormalTok{] }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{1}\NormalTok{, }\DecValTok{1000}\NormalTok{, }\DecValTok{4}\NormalTok{, dtype }\OperatorTok{=} \StringTok{\textquotesingle{}int\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Maskierung wird auch durch eine Wertzuweisung aufgehoben."}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"unmask\_me[6:10] = np.linspace(1, 1000, 4, dtype = \textquotesingle{}int\textquotesingle{}):}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{unmask\_me}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Maske kann auf ma.nomask oder False gesetzt werden.
unmask_me[6:10].mask = ma.nomask: [1 59 -- -- -- -- 353 412 471 529 -- -- -- -- -- -- -- --]

unmask_me[6:10].mask = False: [1 59 -- -- -- -- 353 412 471 529 -- -- -- -- -- -- -- --]

Die Maskierung wird auch durch eine Wertzuweisung aufgehoben.
unmask_me[6:10] = np.linspace(1, 1000, 4, dtype = 'int'):
[1 59 -- -- -- -- 1 334 667 1000 -- -- -- -- -- -- -- --]
\end{verbatim}

Insbesondere die Demaskierung durch eine Wertzuweisung in einem
Indexbereich kann ein unerwünschtes Verhalten sein.

\subsubsection{soft und hard masks}\label{soft-und-hard-masks}

Die Maske eines maskierten Arrays ist eine veränderliche, sogenannte
soft mask. Um die Maske vor Änderungen zu schützen, kann die Maske mit
dem Argument
\texttt{ma.array(data\ =\ {[}data{]},\ mask\ =\ {[}mask{]},\ hard\_mask\ =\ True)}
oder mit der Methode \texttt{masked\_array.harden\_mask()} in eine hard
mask verwandelt werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unmask\_me }\OperatorTok{=}\NormalTok{ my\_ma.copy()}
\NormalTok{unmask\_me.harden\_mask()}
\NormalTok{unmask\_me.mask }\OperatorTok{=}\NormalTok{ ma.nomask}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die hard mask wird auf ma.nomask gesetzt.}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"unmask\_me.mask = ma.nomask: }\SpecialCharTok{\{}\NormalTok{unmask\_me}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{unmask\_me.mask }\OperatorTok{=} \VariableTok{False}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"unmask\_me.mask = False: }\SpecialCharTok{\{}\NormalTok{unmask\_me}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{unmask\_me }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{1}\NormalTok{, }\DecValTok{1000}\NormalTok{, }\DecValTok{18}\NormalTok{, dtype }\OperatorTok{=} \StringTok{\textquotesingle{}int\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die hard mask wird dennoch durch eine Wertzuweisung aufgehoben.}\CharTok{\textbackslash{}n}\SpecialStringTok{Das Objekt wird neu angelegt."}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"unmask\_me = np.linspace(1, 1000, 18, dtype = \textquotesingle{}int\textquotesingle{}):}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{unmask\_me}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die hard mask wird auf ma.nomask gesetzt.
unmask_me.mask = ma.nomask: [1 59 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --]

unmask_me.mask = False: [1 59 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --]

Die hard mask wird dennoch durch eine Wertzuweisung aufgehoben.
Das Objekt wird neu angelegt.
unmask_me = np.linspace(1, 1000, 18, dtype = 'int'):
[   1   59  118  177  236  294  353  412  471  529  588  647  706  764
  823  882  941 1000]
\end{verbatim}

Eine hard mask schützt einen Indexbereich vor der Demaskierung, auch
durch eine Wertzuweisung.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unmask\_me }\OperatorTok{=}\NormalTok{ my\_ma.copy()}
\NormalTok{unmask\_me.harden\_mask()}
\NormalTok{unmask\_me[}\DecValTok{6}\NormalTok{:}\DecValTok{10}\NormalTok{].mask }\OperatorTok{=}\NormalTok{ ma.nomask}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die hard mask wird auf ma.nomask gesetzt.}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"unmask\_me.mask[6:10] = ma.nomask: }\SpecialCharTok{\{}\NormalTok{unmask\_me}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{unmask\_me[}\DecValTok{6}\NormalTok{:}\DecValTok{10}\NormalTok{].mask }\OperatorTok{=} \VariableTok{False}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"unmask\_me[6:10].mask = False: }\SpecialCharTok{\{}\NormalTok{unmask\_me}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{unmask\_me[}\DecValTok{6}\NormalTok{:}\DecValTok{10}\NormalTok{] }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{1}\NormalTok{, }\DecValTok{1000}\NormalTok{, }\DecValTok{4}\NormalTok{, dtype }\OperatorTok{=} \StringTok{\textquotesingle{}int\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die hard mask wird nicht (!) durch eine Wertzuweisung im Indexbereich aufgehoben."}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"unmask\_me[6:10] = np.linspace(1, 1000, 4, dtype = \textquotesingle{}int\textquotesingle{}):}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{unmask\_me}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die hard mask wird auf ma.nomask gesetzt.
unmask_me.mask[6:10] = ma.nomask: [1 59 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --]

unmask_me[6:10].mask = False: [1 59 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --]

Die hard mask wird nicht (!) durch eine Wertzuweisung im Indexbereich aufgehoben.
unmask_me[6:10] = np.linspace(1, 1000, 4, dtype = 'int'):
[1 59 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --]
\end{verbatim}

Eine hard mask kann jedoch auf weitere Indexbereiche erweitert werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unmask\_me[}\DecValTok{0}\NormalTok{:}\DecValTok{2}\NormalTok{] }\OperatorTok{=}\NormalTok{ ma.masked}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Maskierungen zusätzlicher Elemente ist mit einer hard mask möglich.}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{unmask\_me}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Maskierungen zusätzlicher Elemente ist mit einer hard mask möglich.
[-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --]
\end{verbatim}

Eine hard mask kann mit der Methode
\texttt{masked\_array.soften\_mask()} aufgehoben werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unmask\_me.soften\_mask()}
\NormalTok{unmask\_me.mask }\OperatorTok{=}\NormalTok{ ma.nomask}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{unmask\_me}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1 59 118 177 236 294 353 412 471 529 588 647 706 764 823 882 941 1000]
\end{verbatim}

(\href{https://numpy.org/doc/stable/reference/maskedarray.generic.html\#unmasking-an-entry}{NumPy
Dokumentation})

\section{Operationen mit maskierten
Arrays}\label{operationen-mit-maskierten-arrays}

Arithmetische und vergleichende Operationen mit maskierten Arrays werden
nicht auf die maskierten Elemente angewendetet.

\url{https://numpy.org/doc/stable/reference/maskedarray.generic.html\#operations-on-masked-arrays}

\url{https://numpy.org/doc/2.1/reference/routines.ma.html}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Array erzeugen}
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{1}\NormalTok{, }\DecValTok{1000}\NormalTok{, }\DecValTok{18}\NormalTok{, dtype }\OperatorTok{=} \StringTok{\textquotesingle{}int\textquotesingle{}}\NormalTok{)}
\NormalTok{maskiertes\_array }\OperatorTok{=}\NormalTok{ ma.masked\_array(a)}
\NormalTok{maskiertes\_array[::}\DecValTok{2}\NormalTok{] }\OperatorTok{=}\NormalTok{ ma.masked}

\CommentTok{\# Ausgewählte Operationen}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Summe maskiertes\_array: }\SpecialCharTok{\{}\NormalTok{maskiertes\_array}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{\}}\CharTok{\textbackslash{}t}\SpecialStringTok{Summe maskiertes\_array.data: }\SpecialCharTok{\{}\NormalTok{maskiertes\_array}\SpecialCharTok{.}\NormalTok{data}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"maskiertes\_array \textgreater{} 222:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{maskiertes\_array }\OperatorTok{\textgreater{}} \DecValTok{222}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Summe maskiertes_array: 4764    Summe maskiertes_array.data: 9001
maskiertes_array > 222:
[-- False -- False -- True -- True -- True -- True -- True -- True -- True]
\end{verbatim}

Arithmetische und vergleichende Operationen mit maskierten Elementen
führen immer zu maskierten Ergebnissen.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"NumPy ist bei Operationen mit np.nan nicht konsistent."}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"np.nan ** 0:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\NormalTok{nan }\OperatorTok{**} \DecValTok{0}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"1 ** np.nan:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\DecValTok{1} \OperatorTok{**}\NormalTok{ np}\SpecialCharTok{.}\NormalTok{nan}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"np.nan == np.nan:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\NormalTok{nan }\OperatorTok{==}\NormalTok{ np}\SpecialCharTok{.}\NormalTok{nan}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Maskierte Arrays verhalten sich dagegen konsistent."}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"maskiertes\_array[0] ** 0:}\CharTok{\textbackslash{}t\textbackslash{}t\textbackslash{}t\textbackslash{}t\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{maskiertes\_array[}\DecValTok{0}\NormalTok{] }\OperatorTok{**} \DecValTok{0}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"1 ** maskiertes\_array[0]:}\CharTok{\textbackslash{}t\textbackslash{}t\textbackslash{}t\textbackslash{}t\textbackslash{}t}\SpecialCharTok{\{}\DecValTok{1} \OperatorTok{**}\NormalTok{ maskiertes\_array[}\DecValTok{0}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"maskiertes\_array[0] == maskiertes\_array[2]:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{maskiertes\_array[}\DecValTok{0}\NormalTok{] }\OperatorTok{==}\NormalTok{ maskiertes\_array[}\DecValTok{2}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"maskiertes\_array[0] == np.nan:}\CharTok{\textbackslash{}t\textbackslash{}t\textbackslash{}t\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{maskiertes\_array[}\DecValTok{0}\NormalTok{] }\OperatorTok{==}\NormalTok{ np}\SpecialCharTok{.}\NormalTok{nan}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
NumPy ist bei Operationen mit np.nan nicht konsistent.
np.nan ** 0:    1.0
1 ** np.nan:    1.0
np.nan == np.nan:   False

Maskierte Arrays verhalten sich dagegen konsistent.
maskiertes_array[0] ** 0:                   --
1 ** maskiertes_array[0]:                   --
maskiertes_array[0] == maskiertes_array[2]: --
maskiertes_array[0] == np.nan:              --
\end{verbatim}

Das Modul \texttt{numpy.ma} implementiert die meisten NumPy-Funktionen
(siehe \href{https://numpy.org/doc/2.1/reference/routines.ma.html}{NumPy
Dokumentation}). Funktionen, die nur einen bestimmten Wertebereich als
Eingabe akzeptieren, geben den Wert \texttt{masked} zurück, wenn Werte
außerhalb des gültigen Bereichs übergeben werden. Ein Beispiel ist die
Funktion \texttt{ma.log()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ma.log([}\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
masked_array(data=[--, --, 0.0, 0.6931471805599453],
             mask=[ True,  True, False, False],
       fill_value=1e+20)
\end{verbatim}

Auch Operation mit mehreren Arrays sind möglich. Im Ergebnis ist jedes
in der Eingabe maskierte Element ebenfalls maskiert.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(a }\OperatorTok{+}\NormalTok{ maskiertes\_array)}
\BuiltInTok{print}\NormalTok{(np.logical\_or(a, maskiertes\_array))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[-- 118 -- 354 -- 588 -- 824 -- 1058 -- 1294 -- 1528 -- 1764 -- 2000]
[-- True -- True -- True -- True -- True -- True -- True -- True -- True]
\end{verbatim}

Zusammenfassende Funktionen wie \texttt{len()} oder
\texttt{ma.unique(masked\_array)} werden auch auf die maskierten
Elemente angewendet.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ausgewählte Operationen}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{len}\NormalTok{(maskiertes\_array))}
\BuiltInTok{print}\NormalTok{(ma.unique(maskiertes\_array))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
18
[59 177 294 412 529 647 764 882 1000 --]
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-masked-arrays} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-masked-arrays}: Warnhinweis maskierte Arrays}\vspace{3mm}

Die Dokumentation warnt, dass maskierte Werte nicht zuverlässig von
Operationen ausgenommen sind. Welche Operationen dies betrifft, ist
nicht angegeben.

\begin{figure}[H]

\begin{minipage}{0.05\linewidth}
~\end{minipage}%
%
\begin{minipage}{0.90\linewidth}
``Arithmetic and comparison operations are supported by masked arrays.
As much as possible, invalid entries of a masked array are not
processed, meaning that the corresponding \texttt{data} entries
\emph{should} be the same before and after the operation.\end{minipage}%
%
\begin{minipage}{0.05\linewidth}
~\end{minipage}%
\newline
\begin{minipage}{0.05\linewidth}
~\end{minipage}%
%
\begin{minipage}{0.90\linewidth}

\begin{quote}
\textbf{Warning}

We need to stress that this behavior may not be systematic, that masked
data may be affected by the operation in some cases and therefore users
should not rely on this data remaining unchanged.''
\end{quote}

\end{minipage}%
%
\begin{minipage}{0.05\linewidth}
~\end{minipage}%
\newline
\begin{minipage}{\linewidth}
\url{https://numpy.org/doc/stable/reference/maskedarray.generic.html\#operations-on-masked-arrays}\end{minipage}%

\end{figure}%

\end{minipage}%
\end{tcolorbox}

\section{Übungen Operationen mit maskierten
Arrays}\label{uxfcbungen-operationen-mit-maskierten-arrays}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Erstellen Sie ein zweidimensionales Array (10x10) der Zahlen 1 bis
  100. Maskieren Sie alle ungeraden Werte, die ganzzahlig durch 3
  teilbar sind.
\item
  Berechnen Sie anschließend die Summe der maskierten und die Summe der
  unmaskierten Werte.
\item
  Setzen sie die Maske zurück, sodass keine Werte mehr maskiert sind.
\item
  Primzahlensieb: Maskieren Sie alle Elemente, die den Wert 1 haben oder
  Vielfache von Primzahlen sind, bis das gefüllte Array nur noch aus
  Primzahlen besteht (siehe
  \href{https://de.wikipedia.org/wiki/Sieb_des_Eratosthenes}{Sieb des
  Eratosthenes}).
\item
  Wie viele Primzahlen sind in dem Array? Welches ist die größte,
  welches die kleinste Primzahl? Sortieren Sie die Primzahlen
  absteigend.
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-masked-arrays}: Musterlösung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-masked-arrays} 

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 1. NumPy{-}Array erstellen und maskieren}
\NormalTok{maskiertes\_array }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{1}\NormalTok{, }\DecValTok{100} \OperatorTok{+} \DecValTok{1}\NormalTok{).reshape(}\DecValTok{10}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\NormalTok{maskiertes\_array }\OperatorTok{=}\NormalTok{ ma.masked\_where(condition }\OperatorTok{=}\NormalTok{ (maskiertes\_array }\OperatorTok{\%} \DecValTok{2} \OperatorTok{!=} \DecValTok{0}\NormalTok{) }\OperatorTok{\&}\NormalTok{ (maskiertes\_array }\OperatorTok{\%} \DecValTok{3} \OperatorTok{==} \DecValTok{0}\NormalTok{), a }\OperatorTok{=}\NormalTok{ maskiertes\_array)}
\BuiltInTok{print}\NormalTok{(maskiertes\_array, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[1 2 -- 4 5 6 7 8 -- 10]
 [11 12 13 14 -- 16 17 18 19 20]
 [-- 22 23 24 25 26 -- 28 29 30]
 [31 32 -- 34 35 36 37 38 -- 40]
 [41 42 43 44 -- 46 47 48 49 50]
 [-- 52 53 54 55 56 -- 58 59 60]
 [61 62 -- 64 65 66 67 68 -- 70]
 [71 72 73 74 -- 76 77 78 79 80]
 [-- 82 83 84 85 86 -- 88 89 90]
 [91 92 -- 94 95 96 97 98 -- 100]] 
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 2. Summen bilden}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Summe der maskierten Werte: }\SpecialCharTok{\{}\NormalTok{maskiertes\_array}\SpecialCharTok{.}\NormalTok{data[maskiertes\_array.mask]}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{\}}\CharTok{\textbackslash{}t}\SpecialStringTok{Summe der unmaskierten Werte: }\SpecialCharTok{\{}\NormalTok{maskiertes\_array}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Summe der maskierten Werte: 867 Summe der unmaskierten Werte: 4183
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 3. Maske zurücksetzen}
\NormalTok{maskiertes\_array.mask }\OperatorTok{=} \VariableTok{False}
\BuiltInTok{print}\NormalTok{(maskiertes\_array, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[1 2 3 4 5 6 7 8 9 10]
 [11 12 13 14 15 16 17 18 19 20]
 [21 22 23 24 25 26 27 28 29 30]
 [31 32 33 34 35 36 37 38 39 40]
 [41 42 43 44 45 46 47 48 49 50]
 [51 52 53 54 55 56 57 58 59 60]
 [61 62 63 64 65 66 67 68 69 70]
 [71 72 73 74 75 76 77 78 79 80]
 [81 82 83 84 85 86 87 88 89 90]
 [91 92 93 94 95 96 97 98 99 100]] 
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 4. Primzahlsieb}
\CommentTok{\#\# 1}
\NormalTok{i }\OperatorTok{=} \DecValTok{1}
\NormalTok{bedingung1 }\OperatorTok{=}\NormalTok{ maskiertes\_array }\OperatorTok{==}\NormalTok{ i}
\NormalTok{sieb }\OperatorTok{=}\NormalTok{ ma.masked\_where(bedingung1, maskiertes\_array)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"i = }\SpecialCharTok{\{}\NormalTok{i}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{sieb}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\#\# 2}
\NormalTok{i }\OperatorTok{=} \DecValTok{2}
\NormalTok{bedingung2 }\OperatorTok{=}\NormalTok{ (maskiertes\_array }\OperatorTok{\textgreater{}}\NormalTok{ i) }\OperatorTok{\&}\NormalTok{ (maskiertes\_array }\OperatorTok{\%}\NormalTok{ i }\OperatorTok{==} \DecValTok{0}\NormalTok{)}
\NormalTok{sieb }\OperatorTok{=}\NormalTok{ ma.masked\_where(bedingung1 }\OperatorTok{|}\NormalTok{ bedingung2, maskiertes\_array)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"zusätzlich Vielfache von }\SpecialCharTok{\{}\NormalTok{i}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{sieb}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\#\# 3}
\NormalTok{i }\OperatorTok{=} \DecValTok{3}
\NormalTok{bedingung3 }\OperatorTok{=}\NormalTok{ (maskiertes\_array }\OperatorTok{\textgreater{}}\NormalTok{ i) }\OperatorTok{\&}\NormalTok{ (maskiertes\_array }\OperatorTok{\%}\NormalTok{ i }\OperatorTok{==} \DecValTok{0}\NormalTok{)}
\NormalTok{sieb }\OperatorTok{=}\NormalTok{ ma.masked\_where(bedingung1 }\OperatorTok{|}\NormalTok{ bedingung2 }\OperatorTok{|}\NormalTok{ bedingung3, maskiertes\_array)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"zusätzlich Vielfache von }\SpecialCharTok{\{}\NormalTok{i}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{sieb}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\#\# 5}
\NormalTok{i }\OperatorTok{=} \DecValTok{5}
\NormalTok{bedingung5 }\OperatorTok{=}\NormalTok{ (maskiertes\_array }\OperatorTok{\textgreater{}}\NormalTok{ i) }\OperatorTok{\&}\NormalTok{ (maskiertes\_array }\OperatorTok{\%}\NormalTok{ i }\OperatorTok{==} \DecValTok{0}\NormalTok{)}
\NormalTok{sieb }\OperatorTok{=}\NormalTok{ ma.masked\_where(bedingung1 }\OperatorTok{|}\NormalTok{ bedingung2 }\OperatorTok{|}\NormalTok{ bedingung3 }\OperatorTok{|}\NormalTok{ bedingung5, maskiertes\_array)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"zusätzlich Vielfache von }\SpecialCharTok{\{}\NormalTok{i}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{sieb}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\#\# 7}
\NormalTok{i }\OperatorTok{=} \DecValTok{7}
\NormalTok{bedingung7 }\OperatorTok{=}\NormalTok{ (maskiertes\_array }\OperatorTok{\textgreater{}}\NormalTok{ i) }\OperatorTok{\&}\NormalTok{ (maskiertes\_array }\OperatorTok{\%}\NormalTok{ i }\OperatorTok{==} \DecValTok{0}\NormalTok{)}
\NormalTok{sieb }\OperatorTok{=}\NormalTok{ ma.masked\_where(bedingung1 }\OperatorTok{|}\NormalTok{ bedingung2 }\OperatorTok{|}\NormalTok{ bedingung3 }\OperatorTok{|}\NormalTok{ bedingung5 }\OperatorTok{|}\NormalTok{ bedingung7, maskiertes\_array)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"zusätzlich Vielfache von }\SpecialCharTok{\{}\NormalTok{i}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{sieb}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
i = 1
[[-- 2 3 4 5 6 7 8 9 10]
 [11 12 13 14 15 16 17 18 19 20]
 [21 22 23 24 25 26 27 28 29 30]
 [31 32 33 34 35 36 37 38 39 40]
 [41 42 43 44 45 46 47 48 49 50]
 [51 52 53 54 55 56 57 58 59 60]
 [61 62 63 64 65 66 67 68 69 70]
 [71 72 73 74 75 76 77 78 79 80]
 [81 82 83 84 85 86 87 88 89 90]
 [91 92 93 94 95 96 97 98 99 100]]

zusätzlich Vielfache von 2
[[-- 2 3 -- 5 -- 7 -- 9 --]
 [11 -- 13 -- 15 -- 17 -- 19 --]
 [21 -- 23 -- 25 -- 27 -- 29 --]
 [31 -- 33 -- 35 -- 37 -- 39 --]
 [41 -- 43 -- 45 -- 47 -- 49 --]
 [51 -- 53 -- 55 -- 57 -- 59 --]
 [61 -- 63 -- 65 -- 67 -- 69 --]
 [71 -- 73 -- 75 -- 77 -- 79 --]
 [81 -- 83 -- 85 -- 87 -- 89 --]
 [91 -- 93 -- 95 -- 97 -- 99 --]]

zusätzlich Vielfache von 3
[[-- 2 3 -- 5 -- 7 -- -- --]
 [11 -- 13 -- -- -- 17 -- 19 --]
 [-- -- 23 -- 25 -- -- -- 29 --]
 [31 -- -- -- 35 -- 37 -- -- --]
 [41 -- 43 -- -- -- 47 -- 49 --]
 [-- -- 53 -- 55 -- -- -- 59 --]
 [61 -- -- -- 65 -- 67 -- -- --]
 [71 -- 73 -- -- -- 77 -- 79 --]
 [-- -- 83 -- 85 -- -- -- 89 --]
 [91 -- -- -- 95 -- 97 -- -- --]]

zusätzlich Vielfache von 5
[[-- 2 3 -- 5 -- 7 -- -- --]
 [11 -- 13 -- -- -- 17 -- 19 --]
 [-- -- 23 -- -- -- -- -- 29 --]
 [31 -- -- -- -- -- 37 -- -- --]
 [41 -- 43 -- -- -- 47 -- 49 --]
 [-- -- 53 -- -- -- -- -- 59 --]
 [61 -- -- -- -- -- 67 -- -- --]
 [71 -- 73 -- -- -- 77 -- 79 --]
 [-- -- 83 -- -- -- -- -- 89 --]
 [91 -- -- -- -- -- 97 -- -- --]]

zusätzlich Vielfache von 7
[[-- 2 3 -- 5 -- 7 -- -- --]
 [11 -- 13 -- -- -- 17 -- 19 --]
 [-- -- 23 -- -- -- -- -- 29 --]
 [31 -- -- -- -- -- 37 -- -- --]
 [41 -- 43 -- -- -- 47 -- -- --]
 [-- -- 53 -- -- -- -- -- 59 --]
 [61 -- -- -- -- -- 67 -- -- --]
 [71 -- 73 -- -- -- -- -- 79 --]
 [-- -- 83 -- -- -- -- -- 89 --]
 [-- -- -- -- -- -- 97 -- -- --]]
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 5. verschiedene Aufgaben}
\CommentTok{\#\# Wie viele Primzahlen sind in dem Array?}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Anzahl Primzahlen:"}\NormalTok{, sieb.size }\OperatorTok{{-}}\NormalTok{ sieb.mask.}\BuiltInTok{sum}\NormalTok{())}

\CommentTok{\#\# Welches ist die größte, welches die kleinste Primzahl?}
\BuiltInTok{print}\NormalTok{(sieb.}\BuiltInTok{max}\NormalTok{(), sieb.}\BuiltInTok{min}\NormalTok{())}

\CommentTok{\#\# Primzahlen absteigend sortiert}
\CommentTok{\#\#\# ma.sort() sortiert nur aufsteigend, deshalb:}
\CommentTok{\#\#\# Übergabe des eindimensionalen arrays sieb.flatten() in umgekehrter Reihenfolge [::{-}1]}
\CommentTok{\#\#\# anschließend umformen in 2D{-}Array}
\CommentTok{\#\#\# endwith = False missing values are treated as smallest values}
\BuiltInTok{print}\NormalTok{(ma.sort(sieb.flatten(), endwith }\OperatorTok{=} \VariableTok{False}\NormalTok{)[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{].reshape(sieb.shape))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Anzahl Primzahlen: 25
97 2
[[97 89 83 79 73 71 67 61 59 53]
 [47 43 41 37 31 29 23 19 17 13]
 [11 7 5 3 2 -- -- -- -- --]
 [-- -- -- -- -- -- -- -- -- --]
 [-- -- -- -- -- -- -- -- -- --]
 [-- -- -- -- -- -- -- -- -- --]
 [-- -- -- -- -- -- -- -- -- --]
 [-- -- -- -- -- -- -- -- -- --]
 [-- -- -- -- -- -- -- -- -- --]
 [-- -- -- -- -- -- -- -- -- --]]
\end{verbatim}

\end{tcolorbox}

\chapter{Wissenschaftliche Dateiformate}\label{sec-spezialformate}

Wissenschaftliche Datensätze können extrem groß sein. Beispielsweise hat
das Kernforschungszentrum CERN im November 2018 15,8 Petabyte Daten
aufgezeichnet
(\href{https://information-technology.web.cern.ch/sites/default/files/CERNDataCentre_KeyInformation_July2022_V3.pdf}{Key
Facts and Figures - CERN Data Centre}). Für den Austausch großer
Datenmengen wurden Datenformate wie das Hierarchical Data Format (HDF)
und Network Common Data Format (netCDF) entwickelt. Diese erlauben es
unter anderem, Datensätze direkt vom Massenspeicher des Computers
auszulesen, sodass eine mögliche Begrenzung durch den Arbeitsspeicher
vermieden wird.

Im Folgenden werden knapp die Grundfunktionen für das Arbeiten mit HDF5-
und netCDF4-Dateien vorgestellt. Detailliertere Informationen finden Sie
in der jeweiligen Dokumentation.

\section{HDF5}\label{hdf5}

HDF5 bedeutet Hierarchical Data Format Version 5. HDF organisiert Daten
in einer Ordnerstruktur, die mit der Ordnerstruktur eines Computers
vergleichbar ist, und enthält beschreibende Metadaten, weshalb HDF als
selbstbeschreibend gilt. Die HDF-Verzeichnisstruktur wird mit bestimmten
Begriffen beschrieben.

\begin{itemize}
\item
  Gruppen oder \texttt{groups} bezeichnen die Verzeichnisse
  (Unterordner) innerhalb der HDF-Datei. \texttt{groups} können weitere
  Gruppen oder \texttt{datasets} enthalten.
\item
  Dateien oder \texttt{datasets} entsprechen einzelnen Dateien.
\end{itemize}

\begin{figure}[H]

{\centering \includegraphics[width=0.8\linewidth,height=\textheight,keepaspectratio]{books/m-einlesen-strukturierter-datensaetze/skript/00-bilder/hdf5_structure4-by-neonscience.org.jpg}

}

\caption{HDF5-Verzeichnisstruktur}

\end{figure}%

An illsturation of a HDF\ldots and associated metadata von U.S National
Science Foundation's National Ecological Observatory Network (NEON) ist
abrufbar unter
\url{https://www.neonscience.org/resources/learning-hub/tutorials/about-hdf5}.

~

In Python können die Pakete \href{https://www.pytables.org/}{PyTables},
das von Pandas verwendet wird, und h5py mit HDF5 umgehen. Das Einlesen
von HDF5-Dateien funktioniert ähnlich wie das Einlesen von Dateien in
der Pythonbasis: Der Zugriff auf die Datei erfolgt mit einem
Dateiobjekt, über das verschiedene Methoden zum Lesen und Schreiben
bereitgestellt werden. Abschließend wird das Dateiobjekt wieder
geschlossen.

Die Integration des Pakets PyTables in Pandas ist auf die Verwendung von
Pandas-Objekten ausgelegt. Es wird eine spezifische Dateistruktur
genutzt und erwartet. Anders aufgebaute HDF5-Dateien können nicht
eingelesen werden. Deshalb wird das Paket hier nur kurz vorgestellt.
(\href{https://stackoverflow.com/questions/71388502/read-hdf5-file-created-with-h5py-using-pandas}{Thema
auf stackoverflow}, \href{https://stackoverflow.com/a/33644128}{Antwort
von Kevin S unter CC-BY-SA 3.0})

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-hdfdata} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-hdfdata}: Datensatz}\vspace{3mm}

In diesem Abschnitt wird ein Teil des Datensatzes IceBridge ATM L1B
Elevation and Return Strength, Version 2 genutzt
(\href{https://nsidc.org/data/ilatm1b/versions/2\#anchor-data-access-tools}{kostenlose
Registrierung bei NASA Earth erforderlich}). Das
\href{https://nsidc.org/sites/default/files/ilatm1b-v002-userguide_2.pdf}{Handbuch
ist hier verfügbar}. Der Datensatz enhält flugzeugbasierte
Lasermessungen für die Höhe des Eisschildes in der Arktis und Antarktis
mittels des NASA Airborne Topographic Mapper (ATM). ATM hat eine
Abtastrate von 3 bis 5 kHz. Jede Datei enthält die Daten von einigen
Minuten Flugdauer. Das geografische Referenzsystem ist das World
Geodetic System 1984 (WGS 84)

Die Dateien sind nach dem Schema ILATM1B\_YYYYMMDD\_HHMMSS.ATM4BT4.h5
benannt:

\begin{itemize}
\item
  Datensatz-ID\_
\item
  Jahr, Monat, Tag der Messung\_
\item
  Zeitpunkt am Beginn der Messung in Stunden, Minuten, Sekunden\_
\item
  Instrumenten-ID (fünfstellig) und Messwinkel (T2 = 15 Grad, T3 = 23
  Grad, T4 = 30 Grad).
\item
  xxx Dateityp (.h5 = HDF5, h5.xml = zusätzliche Metadatendatei)
\end{itemize}

Studinger, M. 2013, updated 2020. IceBridge ATM L1B Elevation and Return
Strength, Version 2. {[}Indicate subset used{]}. Boulder, Colorado USA.
NASA National Snow and Ice Data Center Distributed Active Archive
Center. https://doi.org/10.5067/19SIM5TXKPGT. {[}05.12.2024{]}

\end{minipage}%
\end{tcolorbox}

\subsection{PyTables}\label{pytables}

Das Paket PyTables wird mit dem Befehl \texttt{pip\ install\ tables}
installiert. Die Funktionen des Pakets sind in Pandas integriert. Der
Zugriff auf HDF-Dateien wird in Pandas über ein
\href{https://pandas.pydata.org/docs/user_guide/io.html\#hdf5-pytables}{HDFStore-Objekt}
bereitgestellt. Hierrüber können HDF-Dateien gelesen und geschrieben
werden. DAs HDFStore-Objekt entspricht dem Wurzelverzeichnis der
strukturierten Datei. Die Funktion \texttt{pd.HDFStore(path,\ mode)}
nimmt als Argumente den Dateipfad \texttt{path} und den Zugriffsmodus
\texttt{mode} entgegen.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.1200}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.8800}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Zugriffsmodus
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Beschreibung
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
`a' & Standardmodus append: öffnet die Datei im Lese- und Schreibmodus.
Falls die Datei nicht vorhanden ist, wird diese erstellt. \\
`w' & Schreibzugriff, Erstellen einer neuer Datei, Überschreiben einer
bestehenden, gleichnamigen Datei \\
`r' & Lesezugriff \\
`r+' & Lese- und Schreibzugriff wie `a', Datei muss aber existieren. \\
\end{longtable}

~

Über das HDFStore-Objekt kann der Inhalt der Datei ausgelesen werden,
sofern das Format kompatibel ist.

\begin{itemize}
\item
  Die Methode \texttt{hdf.info()} gibt Informationen zum Dateiobjekt
  aus.
\item
  Die Methode
  \texttt{hdf.keys(include\ =\ \textquotesingle{}pandas\textquotesingle{})}
  gibt standardmäßig die Schlüssel der Pandas-Objekte im
  Wurzelverzeichnis zurück. Mit dem Argument
  \texttt{hdf.keys(include\ =\ \textquotesingle{}native\textquotesingle{})}
  sollten auch native HDF5-Objekte ausgegeben werden können, sofern die
  HDF5-Datei kompatibel ist.
\item
  Der Zugriff auf ausgewählte Schlüssel erfolgt mit der Methode
  \texttt{hdf.get(\textquotesingle{}key\textquotesingle{})} oder durch
  \texttt{hdf{[}\textquotesingle{}key\textquotesingle{}{]}}.
\item
  Mit der Methode \texttt{hdf.close()} wird das HDFStore-Objekt wieder
  geschlossen.
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-HDFStore}: inkompatible HDF5-Datei}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-HDFStore} 

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Datei öffnen}
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/ILATM1B\_20191120\_041200.ATM6AT6.h5"}
\NormalTok{hdf }\OperatorTok{=}\NormalTok{ pd.HDFStore(dateipfad, mode }\OperatorTok{=} \StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(hdf.info(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# parameter include: str, default ‘pandas’.  When ‘pandas’ return pandas objects. When ‘native’ return native HDF5 Table objects.}
\BuiltInTok{print}\NormalTok{(hdf.keys(include }\OperatorTok{=} \StringTok{\textquotesingle{}native\textquotesingle{}}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{) }
\BuiltInTok{print}\NormalTok{(hdf.keys(include }\OperatorTok{=} \StringTok{\textquotesingle{}pandas\textquotesingle{}}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{) }

\BuiltInTok{print}\NormalTok{(hdf.groups(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# Test hdf.get()}
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  elevation }\OperatorTok{=}\NormalTok{ hdf.get(}\StringTok{\textquotesingle{}elevation\textquotesingle{}}\NormalTok{)}
  \BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(elevation))}
\ControlFlowTok{except} \PreprocessorTok{TypeError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Die Eingabe führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}
\ControlFlowTok{else}\NormalTok{:}
\NormalTok{  elevation }\OperatorTok{=}\NormalTok{ hdf.get(}\StringTok{\textquotesingle{}elevation\textquotesingle{}}\NormalTok{)}
  \BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(elevation))}

\CommentTok{\# Test pd.read\_hdf()}
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  elevation }\OperatorTok{=}\NormalTok{ pd.read\_hdf(path\_or\_buf }\OperatorTok{=}\NormalTok{ hdf, key }\OperatorTok{=} \StringTok{\textquotesingle{}elevation\textquotesingle{}}\NormalTok{)}
  \BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(elevation))}
\ControlFlowTok{except} \PreprocessorTok{TypeError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Die Eingabe führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}
\ControlFlowTok{else}\NormalTok{:}
\NormalTok{  elevation }\OperatorTok{=}\NormalTok{ pd.read\_hdf(path\_or\_buf }\OperatorTok{=}\NormalTok{ hdf, key }\OperatorTok{=} \StringTok{\textquotesingle{}elevation\textquotesingle{}}\NormalTok{)}
  \BuiltInTok{print}\NormalTok{(}\BuiltInTok{type}\NormalTok{(elevation))}

\CommentTok{\# HDFStore{-}Objekt schließen}
\NormalTok{hdf.close()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.io.pytables.HDFStore'>
File path: 01-daten/ILATM1B_20191120_041200.ATM6AT6.h5
Empty 

[] 

[] 

[] 

Die Eingabe führt zu der Fehlermeldung:
 cannot create a storer if the object is not existing nor a value are passed
Die Eingabe führt zu der Fehlermeldung:
 cannot create a storer if the object is not existing nor a value are passed
\end{verbatim}

\end{tcolorbox}

Um die Funktionen zu demonstrieren, wird mit eine HDF5-Datei erstellt.
Dazu wird ein HDFStore-Objekt im Modus \texttt{append} angelegt und mit
der Methode \texttt{hdf.put(key,\ value,\ format)} ein DataFrame
gespeichert.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# HDF5{-}Datei anlegen}
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}Spalte1\textquotesingle{}}\NormalTok{: [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], }\StringTok{\textquotesingle{}Spalte2\textquotesingle{}}\NormalTok{: [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]\})}
\NormalTok{hdf }\OperatorTok{=}\NormalTok{ pd.HDFStore(}\StringTok{"01{-}daten/hdf\_file\_demo.h5"}\NormalTok{, mode }\OperatorTok{=} \StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{)}
\NormalTok{hdf.put(}\StringTok{\textquotesingle{}daten\textquotesingle{}}\NormalTok{, df, }\BuiltInTok{format} \OperatorTok{=} \StringTok{\textquotesingle{}table\textquotesingle{}}\NormalTok{)}

\NormalTok{hdf.close()}

\CommentTok{\# HDF5{-}Datei einlesen}
\NormalTok{hdf2 }\OperatorTok{=}\NormalTok{ pd.HDFStore(}\StringTok{"01{-}daten/hdf\_file\_demo.h5"}\NormalTok{, mode }\OperatorTok{=} \StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(hdf2.info(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(hdf2.keys(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{df2 }\OperatorTok{=}\NormalTok{ hdf2.get(key }\OperatorTok{=} \StringTok{"/daten"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(df2)}

\NormalTok{hdf2.close()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.io.pytables.HDFStore'>
File path: 01-daten/hdf_file_demo.h5
/daten            frame_table  (typ->appendable,nrows->3,ncols->2,indexers->[index],dc->[]) 

['/daten'] 

   Spalte1  Spalte2
0        1        4
1        2        5
2        3        6
\end{verbatim}

Eine Liste verfügbarer Funktionen findet sich
\href{https://pandas.pydata.org/docs/reference/io.html\#hdfstore-pytables-hdf5}{in
der Dokumentation}.\\
(\href{https://www.numpyninja.com/post/hdf5-file-format-with-pandas}{Numpy
Ninja})

\subsection{h5py}\label{h5py}

Das Paket h5py wird mit dem Befehl \texttt{pip\ install\ h5py}
installiert. Das Modul h5py funktioniert ählich wie PyTables. Der
Zugriff auf eine HDF5-Datei erfolgt über ein Dateiobjekt, das mit der
Funktion \texttt{h5py.File(Dateipfad,\ Zugriffsmodus)} erzeugt wird
(\href{https://docs.h5py.org/en/latest/high/file.html\#file}{siehe h5py
Dokumentation}).

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.1200}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.8800}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Zugriffsmodus
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Beschreibung
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
r & Lesemodus, Datei muss existieren (default) \\
r+ & Lese- und Schreibmodus, Datei muss existieren \\
w & Datei erstellen, bestehende Datei kürzen \\
w- or x & Datei erstellen, abbrechen wenn Datei bereits besteht \\
a & Lesen / Schreiben, wenn die Datei besteht, andernfalls Datei
erstellen \\
\end{longtable}

~

Über das Dateiobjekt erfolgt der Zugriff auf Gruppen und Datensätze.
Gruppen sind wie dictionaries aufgebaut, der Zugriff erfolgt also über
Schlüssel-Wert-Paare (key: value). Die Schlüssel sind die Namen der
Elemente in einer Gruppe, die Werte sind die Elemente selbst (Gruppen
oder Datasets).

``The most fundamental thing to remember when using h5py is:

\textbf{Groups work like dictionaries, and datasets work like NumPy
arrays}''
(\href{https://docs.h5py.org/en/latest/quick.html}{Dokumentation h5py},
Hervorhebung im Original)

~

Die Gruppennamen können mit der Methode Dateiobjekt.keys() abgerufen
werden.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ h5py}
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/ILATM1B\_20191120\_041200.ATM6AT6.h5"}
\NormalTok{hdf }\OperatorTok{=}\NormalTok{ h5py.File(dateipfad, mode }\OperatorTok{=} \StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(hdf, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{list}\NormalTok{(hdf.keys()))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<HDF5 file "ILATM1B_20191120_041200.ATM6AT6.h5" (mode r)> 

['elevation', 'latitude', 'longitude', 'ancillary_data', 'instrument_parameters']
\end{verbatim}

Anhand der Schlüssel kann mit der Funktion
\texttt{isinstance(item,\ type)} geprüft werden, ob es sich um Gruppen
\texttt{h5py.Group} oder Datensätze \texttt{h5py.Dataset} handelt.
Datasets besitzen wie NumPy-Arrays die Attribute \texttt{dtype},
\texttt{shape}, \texttt{size}, \texttt{ndim} (und \texttt{nbytes}).

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ key }\KeywordTok{in} \BuiltInTok{list}\NormalTok{(hdf.keys()):}
  
  \BuiltInTok{object} \OperatorTok{=}\NormalTok{ hdf[key]}
  \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Schlüssel:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{key}\SpecialCharTok{\}}\SpecialStringTok{ ist ein }\SpecialCharTok{\{}\BuiltInTok{type}\NormalTok{(}\BuiltInTok{object}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
  
  \ControlFlowTok{if} \BuiltInTok{isinstance}\NormalTok{(hdf[key], h5py.Dataset):}
    
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}t}\SpecialStringTok{Datentyp: }\SpecialCharTok{\{}\BuiltInTok{object}\SpecialCharTok{.}\NormalTok{dtype}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
          \SpecialStringTok{f"}\CharTok{\textbackslash{}t}\SpecialStringTok{Struktur: }\SpecialCharTok{\{}\BuiltInTok{object}\SpecialCharTok{.}\NormalTok{shape}\SpecialCharTok{\}}\CharTok{\textbackslash{}t}\SpecialStringTok{ Dimensionen: }\SpecialCharTok{\{}\BuiltInTok{object}\SpecialCharTok{.}\NormalTok{ndim}\SpecialCharTok{\}}\CharTok{\textbackslash{}t}\SpecialStringTok{Anzahl Elemente: }\SpecialCharTok{\{}\BuiltInTok{object}\SpecialCharTok{.}\NormalTok{size}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
  
  \ControlFlowTok{elif} \BuiltInTok{isinstance}\NormalTok{(hdf[key], h5py.Group):}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}t}\SpecialStringTok{Die Gruppe }\SpecialCharTok{\{}\NormalTok{key}\SpecialCharTok{\}}\SpecialStringTok{ enthält die Objekte:}\CharTok{\textbackslash{}n\textbackslash{}t}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{hdf[key]}\SpecialCharTok{.}\NormalTok{keys()}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Schlüssel:  elevation ist ein <class 'h5py._hl.dataset.Dataset'>
    Datentyp: float32
    Struktur: (327285,)  Dimensionen: 1 Anzahl Elemente: 327285

Schlüssel:  latitude ist ein <class 'h5py._hl.dataset.Dataset'>
    Datentyp: float64
    Struktur: (327285,)  Dimensionen: 1 Anzahl Elemente: 327285

Schlüssel:  longitude ist ein <class 'h5py._hl.dataset.Dataset'>
    Datentyp: float64
    Struktur: (327285,)  Dimensionen: 1 Anzahl Elemente: 327285

Schlüssel:  ancillary_data ist ein <class 'h5py._hl.group.Group'>
    Die Gruppe ancillary_data enthält die Objekte:
     <KeysViewHDF5 ['header_binary', 'header_text', 'max_latitude', 'max_longitude', 'min_latitude', 'min_longitude', 'reference_frame']>

Schlüssel:  instrument_parameters ist ein <class 'h5py._hl.group.Group'>
    Die Gruppe instrument_parameters enthält die Objekte:
     <KeysViewHDF5 ['azimuth', 'gps_pdop', 'pitch', 'pulse_width', 'rcv_sigstr', 'rel_time', 'roll', 'time_hhmmss', 'xmt_sigstr']>
\end{verbatim}

Die Objekte \texttt{elevation}, \texttt{latitude} und \texttt{longitude}
sind Datensätze. Die Objekte \texttt{ancillary\_data} und
\texttt{instrument\_parameters} sind Gruppen. Der Zugriff innerhalb von
Gruppen erfolgt wie bei der Eingabe eines Dateipfads:
\texttt{Dateiobjekt{[}\textquotesingle{}Gruppe/key\textquotesingle{}{]}}.

Um mit Datasets zu arbeiten muss eine Kopie z. B. durch Slicing erstellt
werden.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(hdf[}\StringTok{\textquotesingle{}elevation\textquotesingle{}}\NormalTok{] }\OperatorTok{{-}} \DecValTok{1000}\NormalTok{)}
\ControlFlowTok{except} \PreprocessorTok{TypeError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Der Direktzugriff führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}

\CommentTok{\# Mit einer Kopie kann gearbeitet werden}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Mit einer Kopie geht es:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(hdf[}\StringTok{\textquotesingle{}elevation\textquotesingle{}}\NormalTok{][:] }\OperatorTok{{-}} \DecValTok{1000}\NormalTok{)}

\CommentTok{\# Mit Indexbereichen ebenso}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Ebenso mit ausgewählten Indexbereichen:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(hdf[}\StringTok{\textquotesingle{}elevation\textquotesingle{}}\NormalTok{][}\DecValTok{0}\NormalTok{:}\DecValTok{10}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der Direktzugriff führt zu der Fehlermeldung:
 unsupported operand type(s) for -: 'Dataset' and 'int'

Mit einer Kopie geht es:
[178.32202 178.34302 178.44495 ... 129.38794 128.62195 128.18799]

Ebenso mit ausgewählten Indexbereichen:
[1178.322 1178.343 1178.445 1178.351 1178.363 1178.389 1178.396 1178.393
 1178.274 1178.321]
\end{verbatim}

Am Ende wird das Dateiobjekt geschlossen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hdf.close()}
\end{Highlighting}
\end{Shaded}

\subsection{Übung Zugriff auf
H5P-Datasets}\label{uxfcbung-zugriff-auf-h5p-datasets}

\textbf{Berechnen Sie aus der relativen Zeit
\texttt{hdf{[}\textquotesingle{}instrument\_parameters/rel\_time\textquotesingle{}{]}}
im Format `hhmmss' und dem im Dateinamen enthaltenen Beginn der Messung
die tatsächliche Zeit der Messung.} Der Dateipfad lautet:
`01-daten/ILATM1B\_20191120\_041200.ATM6AT6.h5'.\\
\emph{Hinweis: Die relative Zeit liegt in Tausendstelsekunden aufgelöst
vor. Aufgrund der hohen Abtastrate von ATM kommen Zeiten in der Regel
mehrfach vor.}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-Messzeit}: Musterlösung absolute Zeit berechnen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-Messzeit} 

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# HDF{-}Datei öffnen}
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/ILATM1B\_20191120\_041200.ATM6AT6.h5"}
\NormalTok{hdf }\OperatorTok{=}\NormalTok{ h5py.File(dateipfad, mode }\OperatorTok{=} \StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}

\NormalTok{zeitstempel }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\BuiltInTok{str}\NormalTok{(hdf)[}\DecValTok{29}\NormalTok{:}\DecValTok{35}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Beginn der Messungen: }\SpecialCharTok{\{}\NormalTok{zeitstempel}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{rel\_time }\OperatorTok{=}\NormalTok{ hdf[}\StringTok{\textquotesingle{}instrument\_parameters/rel\_time\textquotesingle{}}\NormalTok{][:]}
\NormalTok{abs\_time }\OperatorTok{=}\NormalTok{ rel\_time }\OperatorTok{+}\NormalTok{ zeitstempel}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"rel\_time[{-}5:]:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{rel\_time[}\OperatorTok{{-}}\DecValTok{5}\NormalTok{:]}\SpecialCharTok{\}}\CharTok{\textbackslash{}n\textbackslash{}n}\SpecialStringTok{abs\_time[{-}5:]:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{abs\_time[}\OperatorTok{{-}}\DecValTok{5}\NormalTok{:]}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# HDF{-}Datei schließen}
\NormalTok{hdf.close()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Beginn der Messungen: 41200

rel_time[-5:]:
[59.986 59.986 59.987 59.989 59.99 ]

abs_time[-5:]:
[41259.984 41259.984 41259.99  41259.99  41259.99 ]
\end{verbatim}

\end{tcolorbox}

\subsubsection{HDF5 Dateien schreiben}\label{hdf5-dateien-schreiben}

Um Objekte in eine HDF5-Datei zu schreiben, muss diese im Schreibmodus
geöffnet werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hdf\_neu }\OperatorTok{=}\NormalTok{ h5py.File(}\StringTok{\textquotesingle{}01{-}daten/hdf\_neu.h5\textquotesingle{}}\NormalTok{, mode }\OperatorTok{=} \StringTok{\textquotesingle{}w\textquotesingle{}}\NormalTok{)}
\NormalTok{hdf\_neu[}\StringTok{\textquotesingle{}abs\_time\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ abs\_time}
\NormalTok{hdf\_neu.close()}

\CommentTok{\# Kontrolle}
\NormalTok{hdf\_neu }\OperatorTok{=}\NormalTok{ h5py.File(}\StringTok{\textquotesingle{}01{-}daten/hdf\_neu.h5\textquotesingle{}}\NormalTok{, mode }\OperatorTok{=} \StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(hdf\_neu.keys())}
\NormalTok{hdf\_neu.close()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<KeysViewHDF5 ['abs_time']>
\end{verbatim}

(\href{https://docs.h5py.org/en/latest/quick.html}{Dokumentation h5py})

\section{netCDF4}\label{netcdf4}

Das Paket netCDF4 (Network Common Data Format Version 4) wird mit
\texttt{pip\ install\ netCDF4} installiert. netCDF4 basiert auf HDF5,
verwendet aber eine eigene Terminologie. Der Zugriff auf eine netCDF4
Datei erfolgt über das Dataset-Objekt, das der Wurzelgruppe entspricht.
Eine netCDF-Datei bzw. das Dataset-Objekt besteht aus:

\begin{itemize}
\item
  Gruppen (groups): Gruppen sind Unterverzeichnisse des Dataset-Objekts
  und können Variablen, Dimensionen, Attribute und weitere Gruppen
  enthalten.
\item
  Variablen (variables): Variablen entsprechen Datensätzen bzw.
  NumPy-Arrays.
\item
  Dimensionen (dimensions): Dimensionen beschreiben Eigenschaften der
  Variablen wie Name (name), Größe (size), Gruppenzugehörigkeit (group)
\item
  Attribute (attributes): Attribute beschreiben entweder das gesamte
  Dataset (globale Attribute) oder einzelne Variablen. Attribute
  speichern die Metadaten.

  \begin{itemize}
  \item
    \texttt{Dataset.description\ =\ \textquotesingle{}Beschreibung\ des\ Datensatzes\textquotesingle{}}
  \item
    \texttt{Dataset.history\ =\ \textquotesingle{}Zeitpunkt\ der\ Erstellung\textquotesingle{}}
  \item
    \texttt{Dataset.source\ =\ \textquotesingle{}Quelle\textquotesingle{}}
  \item
    \texttt{Dataset.units\ =\ \textquotesingle{}Beschreibung\ der\ Messeinheit\textquotesingle{}}
  \item
    \texttt{Dataset.calender\ =\ \textquotesingle{}gregorianischer\ Kalender\textquotesingle{}}
  \end{itemize}
\end{itemize}

Diese Elemente sind als Dictionary aufgebaut und erlauben den Zugriff
über Schlüssel-Wert-Paare.

\phantomsection\label{wrn-netcdfdata}
\section{Datensatz}\label{datensatz-2}

In diesem Abschnitt wird ein Datensatz der NASA zur Blitzdichte (Anzahl
Blitze pro Quadratkilometer) verwendet
\href{https://www.earthdata.nasa.gov/data/catalog/ghrc-daac-lohrfc-2.3.2015}{kostenlose
Registrierung bei NASA Earth erforderlich}. Die netCDF4-Datei enthält
verschiedene Datensätze (Variablen), die mit satellitengestützten
Messinstrumenten erstellt wurden. Blitze im Bereich von +/- 38 Grad um
den Äquator wurden mit dem Lightning Imaging Sensor (LIS) des Satelliten
der Tropical Rainfall Measuring Mission (TRMM) gemessen. In höheren und
niedrigeren Breitengraden wurden Blitze mit dem Optical Transient
Detector (OTD) auf Orbview-1 gemessen. Die Daten liegen in einer
Auflösung von 0.5 Grad vor.
(\href{https://www.earthdata.nasa.gov/data/catalog/ghrc-daac-lolrac-2.3.2015}{Datensatzdokumentation},
\href{https://refubium.fu-berlin.de/handle/fub188/43384}{Poetzsch 2021}:
182-183)

Die Datensätze folgen dem Namensschema HRFC\_COM\_FR

\begin{itemize}
\item
  HRFC = High Resolution Full Climatology
\item
  COM = Kombination beider Messinstrumente {[}LIS, OTD{]}
\item
  FR = Flash Rates {[}RF = Raw Flash Rates, SF = Scaled Flash Rates{]}
\end{itemize}

LIS/OTD 0.5 Degree High Resolution Full Climatology (HRFC) V2.3.2015 von
Global Hydrometeorology Resource Center DAAC (GHRC DAAC)

DOI https://doi.org/10.5067/LIS/LIS-OTD/DATA302

~

Ein Dataset-Objekt wird mit der Funktion
\texttt{nc.Dataset(filename,\ mode)} geöffnet. Mit dem Argument
\texttt{filename} wird der Dateipfad übergeben. Im Argument
\texttt{mode} wird der Zugriffsmodus festgelegt.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.1200}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.8800}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Zugriffsmodus
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Beschreibung
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
r & Lesemodus, Datei muss existieren (default) \\
r+ & Update-Modus, Datei wird ggf. angelegt und kann gelesen und
geschrieben werden \\
w & Schreibmodus Datei erstellen, bestehende Datei überschreiben \\
x & Datei erstellen, abbrechen wenn Datei bereits besteht \\
a & Anhängen: Datei wird ggf. angelegt, neue Inhalte werden am Ende der
Datei angehängt, bestehende Inhalte werden dabei nicht gelöscht. \\
\end{longtable}

~

netCDF-Dateien können verschiedene Versionen haben (NETCDF3\_CLASSIC,
NETCDF3\_64BIT\_OFFSET, NETCDF3\_64BIT\_DATA, NETCDF4\_CLASSIC,
NETCDF4). Um die Version abzurufen, kann das Attribut
\texttt{cdf.data\_model} abgerufen werden.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ netCDF4 }\ImportTok{as}\NormalTok{ nc}

\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/LISOTD\_HRFC\_V2.3.2015.nc"}
\NormalTok{cdf }\OperatorTok{=}\NormalTok{ nc.Dataset(filename }\OperatorTok{=}\NormalTok{ dateipfad, mode }\OperatorTok{=} \StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Dateiversion: }\SpecialCharTok{\{}\NormalTok{cdf}\SpecialCharTok{.}\NormalTok{data\_model}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Dateiversion: NETCDF4
\end{verbatim}

Die wesentlichen Informationen können mit der print-Funktion ausgegeben
werden \texttt{print(cdf)}. Die Ausgabe ist jedoch besonders für
komplexere Dateien unübersichtlich.

Die Gruppen der Datei können mit dem Attribut \texttt{print(cdf.groups)}
ausgegeben werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(cdf.groups)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
{}
\end{verbatim}

Die Ausgabe ist ein Dictionary, das in diesem Fall leer ist. Die Datei
verfügt also über keine Unterverzeichnisse (Gruppen).

Die Variablen (die Datensätze) können mit dem Attribut
\texttt{print(cdf.variables)} ausgegeben werden, die Ausgabe ist
ebenfalls ein Dictionary. Die vollständige Ausgabe findet sich im
folgenden Beispiel.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{variables }\OperatorTok{=}\NormalTok{ cdf.variables}
\ControlFlowTok{for}\NormalTok{ key, value }\KeywordTok{in}\NormalTok{ variables.items():}
    \BuiltInTok{print}\NormalTok{(key)}
    \BuiltInTok{print}\NormalTok{(value, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
    \ControlFlowTok{break} \CommentTok{\# Abbruch nach erstem Schlüssel{-}Wert{-}Paar}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
DE_By_Threshold
<class 'netCDF4.Variable'>
float32 DE_By_Threshold(DE_By_Threshold)
    long_name: By Threshold
    comment: Threshold index for OTD detection efficiency
    units: 1
unlimited dimensions: 
current shape = (3,)
filling on, default _FillValue of 9.969209968386869e+36 used 
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-cdf}: vollständige Ausgabe cdf.variables}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-cdf} 

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{variables }\OperatorTok{=}\NormalTok{ cdf.variables}
\ControlFlowTok{for}\NormalTok{ key, value }\KeywordTok{in}\NormalTok{ variables.items():}
    \BuiltInTok{print}\NormalTok{(key)}
    \BuiltInTok{print}\NormalTok{(value, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
DE_By_Threshold
<class 'netCDF4.Variable'>
float32 DE_By_Threshold(DE_By_Threshold)
    long_name: By Threshold
    comment: Threshold index for OTD detection efficiency
    units: 1
unlimited dimensions: 
current shape = (3,)
filling on, default _FillValue of 9.969209968386869e+36 used 

DE_Local_Hour
<class 'netCDF4.Variable'>
float32 DE_Local_Hour(DE_Local_Hour)
    long_name: Local Hour
    comment: Lightning detection efficiency is the function of local hour. A day is divided into 24 bins. The values indicate the mean time of each bin.
    units: 1
unlimited dimensions: 
current shape = (24,)
filling on, default _FillValue of 9.969209968386869e+36 used 

DE_LowRes_Latitude
<class 'netCDF4.Variable'>
float32 DE_LowRes_Latitude(DE_LowRes_Latitude)
    long_name: LowRes Latitude
    standard_name: latitude
    axis: Y
    units: degrees_north
unlimited dimensions: 
current shape = (72,)
filling on, default _FillValue of 9.969209968386869e+36 used 

DE_LowRes_Longitude
<class 'netCDF4.Variable'>
float32 DE_LowRes_Longitude(DE_LowRes_Longitude)
    long_name: LowRes Longitude
    standard_name: longitude
    axis: X
    units: degrees_east
unlimited dimensions: 
current shape = (144,)
filling on, default _FillValue of 9.969209968386869e+36 used 

HRFC_AREA
<class 'netCDF4.Variable'>
float32 HRFC_AREA(Latitude, Longitude)
    valid_range: [  13.48325 3090.078  ]
    long_name: Grid Cell Area
    units: km^2
    _FillValue: 0.0
unlimited dimensions: 
current shape = (360, 720)
filling on 

HRFC_COM_FR
<class 'netCDF4.Variable'>
float32 HRFC_COM_FR(Latitude, Longitude)
    valid_range: [  0.     201.7618]
    long_name: Combined Flash Rate Climatology
    _FillValue: 0.0
    units: count/km^2/year
unlimited dimensions: 
current shape = (360, 720)
filling on 

HRFC_LIS_DE
<class 'netCDF4.Variable'>
float32 HRFC_LIS_DE(DE_Local_Hour, DE_LowRes_Latitude, DE_LowRes_Longitude)
    valid_range: [ 0.      88.00034]
    long_name: Applied LIS Detection Efficiency
    units: Percent
    _FillValue: 0.0
unlimited dimensions: 
current shape = (24, 72, 144)
filling on 

HRFC_LIS_FR
<class 'netCDF4.Variable'>
float32 HRFC_LIS_FR(Latitude, Longitude)
    valid_range: [   0.    5723.275]
    long_name: LIS Flash Rate Climatology
    _FillValue: 0.0
    units: count/km^2/year
unlimited dimensions: 
current shape = (360, 720)
filling on 

HRFC_LIS_RF
<class 'netCDF4.Variable'>
float32 HRFC_LIS_RF(Latitude, Longitude)
    valid_range: [   0. 9770.]
    long_name: LIS Raw Flashes
    _FillValue: 0.0
    units: count
unlimited dimensions: 
current shape = (360, 720)
filling on 

HRFC_LIS_SF
<class 'netCDF4.Variable'>
float32 HRFC_LIS_SF(Latitude, Longitude)
    valid_range: [    0.   12500.17]
    long_name: LIS Scaled Flashes
    _FillValue: 0.0
    units: count
unlimited dimensions: 
current shape = (360, 720)
filling on 

HRFC_LIS_VT
<class 'netCDF4.Variable'>
float32 HRFC_LIS_VT(Latitude, Longitude)
    valid_range: [0.000000e+00 4.462968e+09]
    long_name: LIS Viewtime
    units: km^2 sec
    _FillValue: 0.0
unlimited dimensions: 
current shape = (360, 720)
filling on 

HRFC_OTD_DE
<class 'netCDF4.Variable'>
float32 HRFC_OTD_DE(DE_By_Threshold, DE_Local_Hour, DE_LowRes_Latitude, DE_LowRes_Longitude)
    valid_range: [ 0.     53.6012]
    long_name: Applied OTD Base Detection Efficiency
    units: Percent
    _FillValue: 0.0
unlimited dimensions: 
current shape = (3, 24, 72, 144)
filling on 

HRFC_OTD_FR
<class 'netCDF4.Variable'>
float32 HRFC_OTD_FR(Latitude, Longitude)
    valid_range: [  0.     201.7618]
    long_name: OTD Flash Rate Climatology
    _FillValue: 0.0
    units: count/km^2/year
unlimited dimensions: 
current shape = (360, 720)
filling on 

HRFC_OTD_RF
<class 'netCDF4.Variable'>
float32 HRFC_OTD_RF(Latitude, Longitude)
    valid_range: [   0. 1298.]
    long_name: OTD Raw Flashes
    _FillValue: 0.0
    units: count
unlimited dimensions: 
current shape = (360, 720)
filling on 

HRFC_OTD_SF
<class 'netCDF4.Variable'>
float32 HRFC_OTD_SF(Latitude, Longitude)
    valid_range: [   0.    2645.824]
    long_name: OTD Scaled Flashes
    _FillValue: 0.0
    units: count
unlimited dimensions: 
current shape = (360, 720)
filling on 

HRFC_OTD_VT
<class 'netCDF4.Variable'>
float32 HRFC_OTD_VT(Latitude, Longitude)
    valid_range: [0.000000e+00 1.119883e+09]
    long_name: OTD Viewtime
    units: km^2 sec
    _FillValue: 0.0
unlimited dimensions: 
current shape = (360, 720)
filling on 

Latitude
<class 'netCDF4.Variable'>
float32 Latitude(Latitude)
    long_name: Latitude
    standard_name: latitude
    axis: Y
    units: degrees_north
unlimited dimensions: 
current shape = (360,)
filling on, default _FillValue of 9.969209968386869e+36 used 

Longitude
<class 'netCDF4.Variable'>
float32 Longitude(Longitude)
    long_name: Longitude
    standard_name: longitude
    axis: X
    units: degrees_east
unlimited dimensions: 
current shape = (720,)
filling on, default _FillValue of 9.969209968386869e+36 used 

lis_rf_data_centered
<class 'netCDF4.Variable'>
float32 lis_rf_data_centered(latitude, longitude)
    description: zentrierte Blitzanzahl
    units: absolute Abweichung vom Mittelwert
unlimited dimensions: 
current shape = (360, 720)
filling on, default _FillValue of 9.969209968386869e+36 used 
\end{verbatim}

\end{tcolorbox}

Ebenso können die Dimensionen (\texttt{cdf.dimensions}) und die globalen
Attribute des Datasets (\texttt{cdf.\_\_dict\_\_} oder als Liste mit
\texttt{cdf.ncattrs()}) ausgegeben werden. Ebenso können die Attribute
einer Variablen ausgegeben werden. Variablen werden direkt über den
Schlüssel
\texttt{variable\ =\ cdf{[}\textquotesingle{}key\textquotesingle{}{]}}
oder mit der Funktion
\texttt{variable\ =\ cdf.variables{[}\textquotesingle{}key\textquotesingle{}{]}}
abgerufen.

\section{Dimensionen}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dimensions }\OperatorTok{=}\NormalTok{ cdf.dimensions}

\ControlFlowTok{for}\NormalTok{ key, value }\KeywordTok{in}\NormalTok{ dimensions.items():}
    \BuiltInTok{print}\NormalTok{(key)}
    \BuiltInTok{print}\NormalTok{(value, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
DE_By_Threshold
"<class 'netCDF4.Dimension'>": name = 'DE_By_Threshold', size = 3 

DE_Local_Hour
"<class 'netCDF4.Dimension'>": name = 'DE_Local_Hour', size = 24 

DE_LowRes_Latitude
"<class 'netCDF4.Dimension'>": name = 'DE_LowRes_Latitude', size = 72 

DE_LowRes_Longitude
"<class 'netCDF4.Dimension'>": name = 'DE_LowRes_Longitude', size = 144 

Latitude
"<class 'netCDF4.Dimension'>": name = 'Latitude', size = 360 

Longitude
"<class 'netCDF4.Dimension'>": name = 'Longitude', size = 720 

latitude
"<class 'netCDF4.Dimension'>": name = 'latitude', size = 360 

longitude
"<class 'netCDF4.Dimension'>": name = 'longitude', size = 720 
\end{verbatim}

\section{globale Attribute}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(cdf.ncattrs(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{global\_attributes }\OperatorTok{=}\NormalTok{ cdf.\_\_dict\_\_}

\ControlFlowTok{for}\NormalTok{ key, value }\KeywordTok{in}\NormalTok{ global\_attributes.items():}
    \BuiltInTok{print}\NormalTok{(key)}
    \BuiltInTok{print}\NormalTok{(value, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['NCProperties', 'OTD_Date_Window_Start', 'OTD_Date_Window_End', 'OTD_Threshold_Level_Used', 'Conventions', 'history', 'NCO'] 

NCProperties
version=1|netcdflibversion=4.4.1|hdf5libversion=1.10.0 

OTD_Date_Window_Start
[1995.333 1995.44  1995.55  1996.81 ] 

OTD_Date_Window_End
[1995.44  1995.55  1996.81  2000.333] 

OTD_Threshold_Level_Used
[0 2 1 0] 

Conventions
CF-1.6 

history
Fri Dec 09 16:42:21 2016: ncks -4 test.nc3 LISOTD_HRFC_V2.3.2014_rename.nc
Fri Dec 09 16:42:21 2016: ncrename -v DE By Threshold,DE_By_Threshold test.nc3
Fri Dec 09 16:42:21 2016: ncrename -d DE By Threshold,DE_By_Threshold test.nc3
Fri Dec 09 16:42:21 2016: ncrename -v DE Local Hour,DE_Local_Hour test.nc3
Fri Dec 09 16:42:21 2016: ncrename -d DE Local Hour,DE_Local_Hour test.nc3
Fri Dec 09 16:42:21 2016: ncrename -v DE LowRes Longitude,DE_LowRes_Longitude test.nc3
Fri Dec 09 16:42:21 2016: ncrename -d DE LowRes Longitude,DE_LowRes_Longitude test.nc3
Fri Dec 09 16:42:21 2016: ncrename -v DE LowRes Latitude,DE_LowRes_Latitude test.nc3
Fri Dec 09 16:42:21 2016: ncrename -d DE LowRes Latitude,DE_LowRes_Latitude test.nc3
Fri Dec 09 16:42:21 2016: ncrename -a global@OTD Threshold Level Used,OTD_Threshold_Level_Used test.nc3
Fri Dec 09 16:42:21 2016: ncrename -a global@OTD Date Window End,OTD_Date_Window_End test.nc3
Fri Dec 09 16:42:21 2016: ncrename -a global@OTD Date Window Start,OTD_Date_Window_Start test.nc3
Fri Dec 09 16:42:21 2016: ncrename -a global@_NCProperties,NCProperties test.nc3
Fri Dec 09 16:42:20 2016: ncks -3 LISOTD_HRFC_V2.3.2014.nc test.nc3 

NCO
"4.6.0" 
\end{verbatim}

\section{Attribute einer Variablen}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{variable }\OperatorTok{=}\NormalTok{ cdf[}\StringTok{\textquotesingle{}HRFC\_OTD\_FR\textquotesingle{}}\NormalTok{]}
\CommentTok{\# Alternativ:}
\CommentTok{\# variable = cdf.variables[\textquotesingle{}HRFC\_OTD\_FR\textquotesingle{}]}

\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Attribute einer Variablen"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Als Liste mit variable.ncattrs():}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{variable}\SpecialCharTok{.}\NormalTok{ncattrs()}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Als Dictionary mit variable.\_\_dict\_\_:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{variable}\SpecialCharTok{.}\NormalTok{\_\_dict\_\_}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}

Attribute einer Variablen
Als Liste mit variable.ncattrs():
['valid_range', 'long_name', '_FillValue', 'units']

Als Dictionary mit variable.__dict__:
{'valid_range': array([  0.    , 201.7618], dtype=float32), 'long_name': 'OTD Flash Rate Climatology', '_FillValue': np.float32(0.0), 'units': 'count/km^2/year'}
\end{verbatim}

\subsection{Daten in netCDF4-Dateien
schreiben}\label{daten-in-netcdf4-dateien-schreiben}

Um Daten in eine netCDF4-Datei zu schreiben, muss diese in einem der
Schreibmodi geöffnet werden
\texttt{Dataset\ =\ nc.Dataset(\textquotesingle{}pfad\textquotesingle{},\ mode\ =\ \textquotesingle{}a\textquotesingle{})}.
Um eine neue Variable anzulegen, muss eine entsprechende Dimension
angelegt werden. Wenn die Variable in einen noch nicht bestehenden Pfad
gespeichert werden soll, sind auch die entsprechenden Gruppen anzulegen.

\begin{itemize}
\item
  Gruppen im Wurzelverzeichnis werden mit der Funktion
  \texttt{Dataset.createGroup("Gruppenname")} angelegt.
  Unterverzeichnisse werden analog als Pfad angelegt:
  \texttt{Dataset.createGroup("/Gruppenname/Unterverzeichnis")}
  (führenden `/' beachten).
\item
  Dimensionen beschreiben die Größe einer Variablen und müssen vor der
  Variablen angelegt werden (Ein Skalar, also ein Einzelwert, hat keine
  Dimension):
  \texttt{Dataset.createDimension(\textquotesingle{}Name\ der\ Dimension\textquotesingle{},\ Größe\ der\ Dimension\ als\ Ganzzahl)}.
  Durch die Übergabe von None oder 0 als Größe, wird eine unbegrenzt
  große Dimension angelegt (netCDF4-Variablen verhalten sich wie
  NumPy-Arrays, besitzen aber keine feste Größe. Das bedeutet, es können
  weitere Daten angehängt werden.). Um beispielsweise eine
  zweidimensionale Datenstruktur mit 10 Zeilen und 5 Spalten anzulegen,
  müssen beide Dimensionen seperat deklariert werden:
  \texttt{Dataset.createDimension(\textquotesingle{}Dimension1\textquotesingle{},\ 10)},
  \texttt{Dataset.createDimension(\textquotesingle{}Dimension2\textquotesingle{},\ 5)}.
\item
  Variablen werden mit der Funktion
  \texttt{Dataset.createVariable(\textquotesingle{}Name\ oder\ Pfad\textquotesingle{},\ \textquotesingle{}Datentypkürzel\textquotesingle{},\ (\textquotesingle{}Name\ der\ Dimension\textquotesingle{},\ )).\ Die\ Argumente\ \textquotesingle{}Name\ oder\ Pfad\textquotesingle{}\ und\ \textquotesingle{}Datentypkürzel\textquotesingle{}\ sind\ Pflichtangaben.\ Die\ Dimensionen\ der\ Variable\ wurden\ zuvor\ mit}cdf\_neu.createDimension(`Name
  der Dimension', Größe der Dimension als
  Ganzzahl)\texttt{definiert\ und\ werden\ als\ Tupel\ übergeben.\ Ein\ Einzelwert\ wird\ erstellt,\ indem\ die\ Angabe\ der\ Dimension\ weggelassen\ wird.\ Eine\ zweidimensionale\ Datenstruktur\ lässt\ sich\ so\ anlegen:}Dataset.createVariable(`Name
  oder Pfad der Variablen', `Datentypkürzel', (`Dimension1',
  `Dimension2', ))`
  \href{https://unidata.github.io/netcdf4-python/\#variables-in-a-netcdf-file}{siehe
  Dokumentation}.
\end{itemize}

\begin{longtable}[]{@{}cc@{}}
\toprule\noalign{}
Datentypkürzel & Datentyp \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
`f4' & 32-bit floating point \\
`f8' & 64-bit floating point \\
`i4' & 32-bit signed integer \\
`i2' & 16-bit signed integer \\
`i8' & 64-bit signed integer \\
`i1' & 8-bit signed integer \\
`u1' & 8-bit unsigned integer \\
`u2' & 16-bit unsigned integer \\
`u4' & 32-bit unsigned integer \\
`u8' & 64-bit unsigned integer \\
`S1' & single-character string \\
\end{longtable}

~

Im folgenden Code wird das Objekt abs\_time aus dem vorherigen Abschnitt
in einer netCDF4-Datei gespeichert. Mit den Attributen
\texttt{variablenname.description}, \texttt{variablename.source} und
\texttt{variablenname.units} werden die Metadaten zur Einheit (hier:
Millisekunden) hinterlegt. Dazu wird die Anweisung zum Erstellen der
Variable einem Objekt \texttt{variablename} zugewiesen.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Neues Dataset im Schreibmodus öffnen}
\NormalTok{cdf\_neu }\OperatorTok{=}\NormalTok{ nc.Dataset(}\StringTok{\textquotesingle{}01{-}daten/cdf\_neu.nc\textquotesingle{}}\NormalTok{, mode }\OperatorTok{=} \StringTok{\textquotesingle{}w\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Gruppe \textquotesingle{}Daten\textquotesingle{} anlegen}
\NormalTok{cdf\_neu.createGroup(}\StringTok{"Daten"}\NormalTok{)}

\CommentTok{\# Dimension anlegen}
\NormalTok{cdf\_neu.createDimension(}\StringTok{\textquotesingle{}abs\_time\textquotesingle{}}\NormalTok{, abs\_time.shape[}\DecValTok{0}\NormalTok{])}

\CommentTok{\# Variable anlegen als \textquotesingle{}f4\textquotesingle{} 32{-}bit float und einem Objekt zuweisen.}
\NormalTok{variablename }\OperatorTok{=}\NormalTok{ cdf\_neu.createVariable(}\StringTok{\textquotesingle{}/Daten/abs\_time\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}f4\textquotesingle{}}\NormalTok{, (}\StringTok{\textquotesingle{}abs\_time\textquotesingle{}}\NormalTok{, ))}

\CommentTok{\#\# Attribute anlegen}
\NormalTok{variablename.description }\OperatorTok{=} \StringTok{\textquotesingle{}sehr wichtige Zeitinformationen\textquotesingle{}}
\NormalTok{variablename.source }\OperatorTok{=} \StringTok{\textquotesingle{}berechnet aus IceBridge ATM L1B Elevation and Return Strength, Version 2\textquotesingle{}}
\NormalTok{variablename.units }\OperatorTok{=} \StringTok{\textquotesingle{}Millisekunden\textquotesingle{}}


\CommentTok{\# Dataset schließen}
\NormalTok{cdf\_neu.close()}

\CommentTok{\# Kontrolle}
\NormalTok{cdf\_neu }\OperatorTok{=}\NormalTok{ nc.Dataset(}\StringTok{\textquotesingle{}01{-}daten/cdf\_neu.nc\textquotesingle{}}\NormalTok{, mode }\OperatorTok{=} \StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(cdf\_neu.groups, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{variables }\OperatorTok{=}\NormalTok{ cdf\_neu[}\StringTok{\textquotesingle{}/Daten\textquotesingle{}}\NormalTok{].variables}
\ControlFlowTok{for}\NormalTok{ key, value }\KeywordTok{in}\NormalTok{ variables.items():}
    \BuiltInTok{print}\NormalTok{(key)}
    \BuiltInTok{print}\NormalTok{(value, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{cdf\_neu.close()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
{'Daten': <class 'netCDF4.Group'>
group /Daten:
    dimensions(sizes): 
    variables(dimensions): float32 abs_time(abs_time)
    groups: } 

abs_time
<class 'netCDF4.Variable'>
float32 abs_time(abs_time)
    description: sehr wichtige Zeitinformationen
    source: berechnet aus IceBridge ATM L1B Elevation and Return Strength, Version 2
    units: Millisekunden
path = /Daten
unlimited dimensions: 
current shape = (327285,)
filling on, default _FillValue of 9.969209968386869e+36 used 
\end{verbatim}

\subsubsection{Operationen mit
Variablen}\label{operationen-mit-variablen}

Wie bei HDF5-Dateien können Operationen mit Variablen nicht direkt
ausgeführt werden.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
  \BuiltInTok{print}\NormalTok{(cdf[}\StringTok{\textquotesingle{}HRFC\_OTD\_FR\textquotesingle{}}\NormalTok{] }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}
\ControlFlowTok{except} \PreprocessorTok{TypeError} \ImportTok{as}\NormalTok{ error:}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"Der Direktzugriff führt zu der Fehlermeldung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, error)}

\CommentTok{\# Mit einer Kopie kann gearbeitet werden}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Mit einer Kopie geht es:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(cdf[}\StringTok{\textquotesingle{}HRFC\_OTD\_FR\textquotesingle{}}\NormalTok{][ :, :])}

\CommentTok{\# Mit Indexbereichen ebenso}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Ebenso mit ausgewählten Indexbereichen:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(cdf[}\StringTok{\textquotesingle{}HRFC\_OTD\_FR\textquotesingle{}}\NormalTok{][}\DecValTok{30}\NormalTok{:}\DecValTok{40}\NormalTok{, }\DecValTok{30}\NormalTok{:}\DecValTok{40}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der Direktzugriff führt zu der Fehlermeldung:
 unsupported operand type(s) for -: 'netCDF4._netCDF4.Variable' and 'int'

Mit einer Kopie geht es:
[[-- -- -- ... -- -- --]
 [-- -- -- ... -- -- --]
 [-- -- -- ... -- -- --]
 ...
 [-- -- -- ... -- -- --]
 [-- -- -- ... -- -- --]
 [-- -- -- ... -- -- --]]

Ebenso mit ausgewählten Indexbereichen:
[[-- -- -- -- -- -- -- -- -- --]
 [-- -- -- -- -- -- -- -- -- --]
 [-- -- -- -- -- -- -- -- -- --]
 [-- -- -- -- -- -- -- -- -- --]
 [-- -- -- -- -- -- -- -- -- --]
 [-- -- -- -- -- -- -- -- -- --]
 [-- -- -- -- -- -- -- -- -- --]
 [-- -- -- -- -- -- -- -- -- --]
 [-- -- -- -- -- -- -- -- -- --]
 [-- -- -- -- -- -- -- -- -- --]]
\end{verbatim}

Am Ende wird die netCDF4-Datei geschlossen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cdf.close()}
\end{Highlighting}
\end{Shaded}

\subsection{Übung Zugriff auf
netCDF-Datasets}\label{uxfcbung-zugriff-auf-netcdf-datasets}

\textbf{Greifen Sie in der Datei unter dem Pfad
`01-daten/LISOTD\_HRFC\_V2.3.2015.nc' auf die Variable `HRFC\_LIS\_RF'
zu.}

\begin{itemize}
\item
  Geben Sie die Attribute der Variablen aus.
\item
  Bestimmen Sie die minimale, maximale und die durchschnittliche Anzahl
  der Blitze.
\item
  Zentrieren Sie die Daten (Wert - Mittelwert) und hängen Sie eine neue
  Variable `HRFC\_LIS\_RF\_centered' an das Dataset an.
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-netCDF}}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-netCDF} 

Da die Ausführung des Codes die Datei entsprechend der Aufgabenstellung
verändert, ist der Code nicht als Python-Code eingebunden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\# Datei im Modus append einlesen}
\NormalTok{dateipfad = "01{-}daten/LISOTD\_HRFC\_V2.3.2015.nc"}
\NormalTok{cdf = nc.Dataset(filename = dateipfad, mode = \textquotesingle{}a\textquotesingle{})}
\NormalTok{print(cdf.data\_model, "\textbackslash{}n")}

\NormalTok{\# Variable einlesen}
\NormalTok{lis\_rf =  cdf[\textquotesingle{}HRFC\_LIS\_RF\textquotesingle{}]}

\NormalTok{\# Attribute der Variablen ausgeben}
\NormalTok{print("Attribute der Variablen \textquotesingle{}HRFC\_LIS\_RF\textquotesingle{}:", lis\_rf.ncattrs(), "\textbackslash{}n")}

\NormalTok{\# Daten aus der Variablen auslesen}
\NormalTok{lis\_rf\_data =  cdf[\textquotesingle{}HRFC\_LIS\_RF\textquotesingle{}][: , :]}
\NormalTok{print(f"min: \{lis\_rf\_data.min()\}\textbackslash{}tmax: \{lis\_rf\_data.max()\}\textbackslash{}tmean: \{lis\_rf\_data.mean()\}\textbackslash{}n")}

\NormalTok{\# Daten zentrieren}
\NormalTok{\# runden wegen interner Darstellung von Gleitkommazahlen {-} optional}
\NormalTok{lis\_rf\_data\_centered = lis\_rf\_data {-} lis\_rf\_data.mean()}
\NormalTok{print(f"min: \{lis\_rf\_data\_centered.min()\}\textbackslash{}tmax: \{lis\_rf\_data\_centered.max()\}\textbackslash{}tmean: \{lis\_rf\_data\_centered.mean()\}\textbackslash{}tmean gerundet: \{round(lis\_rf\_data\_centered.mean())\}\textbackslash{}n")}

\NormalTok{\# Daten an die netCDF4{-}Datei anhängen}

\NormalTok{\#\# Dimension anlegen}
\NormalTok{\#\# latitute und longitude sind die Dimensionen des 2{-}dimensionalen Arrays}
\NormalTok{\#\# Code kann nur einmal ausgeführt werden, prüfen mit try: legt die Dimension bereits an}
\NormalTok{\#\# deshalb Konstruktion mit not in, um zu prüfen, ob Dimension bereites existiert}

\NormalTok{dimensions = cdf.dimensions}

\NormalTok{\#\#\# latitude}
\NormalTok{DIMENSION = \textquotesingle{}latitude\textquotesingle{}}
\NormalTok{if DIMENSION not in dimensions:}
\NormalTok{  print(f"Die Dimension \{DIMENSION\} existiert nicht und wird angelegt.")}
\NormalTok{  cdf.createDimension(DIMENSION, lis\_rf\_data\_centered.shape[0])}
\NormalTok{else:}
\NormalTok{  print(f"Die Dimension \{DIMENSION\} existiert bereits.")}

\NormalTok{\#\#\# longitude}
\NormalTok{DIMENSION = \textquotesingle{}longitude\textquotesingle{}}
\NormalTok{if DIMENSION not in dimensions:}
\NormalTok{  print(f"Die Dimension \{DIMENSION\} existiert nicht und wird angelegt.")}
\NormalTok{  cdf.createDimension(DIMENSION, lis\_rf\_data\_centered.shape[1])}
\NormalTok{else:}
\NormalTok{  print(f"Die Dimension \{DIMENSION\} existiert bereits.")}

\NormalTok{\#\# Variable \textquotesingle{}lis\_rf\_data\_centered\textquotesingle{} anlegen als \textquotesingle{}f4\textquotesingle{} 32{-}bit float und dem Objekt variablename zuweisen.}
\NormalTok{\#\# latitute und longitude sind die Dimensionen des 2{-}dimensionalen Arrays}
\NormalTok{\#\# Code kann nur einmal ausgeführt werden, prüfen mit try: legt die Variable bereits an, deshalb Konstruktion mit not in}
\NormalTok{variables = cdf.variables}

\NormalTok{VARIABLE = \textquotesingle{}lis\_rf\_data\_centered\textquotesingle{}}

\NormalTok{if VARIABLE not in variables:}
\NormalTok{  print(f"Die Variable \{VARIABLE\} existiert nicht und wird angelegt.\textbackslash{}n")}
\NormalTok{  variablename = cdf.createVariable(\textquotesingle{}lis\_rf\_data\_centered\textquotesingle{}, \textquotesingle{}f4\textquotesingle{}, (\textquotesingle{}latitude\textquotesingle{}, \textquotesingle{}longitude\textquotesingle{}, ))}

\NormalTok{  \#\#\# Daten einsetzen}
\NormalTok{  variablename[ :, :] = lis\_rf\_data\_centered}

\NormalTok{  \#\#\# Attribute anlegen}
\NormalTok{  variablename.description = \textquotesingle{}zentrierte Blitzanzahl\textquotesingle{}}
\NormalTok{  variablename.units = \textquotesingle{}absolute Abweichung vom Mittelwert\textquotesingle{}}
\NormalTok{else:}
\NormalTok{  print(f"Die Variable \{VARIABLE\} existiert bereits.\textbackslash{}n")}

\NormalTok{\# Dataset schließen}
\NormalTok{cdf.close()}

\NormalTok{\# Kontrolle}
\NormalTok{dateipfad = "01{-}daten/LISOTD\_HRFC\_V2.3.2015.nc"}
\NormalTok{cdf = nc.Dataset(filename = dateipfad, mode = \textquotesingle{}r\textquotesingle{})}

\NormalTok{variables = cdf.variables}
\NormalTok{for key, value in variables.items():}
\NormalTok{  print(key)}
\NormalTok{  \# print(value, "\textbackslash{}n")}

\NormalTok{kontrolle =  cdf[\textquotesingle{}lis\_rf\_data\_centered\textquotesingle{}][: , :]}

\NormalTok{print(f"\textbackslash{}nTyp der Datenstruktur lis\_rf\_data\_centered: \{type(kontrolle)\}\textbackslash{}nAnzahl der Elemente: \{kontrolle.size\}\textbackslash{}tAnzahl Werte: \{kontrolle.mask.sum()\}\textbackslash{}tMittelwert der Werte: \{kontrolle.mean()\}")}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

\chapter{Das Wichtigste}\label{das-wichtigste-3}

Das Einlesen strukturierter Datensätze mag nach der Bearbeitung dieses
Bausteins wie ein undurchdringlicher Dschungel aus erforderlichem
Detailwissen scheinen: verschiedene technische Formate, die große
Auswahl an Paketen und Funktionen und ein häufig nicht sonderlich
intuitiver innerer Aufbau, der aufgeräumt werden muss. Der Erfolg beim
Einlesen schwieriger Datensätze liegt aber im strukturierten Vorgehen -
dazu mehr in dem folgenden Video:

~

Zum Schluss noch ein Tipp: Für sehr große Datensätze ist eine visuelle
Kontrolle nicht immer praktikabel. Hier ist es hilfreich, sich Testdaten
zu schreiben, die die erwartete Struktur des Datensatzes widerspiegeln,
um damit die einzelnen Schritte zu programmieren. Vergleichen Sie
anschließend das Resultat für die Testdaten mit dem für den eigentlichen
Datensatz.

\chapter{Lernzielkontrolle}\label{lernzielkontrolle-2}

\section{Kompetenzquiz}\label{kompetenzquiz-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Unter dem Dateipfad `01-daten/quiz-aufgabe1.csv' liegt folgender
  Datensatz.
\end{enumerate}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
ID & Name & Geburtsdatum & Gehalt \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & Anna & 1986-04-12 & 55000 \\
2 & Bernd & 1990-05-23 & 62000 \\
3 & Carla & 1982-11-30 & 71000 \\
4 & David & 1975-03-15 & 58000 \\
\end{longtable}

Jedoch gelingt das Einlesen mit der Pandas-Funktion
\texttt{pd.read\_csv(filepath\_or\_buffer\ =\ dateipfad)} nicht wie
gewünscht.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}

\NormalTok{dateipfad }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/quiz{-}aufgabe1.csv\textquotesingle{}}
\NormalTok{aufgabe1 }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ dateipfad)}
\BuiltInTok{print}\NormalTok{(aufgabe1.info())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 4 entries, 0 to 3
Data columns (total 1 columns):
 #   Column                       Non-Null Count  Dtype 
---  ------                       --------------  ----- 
 0   ID;Name;Geburtsdatum;Gehalt  4 non-null      object
dtypes: object(1)
memory usage: 164.0+ bytes
None
\end{verbatim}

Welche Argumente müssen der Pandas-Funktion
\texttt{pd.read\_csv(filepath\_or\_buffer\ =\ dateipfad)} übergeben
werden, damit der Datensatz korrekt eingelesen wird?

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Ein Fehler bei der Datenerhebung soll korrigiert werden. Kennzeichnen
  Sie alle Beobachtungen für Personen, die vor 1980 geboren wurden als
  ungültig.
\item
  Sortieren Sie die Spalte Geburtsdatum aufsteigend (jüngste Person
  zuerst). Sortieren Sie den gesamten Dataframe aufsteigend.
\item
  Warum ist das Geburtsdatum der jüngsten Person ``größer'' als das der
  nächstälteren Person?
\item
  In einem Ordner liegen folgende Dateien: {[}`Datei0.jpg',
  `Datei1.csv', `Datei2.txt', `Datei3.png'{]}. Sie möchten alle Dateien
  mit der Endung .csv und .txt mit dem Modul glob einlesen. Wie könnte
  der Dateipfad im Argument `pathname' beschrieben werden, um alle
  Dateien einzulesen
  \texttt{glob.glob(pathname\ =\ ordnerpfad\ +\ \textquotesingle{}...\textquotesingle{})}?
\item
  Maske aufheben: Das maskierte Array m\_daten soll demaskiert werden.
  Jedoch bleibt der Befehl \texttt{m\_daten.mask\ =\ ma.nomask} ohne
  Erfolg. Was könnte die Ursache sein?
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(m\_daten, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{m\_daten.mask }\OperatorTok{=}\NormalTok{ ma.nomask}
\BuiltInTok{print}\NormalTok{(m\_daten, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1 2 -- 4] 

[1 2 -- 4] 
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\item
  Welche Aussagen treffen zu?

  \begin{enumerate}
  \def\labelenumii{\Alph{enumii})}
  \item
    HDF5 und netCDF4 sind speziell für den Umgang mit großen, komplexen
    wissenschaftlichen Datensätzen optimiert und unterstützen
    mehrdimensionale Arrays.
  \item
    HDF5 ist eine hierarchische Datenstruktur, deren Aufbau der
    Verzeichnisstruktur eines Computers gleicht. NetCDF4 ist dagegen
    eine flache Datenstruktur und unterstützt verzeichnisartige
    Datenstrukturen nicht.
  \item
    Beide Formate, HDF5 und netCDF4, können ausschließlich ein- und
    zweidimensionale Datensätze speichern.
  \item
    Mit HDF5 und netCDF4 können umfangreiche Metadaten hinterlegt
    werden. Die Formate gelten deshalb als selbstbeschreibend.
  \end{enumerate}
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Lösungen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Aufgabe 1: pd.read\_csv()

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/quiz{-}aufgabe1.csv\textquotesingle{}}
\NormalTok{aufgabe1 }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ dateipfad, sep }\OperatorTok{=} \StringTok{\textquotesingle{};\textquotesingle{}}\NormalTok{, parse\_dates }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Geburtsdatum\textquotesingle{}}\NormalTok{], dtype }\OperatorTok{=}\NormalTok{ \{}\StringTok{\textquotesingle{}Name\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}string\textquotesingle{}}\NormalTok{\})}
\BuiltInTok{print}\NormalTok{(aufgabe1.info())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 4 entries, 0 to 3
Data columns (total 4 columns):
 #   Column        Non-Null Count  Dtype         
---  ------        --------------  -----         
 0   ID            4 non-null      int64         
 1   Name          4 non-null      string        
 2   Geburtsdatum  4 non-null      datetime64[ns]
 3   Gehalt        4 non-null      int64         
dtypes: datetime64[ns](1), int64(2), string(1)
memory usage: 260.0 bytes
None
\end{verbatim}

Aufgabe 2: Beobachtungen als ungültig markieren

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bedingung }\OperatorTok{=}\NormalTok{ aufgabe1[}\StringTok{\textquotesingle{}Geburtsdatum\textquotesingle{}}\NormalTok{].dt.year }\OperatorTok{\textless{}} \DecValTok{1980}
\BuiltInTok{print}\NormalTok{(bedingung, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# pd.NA für Zeichenketten und Ganzzahlen}
\CommentTok{\#\# NumPy{-}Datentyp int64 führt zur Umwandlung des Datentyps der Spalte Gehalt}
\NormalTok{aufgabe2 }\OperatorTok{=}\NormalTok{ aufgabe1.copy()}
\NormalTok{aufgabe2.loc[bedingung, :] }\OperatorTok{=}\NormalTok{ pd.NA}
\BuiltInTok{print}\NormalTok{(}\StringTok{"NumPy{-}Datentyp int64 führt zur Umwandlung des Datentyps der Spalte Gehalt"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(aufgabe2, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\CommentTok{\# 3  NaN   \textless{}NA\textgreater{}          NaT      NaN}

\CommentTok{\#\# Pandas{-}Datentyp Int64 unterstützt fehlende Werte für Ganzzahlen}
\NormalTok{aufgabe2 }\OperatorTok{=}\NormalTok{ aufgabe1.copy()}
\NormalTok{aufgabe2[}\StringTok{\textquotesingle{}Gehalt\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ aufgabe2[}\StringTok{\textquotesingle{}Gehalt\textquotesingle{}}\NormalTok{].astype(}\StringTok{\textquotesingle{}Int64\textquotesingle{}}\NormalTok{)}
\NormalTok{aufgabe2[}\StringTok{\textquotesingle{}ID\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ aufgabe2[}\StringTok{\textquotesingle{}ID\textquotesingle{}}\NormalTok{].astype(}\StringTok{\textquotesingle{}Int64\textquotesingle{}}\NormalTok{)}
\NormalTok{aufgabe2.loc[bedingung, :] }\OperatorTok{=}\NormalTok{ pd.NA}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Pandas{-}Datentyp Int64 unterstützt fehlende Werte für Ganzzahlen"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(aufgabe2)}
\CommentTok{\# 3  NaN   \textless{}NA\textgreater{}          NaT    \textless{}NA\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0    False
1    False
2    False
3     True
Name: Geburtsdatum, dtype: bool 

NumPy-Datentyp int64 führt zur Umwandlung des Datentyps der Spalte Gehalt
    ID   Name Geburtsdatum   Gehalt
0  1.0   Anna   1986-04-12  55000.0
1  2.0  Bernd   1990-05-23  62000.0
2  3.0  Carla   1982-11-30  71000.0
3  NaN   <NA>          NaT      NaN 

Pandas-Datentyp Int64 unterstützt fehlende Werte für Ganzzahlen
     ID   Name Geburtsdatum  Gehalt
0     1   Anna   1986-04-12   55000
1     2  Bernd   1990-05-23   62000
2     3  Carla   1982-11-30   71000
3  <NA>   <NA>          NaT    <NA>
\end{verbatim}

Aufgabe 3: datetime aufsteigend sortieren

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{aufgabe3 }\OperatorTok{=}\NormalTok{ aufgabe2.copy()}
\BuiltInTok{print}\NormalTok{(aufgabe3[}\StringTok{\textquotesingle{}Geburtsdatum\textquotesingle{}}\NormalTok{].sort\_values(ascending }\OperatorTok{=} \VariableTok{False}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# Sortieren des DataFrames}
\BuiltInTok{print}\NormalTok{(aufgabe3.sort\_values(by }\OperatorTok{=} \StringTok{\textquotesingle{}Geburtsdatum\textquotesingle{}}\NormalTok{, ascending }\OperatorTok{=} \VariableTok{False}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1   1990-05-23
0   1986-04-12
2   1982-11-30
3          NaT
Name: Geburtsdatum, dtype: datetime64[ns] 

None 
\end{verbatim}

Aufgabe 4: Welches Datum ist größer und warum?

Python zählt die Zeit ausgehend von der sogenannten Epoche
\texttt{pd.to\_datetime(0)}. Jüngere Menschen wurden in größerem Abstand
zur Epoche geboren.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{aufgabe4 }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}Geburtsdatum\textquotesingle{}}\NormalTok{: aufgabe3[}\StringTok{\textquotesingle{}Geburtsdatum\textquotesingle{}}\NormalTok{].sort\_values(ascending }\OperatorTok{=} \VariableTok{False}\NormalTok{)\})}
\NormalTok{aufgabe4[}\StringTok{\textquotesingle{}timedelta zur Epoche\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ aufgabe4[}\StringTok{\textquotesingle{}Geburtsdatum\textquotesingle{}}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ pd.to\_datetime(}\DecValTok{0}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(aufgabe4)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  Geburtsdatum timedelta zur Epoche
1   1990-05-23            7447 days
0   1986-04-12            5945 days
2   1982-11-30            4716 days
3          NaT                  NaT
\end{verbatim}

Aufgabe 5: glob

\texttt{glob.glob(pathname\ =\ \textquotesingle{}ordnerpfad\textquotesingle{}\ +\ \textquotesingle{}?????{[}1-2{]}.*\textquotesingle{})}
oder\\
\texttt{glob.glob(pathname\ =\ \textquotesingle{}ordnerpfad\textquotesingle{}\ +\ \textquotesingle{}Datei{[}1-2{]}.*\textquotesingle{})}
oder\\
\texttt{glob.glob(pathname\ =\ \textquotesingle{}ordnerpfad\textquotesingle{}\ +\ \textquotesingle{}*{[}1-2{]}.*\textquotesingle{})}

Aufgabe 6: masked Array

Das maskierte Array hat eine hard mask.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m\_daten.soften\_mask()}
\NormalTok{m\_daten.mask }\OperatorTok{=}\NormalTok{ ma.nomask}
\BuiltInTok{print}\NormalTok{(m\_daten, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1 2 3 4] 
\end{verbatim}

Aufgabe 7: HDF5 und netCDF4

Richtige Antworten: A) und D)

\end{tcolorbox}

\section{Übungsaufgaben}\label{uxfcbungsaufgaben-1}

\subsubsection{Ein sehr unordentlicher
Datensatz}\label{ein-sehr-unordentlicher-datensatz}

Das Statistische Amt der Europäischen Union Eurostat führt die amtlichen
europäischen Statistiken. In der
\href{https://ec.europa.eu/eurostat/statistics-explained/index.php?title=Natural_gas_price_statistics\#Natural_gas_prices_for_non-household_consumers}{bei
Eurostatt verfügbaren} Datei
(\href{https://ec.europa.eu/eurostat/statistics-explained/images/3/32/SE_figures_for_Gas_2023S2_v3.xlsx}{Direktlink
auf XLSX-Datei}) sind die Preise für Erdgas für die Mitgliedstaaten und
verschiedene mit der Europäischen Union assoziierte Staaten erfasst.
Lesen Sie das Tabellenblatt `Table 1' entweder so ein, dass

\begin{itemize}
\item
  alle Werte mit einem sinnvollen numerischen Datentyp eingelesen
  werden.
\item
  ENTWEDER in einer zweidimensionalen Struktur jede Zeile eine
  Beobachtung und jede Beobachtung eine Zeile sowie jede Spalte eine
  Variable und jede Variable eine Spalte ist.
\item
  ODER wählen Sie eine sinnvolle mehrdimensionale Struktur.
\end{itemize}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Daten & Dateiname \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Preise für Erdgas &
``01-daten/SE\_figures\_for\_Gas\_2023S2\_v3.xlsx'' \\
\end{longtable}

\subsubsection{Ein schwieriges Format}\label{ein-schwieriges-format}

Das statistische Bundesamt veröffentlicht eine Statistik der erteilten
Baugenehmigungen, die zum Zeitpunkt der Erstellung diese Bausteins für
die Jahre 2015 bis 2023 vorliegt. Die Daten können hier abgerufen
werden:
\url{https://www-genesis.destatis.de/datenbank/online/table/31111-0006/sequenz=tabelleErgebnis&selectionname=31111-0006&zeitscheiben=1}.

Laden Sie mindestens zwei Jahrgänge herunter und lesen Sie die Dateien
in einem gemeinsamen Datensatz ein. Ordnen Sie jedem Wert das Jahr der
Beobachtung zu, indem Sie eine Variable `Jahr' einfügen und den
Datensatz entsprechend strukturieren.

\begin{itemize}
\item
  Wie können Sie das Jahr aus dem Datensatz auslesen?
\item
  Liegen alle Variablen in Spalten vor?
\end{itemize}

Dem Skript liegen die Dateien in folgendem Pfad bei:

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Daten & Ordnerpfad \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Baugenehmigungen verschiedener Jahre & ``01-daten/baugenehmigungen'' \\
\end{longtable}

\part{m-datenfitting-und-optimierung}

\chapter*{Methodenbaustein Datenfitting und
Datenoptimierung}\label{methodenbaustein-datenfitting-und-datenoptimierung}
\addcontentsline{toc}{chapter}{Methodenbaustein Datenfitting und
Datenoptimierung}

\markboth{Methodenbaustein Datenfitting und
Datenoptimierung}{Methodenbaustein Datenfitting und Datenoptimierung}

\phantomsection\label{Lizenz}
\begin{figure}

\begin{minipage}{0.20\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/m-datenfitting-und-optimierung/skript/00-bilder/CC-BY.pdf}}\end{minipage}%
%
\begin{minipage}{0.80\linewidth}
Bausteine Computergestützter Datenanalyse von Lukas Arnold, Simone
Arnold, Florian Bagemihl, Matthias Baitsch, Marc Fehr, Franca Hollmann,
Maik Poetzsch und Sebastian Seipel. Methodenbaustein Datenfitting und
Datenoptimierung von Marc Fehr und Maik Poetzsch ist lizensiert unter
\href{https://creativecommons.org/licenses/by/4.0/deed.de}{CC BY 4.0}.
Das Werk ist abrufbar auf
\href{https://github.com/bausteine-der-datenanalyse/m-datenfitting-und-optimierung}{GitHub}.
Ausgenommen von der Lizenz sind alle Logos Dritter und anders
gekennzeichneten Inhalte. 2025\end{minipage}%

\end{figure}%

Zitiervorschlag

Arnold, Lukas, Simone Arnold, Florian Bagemihl, Matthias Baitsch, Marc
Fehr, Franca Hollmann, Maik Poetzsch, und Sebastian Seipel. 2025.
``Bausteine Computergestützter Datenanalyse. Methodenbaustein
Datenfitting und Datenoptimierung''.
\url{https://github.com/bausteine-der-datenanalyse/m-datenfitting-und-optimierunge}.

BibTeX-Vorlage

\begin{verbatim}
@misc{BCD-m-datenfittung-und-optimierung-2025,
 title={Bausteine Computergestützter Datenanalyse. Methodenbaustein Datenfitting und Datenoptimierung.},
 author={Arnold, Lukas and Arnold, Simone and Bagemihl, Florian and Baitsch, Matthias and Fehr, Marc and Hollmann, Franca and Poetzsch, Maik and Seipel, Sebastian},
 year={2025},
 url={https://github.com/bausteine-der-datenanalyse/m-datenfitting-und-optimierung}} 
\end{verbatim}

\chapter*{Voraussetzungen}\label{voraussetzungen-8}
\addcontentsline{toc}{chapter}{Voraussetzungen}

\markboth{Voraussetzungen}{Voraussetzungen}

Die Bearbeitungszeit dieses Bausteins beträgt circa 10 Stunden. Für die
Bearbeitung dieses Bausteins werden folgende Bausteine vorausgesetzt:

\begin{itemize}
\tightlist
\item
  Werkzeugbaustein Python
\item
  Werkzeugbaustein NumPy
\end{itemize}

In diesem Baustein werden die folgenden Module und Pakete verwendet:

\begin{itemize}
\tightlist
\item
  numpy

  \begin{itemize}
  \tightlist
  \item
    numpy.polynomial
  \end{itemize}
\item
  matplotlib.pyplot
\end{itemize}

Im Baustein werden folgende Daten verwendet: Es werden keine von Dritten
bezogene Daten verwendet.

\chapter*{Lernziele}\label{lernziele-8}
\addcontentsline{toc}{chapter}{Lernziele}

\markboth{Lernziele}{Lernziele}

In diesen Baustein lernen Sie \ldots{}

\begin{itemize}
\tightlist
\item
  fehlende Daten in einem Datensatz mit Schätzwerten aufzufüllen.
\item
  Daten mit einer Modellfunktion zu beschreiben.
\item
  Daten mit mehreren Modellfunktionen zu beschreiben.
\item
  verrauschte Daten zu glätten.
\end{itemize}

\chapter{Einleitung}\label{einleitung-3}

Experiementell gewonnene Daten können stark verrauscht sein oder die
Beziehung der Variablen wird am besten durch einen nicht-linearen
Zusammenhang beschrieben. Datenfitting ist der Prozess, ein Modell an
einen Datensatz anzupassen, um die zugrundeliegende Beziehung zwischen
den Variablen zu beschreiben, die Daten zu glätten oder Werte zwischen
den vorhandenen Datenpunkten zu schätzen. Das Ziel dieses Prozesses ist
es, eine Funktion zu finden, die den Datensatz so gut wie möglich
beschreibt, indem die Abweichung zwischen dem Modell und den
tatsächlichen Daten minimiert wird. Man nennt diesen Prozess auch
Modellierung.

In diesem Baustein werden die folgenden Module verwendet:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ numpy.polynomial.polynomial }\ImportTok{as}\NormalTok{ poly}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}
\end{Highlighting}
\end{Shaded}

Die Modellierung von Daten kann auf folgendes Problem verallgemeinert
werden:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Gegeben sind \(n\) Messpunktpaare \((x_i, y_i)\) mit
  \(x_i, y_i \in \mathbb{R}\).
\item
  Gesucht ist eine Modellfunktion \(y(x)\), welche die Messpunktpaare
  approximiert.
\end{enumerate}

Ein möglicher Ansatz ist die Darstellung der Modellfunktion als Summe
von \(m\) Basisfunktionen \(\phi_i(x)\) mit den Koeffizienten
\(\beta_i\). \[
y(x) = \sum_{i=1}^{m}\beta_i \cdot \phi_i(x) = \beta_1\cdot \phi_1(x) + \cdots + \beta_m\cdot \phi_m(x) 
\]

Die Koeffizienten \(\beta_i\) müssen dabei so bestimmt werden, dass
\(y(x)\) so gut wie möglich -- oder gar exakt -- die Messpunkte
approximiert.

Als Abstandmaß zwischen einer Modellfunktion und den Messpunkten kann
die Methode der kleinsten Quadrate genutzt werden.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-ols}: Methode der kleinsten Quadrate}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-ols} 

Mit der Methode der kleinsten Quadrate soll diejenige Gerade
\(\hat{y} = \beta_0 + \beta_1 \cdot x\) gefunden werden, die die
quadrierten Abstände der Vorhersagewerte \(\hat{y}\) von den tatsächlich
gemessenen Werten \(y\) minimiert. Die Werte \(y_i - \hat{y_i}\) sind
die Residuen \(e_i\). Es gilt also:

\[
\sum_{i=1}^{N}(y_i - \hat{y_i})^2 = \sum_{i=1}^{N} e_i = \min
\]

Grafisch kann man sich die Minimierung der quadrierten Abstände so
vorstellen.

\section{Grafik}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-datenfitting-und-optimierung/skript/einleitung_files/figure-pdf/cell-3-output-1.png}}

\begin{verbatim}
Regressionskoeffizienten: [ 2.93333333 -0.73333333]
\end{verbatim}

\section{Code}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\NormalTok{y }\OperatorTok{=} \OperatorTok{{-}}\NormalTok{ x.copy() }\OperatorTok{+} \DecValTok{4}
\NormalTok{y[}\DecValTok{0}\NormalTok{] }\OperatorTok{{-}=} \DecValTok{2}
\NormalTok{y[}\DecValTok{2}\NormalTok{] }\OperatorTok{{-}=} \DecValTok{2}
\NormalTok{y[}\DecValTok{3}\NormalTok{] }\OperatorTok{+=} \DecValTok{3}
\NormalTok{y[}\OperatorTok{{-}}\DecValTok{3}\NormalTok{] }\OperatorTok{+=} \DecValTok{5}

\NormalTok{lm }\OperatorTok{=}\NormalTok{ poly.polyfit(x, y, }\DecValTok{1}\NormalTok{)}
\NormalTok{vorhersagewerte }\OperatorTok{=}\NormalTok{ poly.polyval(x, lm)}

\NormalTok{plt.scatter(x, vorhersagewerte, label }\OperatorTok{=} \StringTok{\textquotesingle{}Vorhersagewerte\textquotesingle{}}\NormalTok{, marker }\OperatorTok{=} \StringTok{"\^{}"}\NormalTok{, color }\OperatorTok{=} \StringTok{"tab:blue"}\NormalTok{)}
\NormalTok{plt.scatter(x, y, label }\OperatorTok{=} \StringTok{\textquotesingle{}Messwerte\textquotesingle{}}\NormalTok{, marker }\OperatorTok{=} \StringTok{\textquotesingle{}o\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{"tab:orange"}\NormalTok{)}
\NormalTok{plt.axline(xy1 }\OperatorTok{=}\NormalTok{ (}\DecValTok{0}\NormalTok{, lm[}\DecValTok{0}\NormalTok{]), slope }\OperatorTok{=}\NormalTok{ lm[}\DecValTok{1}\NormalTok{], label }\OperatorTok{=} \StringTok{"Regressionsgerade"}\NormalTok{, color }\OperatorTok{=} \StringTok{"tab:blue"}\NormalTok{)}
\NormalTok{dotted }\OperatorTok{=}\NormalTok{ plt.vlines(x, ymin }\OperatorTok{=}\NormalTok{ vorhersagewerte, ymax }\OperatorTok{=}\NormalTok{ y, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{, ls }\OperatorTok{=} \StringTok{\textquotesingle{}dotted\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Residuen\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.legend()}
\NormalTok{plt.show()}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Regressionskoeffizienten:"}\NormalTok{, lm)}
\end{Highlighting}
\end{Shaded}

~

Die eingezeichnete Gerade entspricht der linearen Funktion
\(\hat{y} = \beta_0 + \beta_1 \cdot x + e_i\). Die Dreiecksmarker sind
die Vorhersagewerte \(\hat{y_i}\) des linearen Modells für die Werte
\(x_i = np.arange(1, 11)\). Die tatsächlichen Messwerte \(y\) sind mit
Kreismarkern markiert. Die Länge der gestrichelten Linien entspricht der
Größe der Abweichung zwischen den Mess- und Vorhersagewerten
\(y_i - \hat{y_i}\), also den Residuen \(e_i\).

Gesucht wird diejenige Gerade, die die Summe der quadrierten Residuen
minimiert. Die gesuchten Werte \(\beta_0\) und \(\beta_1\) sind die
Kleinst-Quadrate-Schätzer.

\[
\beta_0 = \bar{y} - \beta_1 \cdot \bar{x}
\]

\[
\beta_1 = { \sum_{i=1}^n (x_i- \bar{x}) \cdot (y_i - \bar{y}) \over \sum_{i=1}^n (x_i - \bar{x})^2 }
\]

Der Vollständigkeit halber leiten wir die Kleinst-Quadrate-Schätzer her.
Gesucht werden Werte für \(\beta_0\) und \(\beta_1\), damit die Summe
der Residuenquadrate \(\sum_{i=1}^{n} e_i^2\) möglichst klein wird. Die
Residuenquadratsumme ist die Summe der quadrierten Differenzen aus
beobachteten Werten \(y_i\) und der durch die lineare Funktion
vorhergesagten Werte. \[
\sum_{i=1}^{n} e_i^2 ~ = ~ \sum_{i=1}^{n} (y_i - (\beta_0 + \beta_1 \cdot x_i))^2
\]

Wir untersuchen also eine Funktion, die von zwei Variablen abhängig ist.
\[
f(\beta_0, \beta_1) = \sum_{i=1}^{n} (y_i - (\beta_0 + \beta_1 \cdot x_i))^2
\]

Das Summenzeichen ist die Kurzschreibweise für eine Summe. \[
f(\beta_0, \beta_1) = (y_1 - (\beta_0 + \beta_1 \cdot x_1))^2 ~ + ~ (y_2 - (\beta_0 + \beta_1 \cdot x_2))^2 ~ + ~ ... ~ (y_n - (\beta_0 + \beta_1 \cdot x_n))^2
\]

Im Minimum der Funktion müssen die beiden partiellen Ableitungen gleich
Null sein (Warum das so ist, wird
\href{https://www.sofatutor.com/mathematik/funktionen/funktionen-mehrerer-veraenderlicher/lokale-extrempunkte-bei-funktionen-mit-mehreren-veraenderlichen}{hier}
leicht verständlich erklärt.)

\phantomsection\label{nte-partielleableitung}
\begin{quote}
\textbf{Note~59.1: Partielle Ableitung}

Die partielle Ableitung ist die Ableitung einer Funktion mit mehreren
Variablen nach einer Variablen, wobei die übrigen Variablen als
Konstanten behandelt werden.

Für eine Funktion \(f(x, y) = 2x + y^2\) wird die partielle Ableitung
nach x so ausgedrückt:

\(\frac{\partial f(x, y)}{\partial x}\)

\begin{itemize}
\tightlist
\item
  Das Symbol ∂ ist die kursive Darstellung des kyrillischen
  Kleinbuchstaben д (d) und wird als ``del'' gelesen. Es zeigt an, das
  eine partielle Ableitung durchgeführt wird.
\item
  Im Zähler steht die Funktion, die abgeleitet werden soll. Im Nenner
  steht die Variable nach der abgeleitet wird. Der Term wird gelesen als
  ``del f von x und y nach del x''.
\end{itemize}

Die partielle Ableitung \(\frac{\partial f(x, y)}{\partial x} = 2\).
\(y^2\) wird als Konstante behandelt (z. B. \(5^2\) ) und ist abgeleitet
Null.

Die partielle Ableitung \(\frac{\partial f(x, y)}{\partial y} = 2y\).
\(2x\) wird als Konstante behandelt (z. B. \(2 \cdot 3\) ) und ist
abgeleitet Null.
\end{quote}

In beiden partiellen Ableitungen sind \(x_i\) und \(y_i\) konstant. In
der partiellen Ableitung nach \(\beta_0\) ist außerdem \(\beta_1\)
konstant, in der partiellen Ableitung nach \(\beta_1\) ist entsprechend
\(\beta_0\) konstant.

\section{partielle Ableitung nach dem y-Achsenschnittpunkt}

Für die partielle Ableitung nach \(\beta_0\) gilt also nach der
Kettenregel für die äußere Funktion (oben) und die innere Funktion
(Mitte): \[ \begin{aligned}
\frac{\partial f(\beta_0, \beta_1)}{\partial \beta_0} = 2 \cdot (y_1 - (\beta_0 + \beta_1 \cdot x_1)) ~ + ~ ... ~ (y_n - (\beta_0 + \beta_1 \cdot x_n)) = 2 \cdot \sum_{i=1}^{n} (y_i - (\beta_0 + \beta_1 \cdot x_i)) ~ \cdot
\newline 
(0 - (1 + 0 \cdot 0)) ~ + ~ ... ~ (0 - (1 + 0 \cdot 0)) = \sum_{i=1}^{n} (0 - (1 + 0 \cdot 0)) =
\newline
2 \cdot \sum_{i=1}^{n} (y_i - (\beta_0 + \beta_1 \cdot x_i)) ~ \cdot (-1)
\end{aligned}
\]

Für die partielle Ableitung nach \(\beta_0\) gilt also: \[
\frac{\partial f(\beta_0, \beta_1)}{\partial \beta_0} = -2 \cdot \sum_{i=1}^{n} (y_i - (\beta_0 + \beta_1 \cdot x_i)) = 0
\]

Diese kann vereinfacht werden, indem der Vorfaktor \(-2\) entfällt (weil
\(-2 \cdot 0 = 0\) gelten muss) und die Vorzeichen aufgelöst werden.
Sodass: \[
\sum_{i=1}^{n} (y_i - \beta_0 - \beta_1 \cdot x_i) = 0
\]

Man kann auch schreiben: \[
\sum_{i=1}^{n} y_i - \sum_{i=1}^{n} \beta_0 - \sum_{i=1}^{n} \beta_1 \cdot x_i = 0
\]

\(\beta_0\) und \(\beta_1\) sind Konstanten, sodass gilt
\(\sum_{i=1}^{n} \beta_0  = \beta_0 \cdot \sum_{i=1}^{n} 1 = \beta_0 \cdot n\)
und
\(\sum_{i=1}^{n} \beta_1 \cdot x_i = \beta_1 \cdot \sum_{i=1}^{n} 1 \cdot x_i\).
So gilt: \[
\sum_{i=1}^{n} y_i - n \cdot \beta_0 - \beta_1 \cdot \sum_{i=1}^{n} x_i = 0
\]

Jetzt kann man durch \(n\) teilen. Dabei entspricht
\(\frac{\sum_{i=1}^{n}y_i}{n}\) dem arithmetischen Mittelwert von \(y\)
und \(\frac{\sum_{i=1}^{n}x_i}{n}\) dem arithmetischen Mittelwert von
\(x\). Somit steht: \[
\bar{y} - \beta_0 - \beta_1 \cdot \bar{x}= 0
\]

Umgestellt: \[
\beta_0 = \bar{y} - \beta_1 \cdot \bar{x}
\]

\section{partielle Ableitung nach dem Anstieg}

Für die partielle Ableitung nach \(\beta_1\) ist ebenfalls die
Kettenregel anzuwenden, sodass die äußere Funktion (oben) identisch
abgeleitet wird: \[ \begin{aligned}
\frac{\partial f(\beta_0, \beta_1)}{\partial \beta_1} = 2 \cdot (y_1 - (\beta_0 + \beta_1 \cdot x_1)) ~ + ~ ... ~ (y_n - (\beta_0 + \beta_1 \cdot x_n)) = 2 \cdot \sum_{i=1}^{n} (y_i - (\beta_0 + \beta_1 \cdot x_i)) ~ \cdot
\newline 
(0 - (0 + 1 \cdot x_1)) ~ + ~ ... ~ (0 - (0 + 1 \cdot x_n)) ~ = ~ \sum_{i=1}^{n} -x_i = 
\newline
2 \cdot \sum_{i=1}^{n} (y_i - (\beta_0 + \beta_1 \cdot x_i)) ~ \cdot -x_i
\end{aligned}
\]

Für die partielle Ableitung nach \(\beta_1\) gilt also: \[
\frac{\partial f(\beta_0, \beta_1)}{\partial \beta_1} = -2 \sum_{i=1}^{n} x_i \cdot (y_i - (\beta_0 + \beta_1 \cdot x_i)) = 0
\]

Auch diese kann vereinfacht werden, indem der Vorfaktor \(-2\) entfällt
(weil \(-2 \cdot 0 = 0\) gelten muss) und die Vorzeichen aufgelöst
werden. Außerdem kann ausmultipliziert werden: \[
\sum_{i=1}^{n} x_iy_i - \sum_{i=1}^{n}  \beta_0 \cdot x_i - \sum_{i=1}^{n}  \beta_1 \cdot x_ix_i = 0
\]

Wieder können die Konstanten herausgezogen werden: \[
\sum_{i=1}^{n} x_iy_i - \beta_0 \cdot \sum_{i=1}^{n} x_i - \beta_1 \cdot \sum_{i=1}^{n} x_ix_i = 0
\]

Jetzt kann man \(\beta_0 = \bar{y} - \beta_1 \cdot \bar{x}\) und
\(\sum_{i=1}^{n} x_i = n \cdot \bar{x}\) einsetzen: \[
\sum_{i=1}^{n} x_iy_i - (\bar{y} - \beta_1 \cdot \bar{x}) \cdot  n \cdot \bar{x} - \beta_1 \cdot \sum_{i=1}^{n} x_ix_i = 0
\]

Der mittlere Term wird ausmultipliziert und \(x_ix_i\) im letzten Term
als \(x_i^2\) geschrieben: \[
\sum_{i=1}^{n} x_iy_i - n\bar{x}\bar{y} - \beta_1 \cdot n\bar{x}\bar{x} - \beta_1 \cdot \sum_{i=1}^{n} x_i^2 = 0
\]

Die letzten beiden Terme werden unter Anwendung des Distributivgesetzes
\(a−b = − (b−a)\) zusammengefasst. \[
\sum_{i=1}^{n} x_iy_i - n\bar{x}\bar{y} - \beta_1 \cdot ( \sum_{i=1}^{n} x_i^2 - n \bar{x}^2) = 0
\]

Jetzt kann nach \(\beta_1\) umgestellt werden. Erst: \[
\beta_1 \cdot ( \sum_{i=1}^{n} x_i^2 - n \bar{x}^2) = \sum_{i=1}^{n} x_iy_i - n\bar{x}\bar{y}
\]

Dann: \[
\beta_1 = \frac{\sum_{i=1}^{n} x_iy_i - n\bar{x}\bar{y}}{\sum_{i=1}^{n} x_i^2 - n \bar{x}^2}
\]

Nun kann zuerst mit
\(\sum_{i=1}^{n} x_i^2 - n \bar{x}^2 = \sum_{i=1}^{n} (x_i - \bar{x})^2\)
umgeformt werden. \[
\beta_1 = \frac{\sum_{i=1}^{n} x_iy_i - n\bar{x}\bar{y}}{\sum_{i=1}^{n}  (x_i - \bar{x})^2}
\]

Dann - und das wird gleich gezeigt - mit
\(\sum_{i=1}^{n} x_iy_i - n\bar{x}\bar{y} = \sum_{i=1}^{n} (x_i - \bar{x}) (y_i - \bar{y})\).
Sodass steht: \[
\beta_1 = \frac{\sum_{i=1}^{n} (x_i - \bar{x}) (y_i - \bar{y})}{\sum_{i=1}^{n}  (x_i - \bar{x})^2}
\]

Der letzte Schritt wird ausgehend vom Ergebnis gezeigt und beginnt mit
dem Ausmultiplizieren: \[
\sum_{i=1}^{n} (x_i - \bar{x}) (y_i - \bar{y}) = \sum_{i=1}^{n} (x_iy_i - x_i\bar{y} - \bar{x}y_i + \bar{x}\bar{y})
\]

Man kann auch schreiben: \[
\sum_{i=1}^{n} x_iy_i - \sum_{i=1}^{n} x_i\bar{y} - \sum_{i=1}^{n} \bar{x}y_i + \sum_{i=1}^{n} \bar{x}\bar{y}
\]

\(\bar{x}\) und \(\bar{y}\) sind Konstanten, sodass
\(\bar{x} \cdot \sum_{i=1}^{n} y_i\) und
\(\bar{y} \cdot \sum_{i=1}^{n} x_i\) geschrieben werden kann.
\(\sum_{i=1}^{n} x_i\) ist gleich \(n \cdot \bar{x}\) (analog für
\(y\)). So ergibt sich:

\[
\sum_{i=1}^{n} x_iy_i - \bar{y} \cdot n \cdot \bar{x} - \bar{x} \cdot n \cdot \bar{y} + \sum_{i=1}^{n} \bar{x}\bar{y}
\]

Sortieren: \[
\sum_{i=1}^{n} x_iy_i - n\bar{x}\bar{y}  -  n\bar{x}\bar{y} + \sum_{i=1}^{n} \bar{x}\bar{y}
\]

Der letzte Term \(\sum_{i=1}^{n} \bar{x}\bar{y}\) kann auch
\(n \cdot \bar{x}\bar{y}\) geschrieben werden, sodass sich ergibt: \[
\sum_{i=1}^{n} x_iy_i - n\bar{x}\bar{y} - n\bar{x}\bar{y} + n\bar{x}\bar{y}
\]

Die letzten beiden Terme entfallen somit und es bleibt: \[
\sum_{i=1}^{n} x_iy_i - n\bar{x}\bar{y} 
\]

{[}@Baitsch-2019, S. 73-74{]}

\end{tcolorbox}

In diesem Kapitel werden folgende Verfahren für die Modellierung von
Daten vorgestellt:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  die Polynominterpolation,
\item
  Datenfitting durch Polynome und
\item
  Datenfitting durch Splines.
\end{enumerate}

\chapter{Interpolation -- Lücken
schließen}\label{interpolation-luxfccken-schlieuxdfen}

Was tun, wenn Werte fehlen? In vielen Datensätzen gibt es Lücken -- zum
Beispiel, weil Messungen nur an bestimmten Punkten vorgenommen wurden.
Interpolation ist eine Methode, mit der wir Zwischenwerte schätzen
können, also Werte innerhalb eines bekannten Wertebereichs.

Im Gegensatz dazu versucht Extrapolation, Werte außerhalb des bekannten
Bereichs vorherzusagen -- was in der Regel mit größerer Unsicherheit
verbunden ist.

Bei der Interpolation wird eine Modellfunktion gesucht, welche die
Messdaten exakt abbildet.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Theorie - Modellierung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Die Modellierung von Daten hat das Ziel, eine Menge von Daten durch
einen funktionalen Zusammenhang abzubilden. Daten aus Experimenten oder
Simulationen können stark verrauscht und so für eine Weiterverarbeitung
nicht geeignet sein. Eine mittelnde Funktion kann den Datensatz stark
vereinfachen. Oder es existieren nur wenige Datenpunkte und die
Zwischenstellen müssen durch eine Funktion bestimmt werden.

Generell kann die Modellierung von Daten auf folgendes Problem
verallgemeinert werden:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Gegeben sind \(n\) Messpunktpaare \((x_i, y_i)\) mit
  \(x_i, y_i \in \mathbb{R}\)
\item
  Gesucht ist eine Modellfunktion \(y(x)\), welche die Messpunktpaare
  approximiert
\end{enumerate}

Ein möglicher Ansatz ist die Darstellung der Modellfunktion als Summe
von \(m\) Basisfunktionen \(\phi_i(x)\) mit den Koeffizienten
\(\beta_i\).

\[
y(x) = \sum_{i=1}^{m}\beta_i \cdot \phi_i(x) = \beta_1\cdot \phi_1(x) + \cdots + \beta_m\cdot \phi_m(x)
\]

Die Koeffizienten \(\beta_i\) müssen dabei so bestimmt werden, dass
\(y(x)\) so gut wie möglich -- oder gar exakt -- die Messpunkte
approximieren.

Als Abstandmaß zwischen einer Modellfunktion und den Messpunkten kann
die \href{https://de.wikipedia.org/wiki/Folgenraum\#lp}{L2-Norm}
verwendet werden. Diese ist definiert als

\[
|| y(x) - (x_i, y_i) ||_2 = \sum_{i=1}^n \left(y(x_i) - y_i\right)^2 \quad .
\]

Eine solche Norm gibt ein Maß für die Qualität einer Approximation: je
kleiner der Abstand, desto besser die Qualität. Dies ermöglicht das
Finden optimaler Koeffizienten und wird beispielsweise in der Methode
der kleinsten Quadrate genutzt, in der ein Satz an Koeffizienten gesucht
wird, der die L2-Norm minimiert.

\end{tcolorbox}

\section{Übersicht}\label{uxfcbersicht-2}

In vielen praktischen Anwendungen werden Polynome als Basisfunktionen
der Modellfunktion angenommen. Vorteile von Polynomen:

\begin{itemize}
\tightlist
\item
  Polynome sind leicht zu differenzieren und integrieren.
\item
  Mit Polynomen können beliebige Funktionen angenommen werden, siehe
  \href{https://de.wikipedia.org/wiki/Taylorreihe}{Taylor-Entwicklung}.
\item
  Die Auswertung benötigt nur wenige arithmetische Operationen (Addition
  und Multiplikation) und ist dadurch einfach und schnell anzuwenden.
\end{itemize}

Ein Beispiel für eine Basis aus Polynomen:

\[ \phi_1(x)=1,\quad \phi_2(x)=x,\quad \phi_3(x)=x^2,\quad \cdots,\quad \phi_m =x^{m-1} \]

\section{Polynome}\label{polynome}

Polynome \(P(x)\) sind Funktionen in Form einer Summe von
Potenzfunktionen mit natürlichzahligen Exponenten
\(( x^i, i \in \mathbb{N})\) mit den entsprechenden Koeffzienten
\(a_i\):

\[
P(x) = \sum_{i=0}^n a_i x^i = a_n x^n + a_{n-1} x^{n-1} + \cdots + a_2 x^2 + a_1 x + a_0, \quad i, n \in \mathbb{N}, a_i \in \mathbb{R}
\]

\begin{itemize}
\tightlist
\item
  Als Grad eines Polynoms wird der Term mit dem höchsten Exponenten und
  nichtverschwindenden Koeffizienten (der sogenannte Leitkoeffizient)
  bezeichnet.
\item
  Ein Polynom mit Grad \(n\) hat \(n\), teilweise
  \href{https://de.wikipedia.org/wiki/Komplexe_Zahl}{komplexe},
  Nullstellen.
\end{itemize}

Im NumPy-Modul werden Polynome durch ihre Koeffizienten repräsentiert.
Im Allgemeinen wird ein Polynom mit dem Grad \(n\) durch folgendes Array
dargestellt

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[a0, a1, a2, ..., an]}
\end{Highlighting}
\end{Shaded}

Beispielsweise für \(P(x) = 3 -2x + 5x^2 + x^3\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{P }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{3}\NormalTok{, }\OperatorTok{{-}}\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(P)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[ 3 -2  5  1]
\end{verbatim}

Funktionen für die Auswertung von Polynomfunktionen stellt das Paket
\texttt{numpy.polynomial} bzw. dessen Modul
\texttt{numpy.polynomial.polynomial} bereit.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy.polynomial.polynomial }\ImportTok{as}\NormalTok{ poly}
\end{Highlighting}
\end{Shaded}

Die Auswertung des Polynoms an einem Punkt oder einem Array erfolgt mit
der \texttt{poly.polyval(x,\ c)}-Funktion. Diese berechnet die
Funktionswerte für in \texttt{x} übergebene Werte mit den
Funktionsparametern \texttt{c}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{1}
\NormalTok{y }\OperatorTok{=}\NormalTok{ poly.polyval(x, P)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"P(x=}\SpecialCharTok{\{}\NormalTok{x}\SpecialCharTok{\}}\SpecialStringTok{) = }\SpecialCharTok{\{}\NormalTok{y}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
P(x=1) = 7.0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.array([}\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{])}
\NormalTok{y }\OperatorTok{=}\NormalTok{ poly.polyval(x, P)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"P(x=}\SpecialCharTok{\{}\NormalTok{x}\SpecialCharTok{\}}\SpecialStringTok{) = }\SpecialCharTok{\{}\NormalTok{y}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
P(x=[-1  0  1]) = [9. 3. 7.]
\end{verbatim}

Für die graphische Darstellung im Bereich \(x \in [-6, 2]\) kann das
Paket Matplotlib verwendet werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.linspace(}\OperatorTok{{-}}\DecValTok{6}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{50}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ poly.polyval(x, P)}

\NormalTok{plt.plot(x, y)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}y(x)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.grid()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-datenfitting-und-optimierung/skript/interpolation_files/figure-pdf/cell-7-output-1.png}}

~

Um die Nullstellen eines Polynoms zu finden, kann die Funktion
\texttt{poly.polyroots()} genutzt werden. Für das obige Polynom können
folgende Nullstellen bestimmt werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nullstellen }\OperatorTok{=}\NormalTok{ poly.polyroots(P)}

\CommentTok{\# direkte Ausgabe des Arrays}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Nullstellen: "}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(nullstellen)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Nullstellen: 
[-5.46628038+0.j        0.23314019-0.703182j  0.23314019+0.703182j]
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Nullstellen: "}\NormalTok{)}
\CommentTok{\# schönere Ausgabe des Arrays}
\ControlFlowTok{for}\NormalTok{ i, z }\KeywordTok{in} \BuiltInTok{enumerate}\NormalTok{(nullstellen):}
    \ControlFlowTok{if}\NormalTok{ z.imag }\OperatorTok{==} \DecValTok{0}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"  x\_}\SpecialCharTok{\{}\NormalTok{i}\OperatorTok{+}\DecValTok{1}\SpecialCharTok{\}}\SpecialStringTok{ = }\SpecialCharTok{\{}\NormalTok{z}\SpecialCharTok{.}\NormalTok{real}\SpecialCharTok{:.2\}}\SpecialStringTok{"}\NormalTok{)}
    \ControlFlowTok{else}\NormalTok{:}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"  x\_}\SpecialCharTok{\{}\NormalTok{i}\OperatorTok{+}\DecValTok{1}\SpecialCharTok{\}}\SpecialStringTok{ = }\SpecialCharTok{\{}\NormalTok{z}\SpecialCharTok{.}\NormalTok{real}\SpecialCharTok{:.2\}}\SpecialStringTok{ }\SpecialCharTok{\{}\NormalTok{z}\SpecialCharTok{.}\NormalTok{imag}\SpecialCharTok{:+.2\}}\SpecialStringTok{i"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Nullstellen: 
  x_1 = -5.5
  x_2 = 0.23 -0.7i
  x_3 = 0.23 +0.7i
\end{verbatim}

In diesem Beispiel sind zwei der Nullstellen komplex. Eine komplexe Zahl
\(z\) wird in Python als Summe des Realteils (\(Re\)) und Imaginärteils
(\(Im\)) dargestellt. Letzterer wird durch ein nachfolgendes \texttt{j},
die imaginäre Einheit, gekennzeichnet.

\[
z = Re(z) + Im(z)j
\]

Die Nullstellen können auch zur alternativen Darstellung des Polynoms
verwendet werden. Sind \(x_i\) die \(n\) Nullstellen, so ist das Polynom
\(n\)-ten Grades durch folgendes Produkt beschrieben:

\[
P(x) = \prod_{i=1}^n \left(x - x_i\right) = (x - x_1)\cdot (x - x_2) \cdot \cdots \cdot (x - x_n)
\]

Seien beispielsweise 1 und 2 die Nullstellen eines Polynoms, so lautet
dieses:

\[
P(x) = (x - 1)(x - 2) = 2 - 3x + x^2
\]

Die Funktion \texttt{poly.polyfromroots(nullstellen)} kann aus den
Nullstellen die Polynomkoeffizienten bestimmen. Anhand des obigen
Beispiels lautet der Funktionsaufruf:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nullstellen }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{]}
\NormalTok{koeffizienten }\OperatorTok{=}\NormalTok{ poly.polyfromroots(nullstellen)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Nullstellen:"}\NormalTok{, nullstellen)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Koeffizienten:"}\NormalTok{, koeffizienten)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Nullstellen: [1, 2]
Koeffizienten: [ 2. -3.  1.]
\end{verbatim}

Das Modul \texttt{numpy.polynomial.polynomial} stellt viele praktische
Funktionen zum Umgang mit Polynomen zur Verfügung. So existieren weitere
Funktionen, um Polynome zu addieren, zu multiplizieren, abzuleiten oder
zu integrieren. Eine Übersicht findet sich in der
\href{https://numpy.org/doc/2.3/reference/routines.polynomials.polynomial.html}{numpy-Dokumentation}.

\section{Polynominterpolation}\label{polynominterpolation}

Interpolation ist eine Methode, um Datenpunkte zwischen gegebenen
Messpunkten zu konstruieren. Dazu wird eine Funktion gesucht, die alle
Messpunkte exakt abbildet, was gleichbedeutend damit ist, dass die
L2-Norm zwischen Funktion und Punkten Null ist.

Zwei Punkte können z. B. mit einer Geraden interpoliert werden. Das
heißt, für zwei Messpunktpaare \((x_1, y_1)\) und \((x_2, y_2)\) mit
\(x_1\neq x_2\) existiert ein Koeffizientensatz, sodass die L2-Norm
zwischen den Messpunkten und der Modellfunktion

\[
y(x) = \beta_0 + \beta_1 x 
\]

verschwindet.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beispieldaten aus y(x) = 2 {-} x}

\NormalTok{N }\OperatorTok{=} \DecValTok{50}
\NormalTok{dx }\OperatorTok{=} \FloatTok{0.25}

\KeywordTok{def}\NormalTok{ fnk(x):}
    \ControlFlowTok{return} \DecValTok{2} \OperatorTok{{-}}\NormalTok{ x}

\NormalTok{x }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{])}
\NormalTok{y }\OperatorTok{=}\NormalTok{ fnk(x)}

\NormalTok{plt.scatter(x, y, color}\OperatorTok{=}\StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{"Messpunkte"}\NormalTok{, zorder}\OperatorTok{=}\DecValTok{3}\NormalTok{)}

\NormalTok{x\_modell }\OperatorTok{=}\NormalTok{ np.linspace(np.}\BuiltInTok{min}\NormalTok{(x), np.}\BuiltInTok{max}\NormalTok{(x), N)}
\NormalTok{plt.plot(x\_modell, fnk(x\_modell), color}\OperatorTok{=}\StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{"Modellfunktion"}\NormalTok{)}

\NormalTok{x\_linie }\OperatorTok{=}\NormalTok{ np.linspace(np.}\BuiltInTok{min}\NormalTok{(x)}\OperatorTok{{-}}\NormalTok{dx, np.}\BuiltInTok{max}\NormalTok{(x)}\OperatorTok{+}\NormalTok{dx, N)}
\NormalTok{plt.plot(x\_linie, fnk(x\_linie), }\StringTok{\textquotesingle{}{-}{-}\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.3}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.xlabel(}\StringTok{"x"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"y"}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.grid()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-datenfitting-und-optimierung/skript/interpolation_files/figure-pdf/cell-11-output-1.png}}

~

Für drei Messpunkte muss ein Polynom zweiten Grades verwendet werden, um
die Punkte exakt zu erfassen.

\[
y(x) = \beta_0 + \beta_1 x + \beta_2 x^2
\]

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beispieldaten aus y(x) = {-}1 {-} 4x + 3x\^{}2}

\NormalTok{N }\OperatorTok{=} \DecValTok{50}
\NormalTok{dx }\OperatorTok{=} \FloatTok{0.25}

\KeywordTok{def}\NormalTok{ fnk(x):}
    \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1} \OperatorTok{{-}} \DecValTok{4}\OperatorTok{*}\NormalTok{x }\OperatorTok{+} \DecValTok{3}\OperatorTok{*}\NormalTok{x}\OperatorTok{**}\DecValTok{2}

\NormalTok{x }\OperatorTok{=}\NormalTok{ np.array([}\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{])}
\NormalTok{y }\OperatorTok{=}\NormalTok{ fnk(x)}

\NormalTok{plt.scatter(x, y, color}\OperatorTok{=}\StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{"Messpunkte"}\NormalTok{, zorder}\OperatorTok{=}\DecValTok{3}\NormalTok{)}

\NormalTok{x\_modell }\OperatorTok{=}\NormalTok{ np.linspace(np.}\BuiltInTok{min}\NormalTok{(x), np.}\BuiltInTok{max}\NormalTok{(x), N)}
\NormalTok{plt.plot(x\_modell, fnk(x\_modell), color}\OperatorTok{=}\StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{"Modellfunktion"}\NormalTok{)}

\NormalTok{x\_linie }\OperatorTok{=}\NormalTok{ np.linspace(np.}\BuiltInTok{min}\NormalTok{(x)}\OperatorTok{{-}}\NormalTok{dx, np.}\BuiltInTok{max}\NormalTok{(x)}\OperatorTok{+}\NormalTok{dx, N)}
\NormalTok{plt.plot(x\_linie, fnk(x\_linie), }\StringTok{\textquotesingle{}{-}{-}\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.3}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.xlabel(}\StringTok{"x"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"y"}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.grid()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-datenfitting-und-optimierung/skript/interpolation_files/figure-pdf/cell-12-output-1.png}}

Dies kann verallgemeinert werden: \(n\) Messpunkte können exakt mit
einem Polynom (\(n-1\))-ten Grades abgebildet werden. Die Suche nach den
passenden Koeffizienten ist das Lagrangesche Interpolationsproblem. Für
das gesuchte Polynom \(P(x)\) gilt:

\[
P(x_i) = y_i \quad i \in 1, \dots, n
\]

Die Existenz und Eindeutigkeit eines solchen Polynoms kann gezeigt
werden. Das gesuchte Polynom lautet:

\[  P(x) = \sum_{i=1}^n y_i I_i(x) \]
\[  \text{mit}\quad I_i(x) = \prod_{j=1, i\neq j}^n \frac{x-x_j}{x_i - x_j} \]

Alternativ kann auch ein Gleichungssystem, welches durch die
Polynomialbasis \(\phi_i(x)\) gegeben ist, gelöst werden. Für die \(n\)
Punktepaare gilt jeweils:

\[  y(x_i) = \sum_{i=1}^{m}\beta_i \cdot \phi_i(x_i) = \beta_1\cdot \phi_1(x_i) + \cdots + \beta_m\cdot \phi_m(x_i) = y_i \]

Das allgemeine Geleichungssystem lautet

\[
\left( \begin{matrix} \phi_1(x_1) & \phi_2(x_1) & \cdots & \phi_m(x_1) \\ 
             \phi_1(x_2) & \phi_2(x_2) & \cdots & \phi_m(x_2) \\ 
             \vdots &\vdots & \ddots & \vdots \\ 
             \phi_1(x_n) & \phi_2(x_n) & \cdots & \phi_m(x_n) \\ 
             \end{matrix}\right). 
\left(  \begin{matrix} \beta_1 \\  
      \beta_2 \\   \vdots \\   \beta_m \\ 
      \end{matrix} \right) 
= \left(  \begin{matrix} y_1 \\  y_2 \\   \vdots \\   y_n \\ \end{matrix} \right)
\]

und mit der Polynomialbasis

\[
\underbrace{\left( \begin{matrix} 1 & x_1 & \cdots & x_1^{n-1} \\ 1 & x_2 & \cdots & x_2^{n-1} \\ \vdots &\vdots & \ddots & \vdots \\ 1 & x_n & \cdots & x_n^{n-1} \\ \end{matrix}\right)}_{V}. \left(  \begin{matrix} \beta_1 \\  \beta_2 \\   \vdots \\   \beta_m \\ \end{matrix} \right) = \left(  \begin{matrix} y_1 \\  y_2 \\   \vdots \\   y_n \\ \end{matrix} \right)
\]

Die Matrix \(V\) heisst
\href{https://de.wikipedia.org/wiki/Vandermonde-Matrix}{Vandermonde-Matrix}
und kann exakt gelöst werden, für \(m=n\) und wenn für alle
\(i, j; i\neq j\) gilt \(x_i \neq x_j\).

In Python kann das Interpolationsproblem mit der
\href{https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polyfit.html}{Funktion
\texttt{numpy.polynomial.polynomial.polyfit()}} gelöst werden, das wir
durch durch das Importieren des Moduls mit dem Schlüsselwort
\texttt{poly} mit \texttt{poly.polyfit()} aufrufen können. Das folgende
Beispiel demonstriert deren Anwendung.

Die Messtellen folgen in dem Beispiel der Funktion \(f(x)\), welche nur
zur Generierung der Datenpunkte verwendet wird.

\[ f(x) = \frac{1}{2} + \frac{1}{1+x^2}\]

Zunächst werden die Messpunkte generiert.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ fnk(x):}
    \ControlFlowTok{return} \FloatTok{0.5} \OperatorTok{+} \DecValTok{1}\OperatorTok{/}\NormalTok{(}\DecValTok{1}\OperatorTok{+}\NormalTok{x}\OperatorTok{**}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{xmin }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{5}
\NormalTok{xmax }\OperatorTok{=}  \DecValTok{5}
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.linspace(xmin, xmax, }\DecValTok{100}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ fnk(x)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{=} \DecValTok{5}
\NormalTok{xi }\OperatorTok{=}\NormalTok{ np.linspace(xmin, xmax, n)}
\NormalTok{yi }\OperatorTok{=}\NormalTok{ fnk(xi)}
\end{Highlighting}
\end{Shaded}

Nun folgt die Interpolation für 5 und 15 Messpunkte.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{P }\OperatorTok{=}\NormalTok{ poly.polyfit(xi, yi, n}\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Interpolationskoeffizienten:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(P)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Interpolationskoeffizienten:
[ 1.50000000e+00  1.68520006e-16 -1.71087533e-01 -7.33288031e-18
  5.30503979e-03]
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x, y, color}\OperatorTok{=}\StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.5}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}generierende Funktion\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(x, poly.polyval(x, P), color}\OperatorTok{=}\StringTok{\textquotesingle{}C2\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Interpolation\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.scatter(xi, yi, color}\OperatorTok{=}\StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Messpunkte\textquotesingle{}}\NormalTok{, zorder}\OperatorTok{=}\DecValTok{3}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.grid()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-datenfitting-und-optimierung/skript/interpolation_files/figure-pdf/cell-17-output-1.png}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{=} \DecValTok{15}
\NormalTok{xi }\OperatorTok{=}\NormalTok{ np.linspace(xmin, xmax, n)}
\NormalTok{yi }\OperatorTok{=}\NormalTok{ fnk(xi)}

\NormalTok{P }\OperatorTok{=}\NormalTok{ poly.polyfit(xi, yi, n}\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}

\NormalTok{plt.plot(x, y, color}\OperatorTok{=}\StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.5}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}generierende Funktion\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(x, poly.polyval(x, P), color}\OperatorTok{=}\StringTok{\textquotesingle{}C2\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Interpolation\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.scatter(xi, yi, color}\OperatorTok{=}\StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Messpunkte\textquotesingle{}}\NormalTok{, zorder}\OperatorTok{=}\DecValTok{3}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.grid()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-datenfitting-und-optimierung/skript/interpolation_files/figure-pdf/cell-18-output-1.png}}

~

Die Interpolation erfüllt immer die geforderte Bedingung
\(y(x_i) = y_i\). Jedoch führen Polynome mit einem hohen Grad oft zu
nicht sinnvollen Ergebnissen. Es entstehen starke Überschwinger, welche
mit zunehmendem Grad immer stärker werden.

\chapter{Fitting}\label{fitting}

Beim Fitting wird eine Modellfunktion gesucht, welche die Messdaten
nicht unbedingt exakt abbildet. Wird ein Polynom verwendet, so hat es
einen Grad, welcher deutlich kleiner ist, als die Anzahl der Messpunkte.
Lineare Regression ist ein Beispiel für ein Fitting durch ein Polynom
mit dem Grad Eins.

Zum Fitten durch ein Polynom kann die Funktion
\texttt{numpy.polynomial.polynomial.polyfit()} verwendet werden, genauso
wie bei der Polynominterpolation. Diesmal jedoch mit einem kleineren
Polynomgrad.

Im folgenden Beispiel werden zunächst Modelldaten generiert und dann mit
entsprechenden Polynomen gefittet.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{xmin }\OperatorTok{=} \DecValTok{0}
\NormalTok{xmax }\OperatorTok{=} \DecValTok{5}
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.linspace(xmin, xmax, }\DecValTok{100}\NormalTok{)}

\NormalTok{ni }\OperatorTok{=} \DecValTok{25}

\CommentTok{\# x{-}Werte mit leichtem Rauschen}
\NormalTok{xi }\OperatorTok{=}\NormalTok{ np.linspace(xmin, xmax, ni) }\OperatorTok{+} \FloatTok{0.2}\OperatorTok{*}\NormalTok{(}\DecValTok{2} \OperatorTok{*}\NormalTok{ np.random.random(ni) }\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}

\CommentTok{\# y(x) = 2x+0.5 mit leichtem Rauschen}
\NormalTok{yi }\OperatorTok{=} \DecValTok{2}\OperatorTok{*}\NormalTok{xi }\OperatorTok{+} \FloatTok{0.5} \OperatorTok{+} \DecValTok{2}\OperatorTok{*}\NormalTok{(}\DecValTok{2} \OperatorTok{*}\NormalTok{ np.random.random(ni) }\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}

\NormalTok{plt.scatter(xi, yi, color}\OperatorTok{=}\StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.grid()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-datenfitting-und-optimierung/skript/fitting_files/figure-pdf/cell-3-output-1.png}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{P1 }\OperatorTok{=}\NormalTok{ poly.polyfit(xi, yi, }\DecValTok{1}\NormalTok{)}

\NormalTok{plt.scatter(xi, yi, color}\OperatorTok{=}\StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{, zorder}\OperatorTok{=}\DecValTok{3}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Messpunkte\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(x, poly.polyval(x, P1), color}\OperatorTok{=}\StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{"Modellfunktion"}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.legend()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-datenfitting-und-optimierung/skript/fitting_files/figure-pdf/cell-4-output-1.png}}

In diesem Beispiel werden ein Polynom ersten Grades und ein Polynom
zweiten Grades bestimmt.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# x{-}Werte mit leichtem Rauschen}
\NormalTok{xi }\OperatorTok{=}\NormalTok{ np.linspace(xmin, xmax, ni) }\OperatorTok{+} \FloatTok{0.2}\OperatorTok{*}\NormalTok{(}\DecValTok{2} \OperatorTok{*}\NormalTok{ np.random.random(ni) }\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}

\CommentTok{\# y(x) = 2x+0.5 mit leichtem Rauschen}
\NormalTok{yi }\OperatorTok{=}\NormalTok{ (xi }\OperatorTok{{-}} \DecValTok{2}\NormalTok{)}\OperatorTok{**}\DecValTok{2} \OperatorTok{{-}}\DecValTok{2}\OperatorTok{*}\NormalTok{xi }\OperatorTok{+} \FloatTok{2.5} \OperatorTok{+} \DecValTok{2}\OperatorTok{*}\NormalTok{(}\DecValTok{2} \OperatorTok{*}\NormalTok{ np.random.random(ni) }\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{P1 }\OperatorTok{=}\NormalTok{ poly.polyfit(xi, yi, }\DecValTok{1}\NormalTok{)}
\NormalTok{P2 }\OperatorTok{=}\NormalTok{ poly.polyfit(xi, yi, }\DecValTok{2}\NormalTok{)}

\NormalTok{plt.scatter(xi, yi, color}\OperatorTok{=}\StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{, zorder}\OperatorTok{=}\DecValTok{3}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Messpunkte\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(x, poly.polyval(x, P1), color}\OperatorTok{=}\StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{"Modellfunktion, Grad 1"}\NormalTok{)}
\NormalTok{plt.plot(x, poly.polyval(x, P2), color}\OperatorTok{=}\StringTok{\textquotesingle{}C2\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{"Modellfunktion, Grad 2"}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.legend()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-datenfitting-und-optimierung/skript/fitting_files/figure-pdf/cell-6-output-1.png}}

\chapter{Splines}\label{splines}

Polynominterpolation versucht eine globale Modellfunktion zu finden.
Jedoch eignen sich Polynome mit hohen Graden im Allgemeinen nicht für
eine Interpolation vieler Punkte. Einen anderen Ansatz verfolgen Splines
(auch: Polynomzug), welche mehrere, niedrige Polynome zur Interpolation
vieler Punkte verwenden. Die Polynome haben typischerweise Grade
zwischen eins und drei.

\section{Definition}\label{definition-1}

Für \(n+1\) Messpunkte \((x_i, y_i)\) kann eine Splinefunktion \(s_k\),
hier ein Polynomspline, wie folgt definiert werden:

\begin{itemize}
\tightlist
\item
  Vorausgesetzt ist, dass die Messpunkte sortiert sind, d.~h.
  \(x_0 < x_1 < \cdots < x_n\).
\item
  Für jedes \(i = 0\dots n − 1\) ist \(s_k\) ein Polynom vom Grad \(k\)
  auf dem Intervall \(\left[x_i , x_{i+1}\right]\)
\item
  \(s_k\) ist auf \(\left[x_0 , x_n \right]\) \((k − 1)\)-mal stetig
  differenzierbar
\end{itemize}

Beispiele:

\begin{itemize}
\tightlist
\item
  \(k = 1\): Polygonzug
\item
  \(k = 3\): kubische Polynomsplines (B-Splines)
\end{itemize}

\section{Kubische Splines}\label{kubische-splines}

Die in der Praxis häufig eingesetzten kubischen Polynomsplines \(s_3\)
(\(k = 3\)) haben folgende Eigenschaften:

\begin{itemize}
\tightlist
\item
  \(s_3|\left[x_i,x_{i+1}\right] = \beta_0 +\beta_1 x + \beta_2 x^2 + \beta_3 x^3\)
\item
  \(s_3\) ist zweimal stetig differenzierbar auf
  \(\left[x_0,x_n\right]\), also insbesondere an den Stützpunkten
  \(x_i\) der Messpunkte.
\end{itemize}

Die Koeffizienten \(\beta_i\) werden wie folgt bestimmt:

\begin{itemize}
\item
  Aus den \(n + 1\) Messpunkten ergeben sich \(n\) Intervalle, d.~h. mit
  jeweils vier Koeffizienten sind es insgesamt \(4n\) Koeffizienten.
\item
  Exakte Darstellung der Messpunkte (\(n + 1\) Gleichungen), d.~h.:
  \(s_3(x_i) = y_i\)
\item
  Glattheitsbedingungen an den inneren Messpunkten (\(i=1 \dots n-1\)),
  mit jeweils (\(n − 1\) Gleichungen): \[
  s_3'(x_i)_- =s_3'(x_i)_+
  \] \[
  s_3''(x_i)_- =s_3''(x_i)_+
  \] \[
  s_3'''(x_i)_- =s_3'''(x_i)_+
  \]
\item
  Damit sind es \(4n − 2\) Gleichungen für \(4n\) Koeffizienten.
\end{itemize}

Um die beiden fehlenden Gleichungen zu finden bzw. zu bestimmen, werden
Randbedingungen oder Abschlussbedingungen benötigt. Die gängigsten
Bedingungen sind:

\begin{itemize}
\item
  natürliche Splines: die Krümung am Rand verschwindet, d.~h.: \[
  s_3''(x_0) = s_3''(x_n) = 0
  \]
\item
  periodische Splines: die Steigung und Krümung ist an beiden Rändern
  gleich \[
  s_3'(x_0) = s_3'(x_n)
  \]
\end{itemize}

\[
s_3''(x_0) = s_3''(x_n)
\]

\begin{itemize}
\tightlist
\item
  Hermite Splines: die Steigungen am Rand werden explizit vorgegeben
  (hier durch \(u\) und \(v\)) \[
  s_3'(x_0) = u
  \] \[
  s_3'(x_n) = v
  \]
\end{itemize}

\section{Anwendung}\label{anwendung}

Im Folgenden werden zwei Beispiele, \(s_1\) und \(s_3\), für die
Erstellung von Splines mit Python vorgestellt.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Erzeugung von Messpunkten}
\NormalTok{n }\OperatorTok{=} \DecValTok{7}
\NormalTok{xi }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, np.pi, n)}
\NormalTok{yi }\OperatorTok{=}\NormalTok{ np.sin(xi)}
\end{Highlighting}
\end{Shaded}

Für die \(s_1\) Splines, kann die Funktion \texttt{np.interp()}
verwendet werden. Sie führt eine lineare Interpolation zwischen
gegebenen Wertepaaren durch.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Wertebereich für die Visualisierung der Interpolation}
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, np.pi, n}\OperatorTok{*}\DecValTok{6}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ np.sin(x)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Interpolation}
\NormalTok{y\_s1 }\OperatorTok{=}\NormalTok{ np.interp(x, xi, yi)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x,y, alpha}\OperatorTok{=}\FloatTok{0.3}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}C2\textquotesingle{}}\NormalTok{, lw}\OperatorTok{=}\DecValTok{5}\NormalTok{, }
\NormalTok{         label}\OperatorTok{=}\StringTok{\textquotesingle{}Generierende Funktion\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(x, y\_s1, color}\OperatorTok{=}\StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Interpolation\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.scatter(x, y\_s1, s}\OperatorTok{=}\DecValTok{3}\NormalTok{, zorder}\OperatorTok{=}\DecValTok{3}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.scatter(xi, yi, color}\OperatorTok{=}\StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Messpunkte\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}y\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}\OperatorTok{;}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-datenfitting-und-optimierung/skript/splines_files/figure-pdf/cell-6-output-1.png}}

~

Die \(s_3\) Splines können mit Funktionen aus dem scipy-Modul berechnet
werden. Dazu werden zunächst die Koeffizienten bestimmt
(\texttt{scipy.interpolate.splrep}) und diese ermöglichen die gewünschte
Auswertung, welche mit der Funktion \texttt{scipy.interpolate.splev}
vorgenommen werden kann.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ scipy.interpolate }\ImportTok{as}\NormalTok{ si}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s3 }\OperatorTok{=}\NormalTok{ si.splrep(xi, yi)}
\NormalTok{y\_s3 }\OperatorTok{=}\NormalTok{ si.splev(x, s3)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(x,y, alpha}\OperatorTok{=}\FloatTok{0.3}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}C2\textquotesingle{}}\NormalTok{, lw}\OperatorTok{=}\DecValTok{5}\NormalTok{, }
\NormalTok{         label}\OperatorTok{=}\StringTok{\textquotesingle{}Generierende Funktion\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(x, y\_s3, color}\OperatorTok{=}\StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Interpolation\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.scatter(x, y\_s3, s}\OperatorTok{=}\DecValTok{3}\NormalTok{, zorder}\OperatorTok{=}\DecValTok{3}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.scatter(xi, yi, color}\OperatorTok{=}\StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Messpunkte\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}y\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}\OperatorTok{;}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-datenfitting-und-optimierung/skript/splines_files/figure-pdf/cell-9-output-1.png}}

\chapter{Trendglättung -- Rauschen
reduzieren}\label{trendgluxe4ttung-rauschen-reduzieren}

Verrauschte Daten? Ein \textbf{gleitender Mittelwert} glättet Kurven:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data }\OperatorTok{=}\NormalTok{ np.genfromtxt(}\StringTok{"01{-}daten/trenddaten{-}mit{-}rauschen.csv"}\NormalTok{, delimiter}\OperatorTok{=}\StringTok{","}\NormalTok{, skip\_header}\OperatorTok{=}\DecValTok{1}\NormalTok{)}
\NormalTok{x }\OperatorTok{=}\NormalTok{ data[:, }\DecValTok{0}\NormalTok{]}
\NormalTok{y }\OperatorTok{=}\NormalTok{ data[:, }\DecValTok{1}\NormalTok{]}

\NormalTok{window }\OperatorTok{=} \DecValTok{5}
\NormalTok{weights }\OperatorTok{=}\NormalTok{ np.ones(window) }\OperatorTok{/}\NormalTok{ window}
\NormalTok{y\_smooth }\OperatorTok{=}\NormalTok{ np.convolve(y, weights, mode}\OperatorTok{=}\StringTok{\textquotesingle{}valid\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.plot(x, y, label}\OperatorTok{=}\StringTok{"Original"}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.5}\NormalTok{)}
\NormalTok{plt.plot(x[(window}\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}\OperatorTok{//}\DecValTok{2}\NormalTok{:}\OperatorTok{{-}}\NormalTok{(window}\OperatorTok{//}\DecValTok{2}\NormalTok{)], y\_smooth, label}\OperatorTok{=}\StringTok{"Geglättet"}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.grid(}\VariableTok{True}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{"Trendglättung"}\NormalTok{)}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-datenfitting-und-optimierung/skript/glaetten_files/figure-pdf/cell-3-output-1.png}}

\chapter{Übungen}\label{uxfcbungen-1}

\section{Übung: Ballonfahrt-Daten
analysieren}\label{uxfcbung-ballonfahrt-daten-analysieren}

In der Datei `01-daten/messdaten-ballonfahrt.txt' sind Messdaten zur
Höhe eines Ballons während einer Ballonfahrt gespeichert. In der ersten
Zeile der Datei sind die gemessenen Größen und ihre Einheit notiert.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Dateikopf als String einlesen}
\NormalTok{ballon }\OperatorTok{=}\NormalTok{ np.genfromtxt(}\StringTok{"01{-}daten/messdaten{-}ballonfahrt.txt"}\NormalTok{, delimiter}\OperatorTok{=}\StringTok{","}\NormalTok{, max\_rows}\OperatorTok{=} \DecValTok{4}\NormalTok{, dtype}\OperatorTok{=}\StringTok{\textquotesingle{}str\textquotesingle{}}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Der Kopf der Datei:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(ballon)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der Kopf der Datei:
[['Zeit (s)' 'Hoehe (m)']
 ['0.0' '49.93175839467537']
 ['2.0202020202020203' '52.11727320291297']
 ['4.040404040404041' '50.0624468191306']]
\end{verbatim}

Schauen wir uns die Daten einmal an:

\pandocbounded{\includegraphics[keepaspectratio]{books/m-datenfitting-und-optimierung/skript/uebungen_files/figure-pdf/cell-4-output-1.png}}

~

Gesucht ist ein Polynom, das die Steiggeschwindigkeit, also die Änderung
der Höhe mit der Zeit, des Heißluftballons beschreibt.

Schreiben Sie ein Programm, das:

\begin{itemize}
\tightlist
\item
  die Höhe aus den Daten ausliest und die Steiggeschwindigkeit
  berechnet,
\item
  einen Fit der Steiggeschwindigkeit mit einem Polynom dritten Grades
  durchführt.
\end{itemize}

Stellen Sie die Höhe, die Geschwindigkeit und den Fit jeweils gegen die
Zeit dar. Beschriften Sie die Achsen.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-musterloesung-ballon}: Musterlösung Ballonfahrt}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-musterloesung-ballon} 

Zuerst werden die Daten ausgelesen.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Daten auslesen}
\NormalTok{ballon }\OperatorTok{=}\NormalTok{ np.genfromtxt(}\StringTok{"01{-}daten/messdaten{-}ballonfahrt.txt"}\NormalTok{, delimiter}\OperatorTok{=}\StringTok{","}\NormalTok{, skip\_header}\OperatorTok{=}\DecValTok{1}\NormalTok{)}
\NormalTok{zeit }\OperatorTok{=}\NormalTok{ ballon[:, }\DecValTok{0}\NormalTok{]}
\NormalTok{hoehe }\OperatorTok{=}\NormalTok{ ballon[:, }\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Anschließend berechnen wir die Steiggeschwindigkeit
\(\frac{\Delta Höhe}{\Delta Zeit}\). Dazu verwenden wir die Funktion
\texttt{np.diff()}. Diese berechnet die Differenz jedes Werts zu seinem
Vorgänger \texttt{ergebnis{[}i{]}\ =\ wert{[}i+1{]}\ -\ wert{[}i{]}}.
Für den i-ten Wert wird also keine Differenz berechnet und das Ergebnis
ist um ein Element kürzer. Die Steiggeschwindigkeit in \(\frac{m}{s}\)
ergibt sich aus dem Quotienten beider Reihen.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Differenzen berechnen}
\NormalTok{delta\_hoehe }\OperatorTok{=}\NormalTok{ np.diff(hoehe)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Veränderung der Höhe: "}\NormalTok{, delta\_hoehe[}\DecValTok{0}\NormalTok{:}\DecValTok{4}\NormalTok{])}

\NormalTok{delta\_zeit }\OperatorTok{=}\NormalTok{ np.diff(zeit)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Veränderung der Zeit: "}\NormalTok{, delta\_zeit[}\DecValTok{0}\NormalTok{:}\DecValTok{4}\NormalTok{])}

\CommentTok{\# Steiggeschwindigkeit berechnen}
\NormalTok{steiggeschwindigkeit }\OperatorTok{=}\NormalTok{ delta\_hoehe }\OperatorTok{/}\NormalTok{ delta\_zeit}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Steiggeschwindigkeit: "}\NormalTok{, steiggeschwindigkeit[}\DecValTok{0}\NormalTok{:}\DecValTok{4}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Veränderung der Höhe:  [ 2.18551481 -2.05482638  0.32026988  1.12796595]
Veränderung der Zeit:  [2.02020202 2.02020202 2.02020202 2.02020202]
Steiggeschwindigkeit:  [ 1.08182983 -1.01713906  0.15853359  0.55834314]
\end{verbatim}

Mit \texttt{numpy.polynomial.polynomial.polyfit()} berechnen wir erst
ein Polynom dritten Grades und dann mit
\texttt{numpy.polynomial.polynomial.polyval()} die gefitteten Daten.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{polynom3\_steiggeschwindigkeit }\OperatorTok{=}\NormalTok{ poly.polyfit(zeit[:}\OperatorTok{{-}}\DecValTok{1}\NormalTok{], steiggeschwindigkeit, deg }\OperatorTok{=} \DecValTok{3}\NormalTok{)}

\NormalTok{fit\_steiggeschwindigkeit }\OperatorTok{=}\NormalTok{ poly.polyval(x }\OperatorTok{=}\NormalTok{ zeit[:}\OperatorTok{{-}}\DecValTok{1}\NormalTok{], c }\OperatorTok{=}\NormalTok{ polynom3\_steiggeschwindigkeit)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# plotten}
\NormalTok{plt.suptitle(}\StringTok{"Ballonfahrt"}\NormalTok{)}

\CommentTok{\#\# subplot Höhe über Zeit}
\NormalTok{plt.subplot(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{plt.scatter(zeit, hoehe)}
\NormalTok{plt.title(}\StringTok{"Höhe"}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{"Zeit (s)"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"Höhe (m)"}\NormalTok{)}
\NormalTok{plt.grid(}\VariableTok{True}\NormalTok{)}

\CommentTok{\#\# subplot Steiggeschwindigkeit über Zeit}
\CommentTok{\#\# Länge des Arrays Steiggeschwindigkeit ist n{-}1}
\NormalTok{plt.subplot(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{plt.scatter(zeit[:}\OperatorTok{{-}}\DecValTok{1}\NormalTok{], steiggeschwindigkeit)}
\NormalTok{plt.title(}\StringTok{"Steiggeschwindigkeit"}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{"Zeit (s)"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"Steiggeschwindigkeit (m/s)"}\NormalTok{)}
\NormalTok{plt.grid(}\VariableTok{True}\NormalTok{)}

\CommentTok{\#\# subplot Polynom 3. Grades Steiggeschwinkdigkeit über Zeit}
\CommentTok{\#\# Länge des Arrays Steiggeschwindigkeit ist n{-}1}
\NormalTok{plt.subplot(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{plt.plot(zeit[:}\OperatorTok{{-}}\DecValTok{1}\NormalTok{], fit\_steiggeschwindigkeit)}
\NormalTok{plt.title(}\StringTok{"interpolierte}\CharTok{\textbackslash{}n}\StringTok{Steiggeschwindigkeit"}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{"Zeit (s)"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"Steiggeschwindigkeit (m/s)"}\NormalTok{)}
\NormalTok{plt.grid(}\VariableTok{True}\NormalTok{)}

\NormalTok{plt.tight\_layout()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-datenfitting-und-optimierung/skript/uebungen_files/figure-pdf/cell-8-output-1.png}}

\end{tcolorbox}

\section{Übung: Balkenverformung im
Bauingenieurwesen}\label{uxfcbung-balkenverformung-im-bauingenieurwesen}

Ein Träger wird in der Mitte belastet.

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/m-datenfitting-und-optimierung/skript/00-bilder/balkenverformung-universität-der-bundeswehr.jpeg}}

}

\caption{Beispiel für einen Versuchsaufbau Balkenverformung}

\end{figure}%

Balkenverformung von Universität der Bundeswehr München. Das Werk ist
abrufbar auf der Internetseite der
\href{https://www.unibw.de/mechanik-und-statik/bs/labor-baustatik/ermittlung-der-verformung-von-geraden-balken}{UniBw
M}. ohne Jahr

~

Schauen wir uns die Struktur der Daten einmal an.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{balken }\OperatorTok{=}\NormalTok{ np.genfromtxt(}\StringTok{"01{-}daten/balken{-}durchbiegung.csv"}\NormalTok{, delimiter}\OperatorTok{=}\StringTok{","}\NormalTok{, max\_rows}\OperatorTok{=} \DecValTok{4}\NormalTok{, dtype}\OperatorTok{=}\StringTok{\textquotesingle{}str\textquotesingle{}}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Der Kopf der Datei:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(balken)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der Kopf der Datei:
[['Position (m)' 'Durchbiegung (mm)']
 ['0.0' '-0.28820719619532215']
 ['0.20408163265306123' '-0.22193122300286544']
 ['0.40816326530612246' '0.013978362500916705']]
\end{verbatim}

Die Durchbiegung wird an 50 Punkten gemessen. Glätten Sie die Daten und
stellen Sie die gemessenen und die geglätteten Daten gemeinsam dar.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-musterloesung-balken}: Musterlösung Balken}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-musterloesung-balken} 

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{balken }\OperatorTok{=}\NormalTok{ np.genfromtxt(}\StringTok{"01{-}daten/balken{-}durchbiegung.csv"}\NormalTok{, delimiter}\OperatorTok{=}\StringTok{","}\NormalTok{, skip\_header}\OperatorTok{=}\DecValTok{1}\NormalTok{)}
\NormalTok{x }\OperatorTok{=}\NormalTok{ balken[:, }\DecValTok{0}\NormalTok{]}
\NormalTok{y }\OperatorTok{=}\NormalTok{ balken[:, }\DecValTok{1}\NormalTok{]}

\NormalTok{window }\OperatorTok{=} \DecValTok{7}
\NormalTok{weights }\OperatorTok{=}\NormalTok{ np.ones(window) }\OperatorTok{/}\NormalTok{ window}
\NormalTok{y\_smooth }\OperatorTok{=}\NormalTok{ np.convolve(y, weights, mode}\OperatorTok{=}\StringTok{\textquotesingle{}valid\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.plot(x, y, label}\OperatorTok{=}\StringTok{"Messung"}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.5}\NormalTok{)}
\NormalTok{plt.plot(x[(window}\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}\OperatorTok{//}\DecValTok{2}\NormalTok{:}\OperatorTok{{-}}\NormalTok{(window}\OperatorTok{//}\DecValTok{2}\NormalTok{)], y\_smooth, label}\OperatorTok{=}\StringTok{"Geglättet"}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{"Durchbiegung eines Trägers"}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{"Position (m)"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"Durchbiegung (mm)"}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.grid(}\VariableTok{True}\NormalTok{)}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-datenfitting-und-optimierung/skript/uebungen_files/figure-pdf/cell-10-output-1.png}}

\end{tcolorbox}

\section{Übung: Neutronenstreuung}\label{uxfcbung-neutronenstreuung}

Die Datei `01-daten/neutronen.txt' enthält Daten eines
Neutronenstreuexperiments. Der Dateikopf:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Dateikopf als String einlesen}
\NormalTok{neutronen }\OperatorTok{=}\NormalTok{ np.genfromtxt(}\StringTok{"01{-}daten/neutronen.txt"}\NormalTok{, delimiter}\OperatorTok{=}\StringTok{"}\CharTok{\textbackslash{}t}\StringTok{"}\NormalTok{, max\_rows}\OperatorTok{=} \DecValTok{4}\NormalTok{, dtype}\OperatorTok{=}\StringTok{\textquotesingle{}str\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(neutronen)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[['E(MeV)' 'sigma(mb)' 'Delta sigma(mb)']
 ['0.00' '10.60' ' 1.39']
 ['25.00' '16.00' ' 2.09']
 ['50.00' '45.00' ' 3.85']]
\end{verbatim}

In der Spalte `E(MeV)' ist die Energie eines Neutrons, das auf ein Ziel
geschossen wird, in Megaelektronenvolt eingetragen. In der Spalte
`sigma(mb)' ist der Wirkungsquerschnitt, gemessen in Millibarn (mb),
eingetragen. In der Spalte `Delta sigma(mb)' ist die Unsicherheit des
gemessenen Wirkungsquerschnitts, ebenfalls in Millibarn (mb),
eingetragen.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Lesen Sie die Daten ein
\item
  Versuchen Sie die ersten zwei Spalten mit einem Polynom eines
  geeigneten Grades zu fitten und stellen Sie das Ergebnis graphisch
  dar.
\item
  Fitten Sie die Daten erneut, aber nutzen Sie dieses Mal Splines.
\item
  Stellen Sie das Ergebnis ebenfalls graphisch dar und vergleichen Sie
  mit den Polynomfit.
\item
  Was sind die Vor- und Nachteile der jeweiligen Varianten?
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-musterloesung-neutronen}: Musterlösung Neutronenstreuung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-musterloesung-neutronen} 

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Daten einlesen
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{neutronen }\OperatorTok{=}\NormalTok{ np.genfromtxt(}\StringTok{"01{-}daten/neutronen.txt"}\NormalTok{, delimiter}\OperatorTok{=}\StringTok{"}\CharTok{\textbackslash{}t}\StringTok{"}\NormalTok{, skip\_header}\OperatorTok{=}\DecValTok{1}\NormalTok{)}
\NormalTok{neutronenenergie }\OperatorTok{=}\NormalTok{ neutronen[:, }\DecValTok{0}\NormalTok{]}
\NormalTok{wirkungsquerschnitt }\OperatorTok{=}\NormalTok{ neutronen[:, }\DecValTok{1}\NormalTok{]}

\NormalTok{plt.plot(neutronenenergie, wirkungsquerschnitt, label}\OperatorTok{=}\StringTok{"Messdaten"}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.5}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{"Neutronenenergie (MeV)"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"Wirkungsquerschnitt (mb)"}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.grid(}\VariableTok{True}\NormalTok{)}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-datenfitting-und-optimierung/skript/uebungen_files/figure-pdf/cell-12-output-1.png}}

~

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  \begin{itemize}
  \tightlist
  \item
    \begin{enumerate}
    \def\labelenumii{\arabic{enumii}.}
    \setcounter{enumii}{2}
    \tightlist
    \item
      Polynom und Splines fitten:
    \end{enumerate}
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Polynom }
\NormalTok{polynom5 }\OperatorTok{=}\NormalTok{ poly.polyfit(neutronenenergie, wirkungsquerschnitt, deg }\OperatorTok{=} \DecValTok{5}\NormalTok{)}
\NormalTok{fit }\OperatorTok{=}\NormalTok{  poly.polyval(x }\OperatorTok{=}\NormalTok{ neutronenenergie, c }\OperatorTok{=}\NormalTok{ polynom5)}

\CommentTok{\# Splines mit scipy}
\NormalTok{splines3 }\OperatorTok{=}\NormalTok{ si.splrep(neutronenenergie, wirkungsquerschnitt)}
\NormalTok{y\_splines3 }\OperatorTok{=}\NormalTok{ si.splev(neutronenenergie, splines3)}

\CommentTok{\# Splines mit NumPy}
\NormalTok{x\_neu }\OperatorTok{=}\NormalTok{ np.linspace(neutronenenergie.}\BuiltInTok{min}\NormalTok{(), neutronenenergie.}\BuiltInTok{max}\NormalTok{(), num}\OperatorTok{=}\DecValTok{50}\NormalTok{)}
\NormalTok{y\_splines1 }\OperatorTok{=}\NormalTok{ np.interp(x\_neu, neutronenenergie, wirkungsquerschnitt) }\CommentTok{\# linear interpolieren}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Grafische Darstellung:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.figure(figsize }\OperatorTok{=}\NormalTok{ [}\DecValTok{7}\NormalTok{, }\DecValTok{5}\NormalTok{])}

\CommentTok{\# Vergleich mit kubischen Splines}
\NormalTok{plt.subplot(}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{plt.plot(neutronenenergie, wirkungsquerschnitt, linewidth }\OperatorTok{=} \DecValTok{5}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.3}\NormalTok{, label}\OperatorTok{=}\StringTok{"Messdaten"}\NormalTok{)}
\NormalTok{plt.plot(neutronenenergie, fit, label }\OperatorTok{=} \StringTok{"gefittetes Polynom"}\NormalTok{)}
\NormalTok{plt.plot(neutronenenergie, y\_splines3, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}dashdot\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{"kubische Splines"}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{"Neutronenenergie (MeV)"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"Wirkungsquerschnitt (mb)"}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.grid(}\VariableTok{True}\NormalTok{)}

\CommentTok{\# Vergleich mit linearen Splines}
\NormalTok{plt.subplot(}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{plt.plot(neutronenenergie, wirkungsquerschnitt, linewidth }\OperatorTok{=} \DecValTok{5}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.3}\NormalTok{, label}\OperatorTok{=}\StringTok{"Messdaten"}\NormalTok{)}
\NormalTok{plt.plot(neutronenenergie, fit, label }\OperatorTok{=} \StringTok{"gefittetes Polynom"}\NormalTok{)}

\NormalTok{plt.plot(x\_neu, y\_splines1, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}dotted\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}lineare Splines\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{"Neutronenenergie (MeV)"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"Wirkungsquerschnitt (mb)"}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.grid(}\VariableTok{True}\NormalTok{)}

\NormalTok{plt.tight\_layout()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-datenfitting-und-optimierung/skript/uebungen_files/figure-pdf/cell-14-output-1.png}}

~

5.: Die Splines bilden die Daten exakt nach. Das kann ein Vorteil sein,
wenn keine Glättung der Daten gewünscht ist. Das Polynom ist dagegen
nicht exakt an die Daten angepasst. Dafür können alle Datenpunkte mit
einer einzigen Modellgleichung approximiert werden.

\end{tcolorbox}

\part{a-energiedatenanalyse}

\chapter*{Methodenbaustein
Sensordatenanalyse}\label{methodenbaustein-sensordatenanalyse}
\addcontentsline{toc}{chapter}{Methodenbaustein Sensordatenanalyse}

\markboth{Methodenbaustein Sensordatenanalyse}{Methodenbaustein
Sensordatenanalyse}

\phantomsection\label{Lizenz}
\begin{figure}

\begin{minipage}{0.20\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/m-sensordatenanalyse/skript/00-bilder/CC-BY.pdf}}\end{minipage}%
%
\begin{minipage}{0.80\linewidth}
Bausteine Computergestützter Datenanalyse von Lukas Arnold, Simone
Arnold, Florian Bagemihl, Matthias Baitsch, Marc Fehr, Franca Hollmann,
Maik Poetzsch und Sebastian Seipel. Methodenbaustein Sensordatenanalyse
von Maik Poetzsch ist lizensiert unter
\href{https://creativecommons.org/licenses/by/4.0/deed.de}{CC BY 4.0}.
Das Werk ist abrufbar auf
\href{https://github.com/bausteine-der-datenanalyse/m-sensordatenanalyse}{GitHub}.
Ausgenommen von der Lizenz sind alle Logos Dritter und anders
gekennzeichneten Inhalte. 2025\end{minipage}%

\end{figure}%

Zitiervorschlag

Arnold, Lukas, Simone Arnold, Florian Bagemihl, Matthias Baitsch, Marc
Fehr, Franca Hollmann, Maik Poetzsch, und Sebastian Seipel. 2025.
``Bausteine Computergestützter Datenanalyse. Methodenbaustein
Sensordatenanalyse.''
\url{https://github.com/bausteine-der-datenanalyse/m-sensordatenanalyse}.

BibTeX-Vorlage

\begin{verbatim}
@misc{BCD-m-sensordatenanalyse-2025,
 title={Bausteine Computergestützter Datenanalyse. Methodenbaustein Sensordatenanalyse},
 author={Arnold, Lukas and Arnold, Simone and Bagemihl, Florian and Baitsch, Matthias and Fehr, Marc and Hollmann, Franca and Poetzsch, Maik and Seipel, Sebastian},
 year={2025},
 url={https://github.com/bausteine-der-datenanalyse/m-sensordatenanalyse}} 
\end{verbatim}

\chapter*{Voraussetzungen}\label{voraussetzungen-9}
\addcontentsline{toc}{chapter}{Voraussetzungen}

\markboth{Voraussetzungen}{Voraussetzungen}

Die Bearbeitungszeit dieses Bausteins beträgt circa 30 Stunden. Für die
Bearbeitung dieses Bausteins werden folgende Bausteine vorausgesetzt:

\begin{itemize}
\tightlist
\item
  Werkzeugbaustein Python
\item
  Werkzeugbaustein NumPy
\item
  Werkzeugbaustein Pandas
\item
  Werkzeugbaustein matplotlib
\end{itemize}

In diesem Baustein werden die folgenden Module und Pakete verwendet:

\begin{itemize}
\tightlist
\item
  numpy

  \begin{itemize}
  \tightlist
  \item
    numpy.polynomial
  \end{itemize}
\item
  pandas
\item
  openpyxl
\item
  matplotlib
\item
  glob
\item
  scipy Version 1.14.1
\end{itemize}

Im Baustein werden folgende Daten verwendet:

\begin{itemize}
\tightlist
\item
  Zahnwachstum bei Meerschweinchen
  \href{https://github.com/vincentarelbundock/Rdatasets/blob/master/csv/datasets/ToothGrowth.csv}{CSV-Datei}
\item
  Vermessung von Pinguinen an der Palmer Station
  \href{https://github.com/allisonhorst/palmerpenguins?tab=readme-ov-file\#meet-the-palmer-penguins}{GitHub}
\item
  Elektrische Widerstandswerte eines Pt100-Thermometers aus der DIN
  60751 und von
  \href{https://s8b8d6a7.delivery.rocketcdn.me/wp-content/uploads/2022/08/Pt100-Tabelle-Screen.pdf}{hier
  (PDF)}
\item
  Abstandsmessungen mit einem Ultraschallsensor (Messungen an der FH
  Dortmund)
\item
  Temperaturmessungen mit einem Widerstandsthermometer (Messungen an der
  FH Dortmund)
\end{itemize}

\chapter*{Lernziele}\label{lernziele-9}
\addcontentsline{toc}{chapter}{Lernziele}

\markboth{Lernziele}{Lernziele}

In diesen Baustein lernen Sie \ldots{}

\begin{itemize}
\tightlist
\item
  Statistische Grundbegriffe
\item
  Werkzeuge zur Auswertung und grafischen Darstellung von Sensordaten
  kennen
\item
  Methoden zur Verarbeitung von mehreren Dateien anzuwenden
\item
  Fehlerrechnung und -analyse
\item
  Sensorkennlinien
\item
  Kennlinienfehler und deren Korrektur
\end{itemize}

\chapter{Das Prinzip von Messungen}\label{sec-einleitung}

\begin{figure}

\begin{minipage}{0.05\linewidth}
~\end{minipage}%
%
\begin{minipage}{0.90\linewidth}
``In der Physik existiert nur das, was gemessen worden ist'' (Merz 1968,
14).\end{minipage}%
%
\begin{minipage}{0.05\linewidth}
~\end{minipage}%
\newline
\begin{minipage}{\linewidth}
Merz, Ludwig.1968. ``Grundkurs der Messtechnik. Teil I: Das Messen
elektrischer Größen.'' 2. Auflage. München;Wien. R. Oldenbourg
Verlag.\end{minipage}%

\end{figure}%

In diesem Baustein werden die folgenden Module verwendet:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ numpy.polynomial.polynomial }\ImportTok{as}\NormalTok{ poly}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}
\ImportTok{import}\NormalTok{ scipy}
\ImportTok{import}\NormalTok{ glob}
\end{Highlighting}
\end{Shaded}

Physikalische Größen werden mit der Hilfe von Messgeräten bestimmt.
Diese ordnen der tatsächlichen Merkmalsausprägung eine numerische
Entsprechung relativ zu einem Bezugssystem zu.

Ein Beispiel: ``Johanna ist am Messbrett 173 Zentimeter groß.''

\begin{itemize}
\tightlist
\item
  Die tatsächliche Merkmalsausprägung ist Johannas Größe.
\item
  Das Messgerät ist das Messbrett.
\item
  Die numerische Entsprechung ist 173.
\item
  Das Bezugssystem ist das metrische System.
\end{itemize}

Messwerte können aus verschiedenen Gründen immer nur eine Annäherungen
an den wahren Wert der zugrundeliegenden physikalischen Größe sein. Zum
einen variiert die
\href{https://www.barmer.de/presse/presseinformationen/newsletter-gesundheit-im-blick/koerpergroesse-1126334}{Größe
eines Menschen im Tagesverlauf}. Zum anderen ist das Messergebnis auch
ein Ergebnis der verwendeten Skala. Wäre die Messung im imperialen
Messsystem erfolgt, wäre Johannas Größe mit 68 Zoll bestimmt worden, was
172,72 Zentimetern entspricht.

Das Messergebnis ist also keine exakte Entsprechung der tatsächlichen
Merkmalsausprägung. Ein bekanntes Beispiel für die mit dem Messvorgang
verbundene Unsicherheit ist das Küstenlinienparadox: Das Ergebnis der
Vermessung unregelmäßiger Küstenlinien wird umso größer, je kleiner die
Messabschnitte gewählt werden.

\begin{figure}

\begin{minipage}{0.33\linewidth}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/00-bilder/Britain-fractal-coastline-200km-CCBYSA3.0vonMaksim.png}}

\subcaption{\label{}Gerade Messabschnitte von 200 km Länge, Gesamtlänge
ungefähr 2350 km}
\end{minipage}%
%
\begin{minipage}{0.33\linewidth}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/00-bilder/Britain-fractal-coastline-100km-CCBYSA3.0vonMaksim.png}}

\subcaption{\label{}Gerade Messabschnitte von 100 km Länge, Gesamtlänge
ungefähr 2775 km}
\end{minipage}%
%
\begin{minipage}{0.33\linewidth}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/00-bilder/Britain-fractal-coastline-50km-CCBYSA3.0vonMaksim.png}}

\subcaption{\label{}Gerade Messabschnitte von 50 km Länge, Gesamtlänge
ungefähr 3425 km}
\end{minipage}%

\caption{\label{fig-coastlines}Küstenlinienparadox}

\end{figure}%

Britain-fractal-coastline-200km, Britain-fractal-coastline-100km und
Britain-fractal-coastline-50km von Maksim stehen unter der Lizenz
\href{https://creativecommons.org/licenses/by-sa/3.0/deed.de}{CC BY-SA
3.0} und sind abrufbar auf Wikipedia
(\href{https://de.wikipedia.org/wiki/Datei:Britain-fractal-coastline-200km.png}{200km},
\href{https://de.wikipedia.org/wiki/Datei:Britain-fractal-coastline-100km.png}{100km},
\href{https://de.wikipedia.org/wiki/Datei:Britain-fractal-coastline-50km.png}{50km}).
2006

~

\section{Messung}\label{messung}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-Beispiel}: Messung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-Beispiel} 

``Eine Messung ist der experimentelle Vorgang, durch den ein spezieller
Wert einer physikalischen Größe als Vielfaches einer Einheit oder eines
Bezugswertes ermittelt wird.

Die Messung ergibt zunächst einen Messwert. Dieser stimmt aber aufgrund
störender Einflüsse mit dem wahren Wert der Messgröße praktisch nie
überein, sondern weist eine gewisse Messabweichung auf. Zum
\emph{vollständigen Messergebnis} wird der Messwert, wenn er mit
quantitativen Aussagen über die zu erwartende Größe der Messabweichung
ergänzt wird. Dies wird in der Messtechnik als Teil der Messaufgabe und
damit der Messung verstanden.''

Messung. von verschiedenen
\href{https://xtools.wmcloud.org/authorship/de.wikipedia.org/Messung}{Autor:innen}
steht unter der Lizenz
\href{https://creativecommons.org/licenses/by-sa/4.0/deed.de}{CC BY-SA
4.0} ist abrufbar auf
\href{https://de.wikipedia.org/wiki/Messung}{Wikipedia}. 2025

\begin{itemize}
\tightlist
\item
  Die ideale Messung ist eine direkte Messung oder der gesuchte Wert
  hängt linear vom gemessenen Wert ab.
\item
  Die ideale Messung ist \emph{genau} und \emph{präzise}.
\end{itemize}

\end{tcolorbox}

\subsection{Direkte und indirekte
Messung}\label{direkte-und-indirekte-messung}

Bei einer direkten Messung wird die Messgröße durch den unmittelbaren
Vergleich mit einem Normal oder einem genormten Bezugssystem gewonnen.

\begin{figure}

\begin{minipage}{0.50\linewidth}

\includegraphics[width=\linewidth,height=2.08333in,keepaspectratio]{books/m-sensordatenanalyse/skript/00-bilder/balkenwaage.png}

\subcaption{\label{}Balkenwaage}
\end{minipage}%
%
\begin{minipage}{0.50\linewidth}

\includegraphics[width=\linewidth,height=2.08333in,keepaspectratio]{books/m-sensordatenanalyse/skript/00-bilder/Gliedermaßstäbe-von-Fst76-CC-BY-SA-3.0.jpg}

\subcaption{\label{}Zollstock}
\end{minipage}%

\caption{\label{fig-direktemessung}Direkte Messung}

\end{figure}%

Gliedermaßstäbe von Fst76 ist lizensiert unter
\href{https://creativecommons.org/licenses/by-sa/3.0/}{CC-BY-SA 3.0} und
ist abrufbar auf
\href{https://commons.wikimedia.org/wiki/File:Gliederma\%C3\%9Fst\%C3\%A4be.jpg}{Wikimedia}.
2014

~

Bei einer indirekten Messung wird die Messgröße auf eine andere
physikalische Größe zurückgeführt.

\begin{figure}

\begin{minipage}{0.50\linewidth}

\includegraphics[width=\linewidth,height=2.08333in,keepaspectratio]{books/m-sensordatenanalyse/skript/00-bilder/Spring_scale-von-Amada44-CC-BY-SA-3.0unported.jpg}

\subcaption{\label{}Federwaage}
\end{minipage}%
%
\begin{minipage}{0.50\linewidth}

\includegraphics[width=\linewidth,height=2.08333in,keepaspectratio]{books/m-sensordatenanalyse/skript/00-bilder/observe-the-moon-NASA.png}

\subcaption{\label{}Laserentfernungsmessung}
\end{minipage}%

\caption{\label{fig-indirektemessung}Indirekte Messung}

\end{figure}%

Spring scale von Amada44 steht unter der Lizenz
\href{https://creativecommons.org/licenses/by-sa/3.0/deed.en}{CC-BY-SA-3.0
unported} und ist abrufbar auf
\href{https://commons.wikimedia.org/wiki/File:Spring_scale_-_3241.jpg}{Wikimedia}.
2016

Observe the Moon wurde von der NASA veröffentlicht und ist abrufbar
unter \href{https://www.nasa.gov/image-article/observe-moon/}{nasa.gov}.
2010

~

\subsection{Genauigkeit und
Präzision}\label{genauigkeit-und-pruxe4zision}

\begin{figure}

\begin{minipage}{0.50\linewidth}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/00-bilder/Genauigkeit.png}}

\subcaption{\label{}Genauigkeit}
\end{minipage}%
%
\begin{minipage}{0.50\linewidth}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/00-bilder/Präzision.png}}

\subcaption{\label{}Präsizion}
\end{minipage}%
\newline
\begin{minipage}{0.50\linewidth}
Die Genauigkeit einer Messung ist ein Maß für die Abweichung der
Messwerte vom realen Wert. Die Genauigkeit ist nur bestimmbar, wenn
anerkannte Referenzwerte vorhanden sind.\end{minipage}%
%
\begin{minipage}{0.50\linewidth}
Die Präzision einer Messung beschreibt, wie gut die einzelnen Messwerte
miteinander übereinstimmen. Die Präszision einer Messung wird über die
Standardabweichung der Stichprobe bestimmt.\end{minipage}%

\caption{\label{fig-genauigkeit}Genauigkeit und Präzision}

\end{figure}%

\section{Messreihen}\label{messreihen}

Um die Unsicherheit einer Messung zu verringern, kann man einen Messwert
in Form einer Messreihe wiederholt aufnehmen. Die beste Schätzung der
Messgröße bietet der arithmetische Mittelwert der Messreihe.

Der arithmetische Mittelwert einer Messreihe \(\bar{x}\) ist die Summe
aller Einzelmesswerte \(x_i\) dividiert durch die Anzahl der Messwerte
\(N\).

\[
\bar{x} = \frac{1}{N} \sum_{i=1}^{N} x_i
\]

Mit Hilfe des arithmetischen Mittelwerts kann eine Aussage über die
Streuung der Messwerte und die Präzision der Messung getroffen werden.
Dazu werden die Varianz und die Standardabweichung der Messreihe
berechnet.

\section{Varianz}

Die Varianz ist der Mittelwert der quadrierten Abweichungen vom
Mittelwert.

\[
\text{Var}(x_i) = \frac{1}{N} \sum_{i=1}^{N}(x_i - \bar{x})^2
\]

\section{Standardabweichung}

Die Quadratwurzel der Varianz wird als Standardabweichung bezeichnet.
Diese hat den Vorteil, dass sie in der Einheit der Messwerte vorliegt
und dadurch leichter zu interpretieren ist. Die Standardabweichung \(s\)
wird so berechnet:

\[
s_{N} = \sqrt{\frac{1}{N} \sum_{i=1}^{N}(x_i - \bar{x})^2}
\]

Für Stichproben wird die Stichprobenvarianz verwendet. Für die
Standardabweichung einer Stichprobe gilt:

\[
s_{N-1} = \sqrt{\frac{1}{N-1} \sum_{i=1}^{N}(x_i - \bar{x})^2}
\]

Da die Varianz das Quadrat der Standardabweichung \(s\) ist, wird diese
häufig mit \(s^{2}\) gekennzeichnet.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-Grundgesamtheit} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-Grundgesamtheit}: Standardabweichung und Varianz in der Grundgesamtheit}\vspace{3mm}

In der Stochastik werden Formeln häufig auch mit griechischen Buchstaben
geschrieben, wenn Sie sich statt auf eine Stichprobe auf die
Grundgesamtheit beziehen.

Der Mittelwert in der Grundgesamtheit wird auch Erwartungswert genannt
und mit dem griechischen Buchstaben \(\mu\) (My) dargestellt. Die
Standardabweichung des Erwartungswerts wird mit \(\sigma\) (Sigma)
gekennzeichnet. \[
\sigma = \sqrt{\frac{1}{N} \sum_{i=1}^{N}(x_i - \mu)^2}
\]

\end{minipage}%
\end{tcolorbox}

Mit Hilfe der Standardabweichung kann der \emph{Standardfehler des
Mittelwerts} bestimmt werden. Der Standardfehler des Mittelwerts ist ein
Maß dafür, wie genau sich der arithmetische Mittelwert der Stichprobe an
den tatsächlichen Mittelwert der Grundgesamtheit, den Erwartungswert,
annähert (dazu gleich mehr) und wird auch \emph{Stichprobenfehler}
genannt. Der Standardfehler des Mittelwerts wird aus der
Standardabweichung einer Messung und der Wurzel der Stichprobengröße
berechnet.

\[
\sigma_{\bar{x}} ~ = ~ \frac{s}{\sqrt{N}}
\]

Da die Standardabweichung in der Grundgesamtheit in der Regel unbekannt
ist, wird der Standardfehler des Mittelwerts mit der
Stichprobenstandardabweichung geschätzt.

\[
\sigma_{\bar{x}}~ = ~ \frac{s_{n-1}}{\sqrt{N}}
\]

Manchmal wird der Standardfehler zur längeren Schreibweise umgeformt.

\[
\sigma_{\bar{x}} ~ = ~ \frac{s_{n-1}}{\sqrt{N}} ~ = ~ \sqrt{\frac{1}{N(N-1)} \sum_{i=1}^{N}(x_i - \bar{x})^2}
\]

Der Standardfehler wird umso kleiner (die Messung umso präziser), je
kleiner die Varianz in der Grundgesamtheit und je größer der
Stichprobenumfang ist.

Dies lässt sich mit einem simulierten Würfelexperiment verdeutlichen.
Bei einem idealen, fairen Würfel kommt jede Augenzahl gleich oft vor.
Der Erwartungswert eines sechsseitigen Würfels ist:

\[
\frac{1}{6} \sum_{i=1}^{i=6}(x_i) ~ = ~ 3,5
\]

Die Standardabweichung eines fairen, sechsseitigen Würfels beträgt:

\[
\sqrt{\frac{1}{6} \sum_{i=1}^{i=6}(x_i - 3,5)^2} ~ \approx ~ 1,71 
\]

Da die Varianz in der Grundgesamtheit bekannt ist, hängt der
Standardfehler des Mittelwerts eines fairen Würfels allein von der
Stichprobengröße ab.

\subsection{Experiment
Verteilungskenngrößen}\label{experiment-verteilungskenngruxf6uxdfen}

In einem simulierten Experiment würfeln 100 Personen jeweils 3, 10 und
50 Mal und bilden den Mittelwert der Augen. Weil ein fairer Würfel
simuliert wird, kann der Standardfehler mit der Standardabweichung der
Grundgesamtheit berechnet werden.

\section{Ergebnisse}

\begin{verbatim}
Würfe pro Person: 3             Stichprobengröße: 300
kleinster Mittelwert: 1.00      größter Mittelwert: 6.00
Stichprobenmittelwert: 3.57     Standardfehler: 0.10

Würfe pro Person: 10            Stichprobengröße: 1000
kleinster Mittelwert: 1.70      größter Mittelwert: 4.60
Stichprobenmittelwert: 3.49     Standardfehler: 0.05

Würfe pro Person: 50            Stichprobengröße: 5000
kleinster Mittelwert: 2.98      größter Mittelwert: 4.36
Stichprobenmittelwert: 3.50     Standardfehler: 0.02
\end{verbatim}

Mit zunehmender Anzahl an Würfen nähern sich Minimum und Maximum der
individuellen Durchschnittswerte sowie der Stichprobenmittelwert dem
Erwartungswert an.

\emph{Hinweis: Da das Skript dynamisch generiert wird, wurden die
Zufallszahlen mit einem festgelegten Startwert erzeugt.}

\section{grafische Darstellung}

Die Häufigkeit der individuellen Mittelwerte ist in den folgenden
Histogrammen dargestellt.

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/einleitung_files/figure-pdf/cell-4-output-1.png}}

\section{Code}

Berechnung

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{personen }\OperatorTok{=} \DecValTok{100}
\NormalTok{standardabweichung\_grundgesamtheit }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{1}\NormalTok{, }\DecValTok{7}\NormalTok{).std(ddof }\OperatorTok{=} \DecValTok{0}\NormalTok{)}
\NormalTok{seed }\OperatorTok{=} \DecValTok{1}

\CommentTok{\# 3 Würfe}
\NormalTok{würfe }\OperatorTok{=} \DecValTok{3}

\CommentTok{\#\# Personen stehen in den Zeilen (axis = 0), Würfe in den Spalten (axis = 1)}
\NormalTok{augen3 }\OperatorTok{=}\NormalTok{ np.random.default\_rng(seed }\OperatorTok{=}\NormalTok{ seed).integers(low }\OperatorTok{=} \DecValTok{1}\NormalTok{, high }\OperatorTok{=} \DecValTok{6}\NormalTok{, endpoint }\OperatorTok{=} \VariableTok{True}\NormalTok{, size }\OperatorTok{=}\NormalTok{ (personen, würfe)) }\CommentTok{\# high is exclusive if endpoint = False}

\CommentTok{\#\# zeilenweise Mittelwert bilden mit np.array.mean(axis = 1)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Würfe pro Person: }\SpecialCharTok{\{}\NormalTok{w}\SpecialCharTok{ü}\NormalTok{rfe}\SpecialCharTok{\}}\CharTok{\textbackslash{}t\textbackslash{}t\textbackslash{}t\textbackslash{}t}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Stichprobengröße: }\SpecialCharTok{\{}\NormalTok{w}\SpecialCharTok{ü}\NormalTok{rfe }\OperatorTok{*}\NormalTok{ personen}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"kleinster Mittelwert: }\SpecialCharTok{\{}\NormalTok{augen3}\SpecialCharTok{.}\NormalTok{mean(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{min}\NormalTok{()}\SpecialCharTok{:.2f\}}\CharTok{\textbackslash{}t\textbackslash{}t}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"größter Mittelwert: }\SpecialCharTok{\{}\NormalTok{augen3}\SpecialCharTok{.}\NormalTok{mean(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{max}\NormalTok{()}\SpecialCharTok{:.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Stichprobenmittelwert: }\SpecialCharTok{\{}\NormalTok{augen3}\SpecialCharTok{.}\NormalTok{mean()}\SpecialCharTok{:.2f\}}\CharTok{\textbackslash{}t\textbackslash{}t}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Standardfehler: }\SpecialCharTok{\{}\NormalTok{standardabweichung\_grundgesamtheit }\OperatorTok{/}\NormalTok{ ( augen3.size }\OperatorTok{**}\NormalTok{ (}\DecValTok{1}\OperatorTok{/}\DecValTok{2}\NormalTok{) )}\SpecialCharTok{:.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
\NormalTok{      sep }\OperatorTok{=} \StringTok{""}\NormalTok{)}

\CommentTok{\# 10 Würfe}
\NormalTok{würfe }\OperatorTok{=} \DecValTok{10}

\CommentTok{\#\# Personen stehen in den Zeilen (axis = 0), Würfe in den Spalten (axis = 1)}
\NormalTok{augen10 }\OperatorTok{=}\NormalTok{ np.random.default\_rng(seed }\OperatorTok{=}\NormalTok{ seed).integers(low }\OperatorTok{=} \DecValTok{1}\NormalTok{, high }\OperatorTok{=} \DecValTok{6}\NormalTok{, endpoint }\OperatorTok{=} \VariableTok{True}\NormalTok{, size }\OperatorTok{=}\NormalTok{ (personen, würfe)) }\CommentTok{\# high is exclusive if endpoint = False}

\CommentTok{\#\# zeilenweise Mittelwert bilden mit np.array.mean(axis = 1)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Würfe pro Person: }\SpecialCharTok{\{}\NormalTok{w}\SpecialCharTok{ü}\NormalTok{rfe}\SpecialCharTok{\}}\CharTok{\textbackslash{}t\textbackslash{}t\textbackslash{}t}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Stichprobengröße: }\SpecialCharTok{\{}\NormalTok{w}\SpecialCharTok{ü}\NormalTok{rfe }\OperatorTok{*}\NormalTok{ personen}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"kleinster Mittelwert: }\SpecialCharTok{\{}\NormalTok{augen10}\SpecialCharTok{.}\NormalTok{mean(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{min}\NormalTok{()}\SpecialCharTok{:.2f\}}\CharTok{\textbackslash{}t\textbackslash{}t}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"größter Mittelwert: }\SpecialCharTok{\{}\NormalTok{augen10}\SpecialCharTok{.}\NormalTok{mean(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{max}\NormalTok{()}\SpecialCharTok{:.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Stichprobenmittelwert: }\SpecialCharTok{\{}\NormalTok{augen10}\SpecialCharTok{.}\NormalTok{mean()}\SpecialCharTok{:.2f\}}\CharTok{\textbackslash{}t\textbackslash{}t}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Standardfehler: }\SpecialCharTok{\{}\NormalTok{standardabweichung\_grundgesamtheit }\OperatorTok{/}\NormalTok{ ( augen10.size }\OperatorTok{**}\NormalTok{ (}\DecValTok{1}\OperatorTok{/}\DecValTok{2}\NormalTok{) )}\SpecialCharTok{:.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
\NormalTok{      sep }\OperatorTok{=} \StringTok{""}\NormalTok{)}

\CommentTok{\# 50 Würfe}
\NormalTok{würfe }\OperatorTok{=} \DecValTok{50}

\CommentTok{\#\# Personen stehen in den Zeilen (axis = 1), Würfe in den Spalten (axis = 1)}
\NormalTok{augen50 }\OperatorTok{=}\NormalTok{ np.random.default\_rng(seed }\OperatorTok{=}\NormalTok{ seed).integers(low }\OperatorTok{=} \DecValTok{1}\NormalTok{, high }\OperatorTok{=} \DecValTok{6}\NormalTok{, endpoint }\OperatorTok{=} \VariableTok{True}\NormalTok{, size }\OperatorTok{=}\NormalTok{ (personen, würfe)) }\CommentTok{\# high is exclusive if endpoint = False}

\CommentTok{\#\# zeilenweise Mittelwert bilden mit np.array.mean(axis = 1)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Würfe pro Person: }\SpecialCharTok{\{}\NormalTok{w}\SpecialCharTok{ü}\NormalTok{rfe}\SpecialCharTok{\}}\CharTok{\textbackslash{}t\textbackslash{}t\textbackslash{}t}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Stichprobengröße: }\SpecialCharTok{\{}\NormalTok{w}\SpecialCharTok{ü}\NormalTok{rfe }\OperatorTok{*}\NormalTok{ personen}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"kleinster Mittelwert: }\SpecialCharTok{\{}\NormalTok{augen50}\SpecialCharTok{.}\NormalTok{mean(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{min}\NormalTok{()}\SpecialCharTok{:.2f\}}\CharTok{\textbackslash{}t\textbackslash{}t}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"größter Mittelwert: }\SpecialCharTok{\{}\NormalTok{augen50}\SpecialCharTok{.}\NormalTok{mean(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{max}\NormalTok{()}\SpecialCharTok{:.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Stichprobenmittelwert: }\SpecialCharTok{\{}\NormalTok{augen50}\SpecialCharTok{.}\NormalTok{mean()}\SpecialCharTok{:.2f\}}\CharTok{\textbackslash{}t\textbackslash{}t}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Standardfehler: }\SpecialCharTok{\{}\NormalTok{standardabweichung\_grundgesamtheit }\OperatorTok{/}\NormalTok{ ( augen50.size }\OperatorTok{**}\NormalTok{ (}\DecValTok{1}\OperatorTok{/}\DecValTok{2}\NormalTok{) )}\SpecialCharTok{:.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
\NormalTok{      sep }\OperatorTok{=} \StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Darstellung

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{personen }\OperatorTok{=} \DecValTok{100}
\NormalTok{standardabweichung\_grundgesamtheit }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{1}\NormalTok{, }\DecValTok{7}\NormalTok{).std(ddof }\OperatorTok{=} \DecValTok{0}\NormalTok{)}
\NormalTok{seed }\OperatorTok{=} \DecValTok{1}

\CommentTok{\# 3 Würfe}
\NormalTok{würfe }\OperatorTok{=} \DecValTok{3}
\NormalTok{augen3 }\OperatorTok{=}\NormalTok{ np.random.default\_rng(seed }\OperatorTok{=}\NormalTok{ seed).integers(low }\OperatorTok{=} \DecValTok{1}\NormalTok{, high }\OperatorTok{=} \DecValTok{6}\NormalTok{, endpoint }\OperatorTok{=} \VariableTok{True}\NormalTok{, size }\OperatorTok{=}\NormalTok{ (personen, würfe)) }\CommentTok{\# high is exclusive if endpoint = False}

\CommentTok{\# 10 Würfe}
\NormalTok{würfe }\OperatorTok{=} \DecValTok{10}
\NormalTok{augen10 }\OperatorTok{=}\NormalTok{ np.random.default\_rng(seed }\OperatorTok{=}\NormalTok{ seed).integers(low }\OperatorTok{=} \DecValTok{1}\NormalTok{, high }\OperatorTok{=} \DecValTok{6}\NormalTok{, endpoint }\OperatorTok{=} \VariableTok{True}\NormalTok{, size }\OperatorTok{=}\NormalTok{ (personen, würfe)) }\CommentTok{\# high is exclusive if endpoint = False}

\CommentTok{\# 50 Würfe}
\NormalTok{würfe }\OperatorTok{=} \DecValTok{50}
\NormalTok{augen50 }\OperatorTok{=}\NormalTok{ np.random.default\_rng(seed }\OperatorTok{=}\NormalTok{ seed).integers(low }\OperatorTok{=} \DecValTok{1}\NormalTok{, high }\OperatorTok{=} \DecValTok{6}\NormalTok{, endpoint }\OperatorTok{=} \VariableTok{True}\NormalTok{, size }\OperatorTok{=}\NormalTok{ (personen, würfe)) }\CommentTok{\# high is exclusive if endpoint = False}

\CommentTok{\# plotten}
\NormalTok{bins }\OperatorTok{=} \DecValTok{10}

\CommentTok{\# 3 Würfe}
\NormalTok{fig, (ax1, ax2, ax3) }\OperatorTok{=}\NormalTok{ plt.subplots(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, sharey }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

\NormalTok{ax1.hist(augen3.mean(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{), bins }\OperatorTok{=}\NormalTok{ bins, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{, edgecolor }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, }\BuiltInTok{range} \OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{))}
\NormalTok{ax1.set\_xlim(}\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\NormalTok{ax1.axvline(x }\OperatorTok{=} \FloatTok{3.5}\NormalTok{, ymin }\OperatorTok{=} \DecValTok{0}\NormalTok{, ymax }\OperatorTok{=} \DecValTok{1}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Erwartungswert\textquotesingle{}}\NormalTok{)}
\NormalTok{ax1.set\_ylabel(}\StringTok{\textquotesingle{}mittleres Würfelergebnis\textquotesingle{}}\NormalTok{)}
\NormalTok{ax1.set\_ylabel(}\StringTok{\textquotesingle{}Häufigkeit Mittelwert\textquotesingle{}}\NormalTok{)}
\NormalTok{ax1.set\_title(}\StringTok{"3 Würfe pro Person"}\NormalTok{)}
\NormalTok{ax1.legend(loc }\OperatorTok{=} \StringTok{\textquotesingle{}lower left\textquotesingle{}}\NormalTok{, bbox\_to\_anchor }\OperatorTok{=}\NormalTok{ (}\DecValTok{0}\NormalTok{, }\OperatorTok{{-}}\FloatTok{0.2}\NormalTok{))}

\CommentTok{\# 10 Würfe}
\NormalTok{ax2.hist(augen10.mean(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{), bins }\OperatorTok{=}\NormalTok{ bins, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{, edgecolor }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, }\BuiltInTok{range} \OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{))}
\NormalTok{ax2.set\_xlim(}\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\NormalTok{ax2.axvline(x }\OperatorTok{=} \FloatTok{3.5}\NormalTok{, ymin }\OperatorTok{=} \DecValTok{0}\NormalTok{, ymax }\OperatorTok{=} \DecValTok{1}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{)}
\NormalTok{ax2.set\_ylabel(}\StringTok{\textquotesingle{}mittleres Würfelergebnis\textquotesingle{}}\NormalTok{)}
\NormalTok{ax2.set\_title(}\StringTok{"10 Würfe pro Person"}\NormalTok{)}

\CommentTok{\# 30 Würfe}
\NormalTok{ax3.hist(augen50.mean(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{), bins }\OperatorTok{=}\NormalTok{ bins, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{, edgecolor }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, }\BuiltInTok{range} \OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{))}
\NormalTok{ax3.set\_xlim(}\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\NormalTok{ax3.axvline(x }\OperatorTok{=} \FloatTok{3.5}\NormalTok{, ymin }\OperatorTok{=} \DecValTok{0}\NormalTok{, ymax }\OperatorTok{=} \DecValTok{1}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{)}
\NormalTok{ax3.set\_ylabel(}\StringTok{\textquotesingle{}mittleres Würfelergebnis\textquotesingle{}}\NormalTok{)}
\NormalTok{ax3.set\_title(}\StringTok{"30 Würfe pro Person"}\NormalTok{)}

\NormalTok{plt.tight\_layout()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\subsection{Aufgabe
Verteilungskenngrößen}\label{aufgabe-verteilungskenngruxf6uxdfen}

Im Datensatz ToothGrowth.csv ist eine Messreihe zur Länge zahnbildender
Zellen bei Meerschweinchen gespeichert. Die Tiere erhielten Vitamin C
direkt (VC) oder in Form von Orangensaft (OJ) in unterschiedlichen
Dosen.

\begin{codelisting}

\caption{\label{lst-readfile}}

\centering{

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/ToothGrowth.csv"}
\NormalTok{meerschweinchen }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ dateipfad, sep }\OperatorTok{=} \StringTok{\textquotesingle{},\textquotesingle{}}\NormalTok{, header }\OperatorTok{=} \DecValTok{0}\NormalTok{, }\OperatorTok{\textbackslash{}}
\NormalTok{  names }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}ID\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}supp\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{], dtype }\OperatorTok{=}\NormalTok{ \{}\StringTok{\textquotesingle{}ID\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}int\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}float\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}float\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}supp\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}category\textquotesingle{}}\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

}

\end{codelisting}%

Crampton, E. W. 1947. „THE GROWTH OF THE ODONTOBLASTS OF THE INCISOR
TOOTH AS A CRITERION OF THE VITAMIN C INTAKE OF THE GUINEA PIG``. The
Journal of Nutrition 33 (5): 491--504.
\url{https://doi.org/10.1093/jn/33.5.491}

Der Datensatz kann in R mit dem Befehl ``ToothGrowth'' aufgerufen
werden.

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/einleitung_files/figure-pdf/cell-8-output-1.png}}

~

\textbf{Berechnen Sie den arithmetischen Mittelwert, die Varianz, die
Standardabweichung und den Standardfehler des Mittelwerts der Messreihe
zur Zahnlänge (len). Verwenden Sie dazu die vorgestellten Formeln.}

Das Ergebnis könnte so aussehen:

\begin{verbatim}
N: 60
arithmetisches Mittel: 18.81
Stichprobenfehler: 0.99
Stichprobenvarianz: 58.51
Stichprobenstandardabweichung: 7.65
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-loesungkenngrößen}: Musterlösung Verteilungskenngrößen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-loesungkenngrößen} 

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ verteilungskennwerte(x, output }\OperatorTok{=} \VariableTok{True}\NormalTok{):}

  \CommentTok{\# Anzahl Messwerte bestimmen}
\NormalTok{  N }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(x)}

  \CommentTok{\# arithmetisches Mittel bestimmen}
\NormalTok{  stichprobenmittelwert }\OperatorTok{=} \BuiltInTok{sum}\NormalTok{(x) }\OperatorTok{/}\NormalTok{ N}

  \CommentTok{\# Stichprobenvarianz bestimmen}
\NormalTok{  stichprobenvarianz }\OperatorTok{=} \BuiltInTok{sum}\NormalTok{((x }\OperatorTok{{-}}\NormalTok{ stichprobenmittelwert) }\OperatorTok{**} \DecValTok{2}\NormalTok{) }\OperatorTok{/}\NormalTok{ (N }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}

  \CommentTok{\# Standardabweichung bestimmen}
\NormalTok{  standardabweichung }\OperatorTok{=}\NormalTok{ stichprobenvarianz }\OperatorTok{**}\NormalTok{ (}\DecValTok{1}\OperatorTok{/}\DecValTok{2}\NormalTok{)}

  \CommentTok{\# Stichprobenfehler bestimmen}
\NormalTok{  stichprobenfehler }\OperatorTok{=}\NormalTok{ standardabweichung }\OperatorTok{/}\NormalTok{ (N }\OperatorTok{**}\NormalTok{ (}\DecValTok{1}\OperatorTok{/}\DecValTok{2}\NormalTok{))}

  \CommentTok{\# Ausgabe}
  \ControlFlowTok{if}\NormalTok{ output: }\CommentTok{\# output = True}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"N: }\SpecialCharTok{\{}\NormalTok{N}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
          \SpecialStringTok{f"arithmetisches Mittel: }\SpecialCharTok{\{}\NormalTok{stichprobenmittelwert}\SpecialCharTok{:.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
          \SpecialStringTok{f"Stichprobenfehler: }\SpecialCharTok{\{}\NormalTok{stichprobenfehler}\SpecialCharTok{:.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
          \SpecialStringTok{f"Stichprobenvarianz: }\SpecialCharTok{\{}\NormalTok{stichprobenvarianz}\SpecialCharTok{:.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
          \SpecialStringTok{f"Standardabweichung: }\SpecialCharTok{\{}\NormalTok{standardabweichung}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{,}
\NormalTok{          sep }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}

  \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# output = False}
    \ControlFlowTok{return}\NormalTok{ N, stichprobenmittelwert, stichprobenfehler, stichprobenvarianz, standardabweichung}

\NormalTok{verteilungskennwerte(meerschweinchen[}\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

\subsection{Varianz und Standardabweichung mit NumPy und
Pandas}\label{varianz-und-standardabweichung-mit-numpy-und-pandas}

Die Module NumPy und Pandas verfügen über eigene Funktionen zur
Berechnung der Varianz und der Standardabweichung. Die Varianz und
Standardabweichung werden mit den Funktion \texttt{np.var()} und
\texttt{np.std()} bzw. den Methoden \texttt{pd.var()} und
\texttt{pd.std()} berechnet. Der Parameter \texttt{ddof} (delta degrees
of freedom) steuert, welcher Nenner zur Berechnung der Varianz verwendet
wird in der Form N - ddof. Während der Standardwert in NumPy
\texttt{ddof=0} ist, berechnet Pandas mit dem Standardwert
\texttt{ddof=1} die Stichprobenvarianz.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"Varianz:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"NumPy:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\NormalTok{var(meerschweinchen[}\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{])}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Pandas:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{meerschweinchen[}\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{var()}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Standardabweichung:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"NumPy:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\NormalTok{std(meerschweinchen[}\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{])}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Pandas:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{meerschweinchen[}\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{std()}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Varianz:
NumPy:  57.54
Pandas: 58.51

Standardabweichung:
NumPy:  7.59
Pandas: 7.65
\end{verbatim}

\chapter{Die Normalverteilung}\label{sec-normalverteilung}

Mit zunehmender Stichprobengröße wird eine immer bessere Schätzung des
Erwartungswerts erreicht. Mathematisch liegt dieser Beobachtung der
\href{https://de.wikipedia.org/wiki/Zentraler_Grenzwertsatz}{zentrale
Grenzwertsatz} zugrunde. So werden beim Würfeln mit mehreren Würfeln
weit vom Erwartungswert entfernte Wurfergebnisse immer
unwahrscheinlicher. Dies lässt sich bereits mit wenigen Würfeln zeigen
(siehe Beispiel).

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-wuerfel}: Häufigkeitsverteilung von Würfelergebnissen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-wuerfel} 

Für einen Würfel gibt es 6 mögliche Ergebnisse, für 2 Würfel 6 * 6
mögliche Kombinationen, für 3 Würfel 6 * 6 * 6 Kombinationen und so
weiter. Weil viele Kombinationen wertgleich sind, kommen Wurfergebnisse
in der Nähe des Erwartungswerts häufiger vor als beispielsweise ein
Einserpasch.

\section{ein Würfel}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ein\_würfel }\OperatorTok{=}\NormalTok{ []}

\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{7}\NormalTok{):}
\NormalTok{  ein\_würfel.append(i)}

\NormalTok{ein\_würfel }\OperatorTok{=}\NormalTok{ pd.Series(ein\_würfel)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Häufigkeitsverteilung der Augensumme:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(ein\_würfel.value\_counts(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Durchschnitt: }\SpecialCharTok{\{}\NormalTok{ein\_w}\SpecialCharTok{ü}\NormalTok{rfel}\SpecialCharTok{.}\NormalTok{mean()}\SpecialCharTok{:.1f\}}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{plt.bar(ein\_würfel.unique(), ein\_würfel.value\_counts())}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Augenzahl\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Anzahl Kombinationen\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Häufigkeitsverteilung der Augensumme:
1    1
2    1
3    1
4    1
5    1
6    1
Name: count, dtype: int64 

Durchschnitt: 3.5
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-3-output-2.png}}

\section{zwei Würfel}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zwei\_würfel }\OperatorTok{=}\NormalTok{ []}

\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{7}\NormalTok{):}
\NormalTok{  würfel\_1 }\OperatorTok{=}\NormalTok{ i}

  \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{7}\NormalTok{):}
\NormalTok{    würfel\_2 }\OperatorTok{=}\NormalTok{ j}
\NormalTok{    zwei\_würfel.append(würfel\_1 }\OperatorTok{+}\NormalTok{ würfel\_2)}

\NormalTok{zwei\_würfel }\OperatorTok{=}\NormalTok{ pd.Series(zwei\_würfel)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Häufigkeitsverteilung der Augensumme:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(zwei\_würfel.value\_counts().sort\_index(ascending }\OperatorTok{=} \VariableTok{True}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Durchschnitt: }\SpecialCharTok{\{}\NormalTok{zwei\_w}\SpecialCharTok{ü}\NormalTok{rfel}\SpecialCharTok{.}\NormalTok{mean()}\SpecialCharTok{:.1f\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Durchschnitt pro Würfel: }\SpecialCharTok{\{}\NormalTok{zwei\_w}\SpecialCharTok{ü}\NormalTok{rfel}\SpecialCharTok{.}\NormalTok{mean() }\OperatorTok{/} \DecValTok{2}\SpecialCharTok{:.1f\}}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{plt.bar(zwei\_würfel.unique(), zwei\_würfel.value\_counts().sort\_index(ascending }\OperatorTok{=} \VariableTok{True}\NormalTok{))}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Augenzahl\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Anzahl Kombinationen\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Häufigkeitsverteilung der Augensumme:
2     1
3     2
4     3
5     4
6     5
7     6
8     5
9     4
10    3
11    2
12    1
Name: count, dtype: int64 

Durchschnitt: 7.0
Durchschnitt pro Würfel: 3.5
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-4-output-2.png}}

\section{drei Würfel}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{drei\_würfel }\OperatorTok{=}\NormalTok{ []}

\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{7}\NormalTok{):}
\NormalTok{  würfel\_1 }\OperatorTok{=}\NormalTok{ i}

  \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{7}\NormalTok{):}
\NormalTok{    würfel\_2 }\OperatorTok{=}\NormalTok{ j}

    \ControlFlowTok{for}\NormalTok{ k }\KeywordTok{in} \BuiltInTok{range}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{7}\NormalTok{):}
\NormalTok{      würfel\_3 }\OperatorTok{=}\NormalTok{ k}
\NormalTok{      drei\_würfel.append(würfel\_1 }\OperatorTok{+}\NormalTok{ würfel\_2 }\OperatorTok{+}\NormalTok{ würfel\_3)}

\NormalTok{drei\_würfel }\OperatorTok{=}\NormalTok{ pd.Series(drei\_würfel)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Häufigkeitsverteilung der Augensumme:"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(drei\_würfel.value\_counts().sort\_index(ascending }\OperatorTok{=} \VariableTok{True}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Durchschnitt: }\SpecialCharTok{\{}\NormalTok{drei\_w}\SpecialCharTok{ü}\NormalTok{rfel}\SpecialCharTok{.}\NormalTok{mean()}\SpecialCharTok{:.1f\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Durchschnitt pro Würfel: }\SpecialCharTok{\{}\NormalTok{drei\_w}\SpecialCharTok{ü}\NormalTok{rfel}\SpecialCharTok{.}\NormalTok{mean() }\OperatorTok{/} \DecValTok{3}\SpecialCharTok{:.1f\}}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{plt.bar(drei\_würfel.unique(), drei\_würfel.value\_counts().sort\_index(ascending }\OperatorTok{=} \VariableTok{True}\NormalTok{))}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Augenzahl\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel (}\StringTok{\textquotesingle{}Anzahl Kombinationen\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Häufigkeitsverteilung der Augensumme:
3      1
4      3
5      6
6     10
7     15
8     21
9     25
10    27
11    27
12    25
13    21
14    15
15    10
16     6
17     3
18     1
Name: count, dtype: int64 

Durchschnitt: 10.5
Durchschnitt pro Würfel: 3.5
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-5-output-2.png}}

\end{tcolorbox}

Die mit steigender Stichprobengröße zu beobachtende Annäherung von
Messwerten an einen in der Grundgesamtheit geltenden Erwartungswert gilt
auch, wenn der Erwartungswert und die Varianz in der Grundgesamtheit
unbekannt sind. Mit zunehmender Stichprobengröße nähern sich die
Messwerte der
\href{https://de.wikipedia.org/wiki/Normalverteilung}{Normalverteilung}
an, die nach ihrem Entdecker Carl Friedrich Gauß auch als Gaußsche
Glockenkurve bekannt ist.

Die für größere Stichproben zu beobachtende Annäherung der Verteilung
von Messwerten an die Normalverteilung kann anhand des Gewichts von
Pinguinen aus dem Datensatz palmerpenguins gezeigt werden.

\textbf{palmerpenguins}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/00-bilder/lter_penguins_allison_horst_CC0.png}}

}

\caption{Pinguine des Palmer-Station-Datensatzes}

\end{figure}%

Meet the Palmer penguins von @allison\_horst steht unter der Lizenz
\href{https://github.com/allisonhorst/palmerpenguins?tab=CC0-1.0-1-ov-file\#creative-commons}{CC0-1.0}
und ist auf
\href{https://github.com/allisonhorst/palmerpenguins?tab=readme-ov-file\#meet-the-palmer-penguins}{GitHub}
abrufbar. 2020

Der Datensatz steht unter der Lizenz
\href{https://creativecommons.org/public-domain/cc0/}{CCO} und ist in R
sowie auf
\href{https://github.com/allisonhorst/palmerpenguins?tab=readme-ov-file}{GitHub}
verfügbar. 2020

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\# R Befehle, um den Datensatz zu laden}
\NormalTok{install.packages("palmerpenguins")}
\NormalTok{library(palmerpenguins)}
\end{Highlighting}
\end{Shaded}

Horst AM, Hill AP und Gorman KB. 2020. palmerpenguins: Palmer
Archipelago (Antarctica) penguin data. R package version 0.1.0.
\url{https://allisonhorst.github.io/palmerpenguins/}. doi:
10.5281/zenodo.3960218.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{penguins }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=} \StringTok{"01{-}daten/penguins.csv"}\NormalTok{)}

\CommentTok{\# Tiere mit unvollständigen Einträgen entfernen}
\NormalTok{penguins.drop(np.where(penguins.}\BuiltInTok{apply}\NormalTok{(pd.isna).}\BuiltInTok{any}\NormalTok{(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{))[}\DecValTok{0}\NormalTok{], inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(penguins.info(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
Index: 333 entries, 0 to 343
Data columns (total 8 columns):
 #   Column             Non-Null Count  Dtype  
---  ------             --------------  -----  
 0   species            333 non-null    object 
 1   island             333 non-null    object 
 2   bill_length_mm     333 non-null    float64
 3   bill_depth_mm      333 non-null    float64
 4   flipper_length_mm  333 non-null    float64
 5   body_mass_g        333 non-null    float64
 6   sex                333 non-null    object 
 7   year               333 non-null    int64  
dtypes: float64(4), int64(1), object(3)
memory usage: 23.4+ KB
None 
\end{verbatim}

~

Der Datensatz enthält Daten für drei Pinguinarten.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(penguins.groupby(by }\OperatorTok{=}\NormalTok{ penguins[}\StringTok{\textquotesingle{}species\textquotesingle{}}\NormalTok{]).size())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
species
Adelie       146
Chinstrap     68
Gentoo       119
dtype: int64
\end{verbatim}

Unter anderen wurde das Körpergewicht in Gramm gemessen, das in der
Spalte `body\_mass\_g' eingetragen ist. Die Gewichtsverteilung der drei
Spezies wird jeweils mit einem Histogramm dargestellt. Außerdem werden
für jede Spezies der Stichprobenmittelwert und die
Stichprobenstandardabweichung bestimmt. Mit diesen Werten kann eine
Normalverteilungskurve berechnet und in das Histogramm eingezeichnet
werden (wie das geht, wird in Note~\ref{nte-normalverteilungdarstellen}
gezeigt). So kann optisch geprüft werden, ob die empirische Verteilung
der Werte in der Stichprobe einer Normalverteilung mit den selben Werten
für Mittelwert und Standardabweichung entspricht. (Bei aus Messungen
gewonnenen Daten ist dies häufig nicht so eindeutig, wie bei der
Häufigkeitsverteilung von Würfelergebnissen.)

\section{Grafik}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-8-output-1.png}}

\section{Code}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fig, (ax1, ax2, ax3) }\OperatorTok{=}\NormalTok{ plt.subplots(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, figsize }\OperatorTok{=}\NormalTok{ (}\FloatTok{7.5}\NormalTok{, }\DecValTok{6}\NormalTok{), sharey }\OperatorTok{=} \VariableTok{True}\NormalTok{, layout }\OperatorTok{=} \StringTok{\textquotesingle{}tight\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.suptitle(}\StringTok{\textquotesingle{}Gewichtsverteilung von Pinguinen\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Adelie}
\NormalTok{species }\OperatorTok{=} \StringTok{\textquotesingle{}Adelie\textquotesingle{}}
\NormalTok{data }\OperatorTok{=}\NormalTok{ penguins[}\StringTok{\textquotesingle{}body\_mass\_g\textquotesingle{}}\NormalTok{][penguins[}\StringTok{\textquotesingle{}species\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ species]}

\CommentTok{\#\# Histogramm}
\NormalTok{ax1.hist(data, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{, edgecolor }\OperatorTok{=} \StringTok{\textquotesingle{}lightgrey\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{, density }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{ax1.set\_xlabel(}\StringTok{\textquotesingle{}Gewicht in Gramm\textquotesingle{}}\NormalTok{)}
\NormalTok{ax1.set\_ylabel(}\StringTok{\textquotesingle{}Häufigkeitsdichte\textquotesingle{}}\NormalTok{)}
\NormalTok{ax1.set\_title(label }\OperatorTok{=} \BuiltInTok{str}\NormalTok{(species) }\OperatorTok{+} \StringTok{" N = "} \OperatorTok{+} \BuiltInTok{str}\NormalTok{(data.size))}

\CommentTok{\#\# Normalverteilungskurve}
\NormalTok{stichprobenmittelwert }\OperatorTok{=}\NormalTok{ data.mean()}
\NormalTok{stichprobenstandardabweichung }\OperatorTok{=}\NormalTok{ data.std(ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{hist, bin\_edges }\OperatorTok{=}\NormalTok{ np.histogram(data)}
\NormalTok{x\_values }\OperatorTok{=}\NormalTok{ np.linspace(}\BuiltInTok{min}\NormalTok{(bin\_edges), }\BuiltInTok{max}\NormalTok{(bin\_edges), }\DecValTok{100}\NormalTok{)}
\NormalTok{y\_values }\OperatorTok{=}  \DecValTok{1} \OperatorTok{/}\NormalTok{ (stichprobenstandardabweichung }\OperatorTok{*}\NormalTok{ np.sqrt(}\DecValTok{2} \OperatorTok{*}\NormalTok{ np.pi)) }\OperatorTok{*}\NormalTok{ np.exp(}\OperatorTok{{-}}\NormalTok{ (x\_values }\OperatorTok{{-}}\NormalTok{ stichprobenmittelwert) }\OperatorTok{**} \DecValTok{2} \OperatorTok{/}\NormalTok{ (}\DecValTok{2} \OperatorTok{*}\NormalTok{ stichprobenstandardabweichung }\OperatorTok{**} \DecValTok{2}\NormalTok{))}

\NormalTok{ax1.plot(x\_values, y\_values, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, linewidth }\OperatorTok{=} \DecValTok{1}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Normalverteilung\textquotesingle{}}\NormalTok{)}
\NormalTok{ax1.legend()}

\CommentTok{\# Chinstrap}
\NormalTok{species }\OperatorTok{=} \StringTok{\textquotesingle{}Chinstrap\textquotesingle{}}
\NormalTok{data }\OperatorTok{=}\NormalTok{ penguins[}\StringTok{\textquotesingle{}body\_mass\_g\textquotesingle{}}\NormalTok{][penguins[}\StringTok{\textquotesingle{}species\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ species]}

\CommentTok{\#\# Histogramm}
\NormalTok{ax2.hist(data, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{, edgecolor }\OperatorTok{=} \StringTok{\textquotesingle{}lightgrey\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{, density }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{ax2.set\_xlabel(}\StringTok{\textquotesingle{}Gewicht in Gramm\textquotesingle{}}\NormalTok{)}
\NormalTok{ax2.set\_title(label }\OperatorTok{=} \BuiltInTok{str}\NormalTok{(species) }\OperatorTok{+} \StringTok{" N = "} \OperatorTok{+} \BuiltInTok{str}\NormalTok{(data.size))}

\CommentTok{\#\# Normalverteilungskurve}
\NormalTok{stichprobenmittelwert }\OperatorTok{=}\NormalTok{ data.mean()}
\NormalTok{stichprobenstandardabweichung }\OperatorTok{=}\NormalTok{ data.std(ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{hist, bin\_edges }\OperatorTok{=}\NormalTok{ np.histogram(data)}
\NormalTok{x\_values }\OperatorTok{=}\NormalTok{ np.linspace(}\BuiltInTok{min}\NormalTok{(bin\_edges), }\BuiltInTok{max}\NormalTok{(bin\_edges), }\DecValTok{100}\NormalTok{)}
\NormalTok{y\_values }\OperatorTok{=}  \DecValTok{1} \OperatorTok{/}\NormalTok{ (stichprobenstandardabweichung }\OperatorTok{*}\NormalTok{ np.sqrt(}\DecValTok{2} \OperatorTok{*}\NormalTok{ np.pi)) }\OperatorTok{*}\NormalTok{ np.exp(}\OperatorTok{{-}}\NormalTok{ (x\_values }\OperatorTok{{-}}\NormalTok{ stichprobenmittelwert) }\OperatorTok{**} \DecValTok{2} \OperatorTok{/}\NormalTok{ (}\DecValTok{2} \OperatorTok{*}\NormalTok{ stichprobenstandardabweichung }\OperatorTok{**} \DecValTok{2}\NormalTok{))}

\NormalTok{ax2.plot(x\_values, y\_values, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, linewidth }\OperatorTok{=} \DecValTok{1}\NormalTok{)}

\CommentTok{\# Gentoo}
\NormalTok{species }\OperatorTok{=} \StringTok{\textquotesingle{}Gentoo\textquotesingle{}}
\NormalTok{data }\OperatorTok{=}\NormalTok{ penguins[}\StringTok{\textquotesingle{}body\_mass\_g\textquotesingle{}}\NormalTok{][penguins[}\StringTok{\textquotesingle{}species\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ species]}

\CommentTok{\#\# Histogramm}
\NormalTok{ax3.hist(data, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{, edgecolor }\OperatorTok{=} \StringTok{\textquotesingle{}lightgrey\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}C2\textquotesingle{}}\NormalTok{, density }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{ax3.set\_xlabel(}\StringTok{\textquotesingle{}Gewicht in Gramm\textquotesingle{}}\NormalTok{)}
\NormalTok{ax3.set\_title(label }\OperatorTok{=} \BuiltInTok{str}\NormalTok{(species) }\OperatorTok{+} \StringTok{" N = "} \OperatorTok{+} \BuiltInTok{str}\NormalTok{(data.size))}

\CommentTok{\#\# Normalverteilungskurve}
\NormalTok{stichprobenmittelwert }\OperatorTok{=}\NormalTok{ data.mean()}
\NormalTok{stichprobenstandardabweichung }\OperatorTok{=}\NormalTok{ data.std(ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{hist, bin\_edges }\OperatorTok{=}\NormalTok{ np.histogram(data)}
\NormalTok{x\_values }\OperatorTok{=}\NormalTok{ np.linspace(}\BuiltInTok{min}\NormalTok{(bin\_edges), }\BuiltInTok{max}\NormalTok{(bin\_edges), }\DecValTok{100}\NormalTok{)}
\NormalTok{y\_values }\OperatorTok{=}  \DecValTok{1} \OperatorTok{/}\NormalTok{ (stichprobenstandardabweichung }\OperatorTok{*}\NormalTok{ np.sqrt(}\DecValTok{2} \OperatorTok{*}\NormalTok{ np.pi)) }\OperatorTok{*}\NormalTok{ np.exp(}\OperatorTok{{-}}\NormalTok{ (x\_values }\OperatorTok{{-}}\NormalTok{ stichprobenmittelwert) }\OperatorTok{**} \DecValTok{2} \OperatorTok{/}\NormalTok{ (}\DecValTok{2} \OperatorTok{*}\NormalTok{ stichprobenstandardabweichung }\OperatorTok{**} \DecValTok{2}\NormalTok{))}

\NormalTok{ax3.plot(x\_values, y\_values, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, linewidth }\OperatorTok{=} \DecValTok{1}\NormalTok{)}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

Die Normalverteilung ist eine Dichtekurve, an die sich der Verlauf eines
Histogramms mit einer gegen unendlich gehenden Anzahl von Messwerten und
einer gegen Null gehenden Klassenbreite annähert.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-histogramm}: Histogramm}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-histogramm} 

Das Histogramm ist eine grafische Darstellung der Häufigkeitsverteilung
kardinal skalierter Merkmale (d.~h. mit numerischen, geordneten
Merkmalsausprägungen). Die Daten werden in Klassen, die eine konstante
oder variable Breite haben können, eingeteilt. Es werden direkt
nebeneinanderliegende Rechtecke von der Breite der jeweiligen Klasse
gezeichnet, deren Flächeninhalte die (relativen oder absoluten)
Klassenhäufigkeiten darstellen. Die Höhe jedes Rechtecks stellt dann die
(relative oder absolute) Häufigkeitsdichte dar, also die (relative oder
absolute) Häufigkeit dividiert durch die Breite der entsprechenden
Klasse.

\phantomsection\label{nte-histogram}
\begin{quote}
\textbf{Note~66.2: Histogramm berechnen und visualisieren}

Als Beispiel wird die Länge der zahnbildenden Zellen der Meerschweinchen
verwendet, die eine Vitamin-C-Dosis von 2 erhielten.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dose2 }\OperatorTok{=}\NormalTok{ meerschweinchen.loc[meerschweinchen[}\StringTok{\textquotesingle{}dose\textquotesingle{}}\NormalTok{] }\OperatorTok{==} \DecValTok{2}\NormalTok{, }\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\OperatorTok{*}\BuiltInTok{list}\NormalTok{(dose2)) }\CommentTok{\# * = Ausgabe ohne Kommata}
\BuiltInTok{print}\NormalTok{(}\StringTok{"N"}\NormalTok{, }\BuiltInTok{len}\NormalTok{(dose2), }\StringTok{"Minimum:"}\NormalTok{, dose2.}\BuiltInTok{min}\NormalTok{(), }\StringTok{"Maximum:"}\NormalTok{, dose2.}\BuiltInTok{max}\NormalTok{(), }\StringTok{"Spannweite"}\NormalTok{, dose2.}\BuiltInTok{max}\NormalTok{() }\OperatorTok{{-}}\NormalTok{ dose2.}\BuiltInTok{min}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
23.6 18.5 33.9 25.5 26.4 32.5 26.7 21.5 23.3 29.5 25.5 26.4 22.4 24.5 24.8 30.9 26.4 27.3 29.4 23.0
N 20 Minimum: 18.5 Maximum: 33.9 Spannweite 15.399999999999999
\end{verbatim}

Mit der Funktion
\texttt{np.histogram(a,\ bins\ =\ 10,\ range\ =\ None,\ density\ =\ None)}
kann ein Histogramm berechnet werden.

\begin{itemize}
\tightlist
\item
  \texttt{a} sind die zu berechnenden Daten
\item
  \texttt{bins} spezifiziert die Anzahl an Klassen, standardmäßig werden
  10 gewählt.
\item
  \texttt{range\ =\ (float,\ float)} erlaubt es, die untere und obere
  Grenze der Klassen festzulegen.
\item
  \texttt{density\ =\ True} erlaubt es statt der absoluten Häufigkeiten,
  den Wert der Häufigkeitsdichtefunktion darzustellen. Dies berechnet
  sich wie folgt:

  \begin{itemize}
  \tightlist
  \item
    relative Häufigkeit = Anzahl Werte je Klasse / Anzahl aller Werte
  \item
    Häufigkeitsdichte = Anzahl Werte je Klasse / (Anzahl aller Werte *
    Klassenbreite)
  \item
    Klassenbreite = Maximum(Werte) - Minimum(Werte) / Anzahl Klassen
  \end{itemize}
\end{itemize}

Für die überschaubare Anzahl an Werten wird ein Histogramm mit 5 Klassen
berechnet. Zum Vergleich wird auch die Häufigkeitsdichte ausgegeben.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(np.histogram(dose2, bins }\OperatorTok{=} \DecValTok{5}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Häufigkeitsdichte:"}\NormalTok{, np.histogram(dose2, bins }\OperatorTok{=} \DecValTok{5}\NormalTok{, density }\OperatorTok{=} \VariableTok{True}\NormalTok{)[}\DecValTok{0}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(array([2, 5, 8, 2, 3]), array([18.5 , 21.58, 24.66, 27.74, 30.82, 33.9 ]))
Häufigkeitsdichte: [0.03246753 0.08116883 0.12987013 0.03246753 0.0487013 ]
\end{verbatim}

Die Funktion \texttt{np.histogram()} gibt an erster Stelle ein array mit
den absoluten Häufigkeiten bzw. der Häufigkeitsdichte jeder Klasse
zurück. An zweiter Stelle wird ein array mit den x-Positionen der
Klassenrechtecke zurückgegeben - dabei wird für jede Klasse die Position
der linken Seite sowie für die letzte Klasse zusätzlich die Position der
rechten Seite des Rechtecks ausgegeben. Für 5 Klassen werden also 6
Positionswerte ausgegeben.

Die Klassenbreite kann zum Beispiel mit der Methode \texttt{np.diff()}
ausgegeben werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hist\_abs, bin\_edges }\OperatorTok{=}\NormalTok{ np.histogram(dose2, bins }\OperatorTok{=} \DecValTok{5}\NormalTok{)}
\NormalTok{klassenbreite }\OperatorTok{=}\NormalTok{ np.diff(bin\_edges)}
\BuiltInTok{print}\NormalTok{(klassenbreite)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[3.08 3.08 3.08 3.08 3.08]
\end{verbatim}

Durch Multiplikation der Häufigkeitsdichte mit der Klassenbreite können
die relativen Häufigkeiten berechnet werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hist\_dichte }\OperatorTok{=}\NormalTok{ np.histogram(dose2, bins }\OperatorTok{=} \DecValTok{5}\NormalTok{, density }\OperatorTok{=} \VariableTok{True}\NormalTok{)[}\DecValTok{0}\NormalTok{]}
\NormalTok{hist\_relativ }\OperatorTok{=}\NormalTok{ hist\_dichte }\OperatorTok{*}\NormalTok{ klassenbreite}
\BuiltInTok{print}\NormalTok{(hist\_relativ)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[0.1  0.25 0.4  0.1  0.15]
\end{verbatim}

Die Summe der relativen Häufigkeiten ist 1.

Ein Histogramm kann mit der Funktion
\texttt{plt.hist(x,\ bins\ =\ None,\ *,\ range\ =\ None,\ density\ =\ False)}
aufgerufen werden, welche intern \texttt{np.histogram()} für die
Berechnungen aufruft. Die Parameter der Funktion entsprechenen denen der
NumPy-Funktion, wobei mit dem Argument \texttt{x} die darzustellenden
Daten übergeben werden. Zusätzlich können verschiedene Grafikparameter
übergeben werden.

Die Funktion hat 3 Rückgabewerte: die absolute Häufigkeit der Klassen
(bzw. wenn \texttt{density\ =\ True} die Häufigkeitsdichte), die
x-Position der Rechtecke und die Objekte für die Grafikerstellung
(letztere werden im folgenden Code im Objekt \texttt{ignore} gespeichert
und nicht weiter verwendet.).

\section{absolute Häufigkeit}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.hist(dose2, bins }\OperatorTok{=} \DecValTok{5}\NormalTok{, edgecolor }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Länge zahnbildender Zellen bei Meerschweinchen\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Achsenbeschriftung}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Länge der zahnbildenden Zellen (μm)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}absolute Häufigkeit\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-14-output-1.png}}

\section{relative Häufigkeit}

Eine Darstellung der relativen Häufigkeiten ist nicht direkt möglich.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hist\_dichte, bins, ignore }\OperatorTok{=}\NormalTok{ plt.hist(dose2, bins }\OperatorTok{=} \DecValTok{5}\NormalTok{, density }\OperatorTok{=} \VariableTok{True}\NormalTok{, edgecolor }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Länge zahnbildender Zellen bei Meerschweinchen\textquotesingle{}}\NormalTok{)}

\CommentTok{\# relative Häufigkeit berechnen}
\NormalTok{klassenbreite }\OperatorTok{=}\NormalTok{ np.diff(bins)[}\DecValTok{0}\NormalTok{]}
\NormalTok{hist\_relativ }\OperatorTok{=}\NormalTok{ hist\_dichte }\OperatorTok{*}\NormalTok{ klassenbreite}

\CommentTok{\# yticks erzeugen an der Position von min(hist\_dichte) bis max(hist\_dichte)}
\CommentTok{\# aber mit Werten von hist\_relativ}
\NormalTok{plt.yticks(ticks }\OperatorTok{=}\NormalTok{ np.linspace(}\BuiltInTok{min}\NormalTok{(hist\_dichte), }\BuiltInTok{max}\NormalTok{(hist\_dichte), }\BuiltInTok{len}\NormalTok{(hist\_relativ)),}
\NormalTok{labels }\OperatorTok{=}\NormalTok{ np.linspace(hist\_relativ.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{).}\BuiltInTok{min}\NormalTok{(), hist\_relativ.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{).}\BuiltInTok{max}\NormalTok{(), }\BuiltInTok{len}\NormalTok{(hist\_relativ)).}\BuiltInTok{round}\NormalTok{(}\DecValTok{3}\NormalTok{))}\OperatorTok{;}

\CommentTok{\# Achsenbeschriftung}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Länge der zahnbildenden Zellen (μm)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}relative Häufigkeit\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-15-output-1.png}}

\section{Häufigkeitsdichte}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.hist(dose2, bins }\OperatorTok{=} \DecValTok{5}\NormalTok{, density }\OperatorTok{=} \VariableTok{True}\NormalTok{, edgecolor }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Länge zahnbildender Zellen bei Meerschweinchen\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Achsenbeschriftung}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Länge der zahnbildenden Zellen (μm)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Häufigkeitsdichte\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-16-output-1.png}}

~

Histogramme sind nicht immer gut geeignet, um die Verteilung einer
Stichprobe zu charakterisieren. Der visuelle Eindruck hängt von der
gewählten Klassenzahl ab - ein Beispiel:

\section{3 Klassen}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.hist(meerschweinchen[}\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{], bins }\OperatorTok{=} \DecValTok{3}\NormalTok{, density }\OperatorTok{=} \VariableTok{True}\NormalTok{, edgecolor }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{)}\OperatorTok{;}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Länge zahnbildender Zellen bei Meerschweinchen\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Achsenbeschriftung}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Länge der zahnbildenden Zellen (μm)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Häufigkeitsdichte\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-17-output-1.png}}

\section{5 Klassen}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.hist(meerschweinchen[}\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{], bins }\OperatorTok{=} \DecValTok{5}\NormalTok{, density }\OperatorTok{=} \VariableTok{True}\NormalTok{, edgecolor }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{)}\OperatorTok{;}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Länge zahnbildender Zellen bei Meerschweinchen\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Achsenbeschriftung}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Länge der zahnbildenden Zellen (μm)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Häufigkeitsdichte\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-18-output-1.png}}

\section{7 Klassen}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.hist(meerschweinchen[}\StringTok{\textquotesingle{}len\textquotesingle{}}\NormalTok{], bins }\OperatorTok{=} \DecValTok{7}\NormalTok{, density }\OperatorTok{=} \VariableTok{True}\NormalTok{, edgecolor }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{)}\OperatorTok{;}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Länge zahnbildender Zellen bei Meerschweinchen\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Achsenbeschriftung}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Länge der zahnbildenden Zellen (μm)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Häufigkeitsdichte\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-19-output-1.png}}
\end{quote}

\end{tcolorbox}

Die Dichtefunktion der Normalverteilung beschreibt, welcher Anteil der
Werte innerhalb eines bestimmten Wertebereichs liegt. Bei der Berechnung
der relativen Häufigkeiten in Note~\ref{nte-histogram} haben wir
gesehen, dass die Summe der relativen Häufigkeiten 1 ist. Dies
entspricht der Fläche unterhalb der Dichtekurve.

Die Dichtefunktion der Normalverteilung ist definiert als:

\[
f(x) = \frac{1}{\sigma \sqrt{2\pi}} ~ e^{-\frac{1}{2}\left(\frac{x - \mu}{\sigma}\right)^2}
\]

Die Form der Normalverteilung ergibt sich aus dem Faktor
\(e^{-\frac{1}{2}\left(\frac{x -\mu}{\sigma}\right)^2}\) der
Funktionsgleichung. Das Maximum der Funktion liegt am Punkt \(x = \mu\).
Von dort fällt sie symmetrisch ab und nähert sich der x-Achse an. Der
Abfall der Funktion erfolgt umso schneller, je kleiner \(\sigma\) ist.
Die Wendepunkte der Kurve liegen jeweils eine Standardabweichung vom
Mittelwert entfernt.

Eine Normalverteilung mit dem Mittelwert \(\mu = 0\) und einer
Standardabweichung \(\sigma = 1\) heißt Standardnormalverteilung.

{[}@Baitsch-2019, S. 51-54{]}

~

\section{Normalverteilung anpassen}\label{normalverteilung-anpassen}

Um die Verteilung in einem Datensatz durch eine Normalverteilung
anzunähern, werden dessen Mittelwert und Standardabweichung in die
Funktionsgleichung der Normalverteilung eingesetzt. Mit Python können
die Berechnungen direkt vorgenommen werden. In der Handhabung einfacher
sind die vom Paket SciPy bereitgestellten Funktionen, die im nächsten
Abschnitt ausführlicher vorgestellt werden. Das folgende Beispiel zeigt
die Berechnung und Visualisierung mit Python und mit SciPy.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-normalverteilungdarstellen}: Dichtekurven berechnen und darstellen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-normalverteilungdarstellen} 

Betrachten wir die Verteilungskennwerte der Gruppe der Meerschweinchen,
die eine Dosis von 2 Milligramm Vitamin C erhielten.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(verteilungskennwerte(dose2), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}\OperatorTok{;}

\NormalTok{dose2\_mean }\OperatorTok{=}\NormalTok{ verteilungskennwerte(dose2, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)[}\DecValTok{1}\NormalTok{]}
\NormalTok{dose2\_std }\OperatorTok{=}\NormalTok{ verteilungskennwerte(dose2, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)[}\DecValTok{4}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Exakter Mittelwert:"}\NormalTok{, dose2\_mean)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Exakte Standardabweichung:"}\NormalTok{, dose2\_std)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
N: 20
arithmetisches Mittel: 26.10
Stichprobenfehler: 0.84
Stichprobenvarianz: 14.24
Stichprobenstandardabweichung: 3.77
None 

Exakter Mittelwert: 26.1
Exakte Standardabweichung: 3.7741503052098744
\end{verbatim}

Wenn wir die Standardabweichung und das arithmetische Mittel in die
Normalverteilungsfunktion einsetzen, erhalten wir:

\[
f(x) = \frac{1}{3.7742 \sqrt{2\pi}} ~ e^{-\frac{1}{2}\left(\frac{x-26.10}{3.7742}\right)^2}
\]

\[
f(x) = 0.1057 \cdot e^{-\frac{1}{2}\left(\frac{x-26.10}{3.7742}\right)^2}
\]

In Python können die Berechnungen umgesetzt und grafisch dargestellt
werden:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Histogram der Häufigkeitsdichte zeichnen}
\NormalTok{plt.hist(dose2, bins }\OperatorTok{=} \DecValTok{7}\NormalTok{, density }\OperatorTok{=} \VariableTok{True}\NormalTok{, edgecolor }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{)}\OperatorTok{;}
\NormalTok{plt.title(}\StringTok{\textquotesingle{}Länge zahnbildender Zellen bei Meerschweinchen\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Achsenbeschriftung}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Länge der zahnbildenden Zellen (μm)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Häufigkeitsdichte\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Normalverteilung berechnen.}
\NormalTok{hist, bin\_edges }\OperatorTok{=}\NormalTok{ np.histogram(dose2, bins }\OperatorTok{=} \DecValTok{7}\NormalTok{)}

\NormalTok{x\_values }\OperatorTok{=}\NormalTok{ np.linspace(}\BuiltInTok{min}\NormalTok{(bin\_edges), }\BuiltInTok{max}\NormalTok{(bin\_edges), }\DecValTok{100}\NormalTok{)}

\CommentTok{\#\# Normalverteilungsfunktion mit Python berechnen}
\NormalTok{y\_values }\OperatorTok{=}  \DecValTok{1} \OperatorTok{/}\NormalTok{ (dose2\_std }\OperatorTok{*}\NormalTok{ np.sqrt(}\DecValTok{2} \OperatorTok{*}\NormalTok{ np.pi)) }\OperatorTok{*}\NormalTok{ np.exp(}\OperatorTok{{-}}\NormalTok{ (x\_values }\OperatorTok{{-}}\NormalTok{ dose2\_mean) }\OperatorTok{**} \DecValTok{2} \OperatorTok{/}\NormalTok{ (}\DecValTok{2} \OperatorTok{*}\NormalTok{ dose2\_std }\OperatorTok{**} \DecValTok{2}\NormalTok{))}
\NormalTok{plt.plot(x\_values, y\_values, label }\OperatorTok{=} \StringTok{\textquotesingle{}Normalverteilung\textquotesingle{}}\NormalTok{, lw }\OperatorTok{=} \DecValTok{4}\NormalTok{)}

\CommentTok{\#\# scipy}
\NormalTok{y\_values\_scipy }\OperatorTok{=}\NormalTok{ scipy.stats.norm.pdf(x\_values, loc }\OperatorTok{=}\NormalTok{ dose2\_mean, scale }\OperatorTok{=}\NormalTok{ dose2\_std)}
\NormalTok{plt.plot(x\_values, y\_values\_scipy, label }\OperatorTok{=} \StringTok{\textquotesingle{}SciPy\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}dashed\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.legend()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-21-output-1.png}}

~

Die Verteilung der Länge zahnbildender Zellen bei Meerschweinchen, die
eine Dosis von 2 Milligramm Vitamin C erhielten, könnte einer
Normalverteilung entsprechen. Aufgrund der geringen Stichprobengröße ist
dies aber schwer zu beurteilen.

\end{tcolorbox}

~

\section{Das Paket SciPy}\label{das-paket-scipy}

Funktionen zur Berechnung von Dichtekurven können über Paket SciPy
importiert werden. Das Modul stats (statistical functions) umfasst
zahlreiche Funktionen zum Testen von Hypothesen. Funktionen für die
Normalverteilung werden wie folgt aufgerufen:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ scipy}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Häufigkeitsdichte der Normalverteilung bei x = 0:"}\NormalTok{, scipy.stats.norm.pdf(}\DecValTok{0}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Häufigkeitsdichte der Normalverteilung bei x = 0: 0.3989422804014327 
\end{verbatim}

Für die Normalverteilung sind vier Funktionen relevant:

\begin{figure}

\begin{minipage}{0.45\linewidth}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-23-output-1.png}}

\end{minipage}%
%
\begin{minipage}{0.55\linewidth}
\textbf{Beschreibung}\\
Die Funktion \texttt{scipy.stats.norm.pdf(x)} berechnet die Dichte der
Normalverteilung am Punkt \texttt{x} (pdf = probability density
function). \texttt{x} kann auch ein array sein - so wurde die
linksstehende Kurve mit dem Befehl
\texttt{scipy.stats.norm.pdf(np.linspace(-4,\ 4,\ 100))}
berechnet.\end{minipage}%
\newline
\begin{minipage}{0.45\linewidth}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-24-output-1.png}}

\end{minipage}%
%
\begin{minipage}{0.55\linewidth}
\textbf{Beschreibung}\\
Die Funktion \texttt{scipy.stats.norm.cdf(x)} berechnet den Anteil der
Werte \(q\) links von \texttt{x} (cdf = cumulative density
function).\end{minipage}%
\newline
\begin{minipage}{0.45\linewidth}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-25-output-1.png}}

\end{minipage}%
%
\begin{minipage}{0.55\linewidth}
\textbf{Beschreibung}\\
Die Funktion \texttt{scipy.stats.norm.ppf(q)} ist die Quantilfunktion
der Normalverteilung und die Umkehrfunktion der kumulativen
Häufigkeitsdichtefunktion (cdf). Die Funktion berechnet für
\(0 \le q \le 1\) den Wert \texttt{x}, links von dem der Anteil
\texttt{q} aller Werte liegt und rechts von dem der Anteil \texttt{1-q}
liegt (ppf = percentile point function).\end{minipage}%
\newline
\begin{minipage}{0.45\linewidth}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-26-output-1.png}}

\end{minipage}%
%
\begin{minipage}{0.55\linewidth}
\textbf{Beschreibung}\\
Die Funktion \texttt{scipy.stats.norm.rvs(size)} zieht \texttt{size}
Zufallszahlen aus der Normalverteilung.\\
\emph{Hinweis: Die Zufallszahlen werden im Skript dynamisch
gezogen.}\end{minipage}%

\end{figure}%

Für die vorgestellten Funktionen kann mit den Parametern
\texttt{loc\ =\ mittelwert} und \texttt{scale\ =\ standardabweichung}
die Form der Normalverteilung angepasst werden. Standardmäßig wird die
Standardnormalverteilung mit \texttt{loc\ =\ 0} und \texttt{scale\ =\ 1}
berechnet. Die Parameter der Funktionen können Einzelwerte (Skalare)
oder auch Arrays bzw. Listen sein.

\section{Aufgaben Normalverteilung}\label{aufgaben-normalverteilung}

Möglicherweise haben Sie schon einmal von Mensa International gehört,
einer Vereinigung für Hochbegabte. Wer Mitglied in dieser Vereinigung
werden möchte, soll einen höheren Intelligenzquotienten (IQ) haben als
98 \% der Bevölkerung seines:ihres Herkunftslandes
(\href{https://de.wikipedia.org/wiki/Mensa_International}{Wikipedia}).

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Wenn der durchschnittliche IQ 100 und die Standardabweichung 15
  beträgt, welchen IQ müssten Sie haben, um bei Mensa International
  aufgenommen zu werden?
\item
  Mensa International ist nicht die einzige Organisation ihrer Art.
  Andere Organisationen haben sogar noch strengere Kriterien. Welcher IQ
  wird benötigt, um hier Mitglied zu werden?
\end{enumerate}

\begin{itemize}
\tightlist
\item
  Intertel (Kriterium: IQ aus dem höchsten 1 \%)
\item
  Triple Nine Society (Kriterium: IQ aus dem höchsten 0,1 \%)
\item
  Prometheus Society (Kriterium: IQ aus dem höchsten 0,003 \%)
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Der IQ ist nicht mit angeborener Intelligenz gleichzusetzen und auch
  abhängig davon, wie viel Gelegenheit man zum Gehirntraining hatte,
  etwa durch den Schulbesuch. Der niedrigste durchschnittliche IQ wurde
  mit 71 \href{https://www.laenderdaten.info/iq-nach-laendern.php}{im
  Land Niger} gemessen. Angenommen Sie hätten einen IQ von 100. Würden
  Sie in Niger das Kriterium der Mensa International erfüllen?
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Musterlösung Normalverteilung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Aufgabe 1: Einen IQ von mehr als \ldots{}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(scipy.stats.norm.ppf(loc }\OperatorTok{=} \DecValTok{100}\NormalTok{, scale }\OperatorTok{=} \DecValTok{15}\NormalTok{, q }\OperatorTok{=} \FloatTok{0.98}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
130.80623365947733
\end{verbatim}

Aufgabe 2: Sie benötigen einen IQ von mindestens\ldots{}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(scipy.stats.norm.ppf(loc }\OperatorTok{=} \DecValTok{100}\NormalTok{, scale }\OperatorTok{=} \DecValTok{15}\NormalTok{, q }\OperatorTok{=} \FloatTok{0.99}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(scipy.stats.norm.ppf(loc }\OperatorTok{=} \DecValTok{100}\NormalTok{, scale }\OperatorTok{=} \DecValTok{15}\NormalTok{, q }\OperatorTok{=} \FloatTok{0.999}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(scipy.stats.norm.ppf(loc }\OperatorTok{=} \DecValTok{100}\NormalTok{, scale }\OperatorTok{=} \DecValTok{15}\NormalTok{, q }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ (}\FloatTok{0.003} \OperatorTok{/} \DecValTok{100}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
134.8952181106126
146.3534845925172
160.19216216677682
\end{verbatim}

Aufgabe 3: Nicht ganz.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(scipy.stats.norm.cdf(loc }\OperatorTok{=} \DecValTok{71}\NormalTok{, scale }\OperatorTok{=} \DecValTok{15}\NormalTok{, x }\OperatorTok{=} \DecValTok{100}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.9734024259789904
\end{verbatim}

\end{tcolorbox}

Übrigens: Wie
\href{https://www.spiegel.de/lebenundlernen/intelligenz-von-studenten-neugier-schlaegt-iq-a-816084.html}{der
Spiegel berichtet}, schneiden Studierende mit mittelmäßigem
Intelligenzquotienten ebenso erfolgreich ab wie Hochbegabte,
vorausgesetzt sie sind neugierig genug und arbeiten gewissenhaft.

\section{Konfidenzintervalle}\label{konfidenzintervalle}

Die schließende Statistik beruht auf dem Prinzip, von Stichprobenwerten
auf den tatsächlichen Wert in der Grundgesamtheit zu schließen. Die
Überlegung ist wie folgt:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Wenn eine Stichprobe aus einer Grundgesamtheit gezogen wird, dann
  streuen die Stichprobenwerte normalverteilt um den Mittelwert der
  Grundgesamtheit. Bei einer Normalverteilung liegen

  \begin{itemize}
  \tightlist
  \item
    68,27 \% aller Werte im Intervall \(\pm 1 ~ s\),
  \item
    95,45 \% aller Werte im Intervall \(\pm 2 ~ s\) und
  \item
    99,73 \% aller Werte im Intervall \(\pm 3 ~ s\).
  \end{itemize}
\item
  Mit der gleichen Wahrscheinlichkeitsverteilung liegt der unbekannte
  Mittelwert der Grundgesamtheit um einen zufälligen Wert aus der
  Stichprobe.
\item
  Der Erwartungswert kann mit einer gewissen Wahrscheinlichkeit aus dem
  Standardfehler des Mittelwerts einer Stichprobe geschätzt werden. Man
  wählt dazu ein Konfidenzniveau, also eine
  Vertrauenswahrscheinlichkeit, dass der Erwartungswert tatsächlich im
  Bereich der Schätzung liegt. Der umgekehrte Fall, dass der
  Erwartungswert nicht im Bereich der Schätzung liegt, wird Signifikanz-
  oder Alphaniveau genannt und mit dem griechischen Buchstaben
  \(\alpha\) (alpha) gekennzeichnet. \(\alpha\) liegt im Bereich 0 - 1,
  das Konfidenzniveau ist \(1 - \alpha\) (siehe:
  \href{https://de.wikipedia.org/wiki/Fehler_1._und_2._Art}{Fehler 1.
  und 2. Art}).

  \begin{itemize}
  \tightlist
  \item
    der Erwartungswert liegt in 68,27 \% aller Fälle im Intervall
    \(\pm 1 ~ \frac{s}{\sqrt{n}}\),
  \item
    der Erwartungswert liegt in 95,45 \% aller Fälle im Intervall
    \(\pm 2 ~ \frac{s}{\sqrt{n}}\) und
  \item
    der Erwartungswert liegt in 99,73 \% aller Fälle im Intervall
    \(\pm 3 ~ \frac{s}{\sqrt{n}}\).
  \end{itemize}
\end{enumerate}

Häufig wird das Alphaniveau \(\alpha = 0.05\) bzw. das
Konfidenzintervall 95 \% gewählt, was \(\pm 1.96 ~ \frac{s}{\sqrt{n}}\)
entspricht. Dies gilt aber nur für große Stichproben. Für kleine
Stichprobengrößen folgen die Stichprobenmittelwerte der t-Verteilung,
die im nächsten Abschnitt vorgestellt wird.

\textbf{to do Maik: hier könnte / müsste man noch einseitige und
zweiseitige Hypothesentests und den Begriff ``Alpha-Halbe'' einführen.
Das ließe sich auch gut grafisch mit nur nach rechts gehenden und
beidseitigen Pfeilen darstellen.}

Im folgenden Beispiel wird die Idee, dass mit einer gewissen
Wahrscheinlichkeit vom Stichprobenmittelwert auf den Mittelwert der
Grundgesamtheit (Erwartungswert) geschlossen werden kann, noch einmal
grafisch dargestellt.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-statistik}: Prinzip der schließenden Statistik}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-statistik} 

\section{Standardnormalverteilung}

In einer Normalverteilung kommen Werte in der Nähe des Erwartungswerts
häufiger vor als weit vom Erwartungswert entfernt liegende Werte. Wie
häufig oder selten ein Wert relativ zum Mittelwert der Verteilung
vorkommt, kann mit der Standardabweichung ausgedrückt werden.

In der Grafik sehen Sie zufällig gezogene Werte und eine
Normalverteilungskurve.

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-30-output-1.png}}

\section{Einzelner Messwert}

Ein einzelner Messwert aus der Verteilung entspricht so gut wie nie dem
Erwartungswert. Man weiß aber, dass ein Wert nahe des Erwartungswerts
häufiger vorkommt, als ein weit entfernter.

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-31-output-1.png}}

\section{Stichprobe N = 12}

Der Mittelwert einer Stichprobe entspricht ebenfalls so gut wie nie dem
Erwartungswert. Der zu erwartende, in Einheiten des Standardfehlers des
Mittelwerts ausgedrückte Streuungsbereich ist jedoch erheblich schmaler
als der eines einzelnen Messwerts. Dies ist auch grafisch gut zu sehen.
Die Dichtekurve ist erheblich schmaler und höher als die
Normalverteilungskurve eines einzelnen Messwerts. Dies liegt an der
geringen Standardabweichung in der Stichprobe von \textasciitilde{} 0.2,
was die Kurve staucht.

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-32-output-1.png}}

\section{Code}

Code für das Panel Stichprobe N = 12

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}
\ImportTok{import}\NormalTok{ scipy}

\CommentTok{\# Parameter der Standardnormalverteilung}
\NormalTok{mu, sigma }\OperatorTok{=} \DecValTok{0}\NormalTok{, }\DecValTok{1}  \CommentTok{\# Mittelwert und Standardabweichung}

\CommentTok{\# Daten generieren}
\NormalTok{seed }\OperatorTok{=} \DecValTok{4}
\NormalTok{np.random.seed(seed }\OperatorTok{=}\NormalTok{ seed)}
\NormalTok{data }\OperatorTok{=}\NormalTok{ np.random.default\_rng().normal(mu, sigma, }\DecValTok{1000}\NormalTok{)}

\CommentTok{\# Grafik}
\NormalTok{plt.figure(figsize }\OperatorTok{=}\NormalTok{ (}\FloatTok{8.5}\NormalTok{, }\DecValTok{6}\NormalTok{))}

\CommentTok{\# Histogramm plotten}
\NormalTok{array, bins, patches }\OperatorTok{=}\NormalTok{ plt.hist(data, bins }\OperatorTok{=} \DecValTok{30}\NormalTok{, density }\OperatorTok{=} \VariableTok{True}\NormalTok{, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}lightgoldenrodyellow\textquotesingle{}}\NormalTok{, edgecolor}\OperatorTok{=}\StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Mittelwert einzeichnen}
\NormalTok{mean\_line }\OperatorTok{=}\NormalTok{ plt.axvline(mu, color }\OperatorTok{=} \StringTok{\textquotesingle{}steelblue\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}solid\textquotesingle{}}\NormalTok{, linewidth }\OperatorTok{=} \DecValTok{3}\NormalTok{)}

\CommentTok{\# positive und negative Standardabweichungen einzeichnen}
\NormalTok{pos\_std\_lines }\OperatorTok{=}\NormalTok{ [plt.axvline(mu }\OperatorTok{+}\NormalTok{ i }\OperatorTok{*}\NormalTok{ sigma, color }\OperatorTok{=} \StringTok{\textquotesingle{}steelblue\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}dotted\textquotesingle{}}\NormalTok{, linewidth }\OperatorTok{=} \DecValTok{2}\NormalTok{) }\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{)]}
\NormalTok{neg\_std\_lines }\OperatorTok{=}\NormalTok{ [plt.axvline(mu }\OperatorTok{{-}}\NormalTok{ i }\OperatorTok{*}\NormalTok{ sigma, color }\OperatorTok{=} \StringTok{\textquotesingle{}steelblue\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}dotted\textquotesingle{}}\NormalTok{, linewidth }\OperatorTok{=} \DecValTok{2}\NormalTok{) }\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{)]}

\CommentTok{\# Normalverteilungskurve}
\NormalTok{x\_values }\OperatorTok{=}\NormalTok{ np.linspace(}\BuiltInTok{min}\NormalTok{(bins), }\BuiltInTok{max}\NormalTok{(bins), }\DecValTok{100}\NormalTok{)}
\NormalTok{y\_values }\OperatorTok{=} \DecValTok{1} \OperatorTok{/}\NormalTok{ (sigma }\OperatorTok{*}\NormalTok{ np.sqrt(}\DecValTok{2} \OperatorTok{*}\NormalTok{ np.pi)) }\OperatorTok{*}\NormalTok{ np.exp(}\OperatorTok{{-}}\NormalTok{ (x\_values }\OperatorTok{{-}}\NormalTok{ mu) }\OperatorTok{**} \DecValTok{2} \OperatorTok{/}\NormalTok{ (}\DecValTok{2} \OperatorTok{*}\NormalTok{ sigma }\OperatorTok{**} \DecValTok{2}\NormalTok{))}
\NormalTok{normal\_dist\_curve }\OperatorTok{=}\NormalTok{ plt.plot(x\_values, y\_values, color }\OperatorTok{=} \StringTok{\textquotesingle{}steelblue\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}solid\textquotesingle{}}\NormalTok{, linewidth }\OperatorTok{=} \DecValTok{2}\NormalTok{)}

\CommentTok{\# Stichprobe}
\NormalTok{N }\OperatorTok{=} \DecValTok{12}
\NormalTok{np.random.seed(seed }\OperatorTok{=} \DecValTok{4}\NormalTok{)}
\NormalTok{stichprobe }\OperatorTok{=}\NormalTok{ np.random.default\_rng().normal(mu, sigma, N)}

\NormalTok{stichprobenstandardabweichung }\OperatorTok{=}\NormalTok{ stichprobe.std(ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{stichprobenmittelwert }\OperatorTok{=}\NormalTok{ stichprobe.mean()}
\NormalTok{standardfehler }\OperatorTok{=}\NormalTok{  stichprobenstandardabweichung }\OperatorTok{/}\NormalTok{ np.sqrt(}\BuiltInTok{len}\NormalTok{(stichprobe))}

\CommentTok{\# Histogramm berechnen}
\CommentTok{\# hist, bins = np.histogram(stichprobe, bins = 30, density = True)}

\CommentTok{\# Standardfehlerkurve Stichprobe}
\CommentTok{\# x\_values = np.linspace(min(bins), max(bins), 100)}
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.linspace(stichprobenmittelwert }\OperatorTok{{-}} \DecValTok{4} \OperatorTok{*}\NormalTok{ stichprobenstandardabweichung, stichprobenmittelwert }\OperatorTok{+} \DecValTok{4} \OperatorTok{*}\NormalTok{ stichprobenstandardabweichung, }\DecValTok{100}\NormalTok{)}
\NormalTok{y\_values }\OperatorTok{=}\NormalTok{ scipy.stats.t.pdf(x }\OperatorTok{=}\NormalTok{ x\_values, df }\OperatorTok{=}\NormalTok{ N }\OperatorTok{{-}} \DecValTok{1}\NormalTok{, loc }\OperatorTok{=}\NormalTok{ stichprobenmittelwert, scale }\OperatorTok{=}\NormalTok{ standardfehler) }\CommentTok{\# t{-}Verteilung}

\CommentTok{\# Stichprobenmittelwert einzeichnen}
\NormalTok{mean\_stichprobe }\OperatorTok{=}\NormalTok{ plt.axvline(stichprobenmittelwert, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}solid\textquotesingle{}}\NormalTok{, linewidth }\OperatorTok{=} \DecValTok{2}\NormalTok{)}

\CommentTok{\# Verteilungskurve einzeichnen}
\NormalTok{stichprobe\_dist\_curve }\OperatorTok{=}\NormalTok{ plt.plot(x\_values, y\_values, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}solid\textquotesingle{}}\NormalTok{, linewidth }\OperatorTok{=} \DecValTok{2}\NormalTok{)}

\CommentTok{\# Legende}
\NormalTok{plt.legend([normal\_dist\_curve[}\DecValTok{0}\NormalTok{], mean\_line, neg\_std\_lines[}\DecValTok{0}\NormalTok{], mean\_stichprobe, stichprobe\_dist\_curve[}\DecValTok{0}\NormalTok{]],}
\NormalTok{           [}\StringTok{\textquotesingle{}Standardnormalverteilung\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Mittelwert\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Standardabweichung\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Stichprobenmittelwert\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}t{-}Verteilung\textquotesingle{}}\NormalTok{],}
\NormalTok{           loc}\OperatorTok{=}\StringTok{\textquotesingle{}upper right\textquotesingle{}}\NormalTok{, handlelength }\OperatorTok{=} \DecValTok{3}\NormalTok{)}

\NormalTok{plt.title(}\StringTok{\textquotesingle{}Standardnormalverteilung\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Standardabweichung\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Häufigkeitsdichte\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

~

\section{Die t-Verteilung}\label{die-t-verteilung}

Die t-Verteilung wurde von William Sealy Gosset entdeckt (wenngleich
nicht als erstem) und popularisiert. Die Verteilung ist auch als
Student'sche Verteilung bekannt: Da Gossets Arbeitgeber, die
Guiness-Brauerei, die Veröffentlichung der Entdeckung nicht gestattete,
publizierte Gosset unter dem Synonym Student.
(\href{https://de.wikipedia.org/wiki/Studentsche_t-Verteilung}{Wikipedia})

Die t-Verteilung beschreibt die Verteilung von Stichprobenmittelwerten
mit unbekannter Varianz in der Grundgesamtheit, deren Standardfehler mit
der Stichprobenstandardabweichung geschätzt wird. Die t-Verteilung hat
gegenüber der Normalverteilung die
\href{https://de.wikipedia.org/wiki/Anzahl_der_Freiheitsgrade_(Statistik)}{Anzahl
der Freiheitsgrade} als zusätzlichen Parameter

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-freiheitsgrad}: Anzahl Freiheitsgrade}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-freiheitsgrad} 

``Die Anzahl unabhängiger Information, die in die Schätzung eines
Parameters einfließen, wird als Anzahl der Freiheitsgrade bezeichnet. Im
Allgemeinen sind die Freiheitsgrade einer Schätzung eines Parameters
gleich der Anzahl unabhängiger Einzelinformationen, die in die Schätzung
einfließen, abzüglich der Anzahl der zu schätzenden Parameter, die als
Zwischenschritte bei der Schätzung des Parameters selbst verwendet
werden. Beispielsweise fließen \(n\) Werte in die Berechnung der
Stichprobenvarianz ein. Dennoch lautet die Anzahl der Freiheitsgrade
\(n − 1\), da als Zwischenschritt der Mittelwert geschätzt wird und
somit ein Freiheitsgrad verloren geht.''

Anzahl der Freiheitsgrade (Statistik). von verschiedenen
\href{https://xtools.wmcloud.org/authorship/de.wikipedia.org/Anzahl_der_Freiheitsgrade_(Statistik)?uselang=de}{Autor:innen}
steht unter der Lizenz
\href{https://creativecommons.org/licenses/by-sa/4.0/deed.de}{CC BY-SA
4.0} ist abrufbar auf
\href{https://de.wikipedia.org/wiki/Anzahl_der_Freiheitsgrade_(Statistik)}{Wikipedia}.
2025

\end{tcolorbox}

Die allgemeine Häufigkeitsdichtefunktion der t-Verteilung lautet:

\[
f(x) = \frac{\Gamma\left(\frac{\nu + 1}{2}\right)}{\sqrt{\nu \pi} , \Gamma\left(\frac{\nu}{2}\right)} \left(1 + \frac{x^2}{\nu}\right)^{-\frac{\nu + 1}{2}}
\]

\begin{itemize}
\tightlist
\item
  \(\nu\) (ny) ist die Anzahl der Freiheitsgrade.
\item
  \(\Gamma\) ist die
  \href{https://de.wikipedia.org/wiki/Gammafunktion}{Gammafunktion}, die
  für ganzzahlige Argumente \(n\) den Wert \(\Gamma(n) = (n-1)!\) hat.
\end{itemize}

Da für die Berechnung des Stichprobenmittelwerts die Anzahl der
Freiheitsgrade \(n - 1\) ist, kann auch geschrieben werden: \[
f(x) = \frac{\Gamma\left(\frac{n}{2}\right)}{\sqrt{(n-1) \pi} , \Gamma\left(\frac{n-1}{2}\right)} \left(1 + \frac{x^2}{n-1}\right)^{-\frac{n}{2}}
\]

\begin{itemize}
\tightlist
\item
  \(n\) ist die Stichprobengröße.
\end{itemize}

Das Modul scipy.stats stellt Funktionen zur Berechnung der t-Verteilung
bereit.

\begin{itemize}
\tightlist
\item
  \texttt{scipy.stats.t.pdf(x,\ df,\ loc=0,\ scale=1)} berechnet die
  Häufigkeitsdichte für die Werte \texttt{x} für eine t-Verteilung mit
  \texttt{df} Freiheitsgraden, Mittelwert \texttt{loc} und
  Standardabweichung \texttt{scale} (pdf = probability density
  function).
\item
  \texttt{scipy.stats.t.cdf(x,\ df,\ loc=0,\ scale=1)} berechnet den
  Anteil der Werte links von \texttt{x} (cdf = cumulative density
  function).
\item
  \texttt{scipy.stats.t.ppf(q,\ df,\ loc=0,\ scale=1)} ist die
  Quantilfunktion der t-Verteilung (ppf = percentile point function).
\item
  \texttt{scipy.stats.t.rvs(df,\ loc=0,\ scale=1,\ size=1)} zieht
  \texttt{size} Zufallzahlen aus der t-Verteilung.
\end{itemize}

Die Parameter der Funktionen können Einzelwerte (Skalare) oder auch
Arrays bzw. Listen sein.

Mit zunehmender Stichprobengröße nähert sich die t-Verteilung der
Normalverteilung an. Als Faustformel gilt \(n > 30\). Untenstehende
Grafik zeigt die Annäherung der t-Verteilung an die Normalverteilung.

\section{Grafik}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-34-output-1.png}}

\section{Code}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x\_values }\OperatorTok{=}\NormalTok{ np.linspace(}\OperatorTok{{-}}\DecValTok{4}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{100}\NormalTok{)}

\CommentTok{\# Normalverteilung}
\NormalTok{y\_values }\OperatorTok{=}\NormalTok{ scipy.stats.norm.pdf(x\_values)}
\NormalTok{plt.plot(x\_values, y\_values, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, lw }\OperatorTok{=} \DecValTok{3}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Normalverteilung\textquotesingle{}}\NormalTok{)}
\CommentTok{\# plt.ylim(bottom = 0, top = 0.5)}

\CommentTok{\# t{-}Verteilungen}
\NormalTok{marker }\OperatorTok{=}\NormalTok{ [}\StringTok{"."}\NormalTok{, }\StringTok{"1"}\NormalTok{, }\StringTok{"x"}\NormalTok{]}

\NormalTok{[plt.plot(x\_values, scipy.stats.t.pdf(x\_values, df }\OperatorTok{=}\NormalTok{ (i }\OperatorTok{+}\NormalTok{ (i }\OperatorTok{{-}} \DecValTok{1}\NormalTok{) }\OperatorTok{*} \DecValTok{2}\NormalTok{)), linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}dotted\textquotesingle{}}\NormalTok{, marker }\OperatorTok{=}\NormalTok{ marker[i }\OperatorTok{{-}} \DecValTok{1}\NormalTok{] , linewidth }\OperatorTok{=} \DecValTok{2}\NormalTok{, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}df = \textquotesingle{}} \OperatorTok{+} \BuiltInTok{str}\NormalTok{((i }\OperatorTok{+}\NormalTok{ (i }\OperatorTok{{-}} \DecValTok{1}\NormalTok{) }\OperatorTok{*} \DecValTok{2}\NormalTok{))) }\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{)]}

\NormalTok{plt.suptitle(}\StringTok{\textquotesingle{}Das Argument df der t{-}Verteilung\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Standardabweichung\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Häufigkeitsdichte\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend(loc }\OperatorTok{=} \StringTok{\textquotesingle{}upper left\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

Das Maximum der t-Verteilung ist weniger dicht, dafür sind die Ränder
der Verteilung dichter als die Normalverteilung.

Somit gilt für die t-Verteilung von Stichprobenmittelwerten:

\[
\bar{x} \pm t_{n-1} \cdot \frac{s}{\sqrt{n}}
\]

\begin{itemize}
\tightlist
\item
  \(t\) ist der Rückgabewert der Funktion
  \texttt{scipy.stats.t.ppf(q,\ df\ =\ n\ -\ 1,\ loc\ =\ 0,\ scale\ =\ 1)}
\item
  q ist das gewählte Alphaniveau bzw. für einen zweiseitigen
  Hypothesentest \(\frac{\alpha}{2}\) und \(1 - \frac{\alpha}{2}\).
\item
  Das Ergebnis ist der Rückgabewert der Funktionen:

  \begin{itemize}
  \tightlist
  \item
    \texttt{scipy.stats.t.ppf(q\ =\ alpha/2,\ df\ =\ n\ -\ 1,\ loc\ =\ stichprobenmittelwert,\ scale\ =\ stichprobenstandardfehler)}
  \item
    \texttt{scipy.stats.t.ppf(q\ =\ 1\ -\ alpha/2,\ df\ =\ n\ -\ 1,\ loc\ =\ stichprobenmittelwert,\ scale\ =\ stichprobenstandardfehler)}
  \end{itemize}
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-t}: t-Verteilung oder Normalverteilung?}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-t} 

Am Computer ist die t-Verteilung genauso leicht (oder schwer) zu
berechnen wie die Normalverteilung. Da die t-Verteilung bessere
Schätzwerte für kleine Stichproben liefert und sich für größere
Stichprobengrößen ohnehin der Normalverteilung annähert, empfiehlt es
sich, stets die t-Verteilung zu verwenden.

\end{tcolorbox}

\subsection{Beispiel Gewicht weiblicher
Pinguine}\label{beispiel-gewicht-weiblicher-pinguine}

Die t-Verteilung des geschätzten Stichprobenmittelwerts für kleine
Stichproben wird für im Jahr 2008 beobachtete weibliche Pinguine
dargestellt.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(penguins.groupby(by }\OperatorTok{=}\NormalTok{ [penguins[}\StringTok{\textquotesingle{}species\textquotesingle{}}\NormalTok{], penguins[}\StringTok{\textquotesingle{}sex\textquotesingle{}}\NormalTok{], penguins[}\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{]]).size())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
species    sex     year
Adelie     female  2007    22
                   2008    25
                   2009    26
           male    2007    22
                   2008    25
                   2009    26
Chinstrap  female  2007    13
                   2008     9
                   2009    12
           male    2007    13
                   2008     9
                   2009    12
Gentoo     female  2007    16
                   2008    22
                   2009    20
           male    2007    17
                   2008    23
                   2009    21
dtype: int64
\end{verbatim}

\section{Grafik}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/normalverteilung_files/figure-pdf/cell-37-output-1.png}}

\section{Code}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{year }\OperatorTok{=} \DecValTok{2008}
\NormalTok{sex }\OperatorTok{=} \StringTok{\textquotesingle{}female\textquotesingle{}}
\NormalTok{species }\OperatorTok{=} \StringTok{\textquotesingle{}Adelie\textquotesingle{}}

\NormalTok{fig, (ax1, ax2, ax3) }\OperatorTok{=}\NormalTok{ plt.subplots(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, figsize }\OperatorTok{=}\NormalTok{ (}\FloatTok{7.5}\NormalTok{, }\DecValTok{6}\NormalTok{), sharey }\OperatorTok{=} \VariableTok{True}\NormalTok{, layout }\OperatorTok{=} \StringTok{\textquotesingle{}tight\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.suptitle(}\StringTok{\textquotesingle{}Gewichtsverteilung von weiblichen Pinguinen im Jahr 2008\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Adelie}
\NormalTok{data }\OperatorTok{=}\NormalTok{ penguins[}\StringTok{\textquotesingle{}body\_mass\_g\textquotesingle{}}\NormalTok{][(penguins[}\StringTok{\textquotesingle{}species\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ species) }\OperatorTok{\&}\NormalTok{ (penguins[}\StringTok{\textquotesingle{}sex\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ sex) }\OperatorTok{\&}\NormalTok{ (penguins[}\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ year)]}
\NormalTok{stichprobengröße }\OperatorTok{=}\NormalTok{ data.size}

\CommentTok{\#\# Histogramm}
\NormalTok{ax1.hist(data, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{, edgecolor }\OperatorTok{=} \StringTok{\textquotesingle{}lightgrey\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{, density }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{ax1.set\_xlabel(}\StringTok{\textquotesingle{}Gewicht in Gramm\textquotesingle{}}\NormalTok{)}
\NormalTok{ax1.set\_ylabel(}\StringTok{\textquotesingle{}Häufigkeitsdichte\textquotesingle{}}\NormalTok{)}
\NormalTok{ax1.set\_title(label }\OperatorTok{=} \BuiltInTok{str}\NormalTok{(species) }\OperatorTok{+} \StringTok{" N = "} \OperatorTok{+} \BuiltInTok{str}\NormalTok{(stichprobengröße))}

\CommentTok{\#\# t{-}Verteilung des Stichprobenmittelwerts}
\NormalTok{stichprobenmittelwert }\OperatorTok{=}\NormalTok{ data.mean()}
\NormalTok{stichprobenstandardabweichung }\OperatorTok{=}\NormalTok{ data.std(ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{standardfehler }\OperatorTok{=}\NormalTok{ stichprobenstandardabweichung }\OperatorTok{/}\NormalTok{ np.sqrt(stichprobengröße)}
\NormalTok{hist, bin\_edges }\OperatorTok{=}\NormalTok{ np.histogram(data)}
\NormalTok{x\_values }\OperatorTok{=}\NormalTok{ np.linspace(}\BuiltInTok{min}\NormalTok{(bin\_edges), }\BuiltInTok{max}\NormalTok{(bin\_edges), }\DecValTok{100}\NormalTok{)}
\NormalTok{y\_values }\OperatorTok{=}\NormalTok{ scipy.stats.t.pdf(x\_values, loc }\OperatorTok{=}\NormalTok{ stichprobenmittelwert, scale }\OperatorTok{=}\NormalTok{ standardfehler, df }\OperatorTok{=}\NormalTok{ stichprobengröße }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}

\NormalTok{ax1.plot(x\_values, y\_values, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, linewidth }\OperatorTok{=} \DecValTok{1}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}t{-}Verteilung\textquotesingle{}}\NormalTok{)}
\NormalTok{ax1.legend(loc }\OperatorTok{=} \StringTok{\textquotesingle{}upper left\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Chinstrap}
\NormalTok{species }\OperatorTok{=} \StringTok{\textquotesingle{}Chinstrap\textquotesingle{}}

\NormalTok{data }\OperatorTok{=}\NormalTok{ penguins[}\StringTok{\textquotesingle{}body\_mass\_g\textquotesingle{}}\NormalTok{][(penguins[}\StringTok{\textquotesingle{}species\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ species) }\OperatorTok{\&}\NormalTok{ (penguins[}\StringTok{\textquotesingle{}sex\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ sex) }\OperatorTok{\&}\NormalTok{ (penguins[}\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ year)]}
\NormalTok{stichprobengröße }\OperatorTok{=}\NormalTok{ data.size}

\CommentTok{\#\# Histogramm}
\NormalTok{ax2.hist(data, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{, edgecolor }\OperatorTok{=} \StringTok{\textquotesingle{}lightgrey\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{, density }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{ax2.set\_xlabel(}\StringTok{\textquotesingle{}Gewicht in Gramm\textquotesingle{}}\NormalTok{)}
\NormalTok{ax2.set\_title(label }\OperatorTok{=} \BuiltInTok{str}\NormalTok{(species) }\OperatorTok{+} \StringTok{" N = "} \OperatorTok{+} \BuiltInTok{str}\NormalTok{(stichprobengröße))}

\CommentTok{\#\# t{-}Verteilung des Stichprobenmittelwerts}
\NormalTok{stichprobenmittelwert }\OperatorTok{=}\NormalTok{ data.mean()}
\NormalTok{stichprobenstandardabweichung }\OperatorTok{=}\NormalTok{ data.std(ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{standardfehler }\OperatorTok{=}\NormalTok{ stichprobenstandardabweichung }\OperatorTok{/}\NormalTok{ np.sqrt(stichprobengröße)}
\NormalTok{hist, bin\_edges }\OperatorTok{=}\NormalTok{ np.histogram(data)}
\NormalTok{x\_values }\OperatorTok{=}\NormalTok{ np.linspace(}\BuiltInTok{min}\NormalTok{(bin\_edges), }\BuiltInTok{max}\NormalTok{(bin\_edges), }\DecValTok{100}\NormalTok{)}
\NormalTok{y\_values }\OperatorTok{=}\NormalTok{ scipy.stats.t.pdf(x\_values, loc }\OperatorTok{=}\NormalTok{ stichprobenmittelwert, scale }\OperatorTok{=}\NormalTok{ standardfehler, df }\OperatorTok{=}\NormalTok{ stichprobengröße }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}

\NormalTok{ax2.plot(x\_values, y\_values, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, linewidth }\OperatorTok{=} \DecValTok{1}\NormalTok{)}

\CommentTok{\# Gentoo}
\NormalTok{species }\OperatorTok{=} \StringTok{\textquotesingle{}Gentoo\textquotesingle{}}

\NormalTok{data }\OperatorTok{=}\NormalTok{ penguins[}\StringTok{\textquotesingle{}body\_mass\_g\textquotesingle{}}\NormalTok{][(penguins[}\StringTok{\textquotesingle{}species\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ species) }\OperatorTok{\&}\NormalTok{ (penguins[}\StringTok{\textquotesingle{}sex\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ sex) }\OperatorTok{\&}\NormalTok{ (penguins[}\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ year)]}
\NormalTok{stichprobengröße }\OperatorTok{=}\NormalTok{ data.size}

\CommentTok{\#\# Histogramm}
\NormalTok{ax3.hist(data, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{, edgecolor }\OperatorTok{=} \StringTok{\textquotesingle{}lightgrey\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}C2\textquotesingle{}}\NormalTok{, density }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{ax3.set\_xlabel(}\StringTok{\textquotesingle{}Gewicht in Gramm\textquotesingle{}}\NormalTok{)}
\NormalTok{ax3.set\_title(label }\OperatorTok{=} \BuiltInTok{str}\NormalTok{(species) }\OperatorTok{+} \StringTok{" N = "} \OperatorTok{+} \BuiltInTok{str}\NormalTok{(stichprobengröße))}

\CommentTok{\#\# t{-}Verteilung des Stichprobenmittelwerts}
\NormalTok{stichprobenmittelwert }\OperatorTok{=}\NormalTok{ data.mean()}
\NormalTok{stichprobenstandardabweichung }\OperatorTok{=}\NormalTok{ data.std(ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{standardfehler }\OperatorTok{=}\NormalTok{ stichprobenstandardabweichung }\OperatorTok{/}\NormalTok{ np.sqrt(stichprobengröße)}
\NormalTok{hist, bin\_edges }\OperatorTok{=}\NormalTok{ np.histogram(data)}
\NormalTok{x\_values }\OperatorTok{=}\NormalTok{ np.linspace(}\BuiltInTok{min}\NormalTok{(bin\_edges), }\BuiltInTok{max}\NormalTok{(bin\_edges), }\DecValTok{100}\NormalTok{)}
\NormalTok{y\_values }\OperatorTok{=}\NormalTok{ scipy.stats.t.pdf(x\_values, loc }\OperatorTok{=}\NormalTok{ stichprobenmittelwert, scale }\OperatorTok{=}\NormalTok{ standardfehler, df }\OperatorTok{=}\NormalTok{ stichprobengröße }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}

\NormalTok{ax3.plot(x\_values, y\_values, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, linewidth }\OperatorTok{=} \DecValTok{1}\NormalTok{)}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\section{Aufgabe Konfidenzintervalle}\label{aufgabe-konfidenzintervalle}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Schätzen Sie das Gewicht für im Jahr 2008 beobachtete weibliche
  Pinguine der Spezies Adelie, Chinstrap und Gentoo.
\item
  Welches Konfidenzintervall können Sie für die Mittelwerte angeben,
  wenn eine Vertrauenswahrscheinlichkeit von 90 \% gelten soll?
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-pinguinaufgabe}: Tipp und Musterlösung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-pinguinaufgabe} 

Folgende Schritte helfen Ihnen bei der Lösung:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Bestimmen Sie den Stichprobenmittelwert \(\bar{x}\).
\item
  Bestimmen Sie die Stichprobenstandardabweichung \(s\), die
  Stichprobengröße \(N\) und den Standardfehler \(\frac{s}{\sqrt{N}}\).
\item
  Bestimmen Sie die z- oder t-Werte der Normal- bzw. t-Verteilung für
  das gewählte Konfidenzniveau - für einen zweiseitigen Hypothesentest
  \(\frac{\alpha}{2}\) und \(1 - \frac{\alpha}{2}\)
\item
  Berechnen Sie das Konfidenzintervall
  \(\bar{x} \pm t_{\alpha / 2} ~ \frac{s}{\sqrt{n}}\).
\end{enumerate}

\begin{quote}
\textbf{Musterlösung}

Alphaniveau definieren und Pinguine auswählen

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{alpha }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}} \FloatTok{0.9}
\NormalTok{data }\OperatorTok{=}\NormalTok{ penguins[(penguins[}\StringTok{\textquotesingle{}sex\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ sex) }\OperatorTok{\&}\NormalTok{ (penguins[}\StringTok{\textquotesingle{}year\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ year)]}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Stichprobenmittelwerte bestimmen.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{penguin\_means }\OperatorTok{=}\NormalTok{ data[}\StringTok{\textquotesingle{}body\_mass\_g\textquotesingle{}}\NormalTok{].groupby(by }\OperatorTok{=}\NormalTok{ data[}\StringTok{\textquotesingle{}species\textquotesingle{}}\NormalTok{]).mean()}
\BuiltInTok{print}\NormalTok{(penguin\_means)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
species
Adelie       3386.000000
Chinstrap    3472.222222
Gentoo       4627.272727
Name: body_mass_g, dtype: float64
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Stichprobenstandardabweichung, Stichprobengröße und Standardfehler
  bestimmen.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{penguin\_stds }\OperatorTok{=}\NormalTok{ data[}\StringTok{\textquotesingle{}body\_mass\_g\textquotesingle{}}\NormalTok{].groupby(by }\OperatorTok{=}\NormalTok{ data[}\StringTok{\textquotesingle{}species\textquotesingle{}}\NormalTok{]).std(ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{penguin\_sizes }\OperatorTok{=}\NormalTok{ data[}\StringTok{\textquotesingle{}body\_mass\_g\textquotesingle{}}\NormalTok{].groupby(by }\OperatorTok{=}\NormalTok{ data[}\StringTok{\textquotesingle{}species\textquotesingle{}}\NormalTok{]).size()}
\NormalTok{penguin\_stderrors }\OperatorTok{=}\NormalTok{ penguin\_stds }\OperatorTok{/}\NormalTok{ np.sqrt(penguin\_sizes)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Stichprobenstandardabweichungen:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, penguin\_stds)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Stichprobengrößen:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, penguin\_sizes)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Standardfehler:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, penguin\_stderrors)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Stichprobenstandardabweichungen:
 species
Adelie       288.862712
Chinstrap    370.903551
Gentoo       339.722321
Name: body_mass_g, dtype: float64

Stichprobengrößen:
 species
Adelie       25
Chinstrap     9
Gentoo       22
Name: body_mass_g, dtype: int64

Standardfehler:
 species
Adelie        57.772542
Chinstrap    123.634517
Gentoo        72.429042
Name: body_mass_g, dtype: float64
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  t-Werte bestimmen
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t\_unten }\OperatorTok{=}\NormalTok{ scipy.stats.t.ppf(alpha }\OperatorTok{/} \DecValTok{2}\NormalTok{, loc }\OperatorTok{=} \DecValTok{0}\NormalTok{, scale }\OperatorTok{=} \DecValTok{1}\NormalTok{, df }\OperatorTok{=}\NormalTok{ penguin\_sizes }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"t{-}Wert untere Intervallgrenze:"}\NormalTok{, t\_unten)}

\NormalTok{t\_oben }\OperatorTok{=}\NormalTok{ scipy.stats.t.ppf(}\DecValTok{1} \OperatorTok{{-}}\NormalTok{ alpha }\OperatorTok{/} \DecValTok{2}\NormalTok{, loc }\OperatorTok{=} \DecValTok{0}\NormalTok{, scale }\OperatorTok{=} \DecValTok{1}\NormalTok{, df }\OperatorTok{=}\NormalTok{ penguin\_sizes }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"t{-}Wert obere Intervallgrenze:"}\NormalTok{, t\_oben)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
t-Wert untere Intervallgrenze: [-1.71088208 -1.85954804 -1.7207429 ]
t-Wert obere Intervallgrenze: [1.71088208 1.85954804 1.7207429 ]
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Konfidenzintervall bestimmen
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# mit scipy.stats.t.ppf}
\NormalTok{untere\_intervalle }\OperatorTok{=}\NormalTok{ scipy.stats.t.ppf(alpha }\OperatorTok{/} \DecValTok{2}\NormalTok{, loc }\OperatorTok{=}\NormalTok{ penguin\_means, scale }\OperatorTok{=}\NormalTok{ penguin\_stderrors, df }\OperatorTok{=}\NormalTok{ penguin\_sizes }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"untere Intervallgrenzen:"}\NormalTok{, untere\_intervalle)}

\NormalTok{obere\_intervalle }\OperatorTok{=}\NormalTok{ scipy.stats.t.ppf(}\DecValTok{1} \OperatorTok{{-}}\NormalTok{ alpha }\OperatorTok{/} \DecValTok{2}\NormalTok{, loc }\OperatorTok{=}\NormalTok{ penguin\_means, scale }\OperatorTok{=}\NormalTok{ penguin\_stderrors, df }\OperatorTok{=}\NormalTok{ penguin\_sizes }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"obere Intervallgrenzen:"}\NormalTok{, obere\_intervalle)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}manuelle\textquotesingle{} Berechnung:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\CommentTok{\# \textquotesingle{}manuell\textquotesingle{}}
\BuiltInTok{print}\NormalTok{(penguin\_means }\OperatorTok{+}\NormalTok{ t\_unten }\OperatorTok{*}\NormalTok{ penguin\_stderrors)}
\BuiltInTok{print}\NormalTok{(penguin\_means }\OperatorTok{+}\NormalTok{ t\_oben }\OperatorTok{*}\NormalTok{ penguin\_stderrors)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
untere Intervallgrenzen: [3287.15799233 3242.31789851 4502.64096694]
obere Intervallgrenzen: [3484.84200767 3702.12654593 4751.90448761]

'manuelle' Berechnung:

species
Adelie       3287.157992
Chinstrap    3242.317899
Gentoo       4502.640967
Name: body_mass_g, dtype: float64
species
Adelie       3484.842008
Chinstrap    3702.126546
Gentoo       4751.904488
Name: body_mass_g, dtype: float64
\end{verbatim}
\end{quote}

\end{tcolorbox}

\chapter{Lineare Parameterschätzung}\label{sec-hooke}

Viele physikalische Größen werden indirekt gemessen. Häufig liegt dabei
ein linearer Zusammenhang zwischen der gemessenen und der gesuchten
Größe vor. In der Praxis sind die Daten einer Messreihe nie exakt und
mit mehr oder weniger großen Abweichungen vom wahren Wert der gesuchten
Größe behaftet. Die lineare Parameterschätzung ist ein Verfahren, um aus
einer Menge von Daten denjenigen Wert zu bestimmen, der die Abweichungen
der einzelnen Messwerte minimiert.

\section{Messreihe Hooke'sches
Gesetz}\label{messreihe-hookesches-gesetz}

Das \href{https://de.wikipedia.org/wiki/Hookesches_Gesetz}{Hooke'sche
Gesetz}, benannt nach dem englischen Wissenschaftler Robert Hooke,
beschreibt die Beziehung zwischen der Kraft \(F\) und der Längenänderung
\(\Delta{x}\) einer Feder durch die Gleichung \(F = k \cdot \Delta{x}\),
wobei \(k\) die Federkonstante ist.

Die Federkonstante ist eine grundlegende Eigenschaft elastischer
Materialien und gibt an, wie viel Kraft erforderlich ist, um eine Feder
um eine bestimmte Länge zu dehnen oder zu komprimieren. Das Hooke'sche
Gesetz besagt, dass die Deformation eines elastischen Körpers
proportional zur aufgebrachten Kraft ist, solange die Feder nicht über
den elastischen Bereich hinaus gedehnt oder gestaucht wird.

In einem Experiment wurde das Hooke'sche Gesetz überprüft. An einer an
einer Halterung hängenden Metallfeder ist ein (variables) Gewicht
angebracht. Darunter befindet sich in einigem Abstand ein
Ultraschallsensor zur Abstandsmessung. Der Abstand zwischen der
Unterseite des an der Feder befestigten Gewichts und dem
Ultraschallsensor ist der gemessene Abstand.

Die Gewichte konnten mit einer Genauigkeit von \(\epsilon_{m} = 0,5 g\)
mit einer Küchenwaage bestimmt werden.

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/00-bilder/aufbau.png}}

}

\caption{Versuchsaufbau}

\end{figure}%

Die Messreihe liegt in Form einer CSV-Datei unter dem Pfad
`01-daten/hooke\_data.csv' vor. Die Datei wird mit Pandas eingelesen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/hooke\_data.csv"}
\NormalTok{hooke }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ dateipfad, sep }\OperatorTok{=} \StringTok{\textquotesingle{};\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\subsection{Deskriptive Statistik}\label{deskriptive-statistik}

Nach dem Einlesen sollte man sich einen Überblick über die Daten
verschaffen. Mit den Methoden \texttt{pd.DataFrame.head()} und
\texttt{pd.DataFrame.tail()} kann ein Ausschnitt vom Beginn und vom Ende
der Daten betrachtet werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(hooke.head(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(hooke.tail())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   no  mass  distance
0   0   705    153.29
1   1   705    152.74
2   2   705    153.27
3   3   705    152.81
4   4   705    152.77 

      no  mass  distance
109  109     0    173.70
110  110     0    173.44
111  111     0    173.75
112  112     0    173.30
113  113     0    200.00
\end{verbatim}

Die Methode \texttt{pd.DataFrame.describe()} erstellt die deskriptive
Statistik für den Datensatz. Diese ist in diesem Fall jedoch noch nicht
sonderlich nützlich. Die Spalte `no' enthält lediglich eine laufende
Versuchsnummer, die Spalte `mass' enhält verschiedene Gewichte.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hooke.describe()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
& no & mass & distance \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
count & 114.000000 & 114.000000 & 114.000000 \\
mean & 56.561404 & 394.921053 & 162.301754 \\
std & 33.131552 & 226.237605 & 7.483767 \\
min & 0.000000 & 0.000000 & 152.740000 \\
25\% & 28.250000 & 201.000000 & 156.622500 \\
50\% & 56.500000 & 452.000000 & 160.720000 \\
75\% & 84.750000 & 605.000000 & 167.767500 \\
max & 113.000000 & 705.000000 & 200.000000 \\
\end{longtable}

~

Sinnvoller ist eine nach dem verwendeten Gewicht aufgeteilte
beschreibende Statistik der gemessenen Ausdehnung. Dafür kann die
Pandas-Methode \texttt{pd.DataFrame.groupby()} verwendet werden. So kann
für jedes der gemessenen Gewichte der arithmethische Mittelwert und die
Standardabweichung abgelesen werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hooke.groupby(by }\OperatorTok{=} \StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{)[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{].describe()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& count & mean & std & min & 25\% & 50\% & 75\% & max \\
mass & & & & & & & & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 12.0 & 175.828333 & 7.620157 & 173.27 & 173.3150 & 173.570 &
174.1125 & 200.00 \\
100 & 11.0 & 171.044545 & 0.985833 & 170.15 & 170.3650 & 170.800 &
171.2400 & 173.56 \\
201 & 11.0 & 167.791818 & 0.296305 & 167.26 & 167.7200 & 167.780 &
167.9750 & 168.19 \\
301 & 10.0 & 163.710000 & 1.660977 & 161.60 & 162.0575 & 163.825 &
165.3250 & 165.86 \\
401 & 10.0 & 161.967000 & 0.313229 & 161.42 & 161.8450 & 161.915 &
162.0250 & 162.48 \\
452 & 10.0 & 160.713000 & 0.627854 & 159.98 & 160.4575 & 160.555 &
160.7400 & 161.83 \\
503 & 10.0 & 159.314000 & 0.781099 & 158.43 & 158.6400 & 159.220 &
159.9650 & 160.61 \\
554 & 10.0 & 157.547000 & 0.523791 & 156.92 & 157.2075 & 157.435 &
157.7100 & 158.60 \\
605 & 10.0 & 156.142000 & 0.354206 & 155.62 & 156.0700 & 156.080 &
156.2075 & 156.84 \\
655 & 11.0 & 154.022727 & 0.224414 & 153.72 & 153.8800 & 153.920 &
154.2400 & 154.35 \\
705 & 9.0 & 153.008889 & 0.241425 & 152.74 & 152.8100 & 152.910 &
153.2700 & 153.29 \\
\end{longtable}

~

Bereits an dieser Stelle könnte die hohe Standardabweichung in der
Messreihe mit 0 Gramm auffallen. Leichter ist es jedoch in der
grafischen Betrachtung.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hooke.plot(x }\OperatorTok{=} \StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{, y }\OperatorTok{=} \StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{, kind }\OperatorTok{=} \StringTok{\textquotesingle{}scatter\textquotesingle{}}\NormalTok{, title }\OperatorTok{=} \StringTok{"Messreihe Hooke\textasciigrave{}sches Gesetz"}\NormalTok{, ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}Abstand in cm\textquotesingle{}}\NormalTok{, xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Gewicht in Gramm\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}gemessener Abstand\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/lineare-parameterschätzung_files/figure-pdf/cell-7-output-1.png}}

~

Grafisch fällt der Messwert von 200 cm für das Gewicht 0 Gramm als stark
von den übrigen Messwerten abweichend auf.

Die Messwerte für das Gewicht 0 Gramm sollen näher betrachtet werden.
Dafür werden die Messwerte sowohl absolut, als auch
\href{https://de.wikipedia.org/wiki/Standardisierung_(Statistik)}{standardisiert
in Einheiten der Standardabweichung (z-Werten)} ausgedrückt ausgegeben.

Eine Variable wird standardisiert, indem von jedem Wert der
Erwartungswert abgezogen und das Ergebnis durch die Standardabweichung
geteilt wird.

\[
Z = \frac{x - \mu}{\sigma}
\]

Da in der Regel der Erwartungswert und die Standardabweichung unbekannt
sind, werden der Stichprobenmittelwert und die
Stichprobenstandardabweichung verwendet. Dies nennt man
\emph{studentisieren}, nach dem Pseudonym des bereits im vorherigen
Kapitel erwähnten William Sealy Gosset.

\[
z_{i} = \frac{x_{i} - \bar{x}}{s}
\]

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gewicht }\OperatorTok{=} \DecValTok{0}

\CommentTok{\# z{-}Transformation manuell berechnen}
\NormalTok{mittelwert\_ausdehnung }\OperatorTok{=}\NormalTok{ hooke[hooke[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ gewicht].loc[: , }\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{].mean()}
\NormalTok{standardabweichung\_ausdehnung }\OperatorTok{=}\NormalTok{ hooke[hooke[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ gewicht].loc[: , }\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{].std(ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{)}

\NormalTok{z\_values }\OperatorTok{=}\NormalTok{ hooke[hooke[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ gewicht].loc[: , }\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{].}\BuiltInTok{apply}\NormalTok{(}\KeywordTok{lambda}\NormalTok{ x: ( (x }\OperatorTok{{-}}\NormalTok{ mittelwert\_ausdehnung) }\OperatorTok{/}\NormalTok{ standardabweichung\_ausdehnung))}
\NormalTok{z\_values.name }\OperatorTok{=} \StringTok{\textquotesingle{}z{-}values\textquotesingle{}}

\CommentTok{\# z{-}Transformation mit scipy}
\CommentTok{\#\# scipy gibt ein np.array zurück}
\CommentTok{\#\# zur besseren Darstellung wird das np.array in eine pd.Series umgewandelt, die ein name Attribut hat}
\NormalTok{scipy\_z\_values }\OperatorTok{=}\NormalTok{ pd.Series(scipy.stats.zscore(hooke[hooke[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ gewicht].loc[: , }\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{], ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{))}
\NormalTok{scipy\_z\_values.name }\OperatorTok{=} \StringTok{\textquotesingle{}scipy z{-}values\textquotesingle{}}

\CommentTok{\# gemeinsame Ausgabe der Daten}
\BuiltInTok{print}\NormalTok{(pd.concat([hooke[hooke[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ gewicht], z\_values, scipy\_z\_values], axis }\OperatorTok{=} \DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
        no  mass  distance  z-values  scipy z-values
102  102.0   0.0    173.32 -0.329171             NaN
103  103.0   0.0    174.11 -0.225498             NaN
104  104.0   0.0    173.42 -0.316048             NaN
105  105.0   0.0    174.12 -0.224186             NaN
106  106.0   0.0    173.30 -0.331795             NaN
107  107.0   0.0    174.21 -0.212375             NaN
108  108.0   0.0    173.27 -0.335732             NaN
109  109.0   0.0    173.70 -0.279303             NaN
110  110.0   0.0    173.44 -0.313423             NaN
111  111.0   0.0    173.75 -0.272742             NaN
112  112.0   0.0    173.30 -0.331795             NaN
113  113.0   0.0    200.00  3.172069             NaN
0      NaN   NaN       NaN       NaN       -0.329171
1      NaN   NaN       NaN       NaN       -0.225498
2      NaN   NaN       NaN       NaN       -0.316048
3      NaN   NaN       NaN       NaN       -0.224186
4      NaN   NaN       NaN       NaN       -0.331795
5      NaN   NaN       NaN       NaN       -0.212375
6      NaN   NaN       NaN       NaN       -0.335732
7      NaN   NaN       NaN       NaN       -0.279303
8      NaN   NaN       NaN       NaN       -0.313423
9      NaN   NaN       NaN       NaN       -0.272742
10     NaN   NaN       NaN       NaN       -0.331795
11     NaN   NaN       NaN       NaN        3.172069
\end{verbatim}

Der Wert 200 cm in Zeile 113 scheint fehlerhaft zu sein. Eine
Eigendehnung der Feder um zusätzliche 16 Zentimeter ist nicht plausibel.
Auch der z-Wert \textgreater{} 3 kennzeichnet den Messwert als
\href{https://de.wikipedia.org/wiki/Ausrei\%C3\%9Fer}{Ausreißer}. Die
Zeile wird deshalb aus dem Datensatz entfernt.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-ausreißer}: Ausreißer}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-ausreißer} 

In der Statistik wird ein Messwert als Ausreißer bezeichnet, wenn dieser
stark von der übrigen Messreihe abweicht. In einer Messreihe können auch
mehrere Ausreißer auftreten. Diese Werte können zur Verbesserung der
Schätzung aus der Messreihe entfernt werden, wenn anzunehmen ist, dass
diese durch Messfehler und andere Störgrößen verursacht sind.

Eine Möglichkeit, Ausreißer zu identifizieren, ist die z-Transformation.
Dabei muss ein Schwellenwert gewählt werden, ab dem ein Messwert als
Ausreißer klassifiziert werden soll, bspw. 2,5 oder 3 Einheiten der
Standardabweichung. In der Statistik wurde eine ganze Reihe von
Ausreißertests entwickelt (siehe
\href{https://de.wikipedia.org/wiki/Ausrei\%C3\%9Fer\#Ausrei\%C3\%9Fertests}{Ausreißertests})

Die Einstufung eines Messwerts als Ausreißer kann aber nicht allein auf
der Grundlage statistischer Verfahren erfolgen, sondern ist immer eine
Ermessensentscheidung auf der Grundlage Ihres Fachwissens. Denn nicht
alle abweichenden Werte sind automatisch ungültig, sondern treten mit
einer gewissen statistischen Wahrscheinlichkeit auf (siehe Kapitel
Normalverteilung). Man spricht dann von gültigen Extremwerten.

Ausreißer von verschiedenen
\href{https://xtools.wmcloud.org/authorship/de.wikipedia.org/Ausrei\%C3\%9Fer?uselang=de}{Autor:innen}
steht unter der Lizenz
\href{https://creativecommons.org/licenses/by-sa/4.0/deed.de}{CC BY-SA
4.0} und ist abrufbar auf
\href{https://de.wikipedia.org/wiki/Ausrei\%C3\%9Fer}{Wikipedia}

\end{tcolorbox}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hooke.drop(index }\OperatorTok{=} \DecValTok{113}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

\NormalTok{hooke.groupby(by }\OperatorTok{=} \StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{)[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{].describe()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllll@{}}
\toprule\noalign{}
& count & mean & std & min & 25\% & 50\% & 75\% & max \\
mass & & & & & & & & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 11.0 & 173.630909 & 0.367409 & 173.27 & 173.3100 & 173.440 &
173.9300 & 174.21 \\
100 & 11.0 & 171.044545 & 0.985833 & 170.15 & 170.3650 & 170.800 &
171.2400 & 173.56 \\
201 & 11.0 & 167.791818 & 0.296305 & 167.26 & 167.7200 & 167.780 &
167.9750 & 168.19 \\
301 & 10.0 & 163.710000 & 1.660977 & 161.60 & 162.0575 & 163.825 &
165.3250 & 165.86 \\
401 & 10.0 & 161.967000 & 0.313229 & 161.42 & 161.8450 & 161.915 &
162.0250 & 162.48 \\
452 & 10.0 & 160.713000 & 0.627854 & 159.98 & 160.4575 & 160.555 &
160.7400 & 161.83 \\
503 & 10.0 & 159.314000 & 0.781099 & 158.43 & 158.6400 & 159.220 &
159.9650 & 160.61 \\
554 & 10.0 & 157.547000 & 0.523791 & 156.92 & 157.2075 & 157.435 &
157.7100 & 158.60 \\
605 & 10.0 & 156.142000 & 0.354206 & 155.62 & 156.0700 & 156.080 &
156.2075 & 156.84 \\
655 & 11.0 & 154.022727 & 0.224414 & 153.72 & 153.8800 & 153.920 &
154.2400 & 154.35 \\
705 & 9.0 & 153.008889 & 0.241425 & 152.74 & 152.8100 & 152.910 &
153.2700 & 153.29 \\
\end{longtable}

~

Hiernach ist die höchste Standardabweichung für die Messreihe mit 301
Gramm zu verzeichnen. Die gemessenen Werte sind jedoch unauffällig.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gewicht }\OperatorTok{=} \DecValTok{301}

\CommentTok{\#\# scipy gibt ein np.array zurück}
\CommentTok{\#\# zur besseren Darstellung wird das np.array in eine pd.Series umgewandelt, die ein name Attribut hat}
\NormalTok{z\_values }\OperatorTok{=}\NormalTok{ pd.Series(scipy.stats.zscore(hooke[hooke[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ gewicht].loc[: , }\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{], ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{))}
\NormalTok{z\_values.name }\OperatorTok{=} \StringTok{\textquotesingle{}z{-}values\textquotesingle{}}

\BuiltInTok{print}\NormalTok{(pd.concat([hooke[hooke[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ gewicht], z\_values], axis }\OperatorTok{=} \DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
      no   mass  distance  z-values
70  70.0  301.0    162.38       NaN
71  71.0  301.0    161.93       NaN
72  72.0  301.0    161.95       NaN
73  73.0  301.0    161.60       NaN
74  74.0  301.0    164.59       NaN
75  75.0  301.0    165.86       NaN
76  76.0  301.0    163.82       NaN
77  77.0  301.0    163.83       NaN
78  78.0  301.0    165.57       NaN
79  79.0  301.0    165.57       NaN
0    NaN    NaN       NaN -0.800734
1    NaN    NaN       NaN -1.071658
2    NaN    NaN       NaN -1.059617
3    NaN    NaN       NaN -1.270337
4    NaN    NaN       NaN  0.529809
5    NaN    NaN       NaN  1.294419
6    NaN    NaN       NaN  0.066226
7    NaN    NaN       NaN  0.072247
8    NaN    NaN       NaN  1.119823
9    NaN    NaN       NaN  1.119823
\end{verbatim}

\subsection{Explorative Statistik}\label{explorative-statistik}

Die Grafik des bereinigten Datensatzes legt einen linearen Zusammenhang
nahe. Darüber hinaus sticht der mit zunehmendem Gewicht abfallende Trend
der Datenpunkte ins Auge.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hooke.plot(x }\OperatorTok{=} \StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{, y }\OperatorTok{=} \StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{, kind }\OperatorTok{=} \StringTok{\textquotesingle{}scatter\textquotesingle{}}\NormalTok{, title }\OperatorTok{=} \StringTok{\textquotesingle{}bereinigter Datensatz\textquotesingle{}}\NormalTok{, ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}Abstand in cm\textquotesingle{}}\NormalTok{, xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Gewicht in Gramm\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}gemessener Abstand\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/lineare-parameterschätzung_files/figure-pdf/cell-11-output-1.png}}

~

Entsprechend des Versuchsaufbaus nimmt mit zunehmender Dehnung der Feder
der Abstand zum Abstandssensor ab. Da die Federausdehnung gemessen
werden soll, bietet es sich an, die Daten entsprechend zu
transformieren. Dazu wird der gemessene Abstand bei 0 Gramm Gewicht als
Nullpunkt aufgefasst, von dem aus die Federdehnung gemessen wird. Das
bedeutet, dass von allen Datenpunkten das arithmetische Mittel der für 0
Gramm Gewicht gemessen Ausdehnung abgezogen und das Ergebnis mit -1
multipliziert wird.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nullpunkt }\OperatorTok{=}\NormalTok{ hooke[hooke[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{] }\OperatorTok{==} \DecValTok{0}\NormalTok{].loc[: , }\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{].mean()}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Nullpunkt: }\SpecialCharTok{\{}\NormalTok{nullpunkt}\SpecialCharTok{:.2f\}}\SpecialStringTok{ cm"}\NormalTok{)}

\NormalTok{hooke[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{].sub(nullpunkt).mul(}\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}

\NormalTok{hooke.plot(x }\OperatorTok{=} \StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{, y }\OperatorTok{=} \StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{, kind }\OperatorTok{=} \StringTok{\textquotesingle{}scatter\textquotesingle{}}\NormalTok{, title }\OperatorTok{=} \StringTok{\textquotesingle{}bereinigter und invertierter Datensatz\textquotesingle{}}\NormalTok{, ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}Federausdehnung in cm\textquotesingle{}}\NormalTok{, xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Gewicht in Gramm\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}gemessener Abstand\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Nullpunkt: 173.63 cm
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/lineare-parameterschätzung_files/figure-pdf/cell-12-output-2.png}}

~

Mit der Funktion \texttt{plt.errorbars()} können die Mittelwerte und
Standardfehler für jedes Gewicht grafisch dargestellt werden. Da die
Standardfehler eher klein sind, werden mit dem Parameter
\texttt{capsize} horizontale Linien am Ende des Fehlerbalkens
eingezeichnet.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Mittelwerte nach Gewicht}
\NormalTok{distance\_means\_by\_weight }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{].groupby(by }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{]).mean()}
\NormalTok{distance\_means\_by\_weight.name }\OperatorTok{=} \StringTok{\textquotesingle{}Federausdehnung\textquotesingle{}}

\CommentTok{\# Standardfehler nach Gewicht}
\NormalTok{distance\_stderrors\_by\_weight }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{].groupby(by }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{]).std(ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{).div(np.sqrt(hooke[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{].groupby(by }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{]).size()))}
\NormalTok{distance\_stderrors\_by\_weight.name }\OperatorTok{=} \StringTok{\textquotesingle{}Standardfehler\textquotesingle{}}

\NormalTok{datenpunkte }\OperatorTok{=}\NormalTok{ hooke.plot(x }\OperatorTok{=} \StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{, y }\OperatorTok{=} \StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{, kind }\OperatorTok{=} \StringTok{\textquotesingle{}scatter\textquotesingle{}}\NormalTok{, title }\OperatorTok{=} \StringTok{\textquotesingle{}bereinigter und invertierter Datensatz\textquotesingle{}}\NormalTok{, ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}Federausdehnung in cm\textquotesingle{}}\NormalTok{, xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Gewicht in Gramm\textquotesingle{}}\NormalTok{, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}gemessene Federausdehnung\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Legendeneinträge abgreifen}
\CommentTok{\# siehe: https://matplotlib.org/stable/api/\_as\_gen/matplotlib.axes.Axes.get\_legend\_handles\_labels.html}
\NormalTok{datenpunkte\_handle, datenpunkte\_label }\OperatorTok{=}\NormalTok{ datenpunkte.get\_legend\_handles\_labels()}

\NormalTok{errorbar\_container }\OperatorTok{=}\NormalTok{ plt.errorbar(}
\NormalTok{  x }\OperatorTok{=}\NormalTok{ distance\_means\_by\_weight.index, y }\OperatorTok{=}\NormalTok{ distance\_means\_by\_weight, yerr }\OperatorTok{=}\NormalTok{ distance\_stderrors\_by\_weight,}
\NormalTok{  linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}none\textquotesingle{}}\NormalTok{, marker }\OperatorTok{=} \StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, markersize }\OperatorTok{=} \DecValTok{12}\NormalTok{, elinewidth }\OperatorTok{=} \DecValTok{3}\NormalTok{, ecolor }\OperatorTok{=} \StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{, capsize }\OperatorTok{=} \DecValTok{12}\NormalTok{)}

\CommentTok{\# Legende manuell erstellen}
\CommentTok{\# siehe: https://matplotlib.org/stable/api/container\_api.html\#matplotlib.container.ErrorbarContainer}
\NormalTok{plt.legend([datenpunkte\_handle[}\DecValTok{0}\NormalTok{], errorbar\_container.lines[}\DecValTok{0}\NormalTok{], errorbar\_container.lines[}\DecValTok{2}\NormalTok{][}\DecValTok{0}\NormalTok{]],}
\NormalTok{           [datenpunkte\_label[}\DecValTok{0}\NormalTok{], }\StringTok{\textquotesingle{}Mittelwert\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Standardfehler\textquotesingle{}}\NormalTok{],}
\NormalTok{           loc }\OperatorTok{=} \StringTok{\textquotesingle{}upper left\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.show()}

\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, pd.concat([distance\_means\_by\_weight, distance\_stderrors\_by\_weight], axis }\OperatorTok{=} \DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/lineare-parameterschätzung_files/figure-pdf/cell-13-output-1.png}}

\begin{verbatim}

       Federausdehnung  Standardfehler
mass                                 
0       -7.751375e-15        0.110778
100      2.586364e+00        0.297240
201      5.839091e+00        0.089339
301      9.920909e+00        0.525247
401      1.166391e+01        0.099052
452      1.291791e+01        0.198545
503      1.431691e+01        0.247005
554      1.608391e+01        0.165637
605      1.748891e+01        0.112010
655      1.960818e+01        0.067663
705      2.062202e+01        0.080475
\end{verbatim}

\section{Federkonstante bestimmen}\label{federkonstante-bestimmen}

Die Beziehung zwischen der Kraft \(F\) und der Längenänderung
\(\Delta{x}\) einer Feder mit Federkonstante \(k\) wird durch die
Gleichung \(F = k \cdot \Delta{x}\) beschrieben. Dabei entspricht die
Kraft \(F\) dem mit der Fallbeschleunigung \(g\) multiplizierten Gewicht
in Kilogramm \(m\). Die Fallbeschleunigung beträgt auf der Erde
\(9,81 \frac{m}{s^2}\).

Deshalb wird im Datensatz das in der Spalte `mass' eingetragene Gewicht
in Gramm in die wirkende Kraft umgerechnet. Ebenso wird die gemessene
Abstandsänderung in der Spalte `distance' von Zentimeter in Meter
umgerechnet.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hooke[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{].div(}\DecValTok{1000}\NormalTok{).mul(}\FloatTok{9.81}\NormalTok{)}
\NormalTok{hooke.rename(columns }\OperatorTok{=}\NormalTok{ \{}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}force\textquotesingle{}}\NormalTok{\}, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

\NormalTok{hooke[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{].div(}\DecValTok{100}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(hooke.head())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   no    force  distance
0   0  6.91605  0.203409
1   1  6.91605  0.208909
2   2  6.91605  0.203609
3   3  6.91605  0.208209
4   4  6.91605  0.208609
\end{verbatim}

Für die grafische Darstellung des Zusammenhangs
\(F = k \cdot \Delta{x}\) ist es zweckmäßiger, die Abstandsänderung auf
der x-Achse und die wirkende Kraft auf der y-Achse darzustellen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hooke.plot(x }\OperatorTok{=} \StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{, y }\OperatorTok{=} \StringTok{\textquotesingle{}force\textquotesingle{}}\NormalTok{, kind }\OperatorTok{=} \StringTok{\textquotesingle{}scatter\textquotesingle{}}\NormalTok{, title }\OperatorTok{=} \StringTok{\textquotesingle{}umgeformter Datensatz\textquotesingle{}}\NormalTok{, ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}wirkende Kraft in $N$\textquotesingle{}}\NormalTok{, xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Abstandsänderung in Meter\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}gemessene Abstandsänderung\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/lineare-parameterschätzung_files/figure-pdf/cell-15-output-1.png}}

\subsection{Lineare
Ausgleichsrechnung}\label{lineare-ausgleichsrechnung}

Die Ausgleichsrechnung (oder auch Parameterschätzung) ist eine Methode,
um für eine Messreihe die unbekannten Parameter des zugrundeliegenden
physikalischen Modells zu schätzen. Das Ziel besteht darin, eine (in
diesem Fall lineare) Funktion zu bestimmen, die bestmöglich an die
Messdaten angepasst ist.
(\href{https://de.wikipedia.org/wiki/Ausgleichungsrechnung}{Wikipedia})

Eine lineare Funktion wird durch die Konstante \(\beta_0\), den
Schnittpunkt mit der y-Achse, und den Steigungskoeffizienten \(\beta_1\)
bestimmt.

\[
y = \beta_0 + \beta_1 \cdot x
\]

In der Regel liegt kein deterministischer Zusammenhang vor, sondern es
treten zufällige Abweichungen auf, die mit dem additiven Fehlerterm
ausgedrückt und aus dem Englischen error mit \(e_i\) notiert werden.
Diese Fehler werden Residuen genannt.

\[
y = \beta_0 + \beta_1 \cdot x + e_i
\]

Zur Bestimmung der Parameter einer linearen Funktion wird die Methode
der
\href{https://de.wikipedia.org/wiki/Methode_der_kleinsten_Quadrate}{kleinsten
Quadrate} verwendet.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-ols}: Methode der kleinsten Quadrate}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-ols} 

Mit der Methode der kleinsten Quadrate soll diejenige Gerade
\(\hat{y} = \beta_0 + \beta_1 \cdot x\) gefunden werden, die die
quadrierten Abstände der Vorhersagewerte \(\hat{y}\) von den tatsächlich
gemessenen Werten \(y\) minimiert. Die Werte \(y_i - \hat{y_i}\) sind
die Residuen \(e_i\). Es gilt also:

\[
\sum_{i=1}^{N}(y_i - \hat{y_i})^2 = \sum_{i=1}^{N} e_i = \min
\]

Grafisch kann man sich die Minimierung der quadrierten Abstände so
vorstellen.

\section{Grafik}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/lineare-parameterschätzung_files/figure-pdf/cell-16-output-1.png}}

\begin{verbatim}
Regressionskoeffizienten: [ 2.93333333 -0.73333333]
\end{verbatim}

\section{Code}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\NormalTok{y }\OperatorTok{=} \OperatorTok{{-}}\NormalTok{ x.copy() }\OperatorTok{+} \DecValTok{4}
\NormalTok{y[}\DecValTok{0}\NormalTok{] }\OperatorTok{{-}=} \DecValTok{2}
\NormalTok{y[}\DecValTok{2}\NormalTok{] }\OperatorTok{{-}=} \DecValTok{2}
\NormalTok{y[}\DecValTok{3}\NormalTok{] }\OperatorTok{+=} \DecValTok{3}
\NormalTok{y[}\OperatorTok{{-}}\DecValTok{3}\NormalTok{] }\OperatorTok{+=} \DecValTok{5}

\NormalTok{lm }\OperatorTok{=}\NormalTok{ poly.polyfit(x, y, }\DecValTok{1}\NormalTok{)}
\NormalTok{vorhersagewerte }\OperatorTok{=}\NormalTok{ poly.polyval(x, lm)}

\NormalTok{plt.scatter(x, vorhersagewerte, label }\OperatorTok{=} \StringTok{\textquotesingle{}Vorhersagewerte\textquotesingle{}}\NormalTok{, marker }\OperatorTok{=} \StringTok{"\^{}"}\NormalTok{, color }\OperatorTok{=} \StringTok{"tab:blue"}\NormalTok{)}
\NormalTok{plt.scatter(x, y, label }\OperatorTok{=} \StringTok{\textquotesingle{}Messwerte\textquotesingle{}}\NormalTok{, marker }\OperatorTok{=} \StringTok{\textquotesingle{}o\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{"tab:orange"}\NormalTok{)}
\NormalTok{plt.axline(xy1 }\OperatorTok{=}\NormalTok{ (}\DecValTok{0}\NormalTok{, lm[}\DecValTok{0}\NormalTok{]), slope }\OperatorTok{=}\NormalTok{ lm[}\DecValTok{1}\NormalTok{], label }\OperatorTok{=} \StringTok{"Regressionsgerade"}\NormalTok{, color }\OperatorTok{=} \StringTok{"tab:blue"}\NormalTok{)}
\NormalTok{dotted }\OperatorTok{=}\NormalTok{ plt.vlines(x, ymin }\OperatorTok{=}\NormalTok{ vorhersagewerte, ymax }\OperatorTok{=}\NormalTok{ y, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{, ls }\OperatorTok{=} \StringTok{\textquotesingle{}dotted\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Residuen\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.legend()}
\NormalTok{plt.show()}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Regressionskoeffizienten:"}\NormalTok{, lm)}
\end{Highlighting}
\end{Shaded}

~

Die eingezeichnete Gerade entspricht der linearen Funktion
\(\hat{y} = \beta_0 + \beta_1 \cdot x + e_i\). Die Dreiecksmarker sind
die Vorhersagewerte \(\hat{y_i}\) des linearen Modells für die Werte
\(x_i = np.arange(1, 11)\). Die tatsächlichen Messwerte \(y\) sind mit
Kreismarkern markiert. Die Länge der gestrichelten Linien entspricht der
Größe der Abweichung zwischen den Mess- und Vorhersagewerten
\(y_i - \hat{y_i}\), also den Residuen \(e_i\).

Gesucht wird diejenige Gerade, die die Summe der quadrierten Residuen
minimiert. Die gesuchten Werte \(\beta_0\) und \(\beta_1\) sind die
Kleinst-Quadrate-Schätzer.

\[
\beta_0 = \bar{y} - \beta_1 \cdot \bar{x}
\]

\[
\beta_1 = { \sum_{i=1}^n (x_i- \bar{x}) \cdot (y_i - \bar{y}) \over \sum_{i=1}^n (x_i - \bar{x})^2 }
\]

Der Vollständigkeit halber leiten wir die Kleinst-Quadrate-Schätzer her.
Gesucht werden Werte für \(\beta_0\) und \(\beta_1\), damit die Summe
der Residuenquadrate \(\sum_{i=1}^{n} e_i^2\) möglichst klein wird. Die
Residuenquadratsumme ist die Summe der quadrierten Differenzen aus
beobachteten Werten \(y_i\) und der durch die lineare Funktion
vorhergesagten Werte. \[
\sum_{i=1}^{n} e_i^2 ~ = ~ \sum_{i=1}^{n} (y_i - (\beta_0 + \beta_1 \cdot x_i))^2
\]

Wir untersuchen also eine Funktion, die von zwei Variablen abhängig ist.
\[
f(\beta_0, \beta_1) = \sum_{i=1}^{n} (y_i - (\beta_0 + \beta_1 \cdot x_i))^2
\]

Das Summenzeichen ist die Kurzschreibweise für eine Summe. \[
f(\beta_0, \beta_1) = (y_1 - (\beta_0 + \beta_1 \cdot x_1))^2 ~ + ~ (y_2 - (\beta_0 + \beta_1 \cdot x_2))^2 ~ + ~ ... ~ (y_n - (\beta_0 + \beta_1 \cdot x_n))^2
\]

Im Minimum der Funktion müssen die beiden partiellen Ableitungen gleich
Null sein (Warum das so ist, wird
\href{https://www.sofatutor.com/mathematik/funktionen/funktionen-mehrerer-veraenderlicher/lokale-extrempunkte-bei-funktionen-mit-mehreren-veraenderlichen}{hier}
leicht verständlich erklärt.)

\phantomsection\label{nte-partielleableitung}
\begin{quote}
\textbf{Note~67.1: Partielle Ableitung}

Die partielle Ableitung ist die Ableitung einer Funktion mit mehreren
Variablen nach einer Variablen, wobei die übrigen Variablen als
Konstanten behandelt werden.

Für eine Funktion \(f(x, y) = 2x + y^2\) wird die partielle Ableitung
nach x so ausgedrückt:

\(\frac{\partial f(x, y)}{\partial x}\)

\begin{itemize}
\tightlist
\item
  Das Symbol ∂ ist die kursive Darstellung des kyrillischen
  Kleinbuchstaben д (d) und wird als ``del'' gelesen. Es zeigt an, das
  eine partielle Ableitung durchgeführt wird.
\item
  Im Zähler steht die Funktion, die abgeleitet werden soll. Im Nenner
  steht die Variable nach der abgeleitet wird. Der Term wird gelesen als
  ``del f von x und y nach del x''.
\end{itemize}

Die partielle Ableitung \(\frac{\partial f(x, y)}{\partial x} = 2\).
\(y^2\) wird als Konstante behandelt (z. B. \(5^2\) ) und ist abgeleitet
Null.

Die partielle Ableitung \(\frac{\partial f(x, y)}{\partial y} = 2y\).
\(2x\) wird als Konstante behandelt (z. B. \(2 \cdot 3\) ) und ist
abgeleitet Null.
\end{quote}

In beiden partiellen Ableitungen sind \(x_i\) und \(y_i\) konstant. In
der partiellen Ableitung nach \(\beta_0\) ist außerdem \(\beta_1\)
konstant, in der partiellen Ableitung nach \(\beta_1\) ist entsprechend
\(\beta_0\) konstant.

\section{partielle Ableitung nach dem y-Achsenschnittpunkt}

Für die partielle Ableitung nach \(\beta_0\) gilt also nach der
Kettenregel für die äußere Funktion (oben) und die innere Funktion
(Mitte): \[ \begin{aligned}
\frac{\partial f(\beta_0, \beta_1)}{\partial \beta_0} = 2 \cdot (y_1 - (\beta_0 + \beta_1 \cdot x_1)) ~ + ~ ... ~ (y_n - (\beta_0 + \beta_1 \cdot x_n)) = 2 \cdot \sum_{i=1}^{n} (y_i - (\beta_0 + \beta_1 \cdot x_i)) ~ \cdot
\newline 
(0 - (1 + 0 \cdot 0)) ~ + ~ ... ~ (0 - (1 + 0 \cdot 0)) = \sum_{i=1}^{n} (0 - (1 + 0 \cdot 0)) =
\newline
2 \cdot \sum_{i=1}^{n} (y_i - (\beta_0 + \beta_1 \cdot x_i)) ~ \cdot (-1)
\end{aligned}
\]

Für die partielle Ableitung nach \(\beta_0\) gilt also: \[
\frac{\partial f(\beta_0, \beta_1)}{\partial \beta_0} = -2 \cdot \sum_{i=1}^{n} (y_i - (\beta_0 + \beta_1 \cdot x_i)) = 0
\]

Diese kann vereinfacht werden, indem der Vorfaktor \(-2\) entfällt (weil
\(-2 \cdot 0 = 0\) gelten muss) und die Vorzeichen aufgelöst werden.
Sodass: \[
\sum_{i=1}^{n} (y_i - \beta_0 - \beta_1 \cdot x_i) = 0
\]

Man kann auch schreiben: \[
\sum_{i=1}^{n} y_i - \sum_{i=1}^{n} \beta_0 - \sum_{i=1}^{n} \beta_1 \cdot x_i = 0
\]

\(\beta_0\) und \(\beta_1\) sind Konstanten, sodass gilt
\(\sum_{i=1}^{n} \beta_0  = \beta_0 \cdot \sum_{i=1}^{n} 1 = \beta_0 \cdot n\)
und
\(\sum_{i=1}^{n} \beta_1 \cdot x_i = \beta_1 \cdot \sum_{i=1}^{n} 1 \cdot x_i\).
So gilt: \[
\sum_{i=1}^{n} y_i - n \cdot \beta_0 - \beta_1 \cdot \sum_{i=1}^{n} x_i = 0
\]

Jetzt kann man durch \(n\) teilen. Dabei entspricht
\(\frac{\sum_{i=1}^{n}y_i}{n}\) dem arithmetischen Mittelwert von \(y\)
und \(\frac{\sum_{i=1}^{n}x_i}{n}\) dem arithmetischen Mittelwert von
\(x\). Somit steht: \[
\bar{y} - \beta_0 - \beta_1 \cdot \bar{x}= 0
\]

Umgestellt: \[
\beta_0 = \bar{y} - \beta_1 \cdot \bar{x}
\]

\section{partielle Ableitung nach dem Anstieg}

Für die partielle Ableitung nach \(\beta_1\) ist ebenfalls die
Kettenregel anzuwenden, sodass die äußere Funktion (oben) identisch
abgeleitet wird: \[ \begin{aligned}
\frac{\partial f(\beta_0, \beta_1)}{\partial \beta_1} = 2 \cdot (y_1 - (\beta_0 + \beta_1 \cdot x_1)) ~ + ~ ... ~ (y_n - (\beta_0 + \beta_1 \cdot x_n)) = 2 \cdot \sum_{i=1}^{n} (y_i - (\beta_0 + \beta_1 \cdot x_i)) ~ \cdot
\newline 
(0 - (0 + 1 \cdot x_1)) ~ + ~ ... ~ (0 - (0 + 1 \cdot x_n)) ~ = ~ \sum_{i=1}^{n} -x_i = 
\newline
2 \cdot \sum_{i=1}^{n} (y_i - (\beta_0 + \beta_1 \cdot x_i)) ~ \cdot -x_i
\end{aligned}
\]

Für die partielle Ableitung nach \(\beta_1\) gilt also: \[
\frac{\partial f(\beta_0, \beta_1)}{\partial \beta_1} = -2 \sum_{i=1}^{n} x_i \cdot (y_i - (\beta_0 + \beta_1 \cdot x_i)) = 0
\]

Auch diese kann vereinfacht werden, indem der Vorfaktor \(-2\) entfällt
(weil \(-2 \cdot 0 = 0\) gelten muss) und die Vorzeichen aufgelöst
werden. Außerdem kann ausmultipliziert werden: \[
\sum_{i=1}^{n} x_iy_i - \sum_{i=1}^{n}  \beta_0 \cdot x_i - \sum_{i=1}^{n}  \beta_1 \cdot x_ix_i = 0
\]

Wieder können die Konstanten herausgezogen werden: \[
\sum_{i=1}^{n} x_iy_i - \beta_0 \cdot \sum_{i=1}^{n} x_i - \beta_1 \cdot \sum_{i=1}^{n} x_ix_i = 0
\]

Jetzt kann man \(\beta_0 = \bar{y} - \beta_1 \cdot \bar{x}\) und
\(\sum_{i=1}^{n} x_i = n \cdot \bar{x}\) einsetzen: \[
\sum_{i=1}^{n} x_iy_i - (\bar{y} - \beta_1 \cdot \bar{x}) \cdot  n \cdot \bar{x} - \beta_1 \cdot \sum_{i=1}^{n} x_ix_i = 0
\]

Der mittlere Term wird ausmultipliziert und \(x_ix_i\) im letzten Term
als \(x_i^2\) geschrieben: \[
\sum_{i=1}^{n} x_iy_i - n\bar{x}\bar{y} - \beta_1 \cdot n\bar{x}\bar{x} - \beta_1 \cdot \sum_{i=1}^{n} x_i^2 = 0
\]

Die letzten beiden Terme werden unter Anwendung des Distributivgesetzes
\(a−b = − (b−a)\) zusammengefasst. \[
\sum_{i=1}^{n} x_iy_i - n\bar{x}\bar{y} - \beta_1 \cdot ( \sum_{i=1}^{n} x_i^2 - n \bar{x}^2) = 0
\]

Jetzt kann nach \(\beta_1\) umgestellt werden. Erst: \[
\beta_1 \cdot ( \sum_{i=1}^{n} x_i^2 - n \bar{x}^2) = \sum_{i=1}^{n} x_iy_i - n\bar{x}\bar{y}
\]

Dann: \[
\beta_1 = \frac{\sum_{i=1}^{n} x_iy_i - n\bar{x}\bar{y}}{\sum_{i=1}^{n} x_i^2 - n \bar{x}^2}
\]

Nun kann zuerst mit
\(\sum_{i=1}^{n} x_i^2 - n \bar{x}^2 = \sum_{i=1}^{n} (x_i - \bar{x})^2\)
umgeformt werden. \[
\beta_1 = \frac{\sum_{i=1}^{n} x_iy_i - n\bar{x}\bar{y}}{\sum_{i=1}^{n}  (x_i - \bar{x})^2}
\]

Dann - und das wird gleich gezeigt - mit
\(\sum_{i=1}^{n} x_iy_i - n\bar{x}\bar{y} = \sum_{i=1}^{n} (x_i - \bar{x}) (y_i - \bar{y})\).
Sodass steht: \[
\beta_1 = \frac{\sum_{i=1}^{n} (x_i - \bar{x}) (y_i - \bar{y})}{\sum_{i=1}^{n}  (x_i - \bar{x})^2}
\]

Der letzte Schritt wird ausgehend vom Ergebnis gezeigt und beginnt mit
dem Ausmultiplizieren: \[
\sum_{i=1}^{n} (x_i - \bar{x}) (y_i - \bar{y}) = \sum_{i=1}^{n} (x_iy_i - x_i\bar{y} - \bar{x}y_i + \bar{x}\bar{y})
\]

Man kann auch schreiben: \[
\sum_{i=1}^{n} x_iy_i - \sum_{i=1}^{n} x_i\bar{y} - \sum_{i=1}^{n} \bar{x}y_i + \sum_{i=1}^{n} \bar{x}\bar{y}
\]

\(\bar{x}\) und \(\bar{y}\) sind Konstanten, sodass
\(\bar{x} \cdot \sum_{i=1}^{n} y_i\) und
\(\bar{y} \cdot \sum_{i=1}^{n} x_i\) geschrieben werden kann.
\(\sum_{i=1}^{n} x_i\) ist gleich \(n \cdot \bar{x}\) (analog für
\(y\)). So ergibt sich:

\[
\sum_{i=1}^{n} x_iy_i - \bar{y} \cdot n \cdot \bar{x} - \bar{x} \cdot n \cdot \bar{y} + \sum_{i=1}^{n} \bar{x}\bar{y}
\]

Sortieren: \[
\sum_{i=1}^{n} x_iy_i - n\bar{x}\bar{y}  -  n\bar{x}\bar{y} + \sum_{i=1}^{n} \bar{x}\bar{y}
\]

Der letzte Term \(\sum_{i=1}^{n} \bar{x}\bar{y}\) kann auch
\(n \cdot \bar{x}\bar{y}\) geschrieben werden, sodass sich ergibt: \[
\sum_{i=1}^{n} x_iy_i - n\bar{x}\bar{y} - n\bar{x}\bar{y} + n\bar{x}\bar{y}
\]

Die letzten beiden Terme entfallen somit und es bleibt: \[
\sum_{i=1}^{n} x_iy_i - n\bar{x}\bar{y} 
\]

{[}@Baitsch-2019, S. 73-74{]}

\end{tcolorbox}

Die Funktionen dafür stellen sowohl das Paket \texttt{numpy.polynomial}
bzw. für Polynomfunktionen dessen Modul
\texttt{numpy.polynomial.polynomial} als auch das Modul
\texttt{scipy.stats.linregress} bereit. Im Folgenden wird die Berechnung
mit NumPy gezeigt und anschließend die Funktionen aus dem Modul SciPy
vorgestellt. Die Funktionsweise beider Module ist ähnlich.

\subsubsection{NumPy polyfit und
polyeval}\label{numpy-polyfit-und-polyeval}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy.polynomial.polynomial }\ImportTok{as}\NormalTok{ poly}
\end{Highlighting}
\end{Shaded}

Zur Schätzung von Funktionsparametern nach der Methode der kleinsten
Quadrate wird die Funktion \texttt{poly.polyfit(x,\ y,\ deg)} verwendet.
\texttt{x} sind die Werte der unabhängigen Variablen, \texttt{y} die
Werte der abhängigen Variablen und \texttt{deg} spezifiziert den Grad
der gesuchten Polynomfunktion. \texttt{deg\ =\ 1} spezifiziert eine
lineare Funktion.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-polyfitpolyeval}: polyfit und polyeval erklärt}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-polyfitpolyeval} 

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beispieldaten erzeugen}
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.array(}\BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{100}\NormalTok{)))}
\NormalTok{y }\OperatorTok{=}\NormalTok{ x }\OperatorTok{**} \DecValTok{2}

\BuiltInTok{print}\NormalTok{(poly.polyfit(x, y, }\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[-1617.    99.]
\end{verbatim}

Die Funktion gibt die geschätzten Regressionsparameter als NumPy-Array
zurück. Die Terme sind aufsteigend angeordnet, d.~h. der Achsabschnitt
steht an Indexposition 0, der Steigungskoeffizient an Indexposition 1.
Die Ausgabe für ein Polynom zweiten Grades würde beispielsweise so
aussehen:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(poly.polyfit(x, y, }\DecValTok{2}\NormalTok{).}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[0. 0. 1.]
\end{verbatim}

Mit den Regressionskoeffizienten können die Vorhersagewerte der linearen
Funktion berechnet werden. Dafür wird die Funktion
\texttt{poly.polyeval(x,\ c)} verwendet. Diese berechnet die
Funktionswerte für in \texttt{x} übergebene Werte mit den
Funktionsparametern \texttt{c}. Aus der Differenz der gemessenen Werte
und der Vorhersagewerte können die Residuen bestimmt werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# \textquotesingle{}manuelle\textquotesingle{} Berechnung}
\NormalTok{regressions\_koeffizienten }\OperatorTok{=}\NormalTok{ poly.polyfit(x, y, }\DecValTok{1}\NormalTok{)}
\NormalTok{vorhersagewerte }\OperatorTok{=}\NormalTok{ regressions\_koeffizienten[}\DecValTok{0}\NormalTok{] }\OperatorTok{+}\NormalTok{ x }\OperatorTok{*}\NormalTok{ regressions\_koeffizienten[}\DecValTok{1}\NormalTok{]}
\NormalTok{residuen }\OperatorTok{=}\NormalTok{ y }\OperatorTok{{-}}\NormalTok{ vorhersagewerte}

\CommentTok{\# Berechnung mit polyeval}
\NormalTok{lm }\OperatorTok{=}\NormalTok{ poly.polyfit(x, y, }\DecValTok{1}\NormalTok{)}
\NormalTok{vorhersagewerte\_polyval }\OperatorTok{=}\NormalTok{ poly.polyval(x, lm)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Die Ergebnisse stimmen überein:"}\NormalTok{, np.equal(vorhersagewerte, vorhersagewerte\_polyval).}\BuiltInTok{all}\NormalTok{())}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Ausschnitt der Vorhersagewerte:"}\NormalTok{, vorhersagewerte[:}\DecValTok{10}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Die Ergebnisse stimmen überein: True

Ausschnitt der Vorhersagewerte: [-1617. -1518. -1419. -1320. -1221. -1122. -1023.  -924.  -825.  -726.]
\end{verbatim}

Das
\href{https://de.wikipedia.org/wiki/Bestimmtheitsma\%C3\%9F}{Bestimmtheitsmaß}
\(R^2\) gibt an, wie gut die Schätzfunktion an die Daten angepasst ist.
Der Wertebereich reicht von 0 bis 1. Ein Wert von 1 bedeutet eine
vollständige Anpassung. Für eine einfache lineare Regression mit nur
einer erklärenden Variable kann das Bestimmtheitsmaß als Quadrat des
\href{https://de.wikipedia.org/wiki/Korrelationskoeffizient_nach_Bravais-Pearson}{Bravais-Pearson-Korrelationskoeffizienten}
\(r\) berechnet werden. Dieser wird mit der Funktion
\texttt{np.corrcoef(x,\ y)} ermittelt (die eine Matrix der
Korrelationskoeffizienten ausgibt).

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"r = }\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\NormalTok{corrcoef(x, y)[}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{]}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"R}\CharTok{\textbackslash{}u00b2}\SpecialStringTok{ = }\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\NormalTok{corrcoef(x, y)[}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{] }\OperatorTok{**} \DecValTok{2}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
r = 0.97
R² = 0.94
\end{verbatim}

Die Daten und die geschätzte Gerade können grafisch dargestellt werden.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{plt.scatter(x, y, label }\OperatorTok{=} \StringTok{\textquotesingle{}Beispieldaten\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(x, vorhersagewerte, label }\OperatorTok{=} \StringTok{\textquotesingle{}Vorhersagewerte\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.annotate(}\StringTok{"$R\^{}2$ = }\SpecialCharTok{\{:.2f\}}\StringTok{"}\NormalTok{.}\BuiltInTok{format}\NormalTok{(np.corrcoef(x, y)[}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{] }\OperatorTok{**} \DecValTok{2}\NormalTok{), (}\BuiltInTok{max}\NormalTok{(x) }\OperatorTok{*} \FloatTok{0.9}\NormalTok{, }\DecValTok{1}\NormalTok{))}

\NormalTok{plt.title(label }\OperatorTok{=} \StringTok{\textquotesingle{}Beispieldaten und geschätzte Linearfunktion\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}x{-}Werte\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}y{-}Werte\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/lineare-parameterschätzung_files/figure-pdf/cell-23-output-1.png}}

\end{tcolorbox}

NumPy umfasst außerdem die inzwischen veralteten Funktionen
\texttt{np.polyfit(x,\ y,\ deg)} und \texttt{np.polyval(p,\ x)}.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-polyfit}: np.polyfit \& np.polyval}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-polyfit} 

Die Funktionen \texttt{np.polyfit(x,\ y,\ deg)} und
\texttt{np.polyval(p,\ x)} funktionieren wie die vorgestellten
Funktionen aus dem Modul \texttt{numpy.polynomial.polynomial}. Ein
wichtiger Unterschied besteht jedoch darin, dass \textbf{die Parameter
der Funktion \texttt{polyfit} in umgekehrter Reihenfolge} ausgegeben
werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(poly.polyfit(x, y, deg }\OperatorTok{=} \DecValTok{1}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(np.polyfit(x, y, deg }\OperatorTok{=} \DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[-1617.    99.]
[   99. -1617.]
\end{verbatim}

\begin{quote}
\textbf{Note}

This forms part of the old polynomial API. Since version 1.4, the new
polynomial API defined in \texttt{numpy.polynomial} is preferred. A
summary of the differences can be found in the
\href{https://numpy.org/doc/stable/reference/routines.polynomials.html}{transition
guide}.
\end{quote}

\href{https://numpy.org/doc/stable/reference/generated/numpy.polyfit.html}{NumPy-Dokumentation}

\end{tcolorbox}

Die Parameter der an die Messwerte angepassten linearen Funktion und das
Bestimmtheitsmaß lauten:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(poly.polyfit(hooke[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{], hooke[}\StringTok{\textquotesingle{}force\textquotesingle{}}\NormalTok{], }\DecValTok{1}\NormalTok{))}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"r = }\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\NormalTok{corrcoef(hooke[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{], hooke[}\StringTok{\textquotesingle{}force\textquotesingle{}}\NormalTok{])[}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{]}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"R}\CharTok{\textbackslash{}u00b2}\SpecialStringTok{ = }\SpecialCharTok{\{}\NormalTok{np}\SpecialCharTok{.}\NormalTok{corrcoef(hooke[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{], hooke[}\StringTok{\textquotesingle{}force\textquotesingle{}}\NormalTok{])[}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{] }\OperatorTok{**} \DecValTok{2}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[ 0.05753159 33.01899551]
r = 0.99
R² = 0.99
\end{verbatim}

Mit den Regressionskoeffizienten können die Vorhersagewerte der linearen
Funktion berechnet werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Berechnung mit polyeval}
\NormalTok{lm }\OperatorTok{=}\NormalTok{ poly.polyfit(hooke[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{], hooke[}\StringTok{\textquotesingle{}force\textquotesingle{}}\NormalTok{], }\DecValTok{1}\NormalTok{)}
\NormalTok{vorhersagewerte\_hooke }\OperatorTok{=}\NormalTok{ poly.polyval(hooke[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{], lm)}
\end{Highlighting}
\end{Shaded}

Die Messreihe und die darauf angepasste lineare Funktion können grafisch
dargestellt werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Platzhalter x \& y}
\NormalTok{x }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{]}
\NormalTok{y }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}force\textquotesingle{}}\NormalTok{]}

\CommentTok{\# Plot erstellen}
\NormalTok{plt.scatter(x, y, label }\OperatorTok{=} \StringTok{\textquotesingle{}Messdaten\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.axline(xy1 }\OperatorTok{=}\NormalTok{ (}\DecValTok{0}\NormalTok{, lm[}\DecValTok{0}\NormalTok{]), slope }\OperatorTok{=}\NormalTok{ lm[}\DecValTok{1}\NormalTok{], label }\OperatorTok{=} \StringTok{\textquotesingle{}Regressionsgerade}\CharTok{\textbackslash{}n}\StringTok{y = \textquotesingle{}} \OperatorTok{+} \StringTok{"}\SpecialCharTok{\{beta\_0:.3f\}}\StringTok{"}\NormalTok{.}\BuiltInTok{format}\NormalTok{(beta\_0 }\OperatorTok{=}\NormalTok{ lm[}\DecValTok{0}\NormalTok{]) }\OperatorTok{+} \StringTok{\textquotesingle{} + \textquotesingle{}} \OperatorTok{+} \StringTok{"}\SpecialCharTok{\{beta\_1:.3f\}}\StringTok{ "}\NormalTok{.}\BuiltInTok{format}\NormalTok{(beta\_1 }\OperatorTok{=}\NormalTok{ lm[}\DecValTok{1}\NormalTok{]) }\OperatorTok{+} \StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{ )}
\NormalTok{plt.annotate(}\StringTok{"$R\^{}2$ = }\SpecialCharTok{\{:.2f\}}\StringTok{"}\NormalTok{.}\BuiltInTok{format}\NormalTok{(np.corrcoef(x, y)[}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{] }\OperatorTok{**} \DecValTok{2}\NormalTok{), (}\BuiltInTok{max}\NormalTok{(x) }\OperatorTok{*} \FloatTok{0.9}\NormalTok{, }\DecValTok{1}\NormalTok{))}

\NormalTok{plt.title(label }\OperatorTok{=} \StringTok{\textquotesingle{}Messdaten und geschätzte Linearfunktion\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}gemessene Abstandsänderung in m\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}wirkende Kraft in N\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}

\NormalTok{plt.grid()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/lineare-parameterschätzung_files/figure-pdf/cell-27-output-1.png}}

\subsection{Messabweichung
quantifizieren}\label{messabweichung-quantifizieren}

Für den geschätzten Regressionskoeffizienten kann für die lineare
Regression mit einer erklärenden Variable der Standardfehler des
Regressionskoeffizienten \(SE = \hat{\sigma}_{\hat{\beta_1}}\) ermittelt
werden (siehe
\href{https://de.wikipedia.org/wiki/Standardfehler_des_Regressionskoeffizienten\#Spezialfall:_Lineare_Einfachregression}{Wikipedia}).

\[
SE = \sqrt{\frac{\frac{1}{n-2} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2}{ \sum_{i=1}^{n} (x_i - \bar{x})^2}}
\]

\begin{itemize}
\tightlist
\item
  Im Zähler steht die mittlere
  \href{https://de.wikipedia.org/wiki/Residuenquadratsumme}{Residuenquadratsumme}
  (Summe der quadrierten Residuen / Anzahl der Freiheitsgrade).
\item
  Im Nenner steht die
  \href{https://de.wikipedia.org/wiki/Summe_der_Abweichungsquadrate}{Summe
  der Abweichungsquadrate von \(x\)}.
\end{itemize}

Für ein Signifikanzniveau \(\alpha\) kann ein Konfidenzniveau
\(1 - \alpha\) angegeben werden als:

\[
\hat{\beta_1} \pm SE \cdot t_{1-\alpha / 2} ~ (n - 2)
\]

\begin{itemize}
\tightlist
\item
  \(t_{1-\alpha / 2} ~ (n - 2)\) ist der Wert der t-Verteilung mit n - 2
  Freiheitsgraden bzw. der Rückgabewert der Funktion:

  \begin{itemize}
  \tightlist
  \item
    \texttt{scipy.stats.t.ppf(q\ =\ 1\ -\ alpha/2,\ df\ =\ n\ -\ 2)} für
    die obere Intervallgrenze.
  \end{itemize}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Regressionskoeffizient: }\SpecialCharTok{\{}\NormalTok{lm[}\DecValTok{1}\NormalTok{]}\SpecialCharTok{:.4f\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# \textquotesingle{}manuell\textquotesingle{} Standardfehler des Regressionskoeffizienten berechnen}
\NormalTok{standardfehler\_beta\_1 }\OperatorTok{=}\NormalTok{ np.sqrt( (}\DecValTok{1} \OperatorTok{/}\NormalTok{ (}\BuiltInTok{len}\NormalTok{(x) }\OperatorTok{{-}} \DecValTok{2}\NormalTok{) }\OperatorTok{*} \BuiltInTok{sum}\NormalTok{((y }\OperatorTok{{-}}\NormalTok{ vorhersagewerte\_hooke) }\OperatorTok{**} \DecValTok{2}\NormalTok{)) }\OperatorTok{/} \BuiltInTok{sum}\NormalTok{( (x }\OperatorTok{{-}}\NormalTok{ x.mean()) }\OperatorTok{**} \DecValTok{2}\NormalTok{  ))}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Standardfehler des Regressionskoeffizienten: }\SpecialCharTok{\{}\NormalTok{standardfehler\_beta\_1}\SpecialCharTok{:.4f\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# Signifikanzniveau (alpha{-}Niveau) 1 {-} 95 \% wählen}
\NormalTok{alpha }\OperatorTok{=} \FloatTok{0.05}
\NormalTok{n }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(x)}

\NormalTok{t\_wert }\OperatorTok{=}\NormalTok{ scipy.stats.t.ppf(q }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ alpha}\OperatorTok{/}\DecValTok{2}\NormalTok{, df }\OperatorTok{=}\NormalTok{ n }\OperatorTok{{-}} \DecValTok{2}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"t{-}Wert 95{-}\%{-}Intervall (zweiseitig): }\SpecialCharTok{\{}\NormalTok{t\_wert}\SpecialCharTok{:.4f\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Konfidenzintervall 95 \%: }\SpecialCharTok{\{}\NormalTok{lm[}\DecValTok{1}\NormalTok{]}\SpecialCharTok{:.4f\}}\SpecialStringTok{ ± }\SpecialCharTok{\{}\NormalTok{t\_wert}\SpecialCharTok{:.4f\}}\SpecialStringTok{ * }\SpecialCharTok{\{}\NormalTok{standardfehler\_beta\_1}\SpecialCharTok{:.4f\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"untere 95{-}\%{-}Intervallgrenze: }\SpecialCharTok{\{}\NormalTok{lm[}\DecValTok{1}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ t\_wert }\OperatorTok{*}\NormalTok{ standardfehler\_beta\_1}\SpecialCharTok{:.4f\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"obere 95{-}\%{-}Intervallgrenze: }\SpecialCharTok{\{}\NormalTok{lm[}\DecValTok{1}\NormalTok{] }\OperatorTok{+}\NormalTok{ t\_wert }\OperatorTok{*}\NormalTok{ standardfehler\_beta\_1}\SpecialCharTok{:.4f\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Regressionskoeffizient: 33.0190
Standardfehler des Regressionskoeffizienten: 0.3784
t-Wert 95-%-Intervall (zweiseitig): 1.9816
Konfidenzintervall 95 %: 33.0190 ± 1.9816 * 0.3784
untere 95-%-Intervallgrenze: 32.2692
obere 95-%-Intervallgrenze: 33.7688
\end{verbatim}

Das Konfidenzintervall kann auch grafisch dargestellt werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Platzhalter x \& y}
\NormalTok{x }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{]}
\NormalTok{y }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}force\textquotesingle{}}\NormalTok{]}

\CommentTok{\# Plot erstellen}
\NormalTok{plt.scatter(x, y, label }\OperatorTok{=} \StringTok{\textquotesingle{}Messdaten\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.axline(xy1 }\OperatorTok{=}\NormalTok{ (}\DecValTok{0}\NormalTok{, lm[}\DecValTok{0}\NormalTok{]), slope }\OperatorTok{=}\NormalTok{ lm[}\DecValTok{1}\NormalTok{], label }\OperatorTok{=} \StringTok{\textquotesingle{}Regressionsgerade}\CharTok{\textbackslash{}n}\StringTok{y = \textquotesingle{}} \OperatorTok{+} \StringTok{"}\SpecialCharTok{\{beta\_0:.3f\}}\StringTok{"}\NormalTok{.}\BuiltInTok{format}\NormalTok{(beta\_0 }\OperatorTok{=}\NormalTok{ lm[}\DecValTok{0}\NormalTok{]) }\OperatorTok{+} \StringTok{\textquotesingle{} + \textquotesingle{}} \OperatorTok{+} \StringTok{"}\SpecialCharTok{\{beta\_1:.3f\}}\StringTok{ "}\NormalTok{.}\BuiltInTok{format}\NormalTok{(beta\_1 }\OperatorTok{=}\NormalTok{ lm[}\DecValTok{1}\NormalTok{]) }\OperatorTok{+} \StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{ )}
\NormalTok{plt.annotate(}\StringTok{"$R\^{}2$ = }\SpecialCharTok{\{:.2f\}}\StringTok{"}\NormalTok{.}\BuiltInTok{format}\NormalTok{(np.corrcoef(x, y)[}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{] }\OperatorTok{**} \DecValTok{2}\NormalTok{), (}\BuiltInTok{max}\NormalTok{(x) }\OperatorTok{*} \FloatTok{0.9}\NormalTok{, }\DecValTok{1}\NormalTok{))}

\CommentTok{\# 95{-}\%{-}Konfidenzintervall einzeichnen}
\CommentTok{\#\# poly.polyval(hooke[\textquotesingle{}distance\textquotesingle{}], [lm[0]])}
\NormalTok{beta1\_lower\_boundary }\OperatorTok{=}\NormalTok{ lm[}\DecValTok{1}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ (t\_wert }\OperatorTok{*}\NormalTok{ standardfehler\_beta\_1)}
\NormalTok{beta1\_upper\_boundary }\OperatorTok{=}\NormalTok{ lm[}\DecValTok{1}\NormalTok{] }\OperatorTok{+}\NormalTok{ (t\_wert }\OperatorTok{*}\NormalTok{ standardfehler\_beta\_1)}

\NormalTok{y\_lower\_boundary }\OperatorTok{=}\NormalTok{ poly.polyval(hooke[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{], [lm[}\DecValTok{0}\NormalTok{], beta1\_lower\_boundary])}
\NormalTok{y\_upper\_boundary }\OperatorTok{=}\NormalTok{ poly.polyval(hooke[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{], [lm[}\DecValTok{0}\NormalTok{], beta1\_upper\_boundary])}

\NormalTok{plt.fill\_between(x }\OperatorTok{=}\NormalTok{ x, y1 }\OperatorTok{=}\NormalTok{ y\_lower\_boundary , y2 }\OperatorTok{=}\NormalTok{ y\_upper\_boundary, alpha }\OperatorTok{=} \FloatTok{0.3}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}95{-}\%{-}Konfidenzintervall $}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{beta\_1$\textquotesingle{}}\NormalTok{)}


\NormalTok{plt.title(label }\OperatorTok{=} \StringTok{\textquotesingle{}Messdaten und geschätzte Linearfunktion im 95{-}\%{-}Intervall\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}gemessene Abstandsänderung in m\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}wirkende Kraft in N\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}

\NormalTok{plt.grid()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/lineare-parameterschätzung_files/figure-pdf/cell-29-output-1.png}}

\subsection{Das Modul SciPy}\label{das-modul-scipy}

Die Funktion \texttt{scipy.stats.lingress(x,\ y)} liefert mit einem
Funktionsaufruf zahlreiche Rückgabewerte:

\begin{itemize}
\tightlist
\item
  Steigung der Regressionsgerade,
\item
  y-Achsenschnittpunkt der Regressionsgerade,
\item
  Bravais-Pearson-Korrelationskoeffizient r,
\item
  p-Wert der Nullhypothese, dass die Steigung der Regressionsgerade Null
  ist,
\item
  Standardfehler der Steigung und
\item
  Standardfehler des y-Achsenschnittpunkts.
\end{itemize}

Der Standardfehler des y-Achsenschnittpunkts ist nur verfügbar, wenn die
Rückgabewerte in einem Objekt gespeichert werden. Die Rückgabewerte
können dann als Attribute abgerufen werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Zuweisung mehrerer Objekte}
\NormalTok{slope, intercept, rvalue, pvalue, slope\_stderr }\OperatorTok{=}\NormalTok{ scipy.stats.linregress(x, y)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"y = }\SpecialCharTok{\{}\NormalTok{intercept}\SpecialCharTok{:.4f\}}\SpecialStringTok{ + }\SpecialCharTok{\{}\NormalTok{slope}\SpecialCharTok{:.4f\}}\SpecialStringTok{ * x}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"r = }\SpecialCharTok{\{}\NormalTok{rvalue}\SpecialCharTok{:.4f\}}\SpecialStringTok{ R2 = }\SpecialCharTok{\{}\NormalTok{rvalue }\OperatorTok{**} \DecValTok{2}\SpecialCharTok{:.4f\}}\SpecialStringTok{ p = }\SpecialCharTok{\{}\NormalTok{pvalue}\SpecialCharTok{:.4f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Standardfehler des Anstiegs: }\SpecialCharTok{\{}\NormalTok{slope\_stderr}\SpecialCharTok{:.4f\}}\SpecialStringTok{"}\NormalTok{, sep }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Zuweisung eines Objekts}
\NormalTok{lm }\OperatorTok{=}\NormalTok{ scipy.stats.linregress(x, y)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, lm, sep }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"y{-}Achsenschnittpunkt: }\SpecialCharTok{\{}\NormalTok{lm}\SpecialCharTok{.}\NormalTok{intercept}\SpecialCharTok{:.4f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{Standardfehler des y{-}Achsenschnittpunkts:}\SpecialCharTok{\{}\NormalTok{lm}\SpecialCharTok{.}\NormalTok{intercept\_stderr}\SpecialCharTok{:.4f\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
y = 0.0575 + 33.0190 * x
r = 0.9928 R2 = 0.9856 p = 0.0000
Standardfehler des Anstiegs: 0.3784

LinregressResult(slope=np.float64(33.01899550918018), intercept=np.float64(0.05753158907970102), rvalue=np.float64(0.9927907555799099), pvalue=np.float64(4.115211719827623e-104), stderr=np.float64(0.37837320019327897), intercept_stderr=np.float64(0.0506707972676925))
y-Achsenschnittpunkt: 0.0575
Standardfehler des y-Achsenschnittpunkts:0.0507
\end{verbatim}

So kann mit dem entsprechenden t-Wert das Konfidenzintervall berechnet
werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{alpha }\OperatorTok{=} \FloatTok{0.05}
\NormalTok{n }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(x)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{slope }\OperatorTok{{-}}\NormalTok{ scipy}\SpecialCharTok{.}\NormalTok{stats}\SpecialCharTok{.}\NormalTok{t}\SpecialCharTok{.}\NormalTok{ppf(q }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ alpha }\OperatorTok{/} \DecValTok{2}\NormalTok{, df }\OperatorTok{=}\NormalTok{ n }\OperatorTok{{-}} \DecValTok{2}\NormalTok{) }\OperatorTok{*}\NormalTok{ slope\_stderr}\SpecialCharTok{:.3f\}}\SpecialStringTok{  ≤ }\SpecialCharTok{\{}\NormalTok{slope}\SpecialCharTok{:.3f\}}\SpecialStringTok{ ≤ }\SpecialCharTok{\{}\NormalTok{slope }\OperatorTok{+}\NormalTok{ scipy}\SpecialCharTok{.}\NormalTok{stats}\SpecialCharTok{.}\NormalTok{t}\SpecialCharTok{.}\NormalTok{ppf(q }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ alpha }\OperatorTok{/} \DecValTok{2}\NormalTok{, df }\OperatorTok{=}\NormalTok{ n }\OperatorTok{{-}} \DecValTok{2}\NormalTok{) }\OperatorTok{*}\NormalTok{ slope\_stderr}\SpecialCharTok{:.3f\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
32.269  ≤ 33.019 ≤ 33.769
\end{verbatim}

\subsection{Ergebnis Federkonstante}\label{ergebnis-federkonstante}

Die Federkonstante des Versuchaufbaus liegt mit 95 prozentiger
Sicherheit im Intervall zwischen 32,27 und 33,77. Die Punktschätzung für
die Federkonstante beträgt 33,02.

\textbf{Aufgabe könnte sein, das Konfidenzintervall 99-Prozent zu
berechnen.}\\
--\textgreater{} Dann muss man aber nur eine Zahl ändern

\chapter{Fehlerrechnung}\label{fehlerrechnung}

\begin{figure}

\begin{minipage}{0.05\linewidth}
~\end{minipage}%
%
\begin{minipage}{0.90\linewidth}
``Das Experimentieren ist ein dornenvoller Weg und so ganz sicher ist
man sich nie.''\end{minipage}%
%
\begin{minipage}{0.05\linewidth}
~\end{minipage}%
\newline
\begin{minipage}{\linewidth}
Wagner, Paul. 2015. ``Einführung in die Physik I. PH I - 04 - Die
Messgenauigkeit / Fehlerrechnung Teil 1.'' Universität Wien Physik,
\href{https://youtu.be/sF2_1YNiWXI?feature=shared&t=245}{YouTube},
Zeitstempel 04:05\end{minipage}%

\end{figure}%

~

Kein Messgerät misst exakt und nicht alle Umwelteinflüsse können
kontrolliert werden. Das Ziel der Fehlerrechnung ist es, die sich daraus
ergebende Abweichung der Messwerte um den wahren Wert einer Größe zu
quantifizieren.

\section{Bevor es losgeht}\label{bevor-es-losgeht}

Das Thema ist jedoch mit einigen Schwierigkeiten verbunden, die den
Einstieg und die eigenständige Vertiefung des Themas erschweren.

\subsection{Der Begriff des Fehlers}\label{der-begriff-des-fehlers}

Das Wort Fehler steckt zwar schon in der Überschrift dieses Kapitels,
doch handelt es sich seit 1995 nicht mehr um einen genormten Begriff.
Die DIN 1319 normt Grundbegriffe und Verfahren der Messtechnik. Die Norm
ersetzt den Begriff des Fehlers durch die Begriffe
\textbf{Messabweichung} und \textbf{Messunsicherheit}, umfasst aber
darüber hinaus eine Vielzahl aufeinander bezogener Begriffsdefinitionen,
Anmerkungen und Bemerkungen.

In diesem Kapitel werden die in der Fehlerrechnung gebräuchlichen
Begriffe aufgegriffen, um die Verbindung zu den genormten Begriffen
herzustellen. Im Allgemeinen werden jedoch die genormten Begriffe
verwendet. Um den Einstieg in das Thema zu erleichtern, beschränkt sich
dieses Kapitel auf Messungen mit:

\begin{itemize}
\tightlist
\item
  unkorrelierten Eingangsgrößen und
\item
  vernachlässigbarer Unsicherheit über die systematische Messabweichung.
\end{itemize}

\subsection{Konfidenzniveau}\label{konfidenzniveau}

Wiederholte Messungen enthalten eine zufällige Komponente statistischer
Unsicherheit. Die statistische Unsicherheit kann immer nur mit einer
Vertrauenswahrscheinlichkeit angegeben werden. Die Berechnung von
Konfidenzintervallen haben wir in Chapter~\ref{sec-normalverteilung} und
Chapter~\ref{sec-hooke} behandelt.

Zur statistischen Analyse gehört als erster Schritt, das
Konfidenzniveau, das gelten soll, festzulegen. Hieraus leiten sich die
zu verwendenden Vielfachen der Standardabweichung \(s\) bzw. des
Korrekturfaktors \(t\) ab. Hierbei gibt es je nach Disziplin
unterschiedliche Konventionen.

\begin{figure}

\begin{minipage}{0.05\linewidth}
~\end{minipage}%
%
\begin{minipage}{0.90\linewidth}
``In der Physik und der Vermessungstechnik begnügt man sich mit einer
statistischen Sicherheit von 68,3\% und setzt deshalb t = 1 {[}\ldots{]}
(In der Industrie wird t = 2, in der Biologie t = 3 bevorzugt.)''
{[}@HS-Aalen-2016 S. 4{]}\end{minipage}%
%
\begin{minipage}{0.05\linewidth}
~\end{minipage}%

\end{figure}%

In der ingenieurswissenschaftlichen Literatur wird dieser Schritt nicht
immer explizit gemacht (weil es üblich ist, \(1 s\) bzw. \(1 t\) zu
verwenden). Dagegen heißt es in der DIN 1319: ``Es ist üblich, das
Vertrauensniveau (\(1 - \alpha\)) in Prozent anzugeben, wobei meist
\(\alpha = 0,05\) (Vertrauensniveau: 95 \%) benutzt wird.''
{[}@DIN1319-1, S. 17{]}

\subsection{Notation}\label{notation}

Die Notation ist komplex: Neben dem lateinischen und griechischen
Alphabet wird auch das kyrillische Alphabet verwendet. Trotzdem lassen
sich Dopplungen von Symbolen für Formelzeichen und Einheiten nicht immer
vermeiden (und die Federkonstante ist in dieser Hinsicht der denkbar
ungünstigste Fall).

Die Notation wird außerdem uneinheitlich gehandhabt. Während in der DIN
1319 Messabweichungen mit \(e\) notiert werden, sind in der Literatur
\(\epsilon\) (epsilon) und \(\Delta\) (Delta) gebräuchlich, wobei
letzteres auch für den Größtfehler verwendet wird.

Übrigens: Das in der DIN verwendete \(e\) steht für error, also Fehler (
¯\textbackslash\_(ツ)\_/¯ ).

\section{Fehlerarten}\label{fehlerarten}

Bei Messungen können unterschiedliche Arten von Abweichungen des
Messergebnisses vom tatsächlichen Wert der gemessenen Größe auftreten.
Am gebräuchlichsten ist die Unterteilung in grobe, systematische und
zufällige \emph{Fehler}. Nach DIN 1319 sollte besser von systematischen
und zufälligen Messabweichungen gesprochen werden. Grobe Fehler werden
in der Norm jedoch nicht behandelt und hier ist der Fehlerbegriff
durchaus angemessen.

\begin{itemize}
\item
  Systematische Messabweichungen: unter identischen Bedingungen
  konstante, d.~h. nach Betrag und Vorzeichen gleiche, Verzerrung der
  Messergebnisse durch Abweichungen der Messgeräte. Beispielsweise:

  \begin{itemize}
  \tightlist
  \item
    in Abhängigkeit von der Temperatur
  \item
    fehlerhafte Kalibrierung
  \item
    Alterung der Bauteile
  \item
    die Art der Messung, z. B. Ablese- und Skalenfehler, Messintervall
    bei digitalen Messgeräten
    (\href{https://de.wikipedia.org/wiki/Quantisierungsabweichung}{Quantifizierungsfehler})
  \end{itemize}
\item
  Zufällige Messabweichungen: statistische Streuung der Messwerte um
  ihren Erwartungswert. Beispielsweise:

  \begin{itemize}
  \tightlist
  \item
    Stichprobenfehler
  \item
    Ablesefehler
  \end{itemize}
\item
  Grobe Fehler: Verfälschen der Messergebnisse. Beispielsweise durch:

  \begin{itemize}
  \tightlist
  \item
    falschen Versuchsaufbau
  \item
    ungeeignete Messgeräte
  \item
    falsches Ablesen, z. B. Missachtung der
    \href{https://de.wikipedia.org/wiki/Einschwingzeit}{Einschwingzeit}
    oder Unachtsamkeit, z. B. Mitwiegen des Gefäßes
  \end{itemize}
\end{itemize}

{[}@Hempel-2016, S. 1-2; @EdenGebhard-2024, S. 17-18{]}

Bestimmte Tätigkeiten, wie das Ablesen, können mehreren Fehlerarten
zugehörig sein:

\begin{itemize}
\tightlist
\item
  Unaufmerksames Ablesen und Flüchtigkeitsfehler sind grobe Fehler,
\item
  winkel- und positionsabhängige Fehler wie der
  \href{https://de.wikipedia.org/wiki/Parallaxenfehler}{Parallaxenfehler}
  sind systematische Abweichungen,
\item
  Fehler infolge des begrenzten Auflösungsvermögens des menschlichen
  Auges führen zu zufälligen Abweichungen.
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-umgangmitfehlern}: Umgang mit verschiedenen Arten von Messabweichungen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-umgangmitfehlern} 

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Grobe Fehler: Betroffene Werte streichen und Messung wiederholen.
\item
  Systematische Messabweichungen: Systematische Messabweichungen werden,
  wenn sie bekannt sind, korrigiert.
\item
  Zufällige Messabweichungen: Die statistische Streuung von Messwerten
  um den Erwartungswert wird quantifiziert.
\end{enumerate}

Einige systematische und zufällige Messabweichungen können nur mit hohem
Aufwand reduziert werden (genauere Messgeräte, größere Anzahl von
Messvorgängen). Der Aufwand muss gegen den Gewinn an Genauigkeit
abgewogen werden: Ist das Messergebnis mit der angegebenen Unsicherheit
akzeptabel?

(@Hempel-2016, S. 2)

\end{tcolorbox}

\section{Grundbegriffe nach DIN 1319}\label{grundbegriffe-nach-din-1319}

Die DIN 1319 normt Grundbegriffe und Verfahren der Messtechnik.

\begin{itemize}
\tightlist
\item
  Teil 1 DIN 1319-1 und Teil 2 DIN 1319-2 definieren Grundbegriffe der
  Messtechnik und für Messmittel.
\item
  Teil 3 DIN 1319-3 befasst sich mit der Auswertung von Messungen einer
  \emph{einzelnen} Messgröße und deren Messunsicherheit. DIN 1319-3 wird
  auch angewendet, wenn die Messgröße mittels einer gegebenen Funktion
  aus anderen Größen berechnet wird (beispielsweise die Geschwindigkeit
  \(v\) als Quotient der Strecke \(s\) und der Zeit \(t\)).
\item
  Teil 4 DIN 1319-4 befasst sich mit der Angabe von Messergebnissen und
  deren Messunsicherheit, wenn die Messgrößen aus anderen Größen
  berechnet werden, z. B. durch eine Ausgleichsrechung.
\end{itemize}

DIN 1319-4 befasst sich mit der Berechnung einer Ergebnisgröße \(Y\)
durch eine Funktion wie z. B. die lineare Ausgleichsrechnung. Der
Anwendungsfall des vorherigen Kapitels, die Federkonstante über den
Regressionskoeffizienten \(\beta_1\) zu bestimmen, wird in der Norm
nicht behandelt. Dieser Teil der Norm wird hier deshalb nicht
vorgestellt.

Das Lernziel dieses Kapitels besteht darin, dass Sie die folgende Grafik
aus der DIN 1319 erklären können.

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/00-bilder/fehlerarten-nach-DIN-1319.png}}

}

\caption{Messergebnis nach DIN 1319}

\end{figure}%

{[}@DIN1319-1, S. 30{]}

~

Die drei wichtigsten Grundbegriffe sind:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Messabweichung,
\item
  Messunsicherheit und
\item
  vollständiges Messergebnis.
\end{enumerate}

\subsection{Messabweichung}\label{messabweichung}

Der in der Fehlerrechnung gebräuchliche Begriff des (Mess-)Fehlers meint
im engeren Sinn die Messabweichung nach DIN 1319, also die
\emph{tatsächliche Abweichung} eines einzelnen Messwerts oder des
arithmetischen Mittelwerts einer Messreihe (dem unberichtigten
Messergebnis) vom wahren Wert der gemessenen Größe.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-messabweichung}: Messabweichung nach DIN 1319}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-messabweichung} 

Die Messabweichung ist die: ``Abweichung eines aus Messungen gewonnenen
und der Meßgröße {[}\ldots{]} zugeordneten Wertes vom wahren Wert
{[}\ldots{]}. Ist \(m\) der der Meßgröße zugeordnete Wert und \(x_w\)
der wahre Wert, so ist die Meßabweichung des zugeordneten Wertes
\(m - x_w\) {[}\ldots{]}.'' {[}@DIN1319-1, S. 12{]}

\end{tcolorbox}

Die Messabweichung des \textbf{unberichtigten Messergebnisses} setzt
sich additiv aus der zufälligen Messabweichung \(e_r\) und der
systematischen Messabweichung \(e_s\) zusammen.

\begin{itemize}
\tightlist
\item
  Die systematische Messabweichung ist die Differenz aus dem
  Erwartungswert der Messung \(\mu\) und dem wahrem Wert \(x_w\). Es
  gilt: \(e_s = \mu - x_w\)\\
\item
  Die systematische Messabweichung \(e_s\) setzt sich aus einem
  bekannten \(e_{s,b}\) und einem unbekannten Anteil \(e_{s,u}\)
  zusammen.
\item
  Die bekannte, systematische Messabweichung \(e_{s,b}\) wird mit
  entgegengesetzten Vorzeichen \(- e_{s,b}\) \emph{Korrektion} genannt.
\end{itemize}

Das \textbf{(berichtigte) Messergebnis} \(\bar{x}_E\) ist das um die
bekannte, systematische Messabweichung \(e_{s,b}\) berichtigte
arithmetische Mittel einer Messreihe \(\bar{x}\), das als Schätzer des
wahren Werts \(x_w\) verwendet wird. \(\bar{x}_E = \bar{x} - e_{s,b}\)

{[}@DIN1319-1, S. 11-13{]}

\subsection{Messunsicherheit}\label{messunsicherheit}

Der wahre Wert einer gemessenen Größe ist in der Regel unbekannt, sodass
die tatsächliche Messabweichung ebenfalls nicht bekannt ist. Deshalb
kann nur eine \emph{aus den Messgrößen gewonnene Schätzung} der
Messabweichung - die Messunsicherheit - angegeben werden. Der in der
Fehlerrechnung gebräuchliche Begriff des (Mess-)Fehlers meint im
weiteren Sinn die Messunsicherheit nach DIN 1319.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-messunsicherheit}: Messunsicherheit nach DIN 1319}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-messunsicherheit} 

``Kennwert, der aus Messungen {[}\ldots{]} gewonnen wird und zusammen
mit dem Meßergebnis {[}\ldots{]} zur Kennzeichnung eines
\textbf{Wertebereiches} für den wahren Wert der Meßgröße {[}\ldots{]}
dient.'' {[}@DIN1319-1, S. 14, eigene Hervorhebung{]}

Während die Messabweichung ein Einzelwert ist, kennzeichnet die
Messunsicherheit einen Wertebereich: ``Die Meßunsicherheit ist von der
Meßabweichung {[}\ldots{]} deutlich zu unterscheiden. Letztere ist nur
die Differenz zwischen einem der Meßgröße zuzuordnenden Wert
{[}\ldots{]} und dem wahren Wert. Die Meßabweichung kann gleich Null
sein, ohne daß dies bekannt ist. Diese Unkenntnis drückt sich in einer
Meßunsicherheit größer als Null aus.'' {[}@DIN1319-3, S. 3{]}

\end{tcolorbox}

Die Messunsicherheit einer Messgröße \(Y\) besteht einerseits aus der
zufälligen Messabweichung \(e_r\) und andererseits aus der Unsicherheit
über die systematische Messabweichung \(u(e_s)\).

\textbf{zufällige Messabweichung}

Wird eine Messgröße \(Y = y(x)\) durch mehrere, direkte Messungen
bestimmt, so streuen die Messwerte \(x_i\) zufällig um ihren
Erwartungswert \(\mu\) mit der Standardabweichung \(\sigma\). Der
Erwartungswert \(\mu\) und die Standardabweichung \(\sigma\) sind in der
Regel nicht bekannt und werden aus den Messwerten durch den
arithmetischen Mittelwert \(\bar x\) und die empirische
Standardabweichung \(s_{n-1}\) geschätzt. (siehe
Chapter~\ref{sec-einleitung})

Als Unsicherheit der zufälligen Streuung wird die empirische
Standardabweichung des Mittelwerts verwendet.

\[
u(\bar x) = \frac{s_{n-1}}{\sqrt{N}} ~ = ~ \sqrt{\frac{1}{N(N-1)} \sum_{i=1}^{N}(x_i - \bar{x})^2}
\]

{[}@DIN1319-3, Gleichung (4), S. 5, Notation angepasst{]}

\textbf{systematische Messabweichung}

Die systematische Messabweichung \(e_s\) setzt sich aus einem bekannten
Anteil \(e_{s,b}\) und einem unbekannten Anteil \(e_{s,u}\) zusammen. Da
der unbekannte Anteil nicht bestimmt werden kann, wird die gesamte
systematische Messabweichung über die bekannte systematische
Messabweichung \(e_{s,b}\) geschätzt. Daraus ergibt sich eine
Unsicherheit über die tatsächliche gesamte systematische Messabweichung
\(u(e_{s})\). Diese Unsicherheit besteht auch, wenn die bekannte
systematische Messabweichung \(e_{s,b}\) Null ist, weil der unbekannte
Anteil \(e_{s,u}\) ungleich Null sein kann.

In der DIN 1319 werden zwei Fälle unterschieden, je nachdem, ob die
Unsicherheit \(u(e_{s})\) als vernachlässigbar eingeschätzt wird oder
nicht. In diesem Kapitel gehen wir von einer vernachlässigbaren
Unsicherheit \(u(e_{s})\) aus (Für den zweiten Fall siehe Beispiel).

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-unsicherheit}: \(u(e_{s})\) nicht vernachlässigbar}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-unsicherheit} 

Für den Fall, dass die Unsicherheit der systematischen Messabweichung
nicht als vernachlässigbar angesehen wird, verweist die DIN 1319-3 auf
Berechnungsregeln in Abschnitt 6.2.5 auf die wir hier nicht eingehen.
(@DIN1319-3, S. 5-6)

Die Messunsicherheit des berichtigten Messergebnisses berechnet sich aus
der quadratischen Kombination der Unsicherheiten der zufälligen und der
systematischen Messabweichung.

\[
u(y) = \sqrt{u^2(\bar x) + u^2(e_s)}
\]

{[}@DIN1319-3, Gleichung (8), S. 6, Notation angepasst{]}

\phantomsection\label{wrn-notation2}
\begin{quote}
\textbf{Warning~68.1: Notation in der DIN 1319}

In der DIN wird die zufällige Messabweichung statt mit \(u^2(\bar x)\)
mit \(u^2(x_1)\) und die Unsicherheit der systematischen Messabweichung
statt mit \(u^2(e_s)\) mit \(u^2(x_2)\) notiert.
\end{quote}

\end{tcolorbox}

\subsection{Vollständiges
Messergebnis}\label{vollstuxe4ndiges-messergebnis}

Das \textbf{berichtigte Messergebnis} \(\bar{x}_E = y\) (in der DIN 1319
wechselt die Notation von \(\bar{x}_E\) zu \(y\)) berechnet sich durch
die Korrektion der bekannten systematischen Messabweichung:

\[
y = \bar x - e_{s,b}
\]

{[}@DIN1319-3, Gleichung (7), S. 6, Notation angepasst{]}

Das \textbf{vollständige Messergebnis} \(Y\) besteht aus dem
berichtigten Messergebnis und einer Angabe über die Unsicherheit der
Messung z. B. in der Form:

\[
Y = y \pm u(y)
\]

{[}@DIN1319-3, Gleichung (9), S. 6{]}

\emph{Zusätzlich} zum vollständigen Messergebnis kann ein
Vertrauensbereich (auch: Vertrauensintervall oder Konfidenzintervall)
angegeben werden. Der Berechnung von Konfidenzintervallen haben wir im
Kapitel Chapter~\ref{sec-normalverteilung} vorgegriffen.

\[
y - t \cdot u(y) \le Y \le y + t \cdot u(y)
\]

{[}@DIN1319-3, Gleichung (14), S. 7{]}

Die Wahl eines Vertrauensbereichs ist Ermessenssache. Die DIN 1319
formuliert dazu: ``Es ist üblich, das Vertrauensniveau (\(1 - \alpha\))
in Prozent anzugeben, wobei meist \(\alpha = 0,05\) (Vertrauensniveau:
95 \%) benutzt wird.'' {[}@DIN1319-1, S. 17{]} ``Dieses Vertrauensniveau
von 95 \% sollte verwendet werden, aber kein höheres.'' {[}@DIN1319-3,
S. 7{]}

So ergibt sich beispielsweise:

\[
y - t_{\alpha / 2} \cdot \frac{s_{n-1}}{\sqrt{n}} \le Y \le y + t_{\alpha / 2} \cdot \frac{s_{n-1}}{\sqrt{n}}
\]

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-notation1} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-notation1}: Notation in der DIN 1319}\vspace{3mm}

In der DIN wird der arithmetische Mittelwert einer Messreihe statt mit
\(\bar{x}\) mit \(\bar{v}\) notiert.

\end{minipage}%
\end{tcolorbox}

\subsection{Übersicht}\label{uxfcbersicht-3}

In der DIN 1319 werden eine Reihe weiterer Begriffe definiert, die im
folgenden Kasten zusammen mit den wichtigsten Grundbegriffen
zusammengestellt wurden.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-DIN1319}: Grundbegriffe nach DIN 1319}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-DIN1319} 

\textbf{Messabweichung}: ``Abweichung eines aus Messungen gewonnenen und
der Meßgröße {[}\ldots{]} zugeordneten Wertes vom wahren Wert
{[}\ldots{]}. Ist \(m\) der der Meßgröße zugeordnete Wert und \(x_w\)
der wahre Wert, so ist die Meßabweichung des zugeordneten Wertes
\(m - x_w\) {[}\ldots{]}.'' {[}@DIN1319-1, S. 12{]}

\begin{itemize}
\tightlist
\item
  Die Messabweichung des \textbf{unberichtigten Messergebnisses} setzt
  sich additiv aus der zufälligen Messabweichung \(e_r\) und der
  systematischen Messabweichung \(e_s\) zusammen.
\item
  Die systematische Messabweichung \(e_s\) setzt sich aus einem
  bekannten \(e_{s,b}\) und einem unbekannten Anteil \(e_{s,u}\)
  zusammen.
\item
  Die systematische Messabweichung ist die Differenz aus Erwartungswert
  \(\mu\) und wahrem Wert \(x_w\). \(e_s = \mu - x_w\)
\item
  Die bekannte, systematische Messabweichung \(e_{s,b}\) wird mit
  entgegengesetzten Vorzeichen \(- e_{s,b}\) \emph{Korrektion} genannt.
\end{itemize}

Das \textbf{Messergebnis} \(\bar{x}_E\) ist das um die bekannte,
systematische Messabweichung \(e_{s,b}\) berichtigte arithmetische
Mittel einer Messreihe \(\bar{x}\), das als Schätzer des Erwartungswerts
\(\mu\) verwendet wird.\\
\(\bar{x}_E = \bar{x} - e_{s,b}\)

{[}@DIN1319-1, S. 11-13{]}

\textbf{Messunsicherheit} \(u\) oder \(u(y)\): ``Kennwert, der aus
Messungen {[}\ldots{]} gewonnen wird und zusammen mit dem Meßergebnis
{[}\ldots{]} zur Kennzeichnung eines Wertebereichs für den wahren Wert
der Meßgröße {[}\ldots{]} dient.'' {[}@DIN1319-1, S. 14{]}

\begin{itemize}
\item
  \textbf{Standardmessunsicherheit} oder kurz Standardunsicherheit wird
  verwendet, wenn die Messunsicherheit durch eine Standardabweichung
  ausgedrückt wird. {[}@DIN1319-3, S. 3{]}
\item
  \textbf{erweiterte Messunsicherheit} \(U(y) = k \cdot u(y)\):
  Wertebereich, der den wahren Wert der Messgröße wahrscheinlich
  enthält. Der Erweiterungsfaktor \(k\) sollte zwischen 2 und 3
  festgelegt werden, vorzugsweise wird \(k = 2\) verwendet. Der
  Erweiterungsfaktor \(k\) ist mitzuteilen, damit die
  Standardmessunsicherheit \(u(y) = U(y) / k\) ermittelt werden kann.
  {[}@DIN1319-3, S. 7{]}\\
  \emph{Hinweis: Die erweiterte Messunsicherheit unterscheidet sich vom
  Konfidenzintervall dadurch, dass keine Normalverteilung unterstellt
  wird - es ist schlicht ein Faktor, `um auf Nummer sicher zu gehen',
  dass der wahre Wert vom angegebenen Bereich eingeschlossen wird}.
\end{itemize}

Das \textbf{vollständige Messergebnis} ist das Messergebnis mit
quantitativen Angaben zur Messunsicherheit \(u\).
\(x = \bar{x}_E \pm u\). {[}@DIN1319-1, S. 16{]}

\begin{itemize}
\item
  Der \textbf{Vertrauensbereich}
  \(\bar x - t \cdot u(y) \le Y \le y + t \cdot u(y)\) kann zusätzlich
  zum vollständigen Messergebnis angegeben werden.

  \begin{itemize}
  \tightlist
  \item
    Ist die systematische Messabweichung bekannt und korrigiert worden,
    dann liegt der wahre Wert der Messgröße \(Y\) innerhalb des
    Vertrauensbereichs.
  \item
    Wenn die systematische Messabweichung nicht bekannt ist, liegt der
    Erwartungswert \(\mu\) der Verteilung im Vertrauensbereich.
    {[}@DIN1319-3, S. 7{]}
  \end{itemize}

  \emph{Hinweis: In der DIN wird der arithmetische Mittelwert einer
  Messreihe statt mit \(\bar{x}\) mit \(\bar{v}\) geschrieben}.
\end{itemize}

\end{tcolorbox}

\section{Absolute und relative
Fehler}\label{absolute-und-relative-fehler}

In der Fehlerrechnung werden absolute und relative \emph{Fehler}
unterschieden. Hier sollte besser von absoluter und relativer
Messunsicherheit gesprochen werden.

\begin{itemize}
\item
  Die \textbf{absolute Messunsicherheit} \(u\) wird in der Einheit der
  gemessenen Größe angegebenen: \(u(m) = 0,2 ~ kg\). Das vollständige
  Messergebnis lautet: \(m = 5,0 \pm 0,2 ~ kg\) oder
  \(m = 5,0 ~ kg \pm 0,2 ~ kg\).
\item
  Die \textbf{relative Messunsicherheit}
  \(u_{rel}(m) = \frac{u(m)}{ | m | }\) wird entweder als Produkt in der
  Form \(m \cdot (1 \pm \frac{u(x)}{| m |})\) angegeben. Bspw.:

  \(m = 5,0 ~ kg \cdot (1 \pm \frac{0,2 ~ kg}{5,0 ~ kg}) = 5,0 ~ kg \cdot (1 \pm 0,04)\)

  Alternativ wird die relative Messunsicherheit in Prozent
  \(u_{rel}(m) = \frac{u(m)}{| m |} \cdot 100 ~ \%\) angegeben. Bspw.:

  \(m = 5,0 ~ kg \pm 4 ~ \%\).
\end{itemize}

{[}@DIN1319-1, S. 9-10, 16; @DIN1319-3, S. 10{]}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-warning-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame, coltitle=black, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Warning \ref*{wrn-notation}: (Alternative) Notationen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutwrn{wrn-notation} 

In der DIN 1319 werden Messabweichungen mit \(e\), die Messunsicherheit
mit \(u\) notiert. In der Literatur zur Fehlerrechnung wird zumeist der
Begriff des (Mess-)Fehlers verwendet. Die Notation ist allerdings
uneinheitlich.

\begin{itemize}
\item
  Der absolute Fehler wird häufig mit \(\epsilon x\) (epsilon x)
  notiert. Üblich ist aber auch die Notation mit \(\Delta x\) (Delta),
  (beispielsweise {[}@HS-Aalen-2016; @Dinter-2011; @SchrüferEtAl2022{]}.
  \(\Delta\) wird aber ebenfalls für den Größtfehler verwendet.
\item
  Der relative Fehler wird auch mit \(\delta x\) (delta x) notiert,
  bspw: \(\delta x = 4 \%\).
\end{itemize}

\end{tcolorbox}

\section{Größtfehler}\label{gruxf6uxdftfehler}

Systematische Messabweichungen \(e(x)_{s}\) bewirken eine einseitige
Verzerrung des Messergebnisses, sodass der Messwert immer zu hoch oder
zu niedrig ausfällt. Zufällige Messabweichungen \(e(x)_{r}\) führen
unkontrolliert mal zum Über-, mal zum Unterschätzen des Messwerts.

In der Regel werden sich die verschiedenen Messabweichungen teilweise
ausgleichen. Als \textbf{Größtfehler} wird der ungünstigste Fall
bezeichnet, bei dem sich alle Messabweichungen jeweils um ihren
maximalen (oder minimalen) Wert gegenseitig verstärken, sodass der
Messwert die maximal mögliche Abweichung vom (unbekannten) tatsächlichen
Wert aufweist. Der \textbf{Größtfehler} wird als \(\Delta x\) (Delta x)
notiert.

Der Größtfehler einer Messreihe für eine Größe wird ermittelt, indem man
die Beträge der einzelnen Messabweichungen addiert.

\[
\Delta x = | e(x)_{s} | + | e(x)_{r} |
\]

Da Messungen bei groben Fehlern als ungültig anzusehen sind, entfällt
der Anteil grober Fehler \(| e(x)_{grob} |\).

(@EdenGebhard-2024, S. 35-36)

Werden mehrere Größen betrachtet, addieren sich die Größtfehler der
beteiligten Größen zum Größtfehler der Ergebnisgröße. So gilt für eine
Größe \(Y = f(x_1, x_2)\): \[
\Delta y = \Delta x_1 + \Delta x_2
\]

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-welcherfehler}: Größtfehler}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-welcherfehler} 

Der Größtfehler ist keine genormte Angabe nach DIN 1319, sondern eine
vereinfachte Form der Fehlerabschätzung und überschätzt die
wahrscheinliche Messunsicherheit.

``Für viele Betrachtungen, speziell in den Grundlagenpraktika der ersten
Semester in technischen, naturwissenschaftlichen und ingenieurmäßigen
Studiengängen, reicht es aus, den maximalen Fehler (\emph{absoluter
Größtfehler}) zu bestimmen.'' (@EdenGebhard-2024, S. 35)

\end{tcolorbox}

\section{Signifikante Stellen}\label{signifikante-stellen}

Bei der Angabe des vollständigen Messergebnisses ist die Anzahl der
signifikanten oder zuverlässig bekannten Stellen zu beachten.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-signif}: signifikante Stellen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-signif} 

``Jede zuverlässig bekannte Stelle mit Ausnahme der Nullen, die die
Position des Dezimalkommas angeben, wird signifikante Stelle genannt.''
{[}@EdenGebhard-2024, S. 24{]}

``Gerundete numerische Unsicherheitwerte sind \textbf{mit zwei (oder bei
Bedarf mit drei) signifikanten Ziffern} anzugeben. \textbf{Sie sind
aufzurunden}. Das Meßergebnis ist an derselben Stelle wie die zugehörige
Unsicherheit zu runden, z.B. \(y = 245,5716 ~ mm\) auf
\(y = 245,57 ~ mm\), wenn \(u(y) = 0,4528 ~ mm\) auf
\(u(y) = 0,46 ~ mm\) aufgerundet wird.'' {[}@DIN1319-3, S. 6, eigene
Hervorhebung{]}

\end{tcolorbox}

Beispielsweise liegen die im vorherigen Kapitel verwendeten
Abstandsmessungen im Format \(153,29\) vor, die Messwerte weisen also 5
signifikante Stellen auf. Für den arithmetischen Mittelwert einer
Messreihe \(153,008889\) gelten deshalb ebenfalls 5 signifikante
Stellen. Es wird an der ersten nicht mehr signifikanten Stelle gerundet,
sodass der arithmetische Mittelwert mit \(153,01\) angegeben wird.

Die Anzahl signifikanter Stellen ist allerdings nicht immer zuverlässig
zu bestimmen. Es gilt:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Alle Ziffern ungleich Null sind immer signifikant.
\item
  Führende Nullen sind niemals signifikante Stellen. Beispielsweise hat
  0012 km 2 signifikante Stellen. 0,001 mm hat eine signifikante Stelle.
\item
  Nullen am Ende einer Zahl sind signifikant, wenn sie sich rechts vom
  Dezimaltrennzeichen befinden, bspw: 12,100 km hat 5 signifikante
  Stellen.
\item
  Nullen, die sich am Ende einer Zahl ohne Komma befinden, können
  signifikant sein. 1200 m kann zwei oder vier signifikante Stellen
  haben.
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{signifikante Stellen und wissenschaftliches Runden}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Angaben zur Messunsicherheit werden zwar aufgerundet. Trotzdem an dieser
Stelle: Kennen Sie den Unterschied zwischen kaufmännischem und
wissenschaftlichem Runden?

\url{https://www.youtube.com/watch?v=s0gPyypiGOs}

Runden und signifikante Stellen (Vorkurs Mathematik) von Edmund Weitz
ist abrufbar auf
\href{https://www.youtube.com/watch?v=q2iZDtotiM0}{YouTube}. 2019

Python rundet wissenschaftlich:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{round}\NormalTok{(}\FloatTok{2.5}\NormalTok{), }\BuiltInTok{round}\NormalTok{(}\FloatTok{3.5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2 4
\end{verbatim}

\end{tcolorbox}

\section{Methoden der Fehlerrechnung}\label{methoden-der-fehlerrechnung}

Das Ziel der Fehlerrechnung ist es, Unsicherheitsintervalle für die
gemessene Größe zu ermitteln. Dafür stehen verschiedene Methoden zur
Verfügung:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Fehlerabschätzung,
\item
  Fehlerstatistik und
\item
  Fehlerfortpflanzung.
\end{enumerate}

Bei der Auswahl der Methode besteht ein Ermessensspielraum.
(@Hempel-2016, S. 2) Für Gebrauchsmessungen reicht es aus, die
Unsicherheit im Prozentbereich anzugeben. Im Eichwesen oder beim
Vergleich mit einem \href{https://de.wikipedia.org/wiki/Normal}{Normal}
werden genauere Angaben benötigt. {[}@SchrüferEtAl2022, S. 33{]}

Die Auswahl der geeigneten Methode hängt auch von den zur Verfügung
stehenden Informationen ab. Beispielsweise hängt die im vorherigen
Kapitel ermittelte Federkonstante von drei Größen ab:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  der Masse \(m\), die mit einer Küchenwaage ermittelt wurde, deren
  Ablesegenauigkeit mit \(e_r(m) = 0,5 g = 0,0005 ~ kg\) geschätzt wird.
\item
  dem Abstand zum Gewicht bzw. nach der Aufbereitung der Daten der
  Ausdehnung der Feder \(\Delta x\), die mit einem elektronischen
  Abstandssensor und einem Arduino ermittelt wurden (Ultrasonic Ranging
  Module HC - SR04).

  \begin{itemize}
  \tightlist
  \item
    Die Ablesegenauigkeit des Messsystems beträgt eine Einheit der
    Messauflösung, also \(e_{r} = 0,01 ~ cm = 0,0001 ~ m\).
  \item
    Die Messabweichung des Messsystems beträgt laut Datenblatt bis zu 3
    mm, die symmetrisch zu verstehen ist, also
    \(e_{r} = 3 ~ mm = 0,003 ~ m\).
  \item
    Die zufällige Komponente der Messabweichung beträgt also
    \(e_r(x) = 0,0001 ~ m + 0,003 ~ m = 0,0031 ~ m\)
  \end{itemize}
\item
  der statistischen Schätzung der Federkonstante
  \(k = \frac{m \cdot g}{\Delta x} = 33,019 \pm 0,378\) bzw. im
  festgelegten Vertrauensintervall
  \(k_{95\%} = 32,269 ≤ 33,019 ≤ 33,769\).
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-formelzeichen} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-formelzeichen}: Formelzeichen und Einheiten}\vspace{3mm}

Im Folgenden werden identische Zeichen für Sekunde und Strecke \(s\),
Masse und Meter \(m\), Gramm und die Konstante \(g\) sowie \(\Delta\)
für die Veränderung einer Größe und den Größtfehler verwendet. Die
Formeln sollten also mit großer Aufmerksamkeit gelesen werden.

\end{minipage}%
\end{tcolorbox}

\subsection{1. Fehlerabschätzung}\label{fehlerabschuxe4tzung}

Die Fehlerabschätzung wird verwendet, wenn

\begin{itemize}
\tightlist
\item
  \textbf{eine Größe}
\item
  \textbf{nur einmal}
\end{itemize}

gemessen wird.

Da der wahre Wert einer Messgröße unbekannt ist, bezweckt die
Fehlerabschätzung, die maximal mögliche Abweichung des Messwerts vom
tatsächlichen Wert, also den \textbf{Größtfehler}, zu bestimmen. Bei
einer einmaligen Messung gibt es keine statistische Komponente. In die
Fehlerabschätzung eines einzelnen Messwerts gehen deshalb ein:

\begin{itemize}
\tightlist
\item
  die Garantiefehlergrenze des Messgerätes, die vom Hersteller auf dem
  Gerät oder in der Bedienungsanleitung angegeben ist (siehe Beispiel),
  also die bekannte systematische Messabweichung \(e_{s,b}\), und
\item
  ein abgeschätzter Anteil, der sich nach den konkreten Bedingungen des
  Experiments, etwa der Skalenteilung des Messgerätes oder den
  Ablesebedingungen richtet. Dieser Anteil kann also aus einem
  systematischen Anteil (bspw. eine analoge Skala konnte nur aus einem
  Winkel abgelesen werden) und einem zufälligen Anteil (bspw.
  Ablesegenauigkeit des Messgeräts) bestehen.
\end{itemize}

Der Größtfehler \(\Delta x\) ergibt sich aus der Addition der Beträge
der bekannten systematischen Messabweichung und der geschätzten
zufälligen Messabweichung: \(\Delta x = |e(x)_{s,b}| + |e(x)_{r}|\).

(@Hempel-2016, S. 3)

\subsubsection{Aufgabe
Temperaturmessung}\label{aufgabe-temperaturmessung}

Mit einem digitalen Thermometer und einem thermoelektrischen Element vom
Typ K wurde die Temperatur \(T = 112,1 ~ °C\) gemessen. Welche
systematischen und zufälligen Messabweichungen sind bekannt und können
angegeben werden (siehe Beispiel)?

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-thermometer}: Garantiefehlergrenze Thermometer}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-thermometer} 

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{skript/00-bilder/thermometer.jpg}}

}

\caption{Thermometer}

\end{figure}%

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{skript/00-bilder/thermometerspecifications.jpg}}

}

\caption{Spezifikationen}

\end{figure}%

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-skalengenauigkeit}: Halber oder ganzer Skalenstrich?}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-skalengenauigkeit} 

Messgeräte mit digitaler Anzeige machen es leicht: Die Ablesegenauigkeit
beträgt eine Skaleneinheit. Bei Messgeräten mit analoger Anzeige ist es
Ermessenssache, welche Messgenauigkeit Sie angeben können bzw. möchten.

Sind Sie sich absolut sicher, dass Sie zwischen ``genau auf dem Strich''
und ``zwischen zwei Strichen'' unterscheiden können, beträgt Ihr
Ablesefehler einen halben Skalenstrich. Sind Sie sich nicht sicher,
beträgt Ihr Ablesefehler einen ganzen Skalenstrich.

(\href{https://www.physik.uni-jena.de/pafmedia/9072/fehlerrechnungleichtgemachtpdf.pdf}{Fehlerrechnung
leicht gemacht, FSU Jena})

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-thermometer}: Musterlösung Temperaturmessung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-thermometer} 

\textbf{systematische Messabweichung}

Die absolute Messabweichung beträgt \(u(T) = 0,3 ~ °C\). Die relative
Messabweichung beträgt \(0,05 ~ \%\). Das bedeutet:

\(\frac{u(T)}{112,1 °C} \cdot 100 ~ \% = 0,05 ~ \%\)

\(\frac{u(T)}{112,1 °C} \cdot 100 = 0,05\)

\(u(T) = 0,05 \cdot \frac{112,1 °C}{100}\)

\(u(T) = 0,05605 °C\)

Die bekannte systematische Messabweichung beträgt also:

\(e(T)_{s,b} = 0,3 ~ °C+ 0,05605 ~ °C = 0,35605 ~ °C\)

\textbf{zufällige Messabweichung}

Die zufällige Messabweichung beträgt eine Skaleneinheit, also:

\(e(T)_{r} = 0,1 ~ °C\)

\textbf{Größtfehler}

Der Größtfehler beträgt:

\(\Delta T = |e(T)_{s,b}| + |e(T)_{r}|\)

Die Messunsicherheit ist auf zwei Stellen aufzurunden:

\(\Delta T = |0,35605 °C| + |0,1 ~ °C| = 0,45605 ~ °C \approx 0,46 °C\)

Das vollständige Messergebnis lautet also \(T = 112,1 \pm 0,46 ~ °C\).

\end{tcolorbox}

\subsubsection{Beispiel Messbedingungen}\label{beispiel-messbedingungen}

Was ist mit den konkreten Bedingungen eines Messvorgangs gemeint? Das
soll mit zwei einfachen Messvorgängen demonstriert werden.

\textbf{Hier können Sie mitmachen!}

Sie benötigen:

\begin{itemize}
\tightlist
\item
  ein geeignetes Messinstrument, z. B. ein Lineal, und
\item
  eine Münze (idealerweise 1-Euro-Münze).
\end{itemize}

Im ersten Messvorgang soll der Durchmesser der 1-Euro-Münze bestimmt
werden.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-münze}: Erster Messvorgang Münze}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-münze} 

Die Messung wird mit einem
\href{https://de.wikipedia.org/wiki/Nonius}{Messschieber mit Nonius}
0,05 mm nach DIN 862 durchgeführt. Die DIN 862 normiert symmetrische
Fehlergrenzen von Messschiebern. Die Fehlergrenze ist abhängig von der
Skalengenauigkeit des Messschiebers sowie von der gemessenen Länge und
ist aus einer Tabelle abzulesen. (DIN 862 wurde 2011 durch DIN EN ISO
13385-1 ersetzt, in der der Begriff der Abweichung verwendet wird. Die
DIN 862 ist aber auf dem Messschieber aufgedruckt.)

Messwert: \(x = 23,25 ~ mm\)

\begin{itemize}
\tightlist
\item
  Die Skaleneinteilung ist 0,05 \textasciitilde{} mm, die zufällige
  Ableseabweichung \(e_r\) beträgt also \(\pm 0,025 mm\).
\item
  Die DIN 862 normiert Fehlergrenzen, die abhängig von der gemessenen
  Länge zunehmen, mindestens aber 50 \(\mu m\) oder 0,05 mm betragen.
  Für den Messwert 23,25 mm gilt somit als bekannte systematische
  Messabweichung \(e_{s,b} = \pm 0,05 ~ mm\).
\end{itemize}

Aus der Summe der Beträge ergibt sich der Größtfehler:
\(\Delta x = |0,05| ~ mm + |0,025| ~ mm = 0,075 ~ mm\).

Das vollständige Messergebnis, bestehend aus dem Messwert und der
Messunsicherheit lautet also: \(23,25 ± 0,075 ~ mm\). Der relative
Größtfehler beträgt: \(23,25 ~ mm ± 0,32\%\).

\end{tcolorbox}

Im zweiten Messvorgang soll die Länge des Daumens bestimmt werden.
(\href{https://de.wikipedia.org/wiki/Daumen}{Der Daumen besteht
anatomisch aus nur 2 Fingergliedknochen})

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-daumen}: Zweiter Messvorgang Daumen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-daumen} 

Die Messung wird erneut mit dem Messschieber durchgeführt.

Messwert: \(x = 64,70 ~ mm\)

\begin{itemize}
\tightlist
\item
  Die Skaleneinteilung ist 0,05 mm, die zufällige Ableseabweichung
  beträgt also \(\pm 0,025 ~ mm\).
\item
  Die von der DIN 862 für gemessene Längen zwischen 50 und 300 mm
  normierte Fehlergrenze beträgt 50 \(\mu m\) oder 0,05 mm. Für den
  Messwert 64,7 mm gilt somit die Fehlergrenze \(\pm  0,05 ~ mm\).
\item
  zusätzlich wird eine symmetrische Messabweichung von 3 mm
  veranschlagt, da

  \begin{itemize}
  \tightlist
  \item
    das Messgerät nicht gerade angesetzt,
  \item
    die Daumenwurzel nicht exakt lokalisiert und
  \item
    die elastische Fingerkuppe nicht fixiert werden konnte.
  \end{itemize}
\end{itemize}

Aus der Summe der Beträge ergibt sich der Größtfehler
\(\Delta x = |0,025| ~ mm + |0,05| ~ mm + |3| ~ mm = 3,075 ~ mm \approx 3,08 ~ mm\).

Das Messergebnis, bestehend aus dem Messwert und dem Fehlerintervall
lautet also: \(64,70 ± 3,08 ~ mm\). Der relative Größtfehler beträgt:
\(64,70 ~ mm ± 4,76 \%\).

\end{tcolorbox}

\subsection{2. Fehlerstatistik}\label{fehlerstatistik}

Die Fehlerstatistik wird verwendet, wenn

\begin{itemize}
\tightlist
\item
  \textbf{eine Größe}
\item
  \textbf{mehrfach}
\end{itemize}

gemessen wird.

Die Fehlerstatistik ist nur dann als zuverlässig anzusehen, wenn die
Messabweichung zufällig ist, die Messwerte also betragsmäßig und mit
wechselndem Vorzeichen streuen. Dann ist die Messabweichung in der
ermittelten Standardabweichung enthalten. Liegt jedoch eine bekannte,
systematische Messabweichung vor, muss das Messergebnis entsprechend
korrigiert werden \(\bar x_E = \bar x - e_{s,b}\).

Der Fehlerstatistik haben wir in vorausgehenden Kapiteln mit der
statistischen Beschreibung der empirischen Streuung des Mittelwerts
vorgegriffen. Zur Wiederholung:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Legen Sie ein Signifikanzniveau \(\alpha\) bzw. ein zweiseitiges
  Konfidenzniveau \(1 - \frac{\alpha}{2}\) fest.
\item
  Bestimmen Sie den Stichprobenmittelwert \(\bar{x}\).
\item
  Bestimmen Sie die Stichprobenstandardabweichung \(s\), die
  Stichprobengröße \(N\) und den empirischen Standardfehler
  \(\frac{s_{n-1}}{\sqrt{N}}\).
\item
  Bestimmen Sie die Werte der Normal- bzw. der t-Verteilung für das
  gewählte Konfidenzniveau - für einen zweiseitigen Hypothesentest
  \(\frac{\alpha}{2}\) und \(1 - \frac{\alpha}{2}\)
\item
  Berechnen Sie das Konfidenzintervall
  \(\bar{x} \pm t_{\alpha / 2} ~ \frac{s_{n-1}}{\sqrt{n}}\).
\end{enumerate}

Dieses Konfidenzintervall sagt für eine gewählte Wahrscheinlichkeit aus,
in welchem Bereich der Mittelwert einer erneut durchgeführten Messreihe
oder, wenn die unbekannte systematische Messabweichung Null (oder
vernachlässigbar) ist, der \emph{wahre Wert} liegen wird.\\
Dagegen gibt die Standardabweichung \(s\) Auskunft darüber, in welchem
Bereich ein einzelner Messwert liegen wird. Die Sicherheit dieser
Aussage kann durch Ausweitung des Konfidenzintervalls erhöht werden
(bspw. \(2 \cdot s\)).

{[}@Hempel-2016, S. 3-7{]}

Im folgenden Beispiel wird das Vorgehen gezeigt. Dabei wird auch die
Pandas-Methode \texttt{.sem()} zur einfachen Berechnung des
Standardfehlers vorgestellt.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-fehlerstatistik}: Fehlerstatistik}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-fehlerstatistik} 

Aus dem im vorherigen Kapitel behandelten Experiment wird die Messreihe
für das Gewicht 503g ausgewählt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/hooke\_data.csv"}
\NormalTok{hooke }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ dateipfad, sep }\OperatorTok{=} \StringTok{\textquotesingle{};\textquotesingle{}}\NormalTok{)}
\NormalTok{hooke.drop(index }\OperatorTok{=} \DecValTok{113}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{) }\CommentTok{\# Fehlwert, siehe vorheriges Kapitel}

\NormalTok{hooke\_503g }\OperatorTok{=}\NormalTok{ hooke.loc[hooke[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{] }\OperatorTok{==} \DecValTok{503}\NormalTok{, :]}
\BuiltInTok{print}\NormalTok{(hooke\_503g.head(), hooke\_503g.describe(), sep }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
    no  mass  distance
40  40   503    158.43
41  41   503    158.43
42  42   503    158.60
43  43   503    158.76
44  44   503    159.05

             no   mass    distance
count  10.00000   10.0   10.000000
mean   44.50000  503.0  159.314000
std     3.02765    0.0    0.781099
min    40.00000  503.0  158.430000
25%    42.25000  503.0  158.640000
50%    44.50000  503.0  159.220000
75%    46.75000  503.0  159.965000
max    49.00000  503.0  160.610000
\end{verbatim}

Betrachten wir für diese Messreihe noch einmal das arithmetische Mittel
(das unbereinigte Messergebnis) und den Standardfehler des Mittelwerts
(das statistische Streuungsmaß des Mittelwerts). Die Methode
\texttt{.sem()} berechnet den empirischen Standardfehler des Mittelwerts
(standardmäßig ist der Parameter \texttt{ddof\ =\ 1} gesetzt.)

Ausgabe auf 3 Dezimalstellen genau.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Gewicht in Gramm: }\SpecialCharTok{\{}\NormalTok{hooke\_503g[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{unique()}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Mittelwert der Messwerte: }\SpecialCharTok{\{}\NormalTok{hooke\_503g[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{mean()}\SpecialCharTok{:.3f\}}\SpecialStringTok{ cm"}\NormalTok{,}
      \SpecialStringTok{f"empirischer Standardfehler: }\SpecialCharTok{\{}\NormalTok{hooke\_503g[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{sem()}\SpecialCharTok{:.3f\}}\SpecialStringTok{ cm"}\NormalTok{,}
\NormalTok{      sep }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Gewicht in Gramm: [503]
Mittelwert der Messwerte: 159.314 cm
empirischer Standardfehler: 0.247 cm
\end{verbatim}

Die Messunsicherheit wird auf 2 Dezimalstellen genau aufgerundet. Dafür
kann die NumPy-Funktion \texttt{np.ceil()} verwendet werden. Diese
rundet allerdings zur nächsten Ganzzahl, ein Parameter, um auf eine
bestimmte Dezimalstelle zu runden, ist nicht verfügbar. Deshalb muss die
Dezimalstelle um die gewünschte Anzahl Stellen durch Multiplikation mit
der entsprechenden Zehnerpotenz verschoben werden. Für 2 Dezimalstellen
entsprechend um \(10^2\): \texttt{np.ceil(wert\ *\ 100)\ /\ 100}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{wert }\OperatorTok{=}\NormalTok{ pd.Series([}\FloatTok{0.247}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(np.ceil(wert }\OperatorTok{*} \DecValTok{100}\NormalTok{) }\OperatorTok{/} \DecValTok{100}\NormalTok{)}

\CommentTok{\# mit Pandas{-}Methoden}
\BuiltInTok{print}\NormalTok{(wert.mul(}\DecValTok{100}\NormalTok{).}\BuiltInTok{apply}\NormalTok{(np.ceil).div(}\DecValTok{100}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0    0.25
dtype: float64
0    0.25
dtype: float64
\end{verbatim}

Für die Verkettung mit weiteren Methoden in Pandas muss die Rückgabe der
Funktion, ein NumPy-Skalar oder -Array, wieder in eine
\texttt{pd.Series} umgewandelt werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Gewicht in Gramm: }\SpecialCharTok{\{}\NormalTok{hooke\_503g[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{unique()}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Mittelwert der Messwerte: }\SpecialCharTok{\{}\NormalTok{hooke\_503g[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{mean()}\SpecialCharTok{:.3f\}}\SpecialStringTok{ cm"}\NormalTok{,}
      \SpecialStringTok{f"empirischer Standardfehler: }\SpecialCharTok{\{}\NormalTok{ ( sem\_hooke\_503g}\OperatorTok{:=}\NormalTok{ pd.Series(hooke\_503g[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{].sem()).mul(}\DecValTok{100}\NormalTok{).}\BuiltInTok{apply}\NormalTok{(np.ceil).div(}\DecValTok{100}\NormalTok{) )}\SpecialCharTok{.}\NormalTok{item() }\SpecialCharTok{:.3f\}}\SpecialStringTok{ cm"}\NormalTok{,}
      \SpecialStringTok{f"vollständiges Messergebnis: }\SpecialCharTok{\{}\NormalTok{hooke\_503g[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{mean()}\SpecialCharTok{.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}\SpecialCharTok{:.2f\}}\SpecialStringTok{ cm ± }\SpecialCharTok{\{}\NormalTok{sem\_hooke\_503g}\SpecialCharTok{.}\NormalTok{item()}\SpecialCharTok{\}}\SpecialStringTok{ cm"}\NormalTok{,}
\NormalTok{      sep }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Gewicht in Gramm: [503]
Mittelwert der Messwerte: 159.314 cm
empirischer Standardfehler: 0.250 cm
vollständiges Messergebnis: 159.31 cm ± 0.25 cm
\end{verbatim}

Zusätzliche Angabe des 95-\%-Konfidenzintervalls.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# t{-}Wert bestimmen für Signifikanzniveau (alpha{-}Niveau) 1 {-} 95 \% wählen}
\NormalTok{alpha }\OperatorTok{=} \FloatTok{0.05}
\NormalTok{n }\OperatorTok{=}\NormalTok{ hooke\_503g.shape[}\DecValTok{0}\NormalTok{] }\CommentTok{\# Anzahl Zeilen}
\NormalTok{t\_wert }\OperatorTok{=}\NormalTok{ scipy.stats.t.ppf(q }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ alpha}\OperatorTok{/}\DecValTok{2}\NormalTok{, df }\OperatorTok{=}\NormalTok{ n }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"95{-}\%{-}Konfidenzintervall : }\SpecialCharTok{\{}\NormalTok{hooke\_503g[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{mean()}\SpecialCharTok{.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{ cm  ± }\SpecialCharTok{\{}\NormalTok{t\_wert}\SpecialCharTok{:.4f\}}\SpecialStringTok{ * }\SpecialCharTok{\{}\NormalTok{sem\_hooke\_503g}\SpecialCharTok{.}\NormalTok{item()}\SpecialCharTok{\}}\SpecialStringTok{ cm"}\NormalTok{,}
\SpecialStringTok{f"95{-}\%{-}Konfidenzintervall : }\SpecialCharTok{\{}\NormalTok{hooke\_503g[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{mean()}\SpecialCharTok{.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{ cm  ± }\SpecialCharTok{\{}\NormalTok{( t\_wert }\OperatorTok{*}\NormalTok{ sem\_hooke\_503g.item() )}\SpecialCharTok{.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}\SpecialCharTok{:.2f\}}\SpecialStringTok{ cm"}\NormalTok{,}
\SpecialStringTok{f"untere 95{-}\%{-}Intervallgrenze: }\SpecialCharTok{\{}\NormalTok{hooke\_503g[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{mean()}\SpecialCharTok{.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{) }\OperatorTok{{-}} \BuiltInTok{round}\NormalTok{(t\_wert }\OperatorTok{*}\NormalTok{ sem\_hooke\_503g.item(), }\DecValTok{2}\NormalTok{)}\SpecialCharTok{:.2f\}}\SpecialStringTok{ cm"}\NormalTok{,}
\SpecialStringTok{f"obere 95{-}\%{-}Intervallgrenze: }\SpecialCharTok{\{}\NormalTok{hooke\_503g[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{mean()}\SpecialCharTok{.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{) }\OperatorTok{+} \BuiltInTok{round}\NormalTok{(t\_wert }\OperatorTok{*}\NormalTok{ sem\_hooke\_503g.item(), }\DecValTok{2}\NormalTok{)}\SpecialCharTok{:.2f\}}\SpecialStringTok{ cm"}\NormalTok{,}
\NormalTok{sep }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
95-%-Konfidenzintervall : 159.31 cm  ± 2.2622 * 0.25 cm
95-%-Konfidenzintervall : 159.31 cm  ± 0.57 cm
untere 95-%-Intervallgrenze: 158.74 cm
obere 95-%-Intervallgrenze: 159.88 cm
\end{verbatim}

\end{tcolorbox}

\subsection{3. Fehlerfortpflanzung}\label{fehlerfortpflanzung}

Die Fehlerfortpflanzung wird verwendet, wenn

\begin{itemize}
\tightlist
\item
  \textbf{mehrere Eingangsgrößen},
\item
  \textbf{die durch eine Funktion die Ergebnisgröße ergeben},
\end{itemize}

gemessen werden.

Um die Messunsicherheit einer Größe \(Y\), die durch eine Funktion
\(y = f(x_1, x_2, ..., x_m)\) geschätzt wird, zu ermitteln, gibt es zwei
Verfahren:

\begin{itemize}
\tightlist
\item
  die \textbf{lineare Fehlerfortpflanzung} wird benutzt, wenn die
  Unsicherheit der beteiligten Größen durch Fehlerabschätzung einer
  \textbf{Einzelmessung} ermittelt wurden.
\item
  die \textbf{Gauß'sche Fehlerfortpflanzung} wird benutzt, wenn die
  Unsicherheit aus einer \textbf{Mehrfachmessung statistisch ermittelt}
  und mit Konfidenzintervallen angegeben werden.
\end{itemize}

{[}@Hempel-2016, S. 8-9{]}

\subsubsection{Lineare
Fehlerfortpflanzung}\label{lineare-fehlerfortpflanzung}

Die lineare Fehlerfortpflanzung betrachtet, wie sich die
\textbf{Größtfehler} mehrerer gemessener Größen im ungünstigsten Fall
auswirken. Es wird also der \textbf{Größtfehler} der gesuchten Größe
\(Y\) berechnet. (vgl. @DIN1319-3, S. 9)

Für eine Funktion mit zwei Eingangsgrößen \(f = f(x_1, x_2)\) wird der
Größtfehler \(\Delta f\) aus den Größtfehlern \(\Delta x_1\) und
\(\Delta x_2\) ermittelt.

\[
f + \Delta f = f(x_1 + \Delta x_1, x_2 + \Delta x_2)
\]

Unter der Voraussetzung gegenüber den Messwerten kleiner Fehler kann der
Fehler \(\Delta f\) durch die Beträge der partiellen Ableitung des
ersten Glieds der Taylorreihe berechnet werden (siehe Beispiel).

\[
f + \Delta f = f(x_1, x_2) + | \frac{\partial f(x_1, x_2)}{\partial x_1}  | \cdot \Delta x_1 + | \frac{\partial f(x_1, x_2)}{\partial x_2} | \cdot \Delta x_2
\]

Wann sind die Fehler gegenüber den Messwerten klein? Dafür gibt es
leider keine absolute Grenze. Es kommt hierbei darauf an, dass bei der
Taylor-Entwicklung die Polynome höheren Grades deutlich kleiner als der
lineare Term sind und somit vernachlässigt werden können, wenn das \(x\)
klein ist. Die Entscheidung hängt letztlich von der benötigten
Genauigkeit ab.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-taylorreihe}: Taylorreihe}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-taylorreihe} 

\url{https://www.youtube.com/watch?v=F2lKRaUguBM}

Die Taylorreihe - einfach erklärt von Denkbar ist abrufbar auf
\href{https://www.youtube.com/watch?v=F2lKRaUguBM}{YouTube}. 2015

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-partielleableitung}: Partielle Ableitung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-partielleableitung} 

Die partielle Ableitung ist die Ableitung einer Funktion mit mehreren
Variablen nach einer Variablen, wobei die übrigen Variablen als
Konstanten behandelt werden.

Für eine Funktion \(f(x, y) = 2x + y^2\) wird die partielle Ableitung
nach x so ausgedrückt:

\(\frac{\partial f(x, y)}{\partial x}\)

\begin{itemize}
\tightlist
\item
  Das Symbol ∂ ist die kursive Darstellung des kyrillischen
  Kleinbuchstaben д (d) und wird als ``del'' gelesen. Es zeigt an, das
  eine partielle Ableitung durchgeführt wird.
\item
  Im Zähler steht die Funktion, die abgeleitet werden soll. Im Nenner
  steht die Variable nach der abgeleitet wird. Der Term wird gelesen als
  ``del f von x und y nach del x''.
\end{itemize}

Die partielle Ableitung \(\frac{\partial f(x, y)}{\partial x} = 2\).
\(y^2\) wird als Konstante behandelt (z. B. \(5^2\) ) und ist abgeleitet
Null.

Die partielle Ableitung \(\frac{\partial f(x, y)}{\partial y} = 2y\).
\(2x\) wird als Konstante behandelt (z. B. \(2 \cdot 3\) ) und ist
abgeleitet Null.

\end{tcolorbox}

Der Größtfehler ergibt sich aus: \[
\Delta f = | \frac{\partial f(x_1, x_2)}{\partial x_1}  | \cdot \Delta x_1 + | \frac{\partial f(x_1, x_2)}{\partial x_2} | \cdot \Delta x_2
\]

{[}@Hempel-2016, S. 9-10{]}

Bzw. in Kurzschreibweise für \(i = N\) Eingangsgrößen: \[
\Delta f(x_i) = \pm \sum_{i=1}^{N} | \frac{\partial f}{\partial x_i} \cdot \Delta x_i |
\]

{[}nach @EdenGebhard-2024, S. 35, Notation angepasst{]}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-beispiellineareff}: Beispiel Federkonstante}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-beispiellineareff} 

Beispielhaft betrachten wir die erste Messung aus der Messreihe mit dem
Gewicht 503 Gramm.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hooke\_503g\_einzelwert }\OperatorTok{=}\NormalTok{ hooke\_503g.iloc[}\DecValTok{0}\NormalTok{, :].copy()}
\BuiltInTok{print}\NormalTok{(hooke\_503g\_einzelwert)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
no           40.00
mass        503.00
distance    158.43
Name: 40, dtype: float64
\end{verbatim}

Da mehrere Größen betrachtet werden, werden die Messwerte in eine
SI-Einheit umgerechnet. Als Nullpunkt wird die erste Messung der
Messreihe mit dem Gewicht 0 Gramm aufgefasst.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hooke\_503g\_einzelwert[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ hooke\_503g\_einzelwert[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{] }\OperatorTok{/} \DecValTok{1000}
\NormalTok{hooke\_503g\_einzelwert[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ hooke\_503g\_einzelwert[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{] }\OperatorTok{/} \DecValTok{100}

\NormalTok{nullpunkt }\OperatorTok{=}\NormalTok{ hooke[hooke[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{] }\OperatorTok{==} \DecValTok{0}\NormalTok{].loc[: , }\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{].head(n }\OperatorTok{=} \DecValTok{1}\NormalTok{) }\OperatorTok{/}\DecValTok{100}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Nullpunkt in Metern: }\SpecialCharTok{\{}\NormalTok{nullpunkt}\SpecialCharTok{.}\NormalTok{item()}\SpecialCharTok{:.3f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{hooke\_503g\_einzelwert[}\StringTok{\textquotesingle{}ausdehnung\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ (hooke\_503g\_einzelwert[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{].item() }\OperatorTok{{-}}\NormalTok{nullpunkt.item()) }\OperatorTok{*} \OperatorTok{{-}}\DecValTok{1}
\BuiltInTok{print}\NormalTok{(hooke\_503g\_einzelwert)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Nullpunkt in Metern: 1.733

no            40.0000
mass           0.5030
distance       1.5843
ausdehnung     0.1489
Name: 40, dtype: float64
\end{verbatim}

Für die Federkonstante gilt (die Abstandsänderung \(\Delta x\) wird mit
\(s\) notiert):

\[
k = \frac{m \cdot g}{\Delta{x}} = \frac{m \cdot g}{s}
\]

Einsetzen der Werte (\(s\) steht nun für Sekunde, \(m\) für Meter): \[
k = \frac{0,503 ~ kg \cdot 9,81 m}{0,1489 ~ m \cdot s^2} = \frac{0,503 \cdot 9,81}{0,1489} \frac{N}{{m}} = 33.139 \frac{N}{{m}}
\]

So gilt für den Größtfehler der Funktion: \[
\Delta k(m, s) = | \frac{\partial f(m, s)}{\partial m} | \cdot \Delta m + | \frac{\partial f(m, s)}{\partial s} | \cdot \Delta s
\]

Im ersten Schritt werden die partiellen Ableitungen der Funktion
\(k = \frac{m \cdot g}{s}\) gebildet. Die partielle Ableitung nach \(m\)
lautet mit Faktorregel: \[
\frac{\partial f(m, s)}{\partial m} = \frac{\partial}{\partial m} \frac{m \cdot g}{s} = \frac{\partial}{\partial m} m \cdot \frac{g}{s} = 1 \cdot \frac{g}{s} = \frac{g}{s}
\]

Die partielle Ableitung nach s lautet: \[
\frac{\partial f(m, s)}{\partial s} = \frac{\partial}{\partial s} \frac{m \cdot g}{s} = - \frac {m \cdot g}{s^{2}}
\]

Der Größtfehler ergibt sich also durch: \[
\Delta k = | \frac{g}{s} | \cdot \Delta m ~ + ~ | (-) \frac {m \cdot g}{s^{2}} | \cdot \Delta s
\]

Im zweiten Schritt wird der Größtfehler der beteiligten Größen
ermittelt.

\begin{itemize}
\tightlist
\item
  Die Masse \(m\) der verwendeten Gewichte wurde mit einer Küchenwaage
  ermittelt, deren Ableseabweichung auf
  \(e_r (m) = 0,5 g = 0,0005 ~ kg\) geschätzt wird. Eine systematische
  Messabweichung ist nicht bekannt.\\
  Der Größtfehler der Masse beträgt also \(\Delta m = 0,0005 ~ kg\).
\item
  Der Größtfehler der Abstandsmessung beträgt
  \(e_{r}(s) = 0,01 cm + 0,3 cm = 0,0031 m\).
\end{itemize}

Die Messwerte, die Konstante \(g\) und die Größtfehler werden
eingesetzt. \[
\Delta k = | \frac{9,81 m}{{s}^2 \cdot 0,1489 m} | \cdot 0,0005 ~ kg ~ + ~ | (-) \frac{0,503 ~ kg \cdot 9,81  m}{{s}^2 \cdot (0,1489 m)^2} | \cdot 0,0031 m
\]

Trennen von Werten und Einheiten: \[
\Delta k = | \frac{9,81 \cdot 0,0005}{ 0,1489 } \frac{m \cdot }{{s}^2 \cdot m} | ~ + | (-) \frac{0,503 \cdot 9,81 \cdot 0,0031}{0,02217121} \frac{kg \cdot m^2}{{s}^2 \cdot m^2} |
\]

Berechnen und Newton \(\frac{kg \cdot m}{s^2}\) einsetzen: \[
\Delta k = | 0,0329 \frac{N}{{m}} | ~ + | (-) 0,6899 \frac{N \cdot m}{{m^2}} |
\]

Meter im zweiten Term kürzen: \[
\Delta k = |0,0329 \frac{N}{{m}} | ~ + | (-) 0,6899 \frac{N}{{m}} |
\]

Die Messunsicherheit wird auf zwei Dezimalstellen aufgerundet. \[
\Delta k = 0,7228 \frac{N}{{m}} \approx 0,73 \frac{N}{{m}}
\]

Das vollständige Messergebnis lautet somit: \[
k = 33,14 \frac{N}{m}; \Delta k = 0,73 \frac{N}{{m}}
\]

\end{tcolorbox}

\subsubsection{Gauß'sche
Fehlerfortpflanzung}\label{gauuxdfsche-fehlerfortpflanzung}

Bei der Gauß'schen Fehlerfortpflanzung wird unterstellt, dass sich die
Messunsicherheiten der beteiligten Größen teilweise kompensieren können.
Dadurch wird eine realistischere Abschätzung der Messunsicherheit
erreicht.

Die Ermittlung der Messunsicherheit ist in DIN 1319-3 geregelt. Für eine
Funktion \(Y = f(x_1, x_2, ..., x_m)\) ermittelt sich die
Messunsicherheit aus der Messunsicherheit der beteiligten Größen. Dazu
werden die Varianzen der Mittelwerte verwendet (@DIN1319-3, Gleichung
(29), S. 11). \[
u^2(x_i) = s^2(\bar{x_i}) = s_i^2/n_i ~ ; ~ s_i^2 = \frac{1}{n_i - 1} \sum_{j = 1}^{n_i} (x_{ij - \bar{x_i}})^2
\]

\emph{Hinweis: In der Regel wird man die empirische Standardabweichung
\(s_{n-1}\) verwenden.}\\
\emph{Hinweis: In der DIN wird der arithmetische Mittelwert einer
Messreihe statt mit \(\bar{x}\) mit \(\bar{v}\) geschrieben}.

Die Messunsicherheit der beteiligten Größen wird also über den
Standardfehler des Mittelwerts der beteiligten Größen ermittelt: \[
u(x_i) = s_i/\sqrt{n_i}
\]

\emph{Hinweis: In der Regel wird man die empirische Standardabweichung
\(s_{n-1}\) verwenden.}

{[}@DIN1319-3, S. 11{]}

Die Unsicherheit der Funktion \(y = f(x_1, x_2, ..., x_m)\) berechnet
sich wie folgt (DIN 1319-3, Gleichung (43)):

\[
u(y) = \sqrt{\sum_{i = 1}^{m} (\frac{\partial f}{\partial x_i})^2 \cdot u^2(x_i)}
\]

Die quadrierten Terme können auch zusammengefasst werden:

\[
u(y) = \sqrt{\sum_{i = 1}^{m} \left(\frac{\partial f}{\partial x_i} \cdot u(x_i)\right)^2}
\]

Für eine Funktion mit zwei Eingangsgrößen \(y = f(x_1, x_2)\) berechnet
sich die Unsicherheit der Ergebnisgröße beispielsweise wie folgt:

\[
u(y) = \sqrt{ (\frac{\partial f}{\partial x_1} \cdot \sigma_{x_1})^2 + (\frac{\partial f}{\partial x_2} \cdot \sigma_{x_2})^2 }
\]

\emph{Hinweis: In der Regel wird man die empirische Standardabweichung
\(s_{n-1} / \sqrt{N}\) verwenden.}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-beispiel503g}: Beispiel Messreihe 503 Gramm}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-beispiel503g} 

Betrachten wir noch einmal die Messreihe für das Gewicht 503 Gramm. Es
soll das vereinbarte Konfidenzniveau \(95 ~ \%\) gelten.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Messdaten aus dem Kapitel hooke.qmd wiederherstellen}
\CommentTok{\#\# Datei einlesen und Fehler entfernen}
\NormalTok{dateipfad }\OperatorTok{=} \StringTok{"01{-}daten/hooke\_data.csv"}
\NormalTok{hooke }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ dateipfad, sep }\OperatorTok{=} \StringTok{\textquotesingle{};\textquotesingle{}}\NormalTok{)}
\NormalTok{hooke.drop(index }\OperatorTok{=} \DecValTok{113}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

\CommentTok{\#\# Abstandsmessung auf Nullpunkt normieren}
\NormalTok{nullpunkt }\OperatorTok{=}\NormalTok{ hooke[hooke[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{] }\OperatorTok{==} \DecValTok{0}\NormalTok{].loc[: , }\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{].mean()}
\NormalTok{hooke[}\StringTok{\textquotesingle{}ausdehnung\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{].sub(nullpunkt).mul(}\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}

\CommentTok{\# Messreihe 503 Gramm auswählen}
\NormalTok{hooke\_503g }\OperatorTok{=}\NormalTok{ hooke.loc[hooke[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{] }\OperatorTok{==} \DecValTok{503}\NormalTok{, :].copy()}

\CommentTok{\#\# Masse in kg, Abstand und Ausdehnung in m umrechnen}
\NormalTok{hooke\_503g[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ hooke\_503g[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{].div(}\DecValTok{1000}\NormalTok{)}
\NormalTok{hooke\_503g[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ hooke\_503g[}\StringTok{\textquotesingle{}distance\textquotesingle{}}\NormalTok{].div(}\DecValTok{100}\NormalTok{)}
\NormalTok{hooke\_503g[}\StringTok{\textquotesingle{}ausdehnung\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ hooke\_503g[}\StringTok{\textquotesingle{}ausdehnung\textquotesingle{}}\NormalTok{].div(}\DecValTok{100}\NormalTok{)}

\CommentTok{\# t{-}Wert bestimmen für Signifikanzniveau (alpha{-}Niveau) 1 {-} 95 \% wählen}
\NormalTok{alpha }\OperatorTok{=} \FloatTok{0.05}
\NormalTok{n\_ausdehnung }\OperatorTok{=}\NormalTok{ hooke\_503g.shape[}\DecValTok{0}\NormalTok{] }\CommentTok{\# Anzahl Zeilen}
\NormalTok{t\_wert\_ausdehnung }\OperatorTok{=}\NormalTok{ scipy.stats.t.ppf(q }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ alpha}\OperatorTok{/}\DecValTok{2}\NormalTok{, df }\OperatorTok{=}\NormalTok{ n\_ausdehnung }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}

\CommentTok{\# Ausgabe}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Gewicht in Kilogramm: }\SpecialCharTok{\{}\NormalTok{hooke\_503g[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{unique()}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Mittlere Ausdehnung: }\SpecialCharTok{\{}\NormalTok{hooke\_503g[}\StringTok{\textquotesingle{}ausdehnung\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{mean()}\SpecialCharTok{:.4f\}}\SpecialStringTok{ m"}\NormalTok{,}
      \SpecialStringTok{f"empirischer Standardfehler: }\SpecialCharTok{\{}\NormalTok{ (sem\_hooke\_503g}\OperatorTok{:=}\NormalTok{ pd.Series(hooke\_503g[}\StringTok{\textquotesingle{}ausdehnung\textquotesingle{}}\NormalTok{].sem()))}\SpecialCharTok{.}\NormalTok{item() }\SpecialCharTok{:.6f\}}\SpecialStringTok{ m"}\NormalTok{,}
      \SpecialStringTok{f"t{-}Wert der Ausdehnung: }\SpecialCharTok{\{}\NormalTok{t\_wert\_ausdehnung}\SpecialCharTok{:.4f\}}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"95{-}\%{-}Intervallgrenzen: }\SpecialCharTok{\{}\NormalTok{(hooke\_503g[}\StringTok{\textquotesingle{}ausdehnung\textquotesingle{}}\NormalTok{].mean() }\OperatorTok{{-}}\NormalTok{ t\_wert\_ausdehnung }\OperatorTok{*}\NormalTok{ sem\_hooke\_503g)}\SpecialCharTok{.}\NormalTok{item()}\SpecialCharTok{:.4f\}}\SpecialStringTok{ m ≤ }\SpecialCharTok{\{}\NormalTok{hooke\_503g[}\StringTok{\textquotesingle{}ausdehnung\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{mean()}\SpecialCharTok{:.4f\}}\SpecialStringTok{ m ≤ }\SpecialCharTok{\{}\NormalTok{(hooke\_503g[}\StringTok{\textquotesingle{}ausdehnung\textquotesingle{}}\NormalTok{].mean() }\OperatorTok{+}\NormalTok{ t\_wert\_ausdehnung }\OperatorTok{*}\NormalTok{ sem\_hooke\_503g)}\SpecialCharTok{.}\NormalTok{item()}\SpecialCharTok{:.4f\}}\SpecialStringTok{ m"}\NormalTok{,}
\NormalTok{      sep }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Gewicht in Kilogramm: [0.503]
Mittlere Ausdehnung: 0.1432 m
empirischer Standardfehler: 0.002470 m
t-Wert der Ausdehnung: 2.2622
95-%-Intervallgrenzen: 0.1376 m ≤ 0.1432 m ≤ 0.1488 m
\end{verbatim}

Für die Federkonstante gilt (die Abstandsänderung \(\Delta x\) wird mit
\(s\) notiert):\\
\[
k = \frac{m \cdot g}{\Delta{x}} = \frac{m \cdot g}{s}
\]

\[
k = \frac{0,503 ~ kg \cdot 9,81 m}{0,1432 ~ m \cdot s^2} = \frac{0,503 \cdot 9,81}{0,1432} \frac{N}{{m}} = 34,458\frac{N}{{m}}
\]

~

Um die Unsicherheit der Ergebnisgröße \(k\) nach der Gauß`schen
Fehlerfortpflanzung zu bestimmen, müsste die Masse des verwendeten
Gewichts ebenfalls durch eine Messreihe bestimmt worden sein. (Wie
Messreihen und Einzelmessungen kombiniert werden können, wird im
nächsten Abschnitt gezeigt.) Deshalb wird angenommen, dass mehrere
Messungen zur Ermittlung des Gewichts durchgeführt wurden. Die Messreihe
sowie ihr Mittelwert und Standardfehler könnten wie folgt aussehen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{messreihe\_503g }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{503}\NormalTok{ , }\DecValTok{503}\NormalTok{, }\DecValTok{504}\NormalTok{, }\DecValTok{502}\NormalTok{, }\DecValTok{503}\NormalTok{, }\DecValTok{502}\NormalTok{, }\DecValTok{503}\NormalTok{, }\DecValTok{504}\NormalTok{])}
\NormalTok{messreihe\_503g }\OperatorTok{/=} \DecValTok{1000}

\CommentTok{\# t{-}Wert bestimmen für Signifikanzniveau (alpha{-}Niveau) 1 {-} 95 \% wählen}
\NormalTok{alpha }\OperatorTok{=} \FloatTok{0.05}
\NormalTok{n\_masse }\OperatorTok{=}\NormalTok{ messreihe\_503g.shape[}\DecValTok{0}\NormalTok{] }\CommentTok{\# Anzahl Elemente}
\NormalTok{t\_wert\_masse }\OperatorTok{=}\NormalTok{ scipy.stats.t.ppf(q }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ alpha}\OperatorTok{/}\DecValTok{2}\NormalTok{, df }\OperatorTok{=}\NormalTok{ n\_masse }\OperatorTok{{-}} \DecValTok{1}\NormalTok{)}

\CommentTok{\# Ausgabe}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"arithmetisches Mittel der Masse: }\SpecialCharTok{\{}\NormalTok{messreihe\_503g}\SpecialCharTok{.}\NormalTok{mean()}\SpecialCharTok{\}}\SpecialStringTok{ kg"}\NormalTok{,}
      \SpecialStringTok{f"empirischer Standardfehler: }\SpecialCharTok{\{}\NormalTok{ (sem\_messreihe\_503g}\OperatorTok{:=}\NormalTok{ pd.Series(messreihe\_503g.sem()))}\SpecialCharTok{.}\NormalTok{item() }\SpecialCharTok{:.6f\}}\SpecialStringTok{ kg"}\NormalTok{,}
      \SpecialStringTok{f"t{-}Wert der Masse: }\SpecialCharTok{\{}\NormalTok{t\_wert\_masse}\SpecialCharTok{:.4f\}}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"95{-}\%{-}Intervallgrenzen: }\SpecialCharTok{\{}\NormalTok{(messreihe\_503g.mean() }\OperatorTok{{-}}\NormalTok{ t\_wert\_masse }\OperatorTok{*}\NormalTok{ sem\_messreihe\_503g)}\SpecialCharTok{.}\NormalTok{item()}\SpecialCharTok{:.4f\}}\SpecialStringTok{ kg {-} }\SpecialCharTok{\{}\NormalTok{(messreihe\_503g.mean() }\OperatorTok{+}\NormalTok{ t\_wert\_masse }\OperatorTok{*}\NormalTok{ sem\_messreihe\_503g)}\SpecialCharTok{.}\NormalTok{item()}\SpecialCharTok{:.4f\}}\SpecialStringTok{ kg"}\NormalTok{,}
\NormalTok{      sep }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
arithmetisches Mittel der Masse: 0.503 kg
empirischer Standardfehler: 0.000267 kg
t-Wert der Masse: 2.3646
95-%-Intervallgrenzen: 0.5024 kg - 0.5036 kg
\end{verbatim}

Die Gauß'sche Fehlerfortpflanzung wird ähnlich zur linearen
Fehlerfortpflanzung berechnet.

\[
u(k(m, s)) = \sqrt{ (\frac{\partial f(m, s)}{\partial m} \cdot \sigma_{m})^2 + (\frac{\partial f(m, s)}{\partial s} \cdot \sigma_{s})^2 }
\]

Die partiellen Ableitungen werden eingesetzt. \[
u(k(m, s)) = \sqrt{ ( \frac{g}{s} \cdot \sigma_{m})^2 + (- \frac {m \cdot g}{s^{2}} \cdot \sigma_{s})^2 }
\]

\section{Vollständiges Messergebnis}

Die Messwerte, die Konstante \(g\) und die Standardfehler der
Mittelwerte werden eingesetzt. \[
u(k(m, s)) = \sqrt{ ( \frac{9,81 m}{{s}^2 \cdot  0,1432 m}  \cdot 0,000267 ~ kg)^2 + ((-) \frac{0,503 ~ kg \cdot 9,81  m}{{s}^2 \cdot ( 0,1432 m)^2} \cdot  0,00247 m)^2 }
\]

Trennen von Werten und Einheiten: \[
u(k(m, s)) = \sqrt{ ( \frac{9,81 \cdot 0,000267}{  0,1432 } \frac{m \cdot kg}{{s}^2 \cdot m})^2 + ((-) \frac{0,503 \cdot 9,81 \cdot 0,00247}{0,02051} \frac{kg \cdot m^2}{{s}^2 \cdot m^2})^2 }
\]

Berechnen, Newton \(\frac{kg \cdot m}{s^2}\) einsetzen und Meter im 2.
Term kürzen: \[
u(k(m, s)) = \sqrt{ ( \frac{9,81 \cdot 0,000267}{  0,1432 } \frac{N}{m})^2 + ((-) \frac{0,503 \cdot 9,81 \cdot 0,00247}{0,02051} \frac{N}{m})^2 }
\]

Zusammenfassen: \[
u(k(m, s)) = \sqrt{ ( 0,0183 \frac{N}{m})^2 + ((-) 0,594 \frac{N}{m})^2 }
\]

Ausrechnen: \[
u(k(m, s)) = 0,595 \frac{N}{m} \approx 0,60 \frac{N}{m}
\]

Das vollständige Messergebnis lautet somit: \[
k = 34,46 \frac{N}{m} \pm 0,60 \frac{N}{m}
\]

\section{95-\%-Vertrauensintervall}

Zusätzlich zum vollständigen Messergebnis kann ein Vertrauensintervall
angegeben werden. Entsprechend der vereinbarten
Vertrauenswahrscheinlichkeit, sind die entsprechenden t-Werte als
Korrekturfaktoren einzusetzen.

\[
u(k(m, s)) = \sqrt{ ( \frac{g}{s} \cdot t_{\alpha/2} \cdot \sigma_{m})^2 + (- \frac {m \cdot g}{s^{2}} \cdot t_{\alpha/2} \cdot \sigma_{s})^2 }
\]

Dies sind für die Masse \(t = 2,3646\) und für die Ausdehnung
\(t = 2,2622\).

Die Messwerte, die Konstante \(g\), der Standardfehler des Mittelwerts
und der t-Wert werden in den ersten Term eingesetzt. \[
(\frac{g}{s} \cdot t_{\alpha/2} \cdot \sigma_{m})^2 = ( \frac{9,81 m}{{s}^2 \cdot 0,1432 m}  \cdot 2,3646 \cdot 0,000267 ~ kg)^2
\]

Trennen von Werten und Einheiten, Newton \(\frac{kg \cdot m}{s^2}\)
einsetzen: \[
 (\frac{9,81 \cdot 2,3646 \cdot 0,000267}{  0,1432 } \frac{m \cdot kg}{{s}^2 \cdot m})^2 = (0,0433 \frac{N}{m})^2
\]

Die Messwerte, die Konstante \(g\), der Standardfehler des Mittelwerts
und der t-Wert werden in den zweiten Term eingesetzt. \[
(- \frac {m \cdot g}{s^{2}} \cdot t_{\alpha/2} \cdot \sigma_{s})^2 =  ((-) \frac{0,503 ~ kg \cdot 9,81  m}{{s}^2 \cdot ( 0,1432 m)^2} \cdot  2,2622 \cdot  0,00247 m)^2
\]

Trennen von Werten und Einheiten, Newton \(\frac{kg \cdot m}{s^2}\)
einsetzen und \(m\) kürzen: \[
((-) \frac{0,503 \cdot 9,81 \cdot  2,2622 \cdot 0,00247}{0,02051} \frac{kg \cdot m^2}{{s}^2 \cdot m^2})^2 = ((-) 1,344 \frac{N}{m})^2
\]

Die Formel lautet somit: \[
u(k(m, s)) = \sqrt{ ( 0,0433 \frac{N}{m})^2 + ((-) 1,344 \frac{N}{m})^2 }
\]

Ausrechnen: \[
u(k(m, s)) = 1,345 \frac{N}{m} \approx 1,35 \frac{N}{m}
\]

Die Intervallgrenzen lauten somit: \[
k = 34,46 \frac{N}{m} \pm 1,35 \frac{N}{m}
\]

Also: \[
k_{95\%} = 33,11 \frac{N}{m} \le 34,46 \frac{N}{m} \le 35,81 \frac{N}{m}
\]

\end{tcolorbox}

\subsubsection{Übersicht Fehlerfortpflanzung für Grundrechenarten und
Potenzprodukte}\label{uxfcbersicht-fehlerfortpflanzung-fuxfcr-grundrechenarten-und-potenzprodukte}

Einige Funktionen sind besonders leicht zu berechnen. In der folgenden
Tabelle sind Rechenwege zur Ermittlung der Messunsicherheit nach der
Gauß'schen Fehlerfortpflanzung (Standardfehler) und nach der linearen
Fehlerfortpflanzung (Größtfehler) aufgelistet.

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/00-bilder/tabelle-edengebhard2024.png}}

}

\caption{Fehlerfortpflanzung für Grundrechenarten und Potenzprodukte}

\end{figure}%

{[}@EdenGebhard-2024, S. 36{]}

\subsubsection{Spezialfall: Fehlerfortpflanzung mit
Einzelwerten}\label{spezialfall-fehlerfortpflanzung-mit-einzelwerten}

Ein Sonderfall ist die Ermittlung der Messunsicherheit, wenn diese sich
aus statistischen Vertrauensbereichen und abgeschätzten Fehleranteilen
aus einer Einzelmessung zusammensetzt.

Für die Berechnung eines Gesamtfehlers muss ein Kompromiss eingegangen
werden.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Die lineare Fehlerfortpflanzung wird mit dem abgeschätzten Fehler und
  dem statistischen Vertrauensbereich durchgeführt.
\item
  Die Gauß'sche Fehlerfortpflanzung wird mit dem statistischen
  Vertrauensbereich durchgeführt und ein Fehleranteil addiert, der aus
  der linearen Fehlerfortpflanzung der abgeschätzten Fehler ermittelt
  wird.
\end{enumerate}

``Beide Verfahren sind wohl gleich gut (oder schlecht) als Kompromiss in
der Laborpraxis geeignet.'' (@Hempel-2016, S. 9)

(@Hempel-2016, S. 8 - 9)

Die DIN 1319 behandelt nur die Gauß'sche Fehlerfortpflanzung. Liegt für
eine Eingangsgröße nur ein einzelner Wert vor, wird dieser als
Schätzwert für diese Größe verwendet. Die Unsicherheit ist aus den
verfügbaren Informationen oder nach der Erfahrung, zum Beispiel aus
früheren Messungen, anzusetzen. {[}@DIN1319-3, S. 11{]}

Als Beispiel verwenden wir wieder die Messreihe für das Gewicht 503
Gramm.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-beispieleinzelwert}: Beispiel Federkonstante}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-beispieleinzelwert} 

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Ausgabe}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Gewicht in Kilogramm: }\SpecialCharTok{\{}\NormalTok{hooke\_503g[}\StringTok{\textquotesingle{}mass\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{unique()}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Mittlere Ausdehnung: }\SpecialCharTok{\{}\NormalTok{hooke\_503g[}\StringTok{\textquotesingle{}ausdehnung\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{mean()}\SpecialCharTok{:.4f\}}\SpecialStringTok{ m"}\NormalTok{,}
      \SpecialStringTok{f"empirischer Standardfehler: }\SpecialCharTok{\{}\NormalTok{ (sem\_hooke\_503g}\OperatorTok{:=}\NormalTok{ pd.Series(hooke\_503g[}\StringTok{\textquotesingle{}ausdehnung\textquotesingle{}}\NormalTok{].sem()))}\SpecialCharTok{.}\NormalTok{item() }\SpecialCharTok{:.6f\}}\SpecialStringTok{ m"}\NormalTok{,}
      \SpecialStringTok{f"t{-}Wert der Ausdehnung: }\SpecialCharTok{\{}\NormalTok{t\_wert\_ausdehnung}\SpecialCharTok{:.4f\}}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"95{-}\%{-}Intervallgrenzen: }\SpecialCharTok{\{}\NormalTok{(hooke\_503g[}\StringTok{\textquotesingle{}ausdehnung\textquotesingle{}}\NormalTok{].mean() }\OperatorTok{{-}}\NormalTok{ t\_wert\_ausdehnung }\OperatorTok{*}\NormalTok{ sem\_hooke\_503g)}\SpecialCharTok{.}\NormalTok{item()}\SpecialCharTok{:.4f\}}\SpecialStringTok{ m ≤ }\SpecialCharTok{\{}\NormalTok{hooke\_503g[}\StringTok{\textquotesingle{}ausdehnung\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{mean()}\SpecialCharTok{:.4f\}}\SpecialStringTok{ m ≤ }\SpecialCharTok{\{}\NormalTok{(hooke\_503g[}\StringTok{\textquotesingle{}ausdehnung\textquotesingle{}}\NormalTok{].mean() }\OperatorTok{+}\NormalTok{ t\_wert\_ausdehnung }\OperatorTok{*}\NormalTok{ sem\_hooke\_503g)}\SpecialCharTok{.}\NormalTok{item()}\SpecialCharTok{:.4f\}}\SpecialStringTok{ m"}\NormalTok{,}
\NormalTok{      sep }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Gewicht in Kilogramm: [0.503]
Mittlere Ausdehnung: 0.1432 m
empirischer Standardfehler: 0.002470 m
t-Wert der Ausdehnung: 2.2622
95-%-Intervallgrenzen: 0.1376 m ≤ 0.1432 m ≤ 0.1488 m
\end{verbatim}

\section{Lineare Fehlerfortpflanzung}

Analog zur Fehlerabschätzung ergibt sich der Größtfehler der
Federkonstante durch: \[
\Delta k = | \frac{g}{s} | \cdot \Delta m ~ + ~ | (-) \frac {m \cdot g}{s^{2}} | \cdot \Delta s
\]

\begin{itemize}
\tightlist
\item
  Die Ableseabweichung der Küchenwaage wird auf
  \(e_r (m) = 0,5 g = 0,0005 ~ kg\) geschätzt. Eine systematische
  Messabweichung ist nicht bekannt. Der Größtfehler der Masse beträgt
  also \(\Delta m = 0,0005 ~ kg\)
\item
  Der empirische Standardfehler der Ausdehnung beträgt
  \(\sigma_x = 0.00247 m\) bzw. zum vereinbarten Vertrauensniveau von
  \(\sigma_{x 95 \%} = 0.00247 ~ m * 2.2622 = 0,00559 m\)
\end{itemize}

Die Messwerte, die Konstante \(g\) und die Größtfehler werden
eingesetzt. \[
\Delta k = | \frac{9,81 m}{{s}^2 \cdot 0,1432 m} | \cdot 0,0005 ~ kg ~ + ~ | (-) \frac{0,503 ~ kg \cdot 9,81  m}{{s}^2 \cdot (0,1432 m)^2} | \cdot 0,00247 m
\]

Trennen von Werten und Einheiten: \[
\Delta k = | \frac{9,81 \cdot 0,0005}{ 0,1432 } \frac{m \cdot kg}{{s}^2 \cdot m} | ~ + | (-) \frac{0,503 \cdot 9,81 \cdot 0,00247}{0,020506} \frac{kg \cdot m^2}{{s}^2 \cdot m^2} |
\]

Berechnen und Newton \(\frac{kg \cdot m}{s^2}\) einsetzen: \[
\Delta k = | 0,0342 \frac{N}{{m}} | ~ + | (-) 0,594 \frac{N \cdot m}{{m^2}} |
\]

Meter im zweiten Term kürzen: \[
\Delta k = |0,0342 \frac{N}{{m}} | ~ + | (-) 0,594 \frac{N}{{m}} |
\]

Die Messunsicherheit wird auf zwei Dezimalstellen aufgerundet. \[
\Delta k = 0,628 \frac{N}{{m}} \approx 0,63 \frac{N}{{m}}
\]

Das Messergebnis und der Größtfehler lauten somit: \[
k = 34,46 \frac{N}{m}; \Delta k = 0,63 \frac{N}{{m}}
\]

\section{Gauß'sche Fehlerfortpflanzung}

Die Unsicherheit der Federkonstante berechnet sich durch: \[
u(k(m, s)) = \sqrt{ ( \frac{g}{s} \cdot \Delta m)^2 + (- \frac {m \cdot g}{s^{2}} \cdot \sigma_{s})^2 }
\]

Die Messwerte, die Konstante \(g\) und der abgeschätzte Fehleranteil
(Größtfehler) der Masse werden in den ersten Term eingesetzt. \[
(\frac{g}{s} \cdot \Delta m)^2 = ( \frac{9,81 m}{{s}^2 \cdot 0,1432 m} \cdot 0,0005 ~ kg)^2
\]

Trennen von Werten und Einheiten, Newton \(\frac{kg \cdot m}{s^2}\)
einsetzen: \[
 (\frac{9,81 \cdot 0,0005}{ 0,1432 } \frac{m \cdot kg}{{s}^2 \cdot m})^2 = (0,0342 \frac{N}{m})^2
\]

Die Masse des Gewichts, die Konstante \(g\) und der Standardfehler des
Mittelwerts der Ausdehnung werden in den zweiten Term eingesetzt. \[
(- \frac {m \cdot g}{s^{2}} \cdot \sigma_{s})^2 =  ((-) \frac{0,503 ~ kg \cdot 9,81  m}{{s}^2 \cdot ( 0,1432 m)^2} \cdot  0,00247 m)^2
\]

Trennen von Werten und Einheiten, Newton \(\frac{kg \cdot m}{s^2}\)
einsetzen und \(m\) kürzen: \[
((-) \frac{0,503 \cdot 9,81 \cdot 0,00247}{0,02051} \frac{kg \cdot m^2}{{s}^2 \cdot m^2})^2 = ((-) 0,594 \frac{N}{m})^2
\]

Die Formel lautet somit: \[
u(k(m, s)) = \sqrt{ ( 0,0342  \frac{N}{m})^2 + ((-) 0,594 \frac{N}{m})^2 }
\]

Ausrechnen: \[
u(k(m, s)) = 0,595 \frac{N}{m} \approx 0,60 \frac{N}{m}
\]

Das vollständige Messergebnis lautet somit: \[
k = 34,46 \frac{N}{m}; \Delta k = 0,60 \frac{N}{{m}}
\]

Für das 95-\%-Konfidenzintervall wird der t-Wert der Ausdehnung
\(t = 2,2622\) eingesetzt. \[
u(k(m, s)) = \sqrt{ ( \frac{g}{s} \cdot \Delta m)^2 + (- \frac {m \cdot g}{s^{2}} \cdot t_{\alpha/2} \cdot \sigma_{s})^2 }
\]

Der erste Term lautet unverändert:

\[
(\frac{g}{s} \cdot \Delta m)^2 = ( \frac{9,81 m}{{s}^2 \cdot 0,1432 m} \cdot 0,0005 ~ kg)^2 = ( 0,0342  \frac{N}{m})^2
\]

Die Masse, die Konstante \(g\), der Standardfehler des Mittelwerts der
Ausdehnung und der t-Wert der Ausdehnung \(t = 2,2622\) werden in den
zweiten Term eingesetzt. \[
(- \frac {m \cdot g}{s^{2}} \cdot t_{\alpha/2} \cdot \sigma_{s})^2 =  ((-) \frac{0,503 ~ kg \cdot 9,81  m}{{s}^2 \cdot ( 0,1432 m)^2} \cdot  2,2622 \cdot  0,00247 m)^2
\]

Trennen von Werten und Einheiten, Newton \(\frac{kg \cdot m}{s^2}\)
einsetzen und \(m\) kürzen: \[
((-) \frac{0,503 \cdot 9,81 \cdot  2,2622 \cdot 0,00247}{0,02051} \frac{kg \cdot m^2}{{s}^2 \cdot m^2})^2 = ((-) 1,344 \frac{N}{m})^2
\]

Die Formel lautet somit: \[
u(k(m, s)) = \sqrt{ ( 0,0342  \frac{N}{m})^2 + ((-) 1,344 \frac{N}{m})^2 }
\]

Ausrechnen: \[
u(k(m, s)) = 1,344 \frac{N}{m} \approx 1,35 \frac{N}{m}
\]

Die Intervallgrenzen lauten somit: \[
k_{95\%} = 33,11 \frac{N}{m} \le 34,46 \frac{N}{m} \le 35,81 \frac{N}{m}
\]

\end{tcolorbox}

\chapter{Übung Hooke'sches Gesetz}\label{uxfcbung-hookesches-gesetz}

Häufig liegen Sensordaten in mehreren Dateien vor. Mögliche Gründe dafür
können sein, dass die Messung

\begin{itemize}
\tightlist
\item
  von unterschiedlichen Personen,
\item
  an unterschiedlichen Standorten,
\item
  zu unterschiedlichen Zeiten,
\item
  mit verschiedenen Geräten oder
\item
  für unterschiedliche Messgrößen durchgeführt wurden.
\end{itemize}

Im Ordner `01-daten/hooke' liegen mehrere txt-Dateien mit Messdaten zur
Federausdehnung. In diesem Kapitel sollen Sie das bisher Gelernte
anwenden und die folgenden Fragen beantworten.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Liegen ungültige Messungen vor?
\item
  Welche Werte können für die Federkonstanten ermittelt werden?
\item
  Wurden die Messungen mit der gleichen Feder (oder mit Federn mit
  gleicher Federkonstante) durchgeführt, wenn als
  Vertrauenswahrscheinlichkeit 90 \% bzw. 95 \% angenommen werden soll?
\end{enumerate}

Im Abschnitt Section~\ref{sec-dateien-einlesen} finden Sie Hinweise und
im Abschnitt Section~\ref{sec-aufgabe-einlesen} eine Musterlösung zum
Einlesen der Dateien. Anschließend sollen Sie die Aufgabenstellung
eigenständig bearbeiten. In Abschnitt
Section~\ref{sec-lösung-datenaufbereitung} finden Sie eine Musterlösung
für die Aufbereitung der Daten. In
Section~\ref{sec-lösung-federkonstanten} die Musterlösung zur Bestimmung
der Federkonstanten.

\emph{Hinweis: Je nach gewähltem Vorgehen können sich unterschiedliche
Ergebnisse ergeben (etwa bei der Bewertung von und dem Umgang mit
Extremwerten / Ausreißern).}

\section{Dateien einlesen}\label{sec-dateien-einlesen}

Für das Einlesen der Dateien können Sie das Modul glob verwenden (siehe
\href{https://bausteine-der-datenanalyse.github.io/m-sensordatenanalyse/output/book/}{Methodenbaustein
Einlesen strukturierter Datensätze}).

Zunächst kann der Funktion \texttt{glob.glob()} das Argument
\texttt{pathname\ =\ *} übergeben werden. Der Platzhalter \texttt{*}
steht für eine beliebige Zeichenfolge (außer Dateipfadelemente wie
\texttt{/} oder \texttt{.}), sodass die Namen aller im angegebenen
Ordner gespeicherten Dateien ausgelesen werden. Auf diese Weise kann die
Anzahl der Dateien und die Dateiendung bestimmt werden, falls dies noch
unbekannt ist.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ordnerpfad }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/hooke\textquotesingle{}}

\NormalTok{pfadliste }\OperatorTok{=}\NormalTok{ glob.glob(pathname }\OperatorTok{=} \StringTok{\textquotesingle{}*\textquotesingle{}}\NormalTok{, root\_dir }\OperatorTok{=}\NormalTok{ ordnerpfad, recursive }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(pfadliste)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Anzahl Dateien: }\SpecialCharTok{\{}\BuiltInTok{len}\NormalTok{(pfadliste)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['team_kreativkoepfe.txt', 'team_ma.txt', 'team_fabi.txt', 'team_die_ahnungslosen.txt']
Anzahl Dateien: 4
\end{verbatim}

Mit den Dateipfaden können die Dateien mit Hilfe einer Schleife in eine
Liste eingelesen werden. Zunächst werden nur die jeweils ersten 3 Zeilen
eingelesen, um einen Eindruck vom Aufbau der Dateien zu erhalten.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ pfad }\KeywordTok{in}\NormalTok{ pfadliste:}
\NormalTok{  zwischenspeicher }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ ordnerpfad }\OperatorTok{+} \StringTok{\textquotesingle{}/\textquotesingle{}} \OperatorTok{+}\NormalTok{ pfad, nrows }\OperatorTok{=} \DecValTok{3}\NormalTok{)}
  \BuiltInTok{print}\NormalTok{(pfad, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, zwischenspeicher, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, sep }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
team_kreativkoepfe.txt
   10:33:02\t109.64 cm\t0
0  10:33:05\t109.62 cm\t0
1  10:33:08\t109.64 cm\t0
2  10:33:11\t109.62 cm\t0

team_ma.txt
   10:09:38\t109.26 cm\t0
0  10:09:41\t109.26 cm\t0
1  10:09:44\t109.28 cm\t0
2  10:09:47\t109.18 cm\t0

team_fabi.txt
   09:17:54\t110.31 cm\t0
0  09:17:57\t110.29 cm\t0
1  09:18:03\t110.74 cm\t0
2  09:18:06\t109.95 cm\t0

team_die_ahnungslosen.txt
   11:03:23\t109.66 cm\t0
0  11:03:23\t109.62 cm\t0
1  11:03:23\t109.73 cm\t0
2  11:03:23\t109.55 cm\t0
\end{verbatim}

Die Dateien beinhalten keine Spaltenbeschriftung und verwenden den
Tabulator `\textbackslash t' als Trennzeichen. Die erste Spalte enthält
einen Zeitstempel, die zweite die gemessene Federausdehnung und die
dritte (vermutlich) das angehängte Gewicht.

\section{Aufgabe Dateien einlesen}\label{sec-aufgabe-einlesen}

Lesen Sie die Dateien nun ein. Prüfen Sie dabei:

\begin{itemize}
\tightlist
\item
  ob die Datentypen korrekt eingelesen werden und
\item
  auf fehlende Werte.
\end{itemize}

Sie können:

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\tightlist
\item
  Jede Datei einzeln einlesen.
\item
  Mit dem Modul glob die Dateien automatisch einlesen und jeweils in
  einem separaten Objekt speichern (\emph{Hinweis:} Dieses Vorgehen wird
  im
  \href{https://bausteine-der-datenanalyse.github.io/m-sensordatenanalyse/output/book/}{Methodenbaustein
  Einlesen strukturierter Datensätze} gezeigt).
\item
  Die Dateien mit dem Modul glob automatisch einlesen und in einem
  Objekt zusammenführen.
\end{enumerate}

Die verschiedenen Möglichkeiten sind mit zunehmend mehr Aufwand beim
Programmieren verbunden. Je mehr separate Dateien Sie auswerten möchten,
desto mehr Automatisierung ist gefragt. Da bei der Auswertung von
Sensordaten häufig zahlreiche Dateien ausgewertet werden müssen, wird in
der Musterlösung Variante c) gezeigt.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-schrittweise}: Schrittweises Vorgehen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-schrittweise} 

Das Einlesen der Dateien wird voraussichtlich der aufwändigste und
fehleranfälligste Arbeitsschritt sein. Entwickeln Sie Ihre Lösung
Schritt für Schritt. Beginnen Sie mit der Variante a). Wenn Sie die
Dateien eingelesen haben, können Sie sich durch die Weiterentwicklung
zur Variante b) mit dem Modul glob vertraut machen. Darauf aufbauend
können Sie mit der Variante c) die Automatisierung für beliebig viele
Dateien umsetzen.

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-muster-dateien}: Musterlösung Dateien einlesen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-muster-dateien} 

Der erste Versuch, die Dateien einzulesen, scheitert mit einer
Fehlermeldung. Die Anweisungen werden deshalb in die Struktur zur
Ausnahmebehandlung eingebettet und die verursachende Datei abgefangen.
(Sollten mehrere Dateien Fehler erzeugen, müssten die Dateien in einer
Liste gespeichert und später - falls möglich - mit einer Schleife weiter
behandelt werden.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hooke }\OperatorTok{=}\NormalTok{ pd.DataFrame(columns }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Abstand\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{]) }\CommentTok{\# ein leerer DataFrame}

\ControlFlowTok{for}\NormalTok{ pfad }\KeywordTok{in}\NormalTok{ pfadliste:}

  \ControlFlowTok{try}\NormalTok{:}
\NormalTok{    zwischenspeicher }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ ordnerpfad }\OperatorTok{+} \StringTok{\textquotesingle{}/\textquotesingle{}} \OperatorTok{+}\NormalTok{ pfad, sep }\OperatorTok{=} \StringTok{\textquotesingle{}}\CharTok{\textbackslash{}t}\StringTok{\textquotesingle{}}\NormalTok{, names }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Abstand\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{])}

    \CommentTok{\# Dateiname als Spalte einfügen}
\NormalTok{    zwischenspeicher[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ pfad[}\DecValTok{5}\NormalTok{:}\OperatorTok{{-}}\DecValTok{4}\NormalTok{] }\CommentTok{\# \textquotesingle{}team\_\textquotesingle{} und die Dateiendung abschneiden }

\NormalTok{    hooke }\OperatorTok{=}\NormalTok{ pd.concat([hooke, zwischenspeicher], ignore\_index }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
  
  \ControlFlowTok{except} \PreprocessorTok{Exception} \ImportTok{as}\NormalTok{ error:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Pfad der Problemdatei: "}\NormalTok{, pfad, error, sep }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{    pfad\_problem\_datei }\OperatorTok{=}\NormalTok{ pfad}

\BuiltInTok{print}\NormalTok{(hooke.info(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Erfolgreich einglesen:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{].unique(), sep }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Pfad der Problemdatei: 
team_ma.txt
Error tokenizing data. C error: Expected 3 fields in line 135, saw 4

<class 'pandas.core.frame.DataFrame'>
RangeIndex: 359 entries, 0 to 358
Data columns (total 4 columns):
 #   Column   Non-Null Count  Dtype  
---  ------   --------------  -----  
 0   Zeit     355 non-null    object 
 1   Abstand  355 non-null    object 
 2   Gewicht  355 non-null    float64
 3   Team     359 non-null    object 
dtypes: float64(1), object(3)
memory usage: 11.3+ KB
None 

Erfolgreich einglesen:
['kreativkoepfe' 'fabi' 'die_ahnungslosen']
\end{verbatim}

Der Fehlermeldung zufolge besteht Zeile 135 aus 4 statt aus 3 Spalten.
Die fehlerverursachende Datei wird deshalb zeilenweise durchlaufen und
jede Zeile ausgegeben, die mehr als 3 Einträge hat. Zur Kontrolle werden
auch die ersten 5 Zeilen ausgegeben.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# einen leeren DataFrame mit 3 Spalten erstellen}
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(data }\OperatorTok{=}\NormalTok{ [], columns }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Abstand\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{])}

\NormalTok{dateiobjekt\_problem\_datei }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(}\BuiltInTok{file} \OperatorTok{=}\NormalTok{ ordnerpfad }\OperatorTok{+} \StringTok{\textquotesingle{}/\textquotesingle{}} \OperatorTok{+}\NormalTok{ pfad\_problem\_datei, mode }\OperatorTok{=} \StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}

\NormalTok{index }\OperatorTok{=} \DecValTok{0}
\ControlFlowTok{for}\NormalTok{ zeile }\KeywordTok{in}\NormalTok{ dateiobjekt\_problem\_datei:}
  \ControlFlowTok{try}\NormalTok{:}
\NormalTok{    zwischenspeicher }\OperatorTok{=}\NormalTok{ zeile.split(sep }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}t}\StringTok{"}\NormalTok{)}
    \ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(zwischenspeicher) }\OperatorTok{\textgreater{}} \DecValTok{3}\NormalTok{:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{"Index ="}\NormalTok{, index, }\StringTok{":"}\NormalTok{, zwischenspeicher)}
    \ControlFlowTok{elif}\NormalTok{ index }\OperatorTok{\textless{}=} \DecValTok{5}\NormalTok{:}
      \BuiltInTok{print}\NormalTok{(zeile)}
\NormalTok{    index }\OperatorTok{+=} \DecValTok{1}
  \ControlFlowTok{except} \PreprocessorTok{Exception} \ImportTok{as}\NormalTok{ error:}
    \BuiltInTok{print}\NormalTok{(error)}

\NormalTok{dateiobjekt\_problem\_datei.close()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
10:09:38    109.26 cm   0



10:09:41    109.26 cm   0



10:09:44    109.28 cm   0



Index = 134 : ['10:29:27', '105.49 cm', '300', '\n']
\end{verbatim}

Jede zweite Zeile ist leer. In Zeile 134 wird ein Zeilenumbruch
`\textbackslash n' eingelesen. Die Datei wird deshalb mit einer
angepassten Schleife erneut durchlaufen. Aus der betreffenden Zeile wird
der zusätzliche Zeilenumbruch `\textbackslash n' entfernt. Leere Zeilen
werden übersprungen. Die korrekten Zeilen werden an den DataFrame hooke
angefügt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateiobjekt\_problem\_datei }\OperatorTok{=} \BuiltInTok{open}\NormalTok{(}\BuiltInTok{file} \OperatorTok{=}\NormalTok{ ordnerpfad }\OperatorTok{+} \StringTok{\textquotesingle{}/\textquotesingle{}} \OperatorTok{+}\NormalTok{ pfad\_problem\_datei, mode }\OperatorTok{=} \StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{)}

\ControlFlowTok{for}\NormalTok{ zeile }\KeywordTok{in}\NormalTok{ dateiobjekt\_problem\_datei:}
  \ControlFlowTok{try}\NormalTok{:}
\NormalTok{    zwischenspeicher }\OperatorTok{=}\NormalTok{ zeile.split(sep }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}t}\StringTok{"}\NormalTok{)}
    \ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(zwischenspeicher) }\OperatorTok{\textgreater{}} \DecValTok{3}\NormalTok{:}
\NormalTok{      zwischenspeicher }\OperatorTok{=}\NormalTok{ zwischenspeicher[:}\DecValTok{3}\NormalTok{]}
    \ControlFlowTok{elif} \BuiltInTok{len}\NormalTok{(zwischenspeicher) }\OperatorTok{\textless{}} \DecValTok{3}\NormalTok{: }\CommentTok{\# leere Zeilen überspringen}
      \ControlFlowTok{continue}
    \CommentTok{\# Teamnamen als 4. Spalte anfügen}
\NormalTok{    zwischenspeicher.append(pfad\_problem\_datei[}\DecValTok{5}\NormalTok{:}\OperatorTok{{-}}\DecValTok{4}\NormalTok{]) }\CommentTok{\# \textquotesingle{}team\_\textquotesingle{} und die Dateiendung abschneiden }

\NormalTok{    hooke.loc[}\BuiltInTok{len}\NormalTok{(hooke)] }\OperatorTok{=}\NormalTok{ pd.Series(zwischenspeicher).values}

  \ControlFlowTok{except} \PreprocessorTok{Exception} \ImportTok{as}\NormalTok{ error:}
    \BuiltInTok{print}\NormalTok{(error)}
    \BuiltInTok{print}\NormalTok{(pd.Series(zwischenspeicher).values)}

\NormalTok{dateiobjekt\_problem\_datei.close()}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Erfolgreich einglesen:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{].unique(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, sep }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(hooke.info())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Erfolgreich einglesen:
['kreativkoepfe' 'fabi' 'die_ahnungslosen' 'ma']

<class 'pandas.core.frame.DataFrame'>
Index: 537 entries, 0 to 536
Data columns (total 4 columns):
 #   Column   Non-Null Count  Dtype 
---  ------   --------------  ----- 
 0   Zeit     533 non-null    object
 1   Abstand  533 non-null    object
 2   Gewicht  533 non-null    object
 3   Team     537 non-null    object
dtypes: object(4)
memory usage: 21.0+ KB
None
\end{verbatim}

Anschließend werden zum einen die Zeilen mit Nullwerten betrachtet
\ldots{}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(hooke.loc[hooke.}\BuiltInTok{apply}\NormalTok{(pd.isna).}\BuiltInTok{any}\NormalTok{(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{), :])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
    Zeit Abstand Gewicht              Team
3    NaN     NaN     NaN     kreativkoepfe
23   NaN     NaN     NaN     kreativkoepfe
28   NaN     NaN     NaN     kreativkoepfe
322  NaN     NaN     NaN  die_ahnungslosen
\end{verbatim}

\ldots{} und entfernt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hooke.drop(np.where(hooke.}\BuiltInTok{apply}\NormalTok{(pd.isna).}\BuiltInTok{any}\NormalTok{(axis }\OperatorTok{=} \DecValTok{1}\NormalTok{))[}\DecValTok{0}\NormalTok{], inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Zum anderen werden die Datentypen kontrolliert.

\begin{itemize}
\tightlist
\item
  Die Zeit kann als string stehen bleiben, da sie für die Auswertung
  nicht benötigt wird.
\item
  Der gemessene Abstand ist mit ' cm' notiert - diese Zeichenkette wird
  entfernt. Anschließend sollte die Spalte als numerisch erkannt werden.
\item
  Das Gewicht sollte numerische Werte enthalten, wird aber als Datentyp
  object eingelesen und muss weiter untersucht werden.
\item
  Der Spalte Team könnte der
  \href{https://pandas.pydata.org/docs/user_guide/categorical.html}{Pandas
  Datentyp category} zugewiesen werden, notwendig ist es aber nicht.
\end{itemize}

String ' cm' entfernen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hooke.replace(}\StringTok{\textquotesingle{} cm\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{, regex }\OperatorTok{=} \VariableTok{True}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Ob alle Elemente einer Zelle numerisch sind, kann mit der Pandas-Methode
\texttt{pd.Series.str.isnumeric()} überprüft werden. Ein Blick auf die
Daten zeigt die Ursache.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(hooke[}\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{].}\BuiltInTok{str}\NormalTok{.isnumeric().}\BuiltInTok{sum}\NormalTok{())}

\BuiltInTok{print}\NormalTok{(hooke[}\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{].head())}
\BuiltInTok{print}\NormalTok{(hooke[}\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{].tail())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
0    0.0
1    0.0
2    0.0
4    0.0
5    0.0
Name: Gewicht, dtype: object
532    850\n
533    850\n
534    850\n
535    850\n
536    850\n
Name: Gewicht, dtype: object
\end{verbatim}

Die Zeilenumbrüche werden ebenfalls entfernt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hooke.replace(}\StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{, regex }\OperatorTok{=} \VariableTok{True}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(hooke[}\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{].}\BuiltInTok{str}\NormalTok{.isnumeric().}\BuiltInTok{sum}\NormalTok{())}
\BuiltInTok{print}\NormalTok{(hooke[}\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{].tail())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
178
532    850
533    850
534    850
535    850
536    850
Name: Gewicht, dtype: object
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(hooke.info(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# explizite Zuweisung}
\NormalTok{hooke[}\StringTok{\textquotesingle{}Abstand\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}Abstand\textquotesingle{}}\NormalTok{].astype(}\StringTok{\textquotesingle{}float\textquotesingle{}}\NormalTok{)}
\NormalTok{hooke[}\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{].astype(}\StringTok{\textquotesingle{}float\textquotesingle{}}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(hooke.info())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
Index: 533 entries, 0 to 536
Data columns (total 4 columns):
 #   Column   Non-Null Count  Dtype 
---  ------   --------------  ----- 
 0   Zeit     533 non-null    object
 1   Abstand  533 non-null    object
 2   Gewicht  533 non-null    object
 3   Team     533 non-null    object
dtypes: object(4)
memory usage: 20.8+ KB
None 

<class 'pandas.core.frame.DataFrame'>
Index: 533 entries, 0 to 536
Data columns (total 4 columns):
 #   Column   Non-Null Count  Dtype  
---  ------   --------------  -----  
 0   Zeit     533 non-null    object 
 1   Abstand  533 non-null    float64
 2   Gewicht  533 non-null    float64
 3   Team     533 non-null    object 
dtypes: float64(2), object(2)
memory usage: 20.8+ KB
None
\end{verbatim}

\end{tcolorbox}

Das Ergebnis könnte so aussehen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hooke.groupby(by }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{], sort }\OperatorTok{=} \VariableTok{False}\NormalTok{)[}\StringTok{\textquotesingle{}Abstand\textquotesingle{}}\NormalTok{].describe()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllllll@{}}
\toprule\noalign{}
& & count & mean & std & min & 25\% & 50\% & 75\% & max \\
Team & Gewicht & & & & & & & & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\multirow{12}{=}{kreativkoepfe} & 0.0 & 9.0 & 109.676667 & 0.053619 &
109.62 & 109.6400 & 109.640 & 109.7300 & 109.74 \\
& 50.0 & 8.0 & 108.557500 & 0.489949 & 107.84 & 108.2325 & 108.495 &
108.8675 & 109.33 \\
& 100.0 & 10.0 & 107.093000 & 0.922726 & 106.30 & 106.3800 & 106.875 &
107.2700 & 109.11 \\
& 150.0 & 10.0 & 105.934000 & 0.599967 & 104.87 & 105.6125 & 106.020 &
106.3075 & 106.84 \\
& 200.0 & 10.0 & 105.453000 & 1.618278 & 103.52 & 104.0750 & 105.035 &
106.7700 & 108.27 \\
& 250.0 & 10.0 & 102.527000 & 0.796228 & 101.10 & 102.1700 & 102.410 &
102.7625 & 103.89 \\
& 300.0 & 10.0 & 101.236000 & 0.702095 & 100.29 & 100.7625 & 101.010 &
101.8350 & 102.45 \\
& 350.0 & 10.0 & 98.804000 & 1.471629 & 97.43 & 97.5725 & 98.155 &
100.3600 & 100.84 \\
& 400.0 & 9.0 & 96.827778 & 1.036783 & 95.80 & 95.8900 & 96.900 &
97.4100 & 98.78 \\
& 450.0 & 9.0 & 95.515556 & 1.115954 & 93.91 & 94.6300 & 95.750 &
95.8300 & 97.24 \\
& 500.0 & 8.0 & 95.336250 & 1.564298 & 93.30 & 94.4575 & 95.140 &
96.5625 & 97.69 \\
& 550.0 & 9.0 & 93.155556 & 0.352956 & 92.76 & 92.8700 & 92.950 &
93.4000 & 93.76 \\
\multirow{10}{=}{fabi} & 0.0 & 10.0 & 110.366000 & 0.253693 & 109.95 &
110.2900 & 110.310 & 110.5800 & 110.74 \\
& 50.0 & 12.0 & 110.425833 & 0.210992 & 110.22 & 110.3050 & 110.310 &
110.6225 & 110.77 \\
& 101.0 & 9.0 & 108.238889 & 0.231163 & 107.96 & 107.9900 & 108.410 &
108.4200 & 108.47 \\
& 152.0 & 10.0 & 106.902000 & 0.335685 & 106.45 & 106.6000 & 106.980 &
106.9950 & 107.43 \\
& 201.0 & 10.0 & 105.253000 & 1.052416 & 102.30 & 105.4600 & 105.470 &
105.5775 & 105.90 \\
& 253.0 & 11.0 & 104.279091 & 0.466036 & 103.55 & 103.9400 & 104.100 &
104.6600 & 104.91 \\
& 302.0 & 12.0 & 102.650000 & 0.390943 & 102.09 & 102.4650 & 102.560 &
103.0100 & 103.35 \\
& 353.0 & 11.0 & 100.673636 & 0.199613 & 100.50 & 100.5500 & 100.580 &
100.7800 & 101.03 \\
& 403.0 & 14.0 & 99.447143 & 0.424815 & 98.97 & 99.1025 & 99.410 &
99.5900 & 100.26 \\
& 455.0 & 11.0 & 97.839091 & 0.228099 & 97.51 & 97.6200 & 97.880 &
98.0350 & 98.15 \\
\multirow{10}{=}{die\_ahnungslosen} & 0.0 & 10.0 & 109.759000 & 0.180705
& 109.55 & 109.6300 & 109.730 & 109.7925 & 110.09 \\
& 50.0 & 8.0 & 108.912500 & 0.180930 & 108.53 & 108.8800 & 108.930 &
109.0250 & 109.11 \\
& 100.0 & 12.0 & 107.725833 & 0.704446 & 106.76 & 107.1975 & 107.735 &
108.0725 & 108.92 \\
& 150.0 & 19.0 & 106.265789 & 0.759505 & 104.67 & 105.7050 & 106.120 &
106.7100 & 107.87 \\
& 200.0 & 18.0 & 104.616111 & 0.392955 & 103.96 & 104.2650 & 104.590 &
104.8150 & 105.23 \\
& 250.0 & 18.0 & 102.906667 & 0.221519 & 102.35 & 102.8025 & 102.890 &
102.9750 & 103.33 \\
& 300.0 & 11.0 & 101.840000 & 0.894561 & 101.00 & 101.3650 & 101.460 &
101.8150 & 104.15 \\
& 350.0 & 14.0 & 100.264286 & 0.265930 & 99.98 & 100.1475 & 100.170 &
100.2625 & 101.06 \\
& 400.0 & 11.0 & 99.239091 & 0.232786 & 98.94 & 99.0500 & 99.130 &
99.4150 & 99.57 \\
& 450.0 & 12.0 & 98.042500 & 0.468016 & 97.51 & 97.6750 & 97.970 &
98.2850 & 99.08 \\
\multirow{18}{=}{ma} & 0.0 & 10.0 & 109.258000 & 0.042374 & 109.18 &
109.2600 & 109.260 & 109.2800 & 109.31 \\
& 50.0 & 10.0 & 107.179000 & 1.809588 & 105.83 & 106.0875 & 106.185 &
107.9575 & 110.81 \\
& 100.0 & 10.0 & 102.101000 & 2.958804 & 99.37 & 99.6725 & 101.120 &
104.4825 & 106.67 \\
& 150.0 & 11.0 & 106.656364 & 4.727985 & 100.29 & 100.9900 & 109.730 &
110.1600 & 110.60 \\
& 200.0 & 9.0 & 108.456667 & 1.666816 & 106.74 & 107.2900 & 107.740 &
110.1700 & 111.06 \\
& 250.0 & 10.0 & 106.931000 & 0.957838 & 105.66 & 105.9325 & 107.540 &
107.6975 & 107.80 \\
& 300.0 & 10.0 & 105.696000 & 0.194376 & 105.46 & 105.5075 & 105.715 &
105.8650 & 105.94 \\
& 350.0 & 10.0 & 104.838000 & 0.530949 & 104.10 & 104.5150 & 104.685 &
105.1475 & 105.94 \\
& 400.0 & 10.0 & 104.790000 & 0.602974 & 104.31 & 104.4775 & 104.550 &
104.6925 & 106.09 \\
& 450.0 & 10.0 & 104.517000 & 0.475513 & 103.91 & 104.2225 & 104.510 &
104.7125 & 105.56 \\
& 500.0 & 10.0 & 104.456000 & 0.569097 & 103.65 & 104.0925 & 104.420 &
104.6400 & 105.71 \\
& 550.0 & 10.0 & 103.004000 & 0.800475 & 101.55 & 102.7650 & 103.065 &
103.5000 & 104.20 \\
& 600.0 & 10.0 & 101.403000 & 0.621183 & 100.22 & 101.5000 & 101.580 &
101.7800 & 101.94 \\
& 650.0 & 10.0 & 100.109000 & 0.082523 & 99.97 & 100.0475 & 100.110 &
100.1875 & 100.21 \\
& 700.0 & 10.0 & 98.871000 & 0.534155 & 98.24 & 98.5425 & 98.715 &
99.1850 & 100.02 \\
& 750.0 & 9.0 & 97.966667 & 0.729315 & 96.86 & 97.5000 & 97.980 &
98.6800 & 98.77 \\
& 800.0 & 11.0 & 97.115455 & 0.540210 & 96.19 & 96.7000 & 97.330 &
97.5050 & 97.72 \\
& 850.0 & 8.0 & 95.715000 & 0.245822 & 95.35 & 95.5625 & 95.750 &
95.8775 & 96.07 \\
\end{longtable}

\section{Musterlösung Daten
aufbereiten}\label{sec-luxf6sung-datenaufbereitung}

Im nächsten Schritt werden die Daten geprüft und ggf. bereinigt. Dies
umfasst die Schritte:

\begin{itemize}
\tightlist
\item
  auf Ausreißer prüfen (studentisierte z-Werte und grafisch) und ggf.
  bereinigen,
\item
  Normierung der Abstandsmessung auf den Nullpunkt und Umrechnung der
  verwendeten Einheiten in SI-Einheiten und
\item
  grafische Darstellung.
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-globgroupby} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-globgroupby}: glob, pd.groupby und SciPy}\vspace{3mm}

Die Ausführung des folgenden Codes kann lokal unterschiedlich ausfallen,
je nach dem, in welcher Reihenfolge die Dateien mit dem Modul glob
eingelesen wurden. Im Folgenden werden aus einem groupby-Objekt
Indexpositionen bestimmt, an denen eine Bedingung wahr ist. Mit diesen
Indexpositionen wird dann auf den ursprünglichen DataFrame zugegriffen.
Pandas sortiert die Gruppen im groupby-Objekt standardmäßig alphabetisch
(\texttt{sort\ =\ True}). Wenn die mit glob eingelesenen Dateien nicht
in alphabetischer Reihenfolge vorliegen, wird mit falschen
Indexpositionen auf den DataFrame zugegriffen.

Dem kann durch alphabetisches Sortieren der mit glob eingelesenen
Dateien bzw. des DataFrames nach den groupby-Kriterien begegnet werden
oder, wie im Folgenden, durch das Argument
\texttt{pd.groupby(by\ =\ Bedingung,\ sort\ =\ False)}. Letztere
Variante ist flexibler.

Auch gibt \texttt{scipy.stats.zscore()} je nach Version eine
\texttt{pd.Series} oder ein \texttt{np.array} zurück. Dementsprechend
sind die Methoden aus Pandas oder NumPy zu verwenden.

\end{minipage}%
\end{tcolorbox}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Liegen ungültige Messungen vor?}
\end{enumerate}

\subsection{Auf Ausreißer prüfen}\label{auf-ausreiuxdfer-pruxfcfen}

Auf Ausreißer kann (unter anderem) mit studentisierten z-Werten und
grafisch geprüft werden.

\section{Ausreißer bestimmen}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Anzahl der Ausreißer bestimmen und Position ausgeben.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# z{-}Werte größer gleich abs(3) finden}
\CommentTok{\#\# Lösung für SciPy 1.14.1 (gibt pd.Series zurück)}
\CommentTok{\#\# z\_values\_ge3\_sum = hooke.groupby(by = [\textquotesingle{}Team\textquotesingle{}, \textquotesingle{}Gewicht\textquotesingle{}])[\textquotesingle{}Abstand\textquotesingle{}].apply(lambda x: scipy.stats.zscore(x, ddof = 1)).abs().ge(3).sum()}

\CommentTok{\#\# Lösung für SciPy 1.15 und neuer (gibt np.array zurück)}
\NormalTok{z\_values\_ge3\_sum }\OperatorTok{=}\NormalTok{ hooke.groupby(by }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{], sort }\OperatorTok{=} \VariableTok{False}\NormalTok{)[}\StringTok{\textquotesingle{}Abstand\textquotesingle{}}\NormalTok{].}\BuiltInTok{apply}\NormalTok{(scipy.stats.zscore, ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{).}\BuiltInTok{apply}\NormalTok{(np.}\BuiltInTok{abs}\NormalTok{).}\BuiltInTok{apply}\NormalTok{(}\KeywordTok{lambda}\NormalTok{ x: np.greater\_equal(x, }\DecValTok{3}\NormalTok{)).}\BuiltInTok{apply}\NormalTok{(}\BuiltInTok{sum}\NormalTok{).}\BuiltInTok{sum}\NormalTok{()}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Anzahl der studentisierten z{-}Werte mit Betrag ≥ 3:"}\NormalTok{, z\_values\_ge3\_sum, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# z{-}Werte größer gleich abs(2.5) finden}
\CommentTok{\#\# Lösung für SciPy 1.14.1 (gibt pd.Series zurück)}
\CommentTok{\#\# z\_values\_ge25\_sum = hooke.groupby(by = [\textquotesingle{}Team\textquotesingle{}, \textquotesingle{}Gewicht\textquotesingle{}])[\textquotesingle{}Abstand\textquotesingle{}].apply(lambda x: scipy.stats.zscore(x, ddof = 1)).abs().ge(2.5).sum()}

\CommentTok{\#\# Lösung für SciPy 1.15 und neuer (gibt np.array zurück)}
\NormalTok{z\_values\_ge25\_sum }\OperatorTok{=}\NormalTok{ hooke.groupby(by }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{], sort }\OperatorTok{=} \VariableTok{False}\NormalTok{)[}\StringTok{\textquotesingle{}Abstand\textquotesingle{}}\NormalTok{].}\BuiltInTok{apply}\NormalTok{(scipy.stats.zscore, ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{).}\BuiltInTok{apply}\NormalTok{(np.}\BuiltInTok{abs}\NormalTok{).}\BuiltInTok{apply}\NormalTok{(}\KeywordTok{lambda}\NormalTok{ x: np.greater\_equal(x, }\FloatTok{2.5}\NormalTok{)).}\BuiltInTok{apply}\NormalTok{(}\BuiltInTok{sum}\NormalTok{).}\BuiltInTok{sum}\NormalTok{()}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Anzahl der studentisierten z{-}Werte mit Betrag ≥ 2.5:"}\NormalTok{, z\_values\_ge25\_sum)}

\CommentTok{\# Die Zeilen mit z{-}Werten größer abs(2.5) ausgeben}
\CommentTok{\#\# Lösung für SciPy 1.14.1 (gibt pd.Series zurück)}
\CommentTok{\#\# bool\_index = hooke.groupby(by = [\textquotesingle{}Team\textquotesingle{}, \textquotesingle{}Gewicht\textquotesingle{}])[\textquotesingle{}Abstand\textquotesingle{}].apply(lambda x: scipy.stats.zscore(x, ddof = 1)).abs().ge(2.5).values}

\CommentTok{\#\# Lösung für SciPy 1.15 und neuer (gibt np.array zurück)}
\CommentTok{\#\#\# Schritt 1: Wahrheitswerte abgreifen}
\NormalTok{bool\_index }\OperatorTok{=}\NormalTok{ hooke.groupby(by }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{], sort }\OperatorTok{=} \VariableTok{False}\NormalTok{)[}\StringTok{\textquotesingle{}Abstand\textquotesingle{}}\NormalTok{].}\BuiltInTok{apply}\NormalTok{(scipy.stats.zscore, ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{).}\BuiltInTok{apply}\NormalTok{(np.}\BuiltInTok{abs}\NormalTok{).}\BuiltInTok{apply}\NormalTok{(}\KeywordTok{lambda}\NormalTok{ x: np.greater\_equal(x, }\FloatTok{2.5}\NormalTok{)).values}
\CommentTok{\#\#\# Schritt 2: Rückgabe in ein eindimensionales Array überführen: }
\NormalTok{bool\_index }\OperatorTok{=}\NormalTok{ np.hstack(bool\_index)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{An diesen Indexpositionen liegen die Ausreißer:"}\NormalTok{, np.nonzero(bool\_index))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Anzahl der studentisierten z-Werte mit Betrag ≥ 3: 0 

Anzahl der studentisierten z-Werte mit Betrag ≥ 2.5: 4

An diesen Indexpositionen liegen die Ausreißer: (array([156, 298, 313, 318]),)
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Ausgabe der Zeilen aus den Messreihen
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Auswahl der Zeilen mit den z{-}Werten größer gleich 2.5}
\NormalTok{z\_values\_ge\_25 }\OperatorTok{=}\NormalTok{ hooke.iloc[bool\_index , :] }\CommentTok{\# {-}{-}\textgreater{} Hier muss das Problem liegen}
\BuiltInTok{print}\NormalTok{(z\_values\_ge\_25, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\# Kombinationen aus Gewicht \& Team bestimmen}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Kombinationen aus Gewicht \& Team bestimmen"}\NormalTok{)}
\NormalTok{teams }\OperatorTok{=}\NormalTok{ z\_values\_ge\_25[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{].unique()}

\CommentTok{\#\# teams durchlaufen und jeweils die Gewichte speichern}
\NormalTok{team\_gewichte }\OperatorTok{=}\NormalTok{ [] }\CommentTok{\# leere liste}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(teams)):}
  \BuiltInTok{print}\NormalTok{(teams[i])}
  \BuiltInTok{print}\NormalTok{(z\_values\_ge\_25.loc[z\_values\_ge\_25[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ teams[i], }\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{], }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{  team\_gewichte.append(z\_values\_ge\_25.loc[z\_values\_ge\_25[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ teams[i], }\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{].values)}

\CommentTok{\# print("Als Liste von arrays:")}
\CommentTok{\# print(team\_gewichte, "\textbackslash{}n")}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
         Zeit  Abstand  Gewicht              Team
159  09:27:18   102.30    201.0              fabi
301  11:10:38   102.35    250.0  die_ahnungslosen
316  11:11:42   104.15    300.0  die_ahnungslosen
321  11:12:43   101.06    350.0  die_ahnungslosen 

Kombinationen aus Gewicht & Team bestimmen
fabi
159    201.0
Name: Gewicht, dtype: float64 

die_ahnungslosen
301    250.0
316    300.0
321    350.0
Name: Gewicht, dtype: float64 
\end{verbatim}

\section{Gemeinsame Ausgabe der Messreihen}

Diese Ausgabe dient der Veranschaulichung und Kontrolle.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Messreihen auswählen}
\NormalTok{messreihen }\OperatorTok{=}\NormalTok{ pd.DataFrame()}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(teams)):}
  \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(team\_gewichte[i])):}

    \BuiltInTok{print}\NormalTok{(teams[i], team\_gewichte[i][j])}

\NormalTok{    messreihen }\OperatorTok{=}\NormalTok{ pd.concat([messreihen, hooke.loc[ (hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ teams[i]) }\OperatorTok{\&}\NormalTok{ (hooke[}\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ team\_gewichte[i][j]) ]])}

\CommentTok{\# studentisierte z{-}Werte der Messreihen bilden}
\CommentTok{\#\# Lösung für SciPy 1.14.1 (gibt pd.Series zurück)}
\CommentTok{\#\# messreihen\_z\_scores = messreihen.groupby(by = [\textquotesingle{}Team\textquotesingle{}, \textquotesingle{}Gewicht\textquotesingle{}])[\textquotesingle{}Abstand\textquotesingle{}].apply(lambda x: scipy.stats.zscore(x, ddof = 1)).reset\_index(drop = True)}

\CommentTok{\#\# Lösung für SciPy 1.15 und neuer (gibt np.array zurück)}
\CommentTok{\#\# Rückgabe zeilenweise in ein eindimensionales Array überführen: }
\NormalTok{messreihen\_z\_scores }\OperatorTok{=}\NormalTok{ np.hstack(messreihen.groupby(by }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{], sort }\OperatorTok{=} \VariableTok{False}\NormalTok{)[}\StringTok{\textquotesingle{}Abstand\textquotesingle{}}\NormalTok{].}\BuiltInTok{apply}\NormalTok{(}\KeywordTok{lambda}\NormalTok{ x: scipy.stats.zscore(x, ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{)).reset\_index(drop }\OperatorTok{=} \VariableTok{True}\NormalTok{))}

\CommentTok{\# gemeinsame Ausgabe der Daten}
\CommentTok{\#\# Lösung für SciPy 1.14.1 (gibt pd.Series zurück)}
\CommentTok{\#\# messreihen.insert(loc = 2, column = \textquotesingle{}z{-}Werte Abstand\textquotesingle{}, value = messreihen\_z\_scores.values)}

\CommentTok{\#\# Lösung für SciPy 1.15 und neuer (gibt np.array zurück)}
\NormalTok{messreihen.insert(loc }\OperatorTok{=} \DecValTok{2}\NormalTok{, column }\OperatorTok{=} \StringTok{\textquotesingle{}z{-}Werte Abstand\textquotesingle{}}\NormalTok{, value }\OperatorTok{=}\NormalTok{ messreihen\_z\_scores)}
\BuiltInTok{print}\NormalTok{(messreihen)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
fabi 201.0
die_ahnungslosen 250.0
die_ahnungslosen 300.0
die_ahnungslosen 350.0
         Zeit  Abstand  z-Werte Abstand  Gewicht              Team
156  09:27:09   105.47         0.206192    201.0              fabi
157  09:27:12   105.90         0.614776    201.0              fabi
158  09:27:15   105.54         0.272706    201.0              fabi
159  09:27:18   102.30        -2.805925    201.0              fabi
160  09:27:21   105.90         0.614776    201.0              fabi
161  09:27:24   105.47         0.206192    201.0              fabi
162  09:27:27   105.44         0.177686    201.0              fabi
163  09:27:30   105.59         0.320216    201.0              fabi
164  09:27:33   105.46         0.196690    201.0              fabi
165  09:27:36   105.46         0.196690    201.0              fabi
292  11:10:11   102.99         0.376191    250.0  die_ahnungslosen
293  11:10:13   102.99         0.376191    250.0  die_ahnungslosen
294  11:10:17   102.93         0.105333    250.0  die_ahnungslosen
295  11:10:20   102.83        -0.346095    250.0  die_ahnungslosen
296  11:10:23   103.16         1.143620    250.0  die_ahnungslosen
297  11:10:26   102.80        -0.481524    250.0  die_ahnungslosen
298  11:10:29   102.90        -0.030095    250.0  die_ahnungslosen
299  11:10:32   103.33         1.911049    250.0  die_ahnungslosen
300  11:10:35   102.78        -0.571810    250.0  die_ahnungslosen
301  11:10:38   102.35        -2.512954    250.0  die_ahnungslosen
302  11:10:41   102.93         0.105333    250.0  die_ahnungslosen
303  11:10:44   102.88        -0.120381    250.0  die_ahnungslosen
304  11:10:47   102.90        -0.030095    250.0  die_ahnungslosen
305  11:10:50   102.88        -0.120381    250.0  die_ahnungslosen
306  11:10:53   102.73        -0.797524    250.0  die_ahnungslosen
307  11:10:56   102.81        -0.436381    250.0  die_ahnungslosen
308  11:10:59   102.80        -0.481524    250.0  die_ahnungslosen
309  11:11:02   103.33         1.911049    250.0  die_ahnungslosen
310  11:11:24   101.37        -0.525397    300.0  die_ahnungslosen
311  11:11:27   101.43        -0.458325    300.0  die_ahnungslosen
312  11:11:30   102.80         1.073152    300.0  die_ahnungslosen
313  11:11:33   101.72        -0.134144    300.0  die_ahnungslosen
314  11:11:36   101.36        -0.536576    300.0  die_ahnungslosen
315  11:11:39   101.46        -0.424789    300.0  die_ahnungslosen
316  11:11:42   104.15         2.582271    300.0  die_ahnungslosen
317  11:11:45   101.36        -0.536576    300.0  die_ahnungslosen
318  11:11:48   101.00        -0.939008    300.0  die_ahnungslosen
319  11:11:51   101.91         0.078251    300.0  die_ahnungslosen
320  11:11:54   101.68        -0.178859    300.0  die_ahnungslosen
321  11:12:43   101.06         2.992196    350.0  die_ahnungslosen
323  11:12:46   100.17        -0.354551    350.0  die_ahnungslosen
324  11:12:49    99.98        -1.069025    350.0  die_ahnungslosen
325  11:12:52   100.07        -0.730590    350.0  die_ahnungslosen
326  11:12:55   100.21        -0.204135    350.0  die_ahnungslosen
327  11:12:58   100.21        -0.204135    350.0  die_ahnungslosen
328  11:13:01   100.14        -0.467363    350.0  die_ahnungslosen
329  11:13:04   100.17        -0.354551    350.0  die_ahnungslosen
330  11:13:07   100.28         0.059092    350.0  die_ahnungslosen
331  11:13:10   100.55         1.074397    350.0  die_ahnungslosen
332  11:13:13   100.14        -0.467363    350.0  die_ahnungslosen
333  11:13:16   100.17        -0.354551    350.0  die_ahnungslosen
334  11:13:19   100.17        -0.354551    350.0  die_ahnungslosen
335  11:13:22   100.38         0.435131    350.0  die_ahnungslosen
\end{verbatim}

Die Werte können mit der Pandas-Methode \texttt{pd.plot()} mit wenig
Aufwand dargestellt werden. Die Methode ist jedoch nicht so flexibel,
wie das Paket matplotlib. So ist das Punktdiagramm
(\texttt{kind\ =\ \textquotesingle{}scatter\textquotesingle{}}) nur für
DataFrames, nicht aber für groupby-Objekte verfügbar. Dies wird durch
das Setzen eines Markers und die Einstellung der Liniendicke auf 0
kompensiert.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{messreihen.reset\_index(drop }\OperatorTok{=} \VariableTok{True}\NormalTok{).groupby(by }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{], sort }\OperatorTok{=} \VariableTok{False}\NormalTok{)[}\StringTok{\textquotesingle{}Abstand\textquotesingle{}}\NormalTok{].plot(marker }\OperatorTok{=} \StringTok{\textquotesingle{}o\textquotesingle{}}\NormalTok{, lw }\OperatorTok{=} \DecValTok{0}\NormalTok{)}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Messwert\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Abstand\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/übung-hooke_files/figure-pdf/cell-18-output-1.png}}

~

Die Werte, die betragsmäßig studentisierte z-Werte \(\ge\) 2,5
aufweisen, könnten als Ausreißer entfernt werden. In diesem Fall wird
darauf verzichtet.

\subsection{Umwandlung der
Rechengrößen}\label{umwandlung-der-rechengruxf6uxdfen}

Im nächsten Schritt wird die Abstandsmessung auf den Nullpunkt normiert,
um die Federausdehnung abzubilden. Ebenso wird das Gewicht in \(g\) in
die wirkende Kraft in \(N\) umgerechnet.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-einheiten}: Musterlösung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-einheiten} 

\subsubsection{Abstandsmessung auf Meter und auf den Nullpunkt
normieren}\label{abstandsmessung-auf-meter-und-auf-den-nullpunkt-normieren}

Abstandsmessung auf den Nullpunkt normieren. Die Spalte Abstand wird in
Abständsänderung umbenannt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nullpunkte }\OperatorTok{=}\NormalTok{ hooke.loc[hooke[}\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{] }\OperatorTok{==} \DecValTok{0}\NormalTok{, : ].groupby(by }\OperatorTok{=} \StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{, sort }\OperatorTok{=} \VariableTok{False}\NormalTok{)[}\StringTok{\textquotesingle{}Abstand\textquotesingle{}}\NormalTok{].mean()}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Nullpunkte"}\NormalTok{, nullpunkte, sep }\OperatorTok{=} \StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}

\NormalTok{teams }\OperatorTok{=}\NormalTok{ nullpunkte.index}

\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(teams)):}

\NormalTok{  hooke.loc[hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ teams[i] , }\StringTok{\textquotesingle{}Abstand\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ hooke.loc[hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ teams[i] , }\StringTok{\textquotesingle{}Abstand\textquotesingle{}}\NormalTok{].sub(nullpunkte.values[i]).mul(}\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}

\NormalTok{hooke.rename(columns }\OperatorTok{=}\NormalTok{ \{}\StringTok{\textquotesingle{}Abstand\textquotesingle{}}\NormalTok{: }\StringTok{\textquotesingle{}Abstandsänderung\textquotesingle{}}\NormalTok{\}, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{hooke[}\StringTok{\textquotesingle{}Abstandsänderung\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}Abstandsänderung\textquotesingle{}}\NormalTok{].div(}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Nullpunkte
Team
kreativkoepfe       109.676667
fabi                110.366000
die_ahnungslosen    109.759000
ma                  109.258000
Name: Abstand, dtype: float64
\end{verbatim}

\subsubsection{Gewicht in wirkende Kraft
umrechnen}\label{gewicht-in-wirkende-kraft-umrechnen}

Gewicht in \(g\) in die wirkende Kraft in \(N\) umrechnen. Die Spalte
wird in den Datensatz eingefügt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hooke[}\StringTok{\textquotesingle{}Kraft\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{].div(}\DecValTok{1000}\NormalTok{).mul(}\FloatTok{9.81}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

Das Ergebnis könnte so aussehen. Die Spalte Abstand wurde in
Abständsänderung umbenannt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hooke.groupby(by }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Kraft\textquotesingle{}}\NormalTok{], sort }\OperatorTok{=} \VariableTok{False}\NormalTok{)[}\StringTok{\textquotesingle{}Abstandsänderung\textquotesingle{}}\NormalTok{].describe()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllllllll@{}}
\toprule\noalign{}
& & count & mean & std & min & 25\% & 50\% & 75\% & max \\
Team & Kraft & & & & & & & & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\multirow{12}{=}{kreativkoepfe} & 0.00000 & 9.0 & 7.894196e-17 &
0.000536 & -0.000633 & -0.000533 & 0.000367 & 0.000367 & 0.000567 \\
& 0.49050 & 8.0 & 1.119167e-02 & 0.004899 & 0.003467 & 0.008092 &
0.011817 & 0.014442 & 0.018367 \\
& 0.98100 & 10.0 & 2.583667e-02 & 0.009227 & 0.005667 & 0.024067 &
0.028017 & 0.032967 & 0.033767 \\
& 1.47150 & 10.0 & 3.742667e-02 & 0.006000 & 0.028367 & 0.033692 &
0.036567 & 0.040642 & 0.048067 \\
& 1.96200 & 10.0 & 4.223667e-02 & 0.016183 & 0.014067 & 0.029067 &
0.046417 & 0.056017 & 0.061567 \\
& 2.45250 & 10.0 & 7.149667e-02 & 0.007962 & 0.057867 & 0.069142 &
0.072667 & 0.075067 & 0.085767 \\
& 2.94300 & 10.0 & 8.440667e-02 & 0.007021 & 0.072267 & 0.078417 &
0.086667 & 0.089142 & 0.093867 \\
& 3.43350 & 10.0 & 1.087267e-01 & 0.014716 & 0.088367 & 0.093167 &
0.115217 & 0.121042 & 0.122467 \\
& 3.92400 & 9.0 & 1.284889e-01 & 0.010368 & 0.108967 & 0.122667 &
0.127767 & 0.137867 & 0.138767 \\
& 4.41450 & 9.0 & 1.416111e-01 & 0.011160 & 0.124367 & 0.138467 &
0.139267 & 0.150467 & 0.157667 \\
& 4.90500 & 8.0 & 1.434042e-01 & 0.015643 & 0.119867 & 0.131142 &
0.145367 & 0.152192 & 0.163767 \\
& 5.39550 & 9.0 & 1.652111e-01 & 0.003530 & 0.159167 & 0.162767 &
0.167267 & 0.168067 & 0.169167 \\
\multirow{10}{=}{fabi} & 0.00000 & 10.0 & 1.137111e-16 & 0.002537 &
-0.003740 & -0.002140 & 0.000560 & 0.000760 & 0.004160 \\
& 0.49050 & 12.0 & -5.983333e-04 & 0.002110 & -0.004040 & -0.002565 &
0.000560 & 0.000610 & 0.001460 \\
& 0.99081 & 9.0 & 2.127111e-02 & 0.002312 & 0.018960 & 0.019460 &
0.019560 & 0.023760 & 0.024060 \\
& 1.49112 & 10.0 & 3.464000e-02 & 0.003357 & 0.029360 & 0.033710 &
0.033860 & 0.037660 & 0.039160 \\
& 1.97181 & 10.0 & 5.113000e-02 & 0.010524 & 0.044660 & 0.047885 &
0.048960 & 0.049060 & 0.080660 \\
& 2.48193 & 11.0 & 6.086909e-02 & 0.004660 & 0.054560 & 0.057060 &
0.062660 & 0.064260 & 0.068160 \\
& 2.96262 & 12.0 & 7.716000e-02 & 0.003909 & 0.070160 & 0.073560 &
0.078060 & 0.079010 & 0.082760 \\
& 3.46293 & 11.0 & 9.692364e-02 & 0.001996 & 0.093360 & 0.095860 &
0.097860 & 0.098160 & 0.098660 \\
& 3.95343 & 14.0 & 1.091886e-01 & 0.004248 & 0.101060 & 0.107760 &
0.109560 & 0.112635 & 0.113960 \\
& 4.46355 & 11.0 & 1.252691e-01 & 0.002281 & 0.122160 & 0.123310 &
0.124860 & 0.127460 & 0.128560 \\
\multirow{10}{=}{die\_ahnungslosen} & 0.00000 & 10.0 & -1.420088e-16 &
0.001807 & -0.003310 & -0.000335 & 0.000290 & 0.001290 & 0.002090 \\
& 0.49050 & 8.0 & 8.465000e-03 & 0.001809 & 0.006490 & 0.007340 &
0.008290 & 0.008790 & 0.012290 \\
& 0.98100 & 12.0 & 2.033167e-02 & 0.007044 & 0.008390 & 0.016865 &
0.020240 & 0.025615 & 0.029990 \\
& 1.47150 & 19.0 & 3.493211e-02 & 0.007595 & 0.018890 & 0.030490 &
0.036390 & 0.040540 & 0.050890 \\
& 1.96200 & 18.0 & 5.142889e-02 & 0.003930 & 0.045290 & 0.049440 &
0.051690 & 0.054940 & 0.057990 \\
& 2.45250 & 18.0 & 6.852333e-02 & 0.002215 & 0.064290 & 0.067840 &
0.068690 & 0.069565 & 0.074090 \\
& 2.94300 & 11.0 & 7.919000e-02 & 0.008946 & 0.056090 & 0.079440 &
0.082990 & 0.083940 & 0.087590 \\
& 3.43350 & 14.0 & 9.494714e-02 & 0.002659 & 0.086990 & 0.094965 &
0.095890 & 0.096115 & 0.097790 \\
& 3.92400 & 11.0 & 1.051991e-01 & 0.002328 & 0.101890 & 0.103440 &
0.106290 & 0.107090 & 0.108190 \\
& 4.41450 & 12.0 & 1.171650e-01 & 0.004680 & 0.106790 & 0.114740 &
0.117890 & 0.120840 & 0.122490 \\
\multirow{18}{=}{ma} & 0.00000 & 10.0 & -7.105997e-17 & 0.000424 &
-0.000520 & -0.000220 & -0.000020 & -0.000020 & 0.000780 \\
& 0.49050 & 10.0 & 2.079000e-02 & 0.018096 & -0.015520 & 0.013005 &
0.030730 & 0.031705 & 0.034280 \\
& 0.98100 & 10.0 & 7.157000e-02 & 0.029588 & 0.025880 & 0.047755 &
0.081380 & 0.095855 & 0.098880 \\
& 1.47150 & 11.0 & 2.601636e-02 & 0.047280 & -0.013420 & -0.009020 &
-0.004720 & 0.082680 & 0.089680 \\
& 1.96200 & 9.0 & 8.013333e-03 & 0.016668 & -0.018020 & -0.009120 &
0.015180 & 0.019680 & 0.025180 \\
& 2.45250 & 10.0 & 2.327000e-02 & 0.009578 & 0.014580 & 0.015605 &
0.017180 & 0.033255 & 0.035980 \\
& 2.94300 & 10.0 & 3.562000e-02 & 0.001944 & 0.033180 & 0.033930 &
0.035430 & 0.037505 & 0.037980 \\
& 3.43350 & 10.0 & 4.420000e-02 & 0.005309 & 0.033180 & 0.041105 &
0.045730 & 0.047430 & 0.051580 \\
& 3.92400 & 10.0 & 4.468000e-02 & 0.006030 & 0.031680 & 0.045655 &
0.047080 & 0.047805 & 0.049480 \\
& 4.41450 & 10.0 & 4.741000e-02 & 0.004755 & 0.036980 & 0.045455 &
0.047480 & 0.050355 & 0.053480 \\
& 4.90500 & 10.0 & 4.802000e-02 & 0.005691 & 0.035480 & 0.046180 &
0.048380 & 0.051655 & 0.056080 \\
& 5.39550 & 10.0 & 6.254000e-02 & 0.008005 & 0.050580 & 0.057580 &
0.061930 & 0.064930 & 0.077080 \\
& 5.88600 & 10.0 & 7.855000e-02 & 0.006212 & 0.073180 & 0.074780 &
0.076780 & 0.077580 & 0.090380 \\
& 6.37650 & 10.0 & 9.149000e-02 & 0.000825 & 0.090480 & 0.090705 &
0.091480 & 0.092105 & 0.092880 \\
& 6.86700 & 10.0 & 1.038700e-01 & 0.005342 & 0.092380 & 0.100730 &
0.105430 & 0.107155 & 0.110180 \\
& 7.35750 & 9.0 & 1.129133e-01 & 0.007293 & 0.104880 & 0.105780 &
0.112780 & 0.117580 & 0.123980 \\
& 7.84800 & 11.0 & 1.214255e-01 & 0.005402 & 0.115380 & 0.117530 &
0.119280 & 0.125580 & 0.130680 \\
& 8.33850 & 8.0 & 1.354300e-01 & 0.002458 & 0.131880 & 0.133805 &
0.135080 & 0.136955 & 0.139080 \\
\end{longtable}

\subsection{Grafische Darstellung}\label{grafische-darstellung-1}

Da es nur vier Teams gibt, können die Messreihen grafisch dargestellt
werden. Eine mögliche Darstellung können Sie dem ersten Reiter, die
Zwischenschritte und Schlussfolgerungen den folgenden Reitern entnehmen.

\section{Grafische Darstellung}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/übung-hooke_files/figure-pdf/cell-22-output-1.png}}

\section{Mittelwerte und Standardfehler berechnen}

Die Ausgabe ist aus Platzgründen auf die ersten Zeilen beschränkt.

\begin{verbatim}
Mittelwerte der Abstandsänderung nach Team und Kraft:
Team           Kraft 
kreativkoepfe  0.0000    7.895401e-17
               0.4905    1.119167e-02
               0.9810    2.583667e-02
               1.4715    3.742667e-02
               1.9620    4.223667e-02
Name: Federausdehnung, dtype: float64

Standardfehler der Mittelwerte nach Team und Kraft
Team           Kraft 
kreativkoepfe  0.0000    0.000179
               0.4905    0.001732
               0.9810    0.002918
               1.4715    0.001897
               1.9620    0.005117
Name: Standardfehler, dtype: float64
\end{verbatim}

\section{Code}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Mittelwerte der Teams nach Kraft}
\NormalTok{distance\_means\_by\_team\_and\_force }\OperatorTok{=}\NormalTok{ hooke.groupby(by }\OperatorTok{=}\NormalTok{ [hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{], hooke[}\StringTok{\textquotesingle{}Kraft\textquotesingle{}}\NormalTok{]], sort }\OperatorTok{=} \VariableTok{False}\NormalTok{)[}\StringTok{\textquotesingle{}Abstandsänderung\textquotesingle{}}\NormalTok{].mean()}
\NormalTok{distance\_means\_by\_team\_and\_force.name }\OperatorTok{=} \StringTok{\textquotesingle{}Federausdehnung\textquotesingle{}}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Mittelwerte der Abstandsänderung nach Team und Kraft:"}\NormalTok{, distance\_means\_by\_team\_and\_force.head(), sep }\OperatorTok{=} \StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}

\BuiltInTok{print}\NormalTok{() }\CommentTok{\# leere Zeile}

\CommentTok{\# Standardfehler der Teams nach Kraft}
\NormalTok{distance\_stderrors\_by\_team\_and\_force }\OperatorTok{=}\NormalTok{ hooke.groupby(by }\OperatorTok{=}\NormalTok{ [hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{], hooke[}\StringTok{\textquotesingle{}Kraft\textquotesingle{}}\NormalTok{]], sort }\OperatorTok{=} \VariableTok{False}\NormalTok{)[}\StringTok{\textquotesingle{}Abstandsänderung\textquotesingle{}}\NormalTok{].std(ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{).div(np.sqrt(hooke[}\StringTok{\textquotesingle{}Abstandsänderung\textquotesingle{}}\NormalTok{].groupby(by }\OperatorTok{=}\NormalTok{ [hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{], hooke[}\StringTok{\textquotesingle{}Kraft\textquotesingle{}}\NormalTok{]], sort }\OperatorTok{=} \VariableTok{False}\NormalTok{).size()))}
\NormalTok{distance\_stderrors\_by\_team\_and\_force.name }\OperatorTok{=} \StringTok{\textquotesingle{}Standardfehler\textquotesingle{}}

\BuiltInTok{print}\NormalTok{(}\StringTok{"Standardfehler der Mittelwerte nach Team und Kraft"}\NormalTok{, distance\_stderrors\_by\_team\_and\_force.head(), sep }\OperatorTok{=} \StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}

\CommentTok{\# grafische Darstellung}
\NormalTok{anzahl\_teams }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{].unique().size}

\NormalTok{plt.figure(figsize }\OperatorTok{=}\NormalTok{ (}\FloatTok{7.5}\NormalTok{, }\DecValTok{12}\NormalTok{))}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(anzahl\_teams):}
  
\NormalTok{  plt.subplot(}\DecValTok{4}\NormalTok{, }\DecValTok{1}\NormalTok{, i }\OperatorTok{+} \DecValTok{1}\NormalTok{) }\CommentTok{\# plt.subplot zählt ab 1}

  \CommentTok{\# Punktdiagramm}
\NormalTok{  plotting\_data }\OperatorTok{=}\NormalTok{ hooke.loc[hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{].unique()[i], :]}
\NormalTok{  plt.scatter(x }\OperatorTok{=}\NormalTok{ plotting\_data[}\StringTok{\textquotesingle{}Abstandsänderung\textquotesingle{}}\NormalTok{], y }\OperatorTok{=}\NormalTok{ plotting\_data[}\StringTok{\textquotesingle{}Kraft\textquotesingle{}}\NormalTok{], alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{)}

\NormalTok{  plt.title(label }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{].unique()[i])}
\NormalTok{  plt.xlabel(}\StringTok{"Federausdehnung in m"}\NormalTok{)}
\NormalTok{  plt.ylabel(}\StringTok{"wirkende Kraft in N"}\NormalTok{)}

  \CommentTok{\# \# Fehlerbalken}
\NormalTok{  distance\_means\_by\_force }\OperatorTok{=}\NormalTok{ plotting\_data.groupby(by }\OperatorTok{=}\NormalTok{ plotting\_data[}\StringTok{\textquotesingle{}Kraft\textquotesingle{}}\NormalTok{], sort }\OperatorTok{=} \VariableTok{False}\NormalTok{)[}\StringTok{\textquotesingle{}Abstandsänderung\textquotesingle{}}\NormalTok{].mean()}
\NormalTok{  distance\_stderrors\_by\_force }\OperatorTok{=}\NormalTok{ plotting\_data.groupby(by }\OperatorTok{=}\NormalTok{ plotting\_data[}\StringTok{\textquotesingle{}Kraft\textquotesingle{}}\NormalTok{], sort }\OperatorTok{=} \VariableTok{False}\NormalTok{)[}\StringTok{\textquotesingle{}Abstandsänderung\textquotesingle{}}\NormalTok{].std(ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{).div(np.sqrt(plotting\_data[}\StringTok{\textquotesingle{}Abstandsänderung\textquotesingle{}}\NormalTok{].groupby(by }\OperatorTok{=}\NormalTok{ plotting\_data[}\StringTok{\textquotesingle{}Kraft\textquotesingle{}}\NormalTok{], sort }\OperatorTok{=} \VariableTok{False}\NormalTok{).size()))}

\NormalTok{  errorbar\_container }\OperatorTok{=}\NormalTok{ plt.errorbar(x }\OperatorTok{=}\NormalTok{ distance\_means\_by\_force, y }\OperatorTok{=}\NormalTok{ distance\_means\_by\_force.index, xerr }\OperatorTok{=}\NormalTok{ distance\_stderrors\_by\_force,}
\NormalTok{  linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}none\textquotesingle{}}\NormalTok{, marker }\OperatorTok{=} \StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, markersize }\OperatorTok{=} \DecValTok{12}\NormalTok{, elinewidth }\OperatorTok{=} \DecValTok{3}\NormalTok{, ecolor }\OperatorTok{=} \StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{, capsize }\OperatorTok{=} \DecValTok{12}\NormalTok{)}

  \CommentTok{\# siehe: https://matplotlib.org/stable/api/container\_api.html\#matplotlib.container.ErrorbarContainer}
\NormalTok{  plt.legend([errorbar\_container.lines[}\DecValTok{0}\NormalTok{], errorbar\_container.lines[}\DecValTok{2}\NormalTok{][}\DecValTok{0}\NormalTok{]],}
\NormalTok{             [}\StringTok{\textquotesingle{}Mittelwert\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Standardfehler\textquotesingle{}}\NormalTok{],}
\NormalTok{             loc }\OperatorTok{=} \StringTok{\textquotesingle{}upper left\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.tight\_layout()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\section{Auswertung}

\begin{itemize}
\tightlist
\item
  Die Messreihen des Teams die\_ahnungslosen entsprechen dem erwarteten
  linearen Trend.
\item
  Bei Team fabi scheint für das erste angehängte Gewicht (50 Gramm) ein
  Fehler bei der Datenerhebung vorzuliegen. Vermutlich wurde hier mit 0
  Gramm gemessen.
\item
  Die Messreihen des Teams kreativköpfe entsprechen weitgehend dem
  erwarteten linearen Trend.
\item
  Die Messreihen des Teams ma scheinen wenigstens für die ersten vier
  angehängten Gewichten durch grobe Messfehler geprägt zu sein.
\end{itemize}

Die Messreihe des Teams ma wird wegen grober Messfehler aus dem
Datensatz entfernt. Aus der Messreihe des Teams fabi wird die Messung
für das Gewicht 50 Gramm entfernt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hooke.drop(index }\OperatorTok{=}\NormalTok{ hooke.loc[hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{] }\OperatorTok{==} \StringTok{\textquotesingle{}ma\textquotesingle{}}\NormalTok{, :].index, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{hooke.drop(index }\OperatorTok{=}\NormalTok{ hooke.loc[(hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{] }\OperatorTok{==} \StringTok{\textquotesingle{}fabi\textquotesingle{}}\NormalTok{) }\OperatorTok{\&}\NormalTok{ (hooke[}\StringTok{\textquotesingle{}Gewicht\textquotesingle{}}\NormalTok{] }\OperatorTok{==} \DecValTok{50}\NormalTok{), :].index, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

~

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-vieledatensätze}: Vorgehen bei vielen Datensätzen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-vieledatensätze} 

Bei einer großen Anzahl an Datensätzen kann auch die grafische Kontrolle
an Grenzen stoßen. In diesem Fall empfiehlt es sich, die visuellen und
kennzahlenbasierten Methoden zusammen zu nutzen, um Muster zu
identifizieren und für eine große Zahl von Messungen zu überprüfen.
Beispielsweise könnten nach einer visuellen Inspektion von Messreihen
mit Extremwerten bzw. Ausreißern alle Messreihen daraufhin überprüft
werden, ob mit zunehmenden Gewicht stets auch die mittlere
Federausdehnung größer als für leichtere Gewichte ist. Abweichende
Messreihen könnten dann grafisch kontrolliert werden.

\end{tcolorbox}

\section{Musterlösung Federkonstanten
bestimmen}\label{sec-luxf6sung-federkonstanten}

Im nächsten Schritt können die Federkonstanten mittels linearer
Regression bestimmt werden.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  \textbf{Welche Werte können für die Federkonstanten ermittelt
  werden?}\\
\item
  \textbf{Wurden die Messungen mit der gleichen Feder durchgeführt, wenn
  als Vertrauenswahrscheinlichkeit 90 \% bzw. 95 \% angenommen werden
  soll?}
\end{enumerate}

\section{\texorpdfstring{\(\alpha = 0.10\)}{\textbackslash alpha = 0.10}}

\begin{verbatim}

kreativkoepfe Konfidenzniveau: 0.9
y = 0.3180 + 29.7643 * x
r = 0.9773 R2 = 0.9552 p = 0.0000
Standardfehler des Anstiegs: 0.6148
28.744  ≤ 29.764 ≤ 30.784

fabi Konfidenzniveau: 0.9
y = 0.2373 + 34.1048 * x
r = 0.9907 R2 = 0.9814 p = 0.0000
Standardfehler des Anstiegs: 0.4792
33.309  ≤ 34.105 ≤ 34.901

die_ahnungslosen Konfidenzniveau: 0.9
y = 0.1798 + 34.9183 * x
r = 0.9886 R2 = 0.9773 p = 0.0000
Standardfehler des Anstiegs: 0.4651
34.148  ≤ 34.918 ≤ 35.689
\end{verbatim}

\section{\texorpdfstring{\(\alpha = 0.05\)}{\textbackslash alpha = 0.05}}

\begin{verbatim}

kreativkoepfe Konfidenzniveau: 0.95
y = 0.3180 + 29.7643 * x
r = 0.9773 R2 = 0.9552 p = 0.0000
Standardfehler des Anstiegs: 0.6148
28.546  ≤ 29.764 ≤ 30.983

fabi Konfidenzniveau: 0.95
y = 0.2373 + 34.1048 * x
r = 0.9907 R2 = 0.9814 p = 0.0000
Standardfehler des Anstiegs: 0.4792
33.154  ≤ 34.105 ≤ 35.056

die_ahnungslosen Konfidenzniveau: 0.95
y = 0.1798 + 34.9183 * x
r = 0.9886 R2 = 0.9773 p = 0.0000
Standardfehler des Anstiegs: 0.4651
33.998  ≤ 34.918 ≤ 35.838
\end{verbatim}

\section{Code}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{anzahl\_teams }\OperatorTok{=}\NormalTok{ hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{].unique().size}
\NormalTok{alpha }\OperatorTok{=} \FloatTok{0.10}

\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(anzahl\_teams):}

\NormalTok{  reg\_data }\OperatorTok{=}\NormalTok{ hooke.loc[hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{].unique()[i], :]}
\NormalTok{  x }\OperatorTok{=}\NormalTok{ reg\_data[}\StringTok{\textquotesingle{}Abstandsänderung\textquotesingle{}}\NormalTok{]}
\NormalTok{  y }\OperatorTok{=}\NormalTok{ reg\_data[}\StringTok{\textquotesingle{}Kraft\textquotesingle{}}\NormalTok{]}
\NormalTok{  n }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(x)}
  
  \BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{].unique()[i], }\StringTok{" Konfidenzniveau: "}\NormalTok{, }\DecValTok{1} \OperatorTok{{-}}\NormalTok{ alpha, sep }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}

\NormalTok{  slope, intercept, rvalue, pvalue, slope\_stderr }\OperatorTok{=}\NormalTok{ scipy.stats.linregress(x, y)}
  \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"y = }\SpecialCharTok{\{}\NormalTok{intercept}\SpecialCharTok{:.4f\}}\SpecialStringTok{ + }\SpecialCharTok{\{}\NormalTok{slope}\SpecialCharTok{:.4f\}}\SpecialStringTok{ * x}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
        \SpecialStringTok{f"r = }\SpecialCharTok{\{}\NormalTok{rvalue}\SpecialCharTok{:.4f\}}\SpecialStringTok{ R2 = }\SpecialCharTok{\{}\NormalTok{rvalue }\OperatorTok{**} \DecValTok{2}\SpecialCharTok{:.4f\}}\SpecialStringTok{ p = }\SpecialCharTok{\{}\NormalTok{pvalue}\SpecialCharTok{:.4f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
        \SpecialStringTok{f"Standardfehler des Anstiegs: }\SpecialCharTok{\{}\NormalTok{slope\_stderr}\SpecialCharTok{:.4f\}}\SpecialStringTok{"}\NormalTok{, sep }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}

  \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{slope }\OperatorTok{{-}}\NormalTok{ scipy}\SpecialCharTok{.}\NormalTok{stats}\SpecialCharTok{.}\NormalTok{t}\SpecialCharTok{.}\NormalTok{ppf(q }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ alpha }\OperatorTok{/} \DecValTok{2}\NormalTok{, df }\OperatorTok{=}\NormalTok{ n }\OperatorTok{{-}} \DecValTok{2}\NormalTok{) }\OperatorTok{*}\NormalTok{ slope\_stderr}\SpecialCharTok{:.3f\}}\SpecialStringTok{  ≤ }\SpecialCharTok{\{}\NormalTok{slope}\SpecialCharTok{:.3f\}}\SpecialStringTok{ ≤ }\SpecialCharTok{\{}\NormalTok{slope }\OperatorTok{+}\NormalTok{ scipy}\SpecialCharTok{.}\NormalTok{stats}\SpecialCharTok{.}\NormalTok{t}\SpecialCharTok{.}\NormalTok{ppf(q }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ alpha }\OperatorTok{/} \DecValTok{2}\NormalTok{, df }\OperatorTok{=}\NormalTok{ n }\OperatorTok{{-}} \DecValTok{2}\NormalTok{) }\OperatorTok{*}\NormalTok{ slope\_stderr}\SpecialCharTok{:.3f\}}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{alpha }\OperatorTok{=} \FloatTok{0.05}

\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(anzahl\_teams):}

\NormalTok{  reg\_data }\OperatorTok{=}\NormalTok{ hooke.loc[hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{] }\OperatorTok{==}\NormalTok{ hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{].unique()[i], :]}
\NormalTok{  x }\OperatorTok{=}\NormalTok{ reg\_data[}\StringTok{\textquotesingle{}Abstandsänderung\textquotesingle{}}\NormalTok{]}
\NormalTok{  y }\OperatorTok{=}\NormalTok{ reg\_data[}\StringTok{\textquotesingle{}Kraft\textquotesingle{}}\NormalTok{]}
\NormalTok{  n }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(x)}
  
  \BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, hooke[}\StringTok{\textquotesingle{}Team\textquotesingle{}}\NormalTok{].unique()[i], }\StringTok{" Konfidenzniveau: "}\NormalTok{, }\DecValTok{1} \OperatorTok{{-}}\NormalTok{ alpha, sep }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}

\NormalTok{  slope, intercept, rvalue, pvalue, slope\_stderr }\OperatorTok{=}\NormalTok{ scipy.stats.linregress(x, y)}
  \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"y = }\SpecialCharTok{\{}\NormalTok{intercept}\SpecialCharTok{:.4f\}}\SpecialStringTok{ + }\SpecialCharTok{\{}\NormalTok{slope}\SpecialCharTok{:.4f\}}\SpecialStringTok{ * x}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
        \SpecialStringTok{f"r = }\SpecialCharTok{\{}\NormalTok{rvalue}\SpecialCharTok{:.4f\}}\SpecialStringTok{ R2 = }\SpecialCharTok{\{}\NormalTok{rvalue }\OperatorTok{**} \DecValTok{2}\SpecialCharTok{:.4f\}}\SpecialStringTok{ p = }\SpecialCharTok{\{}\NormalTok{pvalue}\SpecialCharTok{:.4f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
        \SpecialStringTok{f"Standardfehler des Anstiegs: }\SpecialCharTok{\{}\NormalTok{slope\_stderr}\SpecialCharTok{:.4f\}}\SpecialStringTok{"}\NormalTok{, sep }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}

  \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{slope }\OperatorTok{{-}}\NormalTok{ scipy}\SpecialCharTok{.}\NormalTok{stats}\SpecialCharTok{.}\NormalTok{t}\SpecialCharTok{.}\NormalTok{ppf(q }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ alpha }\OperatorTok{/} \DecValTok{2}\NormalTok{, df }\OperatorTok{=}\NormalTok{ n }\OperatorTok{{-}} \DecValTok{2}\NormalTok{) }\OperatorTok{*}\NormalTok{ slope\_stderr}\SpecialCharTok{:.3f\}}\SpecialStringTok{  ≤ }\SpecialCharTok{\{}\NormalTok{slope}\SpecialCharTok{:.3f\}}\SpecialStringTok{ ≤ }\SpecialCharTok{\{}\NormalTok{slope }\OperatorTok{+}\NormalTok{ scipy}\SpecialCharTok{.}\NormalTok{stats}\SpecialCharTok{.}\NormalTok{t}\SpecialCharTok{.}\NormalTok{ppf(q }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ alpha }\OperatorTok{/} \DecValTok{2}\NormalTok{, df }\OperatorTok{=}\NormalTok{ n }\OperatorTok{{-}} \DecValTok{2}\NormalTok{) }\OperatorTok{*}\NormalTok{ slope\_stderr}\SpecialCharTok{:.3f\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\section{Auswertung}

Die Punktschätzung der Federkonstante von Team fabi 34.105 liegt im
95-\%-Konfidenzintervall der Messung von Team die\_ahnungslosen 33.998 ≤
34.918 ≤ 35.838. Die Punktschätzung der Federkonstante von Team fabi
34.105 liegt \textbf{aber nicht im 90-\%-Konfidenzintervall} der Messung
von Team die\_ahnungslosen 34.148 ≤ 34.918 ≤ 35.689.

Unabhängig vom gewählten Vertrauensniveau liegt die Punktschätzung der
Federkonstante von Team kreativkoepfe 29.764 nicht in den
Konfidenzintervallen der beiden übrigen Teams.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-results} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-results}: Ergebnisse}\vspace{3mm}

Abhängig vom gewählten Vorgehen sind andere Ergebnisse möglich,
beispielsweise durch das Entfernen von als Ausreißern eingestuften
Einzelwerten oder einer anderen Behandlung der Messreihe vom Team fabi
für das angehängte Gewicht 50 Gramm.

\end{minipage}%
\end{tcolorbox}

\chapter{Kalibrierung}\label{kalibrierung}

Die Genauigkeit von Messungen wird durch die Korrektion systemtischer
Messabweichungen verbessert. In diesem Kapitel werden typische
\emph{Fehlerarten} bei Messungen behandelt:

\begin{itemize}
\tightlist
\item
  additive Fehler,
\item
  multiplikative Fehler und
\item
  Nichtlinearität.
\end{itemize}

In diesem Abschnitt greifen wir die etablierten Begriffe auf, auch wenn
die Fehler besser als systematische Messabweichungen bezeichnet werden
sollten.

\section{Kalibrieren und Justieren}\label{kalibrieren-und-justieren}

Die Korrektion systemtischer Messabweichungen kann auf zwei Arten
geschehen: durch Kalibrierung oder Justierung des Messgeräts.

Mit dem Begriff Kalibrierung wird im engeren Sinn die Ermittlung des
Zusammenhangs zwischen Messwerten bzw. ihres arithmetischen Mittelwerts
und dem vereinbarten richtigen Wert der Messgröße bezeichnet.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-kalibrierung1}: Kalibrierung nach DIN 1319}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-kalibrierung1} 

``Ermitteln des Zusammenhangs zwischen Meßwert {[}\ldots{]} oder
Erwartungswert {[}\ldots{]} der Ausgangsgröße {[}\ldots{]} und dem
zugehörigen wahren {[}\ldots{]} oder richtigen Wert {[}\ldots{]} der als
Eingangsgröße vorliegenden Meßgröße für eine betrachtete Meßeinrichtung
{[}\ldots{]}.'' {[}@DIN1319-1, S. 22{]}

\end{tcolorbox}

Im weiteren Sinn ist mit Kalibrierung auch ``die Erstellung einer
Korrektionstabelle {[}\ldots{]}, die Ermittlung von Kalibrierfaktoren
oder einer (empirischen) Kalibrierfunktion'' {[}@DIN1319-1, S. 22{]}
gemeint. Dabei handelt es sich um Methoden, um mit systematischen
Messabweichungen behaftete Messwerte zu korrigieren, ohne das Messgerät
zu verändern.

Im Unterschied dazu verändert die Justierung das Messgerät dauerhaft.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-justierung}: Justierung nach DIN 1319}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-justierung} 

``Einstellen oder Abgleichen eines Meßgeräts {[}\ldots{]}, um
systematische Meßabweichungen {[}\ldots{]} soweit zu beseitigen, wie es
für die vorgesehene Anwendung erforderlich ist.'' {[}@DIN1319-1, S.
22{]}

\end{tcolorbox}

\section{Kalibriermethoden nach DIN
1319}\label{kalibriermethoden-nach-din-1319}

In der DIN 1319 werden drei Kalibriermethoden genannt, die hier nur kurz
behandelt werden:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Korrektionstabelle,
\item
  Ermittlung von Kalibrierfaktoren und
\item
  Ermittlung einer (empirischen) Kalibrierfunktion.
\end{enumerate}

Welche Methode verwendet wird, hängt von dem Anwendungsbereich, der
Datenverfügbarkeit sowie von der gewünschten Genauigkeit ab.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1849}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2689}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2689}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2773}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Methode
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Anwendung bei \ldots{}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Vorteile
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Nachteile
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Korrektionstabelle} & nichtlinear, schwer modellierbar & einfach
zu nutzen & viele Daten erforderlich, sonst Interpolation ungenau \\
\textbf{Kalibrierfaktoren} & lineare Abweichung & leicht umsetzbar &
unzureichend bei Nichtlinearität \\
\textbf{Kalibrierfunktion} & nichtlinear, modellierbar & sehr genau &
höherer Aufwand \\
\end{longtable}

\subsection{Korrektionstabelle}\label{korrektionstabelle}

Mit der Korrektionstabelle können beliebige Korrektionen dargestellt
werden, sofern ausreichend Datenpunkte verfügbar sind. In
Section~\ref{sec-pt100} werden wir ein Beispiel für eine
Korrektionstabelle kennenlernen.

\subsection{Ermittlung von
Kalibrierfaktoren}\label{ermittlung-von-kalibrierfaktoren}

Ein Kalibrierfaktor kann angegeben werden, wenn eine konstante relative
Abweichung vorliegt. Ein Beispiel aus der Praxis ist
\href{https://www.lanuk.nrw.de/fileadmin/lanuv/luft/immissionen/ber_trend/Aequivalenznachweis/AEquivalenztest_und_Faktorenbestimmung_2023.pdf}{hier
auf Seite 1} zu finden.

\subsection{Ermittlung einer (empirischen)
Kalibrierfunktion}\label{ermittlung-einer-empirischen-kalibrierfunktion}

Eine Kalibrierfunktion erlaubt die Modellierung komplexer Zusammenhänge.
Die Methoden dafür werden im
\href{https://bausteine-der-datenanalyse.github.io/m-datenfitting-und-optimierung/output/book/}{Methodenbaustein
Datenfitting und Datenoptimierung} vorgestellt.

\section{Additive Fehler: Der
Nullpunktfehler}\label{additive-fehler-der-nullpunktfehler}

Der Nullpunktfehler beschreibt die Abweichung der Messgröße von Null,
wenn der gesuchte Wert tatsächlich Null ist. Der Nullpunktfehler wird
auch als Nullabgleich, Nullpunktverschiebung oder Offset-Fehler
bezeichnet. Der Nullpunktfehler ist konstant und wirkt additiv auf jeden
Messwert.
(\href{https://www.ics-schneider.de/wie-wirken-sich-nullpunktfehler-spannfehler-und-nichtlinearitaet-auf-die-genauigkeit-von-drucksensoren-aus/}{ics
Schneider Messtechnik})

\[
\text{Messwerte} = \text{wahre Werte} + \text{Nullpunktfehler}
\]

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Daten erzeugen}
\NormalTok{messgröße }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{0}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\NormalTok{messwerte }\OperatorTok{=}\NormalTok{ messgröße }\OperatorTok{+} \DecValTok{4}

\CommentTok{\# plotten}
\NormalTok{plt.plot(messgröße, marker }\OperatorTok{=} \StringTok{\textquotesingle{}o\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}wahrer Wert\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(messwerte, marker }\OperatorTok{=} \StringTok{\textquotesingle{}\^{}\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}gemessener Wert\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot([}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{], [messgröße[}\DecValTok{0}\NormalTok{], messwerte[}\DecValTok{0}\NormalTok{]], linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}dashed\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Nullpunktfehler\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot([}\DecValTok{4}\NormalTok{, }\DecValTok{4}\NormalTok{], [messgröße[}\DecValTok{4}\NormalTok{], messwerte[}\DecValTok{4}\NormalTok{]], linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}dashed\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot([}\DecValTok{8}\NormalTok{, }\DecValTok{8}\NormalTok{], [messgröße[}\DecValTok{8}\NormalTok{], messwerte[}\DecValTok{8}\NormalTok{]], linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}dashed\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Achsenbeschriftung}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Index\textquotesingle{}}\NormalTok{) }
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Merkmalsausprägung\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.legend()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/kalibrierung_files/figure-pdf/cell-3-output-1.png}}

~

\subsection{Nullpunktfehler
quantifizieren}\label{nullpunktfehler-quantifizieren}

Der Nullpunktfehler kann leicht bestimmt werden, wenn Messwerte für den
Nullpunkt vorliegen und der wahre Wert bekannt ist. (Wenn außerdem
bekannt ist, dass keine weiteren systematischen Messabweichungen
vorliegen, kann der Nullpunktfehler über einen beliebigen wahren
Referenzwert bestimmt werden.) Für die zur grafischen Darstellung
angelegten Daten ist dies der Fall.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Nullpunktfehler beträgt: }\SpecialCharTok{\{}\NormalTok{messwerte[}\DecValTok{0}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ messgr}\SpecialCharTok{öß}\NormalTok{e[}\DecValTok{0}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der Nullpunktfehler beträgt: 4
\end{verbatim}

Wenn keine Daten für den Nullpunkt vorliegen, kann der Nullpunktfehler
mit linearer Regression aus mindestens zwei bekannten Referenzpunkten
geschätzt werden. Dazu wird wird eine lineare Regression mit den
bekannten Referenzwerten als unabhängige Größe \(x\) und den Messwerten
als abhängige Größe \(y\) durchgeführt. Der y-Achsenabschnitt der
Regressionsgeraden ist der Nullpunktfehler.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# bekannte Referenzpunkte }
\NormalTok{x1 }\OperatorTok{=} \DecValTok{4}
\NormalTok{x2 }\OperatorTok{=} \DecValTok{8}
\NormalTok{y1 }\OperatorTok{=}\NormalTok{ messgröße[x1]}
\NormalTok{y2 }\OperatorTok{=}\NormalTok{ messgröße[x2]}

\CommentTok{\# Nullpunktfehler bestimmen}
\NormalTok{lm\_referenzpunkte }\OperatorTok{=}\NormalTok{ poly.polyfit(x }\OperatorTok{=}\NormalTok{ [messgröße[x1], messgröße[x2]], y }\OperatorTok{=}\NormalTok{ [messwerte[x1], messwerte[x2]], deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Nullpunktfehler beträgt: }\SpecialCharTok{\{}\BuiltInTok{round}\NormalTok{(lm\_referenzpunkte[}\DecValTok{0}\NormalTok{], }\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der Nullpunktfehler beträgt: 4.0
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-regression} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-regression}: Regression}\vspace{3mm}

Eine Schätzung der Regressionsgeraden aus 2 Punkten ist im Allgemeinen
weniger zuverlässig als eine Schätzung aus mehreren Messpunkten. Die
Beispieldaten sind perfekt linear.

\end{minipage}%
\end{tcolorbox}

Grafisch wird das Vorgehen deutlich.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# lineare Funktionen berechnen}
\NormalTok{lm\_kennlinie }\OperatorTok{=}\NormalTok{ poly.polyfit(x }\OperatorTok{=}\NormalTok{ [x1, x2], y }\OperatorTok{=}\NormalTok{ [y1, y2], deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{geschätzte\_ideale\_kennlinie }\OperatorTok{=}\NormalTok{ poly.polyval(x }\OperatorTok{=}\NormalTok{ np.arange(messwerte.size), c }\OperatorTok{=}\NormalTok{ lm\_kennlinie)}

\NormalTok{lm\_messwerte }\OperatorTok{=}\NormalTok{ poly.polyfit(x }\OperatorTok{=}\NormalTok{ [x1, x2], y }\OperatorTok{=}\NormalTok{ [messwerte[x1], messwerte[x2]], deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{lineare\_funktion\_messwerte }\OperatorTok{=}\NormalTok{ poly.polyval(x }\OperatorTok{=}\NormalTok{ np.arange(messwerte.size), c }\OperatorTok{=}\NormalTok{ lm\_messwerte)}

\CommentTok{\# plotten}
\CommentTok{\#\# Punkte}
\NormalTok{plt.plot([x1, x2], [y1, y2], marker }\OperatorTok{=} \StringTok{\textquotesingle{}o\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}none\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}bekannte Referenzwerte\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot([x1, x2], [messwerte[x1], messwerte[x2]], marker }\OperatorTok{=} \StringTok{\textquotesingle{}\^{}\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}none\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Messwerte an Referenzpunkten\textquotesingle{}}\NormalTok{)}

\CommentTok{\#\# Linien}
\NormalTok{plt.plot(np.arange(messwerte.size), geschätzte\_ideale\_kennlinie, marker }\OperatorTok{=} \StringTok{\textquotesingle{}none\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}dashed\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}ideale Kennlinie\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(np.arange(messwerte.size), lineare\_funktion\_messwerte , marker }\OperatorTok{=} \StringTok{\textquotesingle{}none\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}dashed\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}lineare Funktion Messwerte\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.plot([}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{], [messgröße[}\DecValTok{0}\NormalTok{], messwerte[}\DecValTok{0}\NormalTok{]], linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}dashed\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Nullpunktfehler\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot([}\DecValTok{4}\NormalTok{, }\DecValTok{4}\NormalTok{], [messgröße[}\DecValTok{4}\NormalTok{], messwerte[}\DecValTok{4}\NormalTok{]], linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}dashed\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot([}\DecValTok{8}\NormalTok{, }\DecValTok{8}\NormalTok{], [messgröße[}\DecValTok{8}\NormalTok{], messwerte[}\DecValTok{8}\NormalTok{]], linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}dashed\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.legend()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/kalibrierung_files/figure-pdf/cell-6-output-1.png}}

~

\subsection{Nullpunktfehler
korrigieren}\label{nullpunktfehler-korrigieren}

Der Nullpunktfehler wird durch Subtraktion von den Messwerten
korrigiert.

\[
\text{wahre Werte} = \text{Messwerte} - \text{Nullpunktfehler}
\]

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Daten erzeugen}
\NormalTok{messgröße }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{0}\NormalTok{, }\DecValTok{11}\NormalTok{) }\OperatorTok{+} \DecValTok{5}
\NormalTok{messwerte }\OperatorTok{=}\NormalTok{ messgröße }\OperatorTok{+} \FloatTok{2.5}

\CommentTok{\# bekannte Referenzpunkte }
\NormalTok{x1 }\OperatorTok{=} \DecValTok{2}
\NormalTok{x2 }\OperatorTok{=} \DecValTok{5}
\NormalTok{y1 }\OperatorTok{=}\NormalTok{ messgröße[x1]}
\NormalTok{y2 }\OperatorTok{=}\NormalTok{ messgröße[x2]}

\CommentTok{\# Nullpunktfehler bestimmen}
\NormalTok{lm\_referenzpunkte }\OperatorTok{=}\NormalTok{ poly.polyfit(x }\OperatorTok{=}\NormalTok{ [messgröße[x1], messgröße[x2]], y }\OperatorTok{=}\NormalTok{ [messwerte[x1], messwerte[x2]], deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{nullpunktfehler }\OperatorTok{=}\NormalTok{ lm\_referenzpunkte[}\DecValTok{0}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Nullpunktfehler beträgt: }\SpecialCharTok{\{}\NormalTok{nullpunktfehler}\SpecialCharTok{.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# Nullpunktfehler korrigieren}
\NormalTok{korrigierte\_messwerte }\OperatorTok{=}\NormalTok{ messwerte }\OperatorTok{{-}}\NormalTok{ nullpunktfehler}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Wahre Werte:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{messgr}\SpecialCharTok{öß}\NormalTok{e}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Korrigierte Messwerte:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{korrigierte\_messwerte}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der Nullpunktfehler beträgt: 2.5
Wahre Werte:
[ 5  6  7  8  9 10 11 12 13 14 15]
Korrigierte Messwerte:
[ 5.  6.  7.  8.  9. 10. 11. 12. 13. 14. 15.]
\end{verbatim}

\subsection{Übung Nullpunktfehler}\label{uxfcbung-nullpunktfehler}

Die Quantifizierung des Nullpunktfehlers ist manchmal schwierig,
beispielsweise weil der wahre Nullpunkt einer Größe nur schwer vermessen
werden kann oder die Messdaten nicht durch eine einfache Funktion
approximiert werden können. In diesem Fall muss eine möglichst gute
Schätzung gefunden werden.

In einem Klimaschrank wurden 16 Thermoelemente Temperaturen von -10 °C
bis 140 °C in Schritten von 10 °C ausgesetzt. Die Messgenauigkeit des
verwendeten Datenloggers TCTempX16 liegt bei 0,01 °C, die Auflösung bei
0,1 °C. \textbf{Für die Thermoelemente soll der Nullpunktfehler bestimmt
werden}.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-celsius} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-celsius}: Nullpunkt}\vspace{3mm}

0 ° C auf der Celsius-Skala ist kein sinnvoller Referenzpunkt zur
Bestimmung des Nullpunktfehlers, weil die Abwesenheit von Wärme erst bei
-273,15 °C gegeben ist. Da der Nullpunktfehler über alle Messwerte
konstant ist, kann der Nullpunktfehler geschätzt werden, indem für jede
Temperaturstufe der Nullpunktfehler separat geschätzt und die Ergebnisse
anschließend gemittelt werden.

\end{minipage}%
\end{tcolorbox}

Die Messdaten liegen in der Datei `01-daten/kalibration\_tc.xlsx'. Die
Daten können mit dem folgenden Befehl eingelesen werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{klimaschrank }\OperatorTok{=}\NormalTok{ pd.read\_excel(io }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/kalibration\_tc.xlsx\textquotesingle{}}\NormalTok{, sheet\_name }\OperatorTok{=} \StringTok{\textquotesingle{}T15949 MultiChannel {-} Daten\textquotesingle{}}\NormalTok{, skiprows }\OperatorTok{=} \DecValTok{6}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(klimaschrank.info())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 2771 entries, 0 to 2770
Data columns (total 18 columns):
 #   Column                 Non-Null Count  Dtype         
---  ------                 --------------  -----         
 0   Datum                  2771 non-null   datetime64[ns]
 1   Zeit                   2771 non-null   datetime64[ns]
 2   Thermoelement 1 (°C)   2771 non-null   float64       
 3   Thermoelement 2 (°C)   2771 non-null   float64       
 4   Thermoelement 3 (°C)   2771 non-null   float64       
 5   Thermoelement 4 (°C)   2771 non-null   float64       
 6   Thermoelement 5 (°C)   2771 non-null   float64       
 7   Thermoelement 6 (°C)   2771 non-null   float64       
 8   Thermoelement 7 (°C)   2771 non-null   float64       
 9   Thermoelement 8 (°C)   2771 non-null   float64       
 10  Thermoelement 9 (°C)   2771 non-null   float64       
 11  Thermoelement 10 (°C)  2771 non-null   float64       
 12  Thermoelement 11 (°C)  2771 non-null   float64       
 13  Thermoelement 12 (°C)  2771 non-null   float64       
 14  Thermoelement 13 (°C)  2771 non-null   float64       
 15  Thermoelement 14 (°C)  2771 non-null   float64       
 16  Thermoelement 15 (°C)  2771 non-null   float64       
 17  Thermoelement 16 (°C)  2771 non-null   float64       
dtypes: datetime64[ns](2), float64(16)
memory usage: 389.8 KB
None
\end{verbatim}

Mit \texttt{klimaschrank.describe()} kann ein Überblick über die Daten
gewonnen werden (hier aus Platzgründen für die ersten 4 Spalten).

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(klimaschrank.iloc[: , }\DecValTok{0}\NormalTok{:}\DecValTok{4}\NormalTok{].describe())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
                               Datum                           Zeit  \
count                           2771                           2771   
mean   2026-01-13 14:46:20.314687744  2026-01-13 14:46:20.314687744   
min              2026-01-13 10:55:17            2026-01-13 10:55:17   
25%       2026-01-13 12:50:48.500000     2026-01-13 12:50:48.500000   
50%              2026-01-13 14:46:21            2026-01-13 14:46:21   
75%              2026-01-13 16:41:52            2026-01-13 16:41:52   
max              2026-01-13 18:37:24            2026-01-13 18:37:24   
std                              NaN                            NaN   

       Thermoelement 1 (°C)  Thermoelement 2 (°C)  
count           2771.000000           2771.000000  
mean              59.761097             60.795669  
min               -9.100000            -11.400000  
25%               20.900000             20.950000  
50%               58.800000             60.400000  
75%               98.300000            100.200000  
max              138.700000            140.500000  
std               43.075393             44.310769  
\end{verbatim}

Die Spalten Datum und Zeit enthalten die selben Informationen. Eine der
beiden Spalten kann deshalb entfernt werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{klimaschrank.drop(labels }\OperatorTok{=} \StringTok{\textquotesingle{}Datum\textquotesingle{}}\NormalTok{, axis }\OperatorTok{=} \DecValTok{1}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Betrachten wir den Verlauf der Daten für die ersten beiden
Thermoelemente. (In der Darstellung mit \texttt{pd.plot()} ist die
automatisch gewählte x-Achsenbeschriftung unansehnlich. Deshalb wird ein
Datenobjekt für die Darstellung angelegt und die Spalte `Zeit' auf die
Uhrzeit reduziert.)

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Darstellung mit automatischer Achsenbeschriftung}
\CommentTok{\# klimaschrank.iloc[: , 0:3].plot(x = \textquotesingle{}Zeit\textquotesingle{}, y = [\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}, \textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}])}

\NormalTok{plotting\_data }\OperatorTok{=}\NormalTok{ klimaschrank.copy()}
\NormalTok{plotting\_data[}\StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ plotting\_data[}\StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{].dt.time}

\NormalTok{plotting\_data.plot(x }\OperatorTok{=} \StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{, y }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{], grid }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{plt.ylabel(ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}° C\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/kalibrierung_files/figure-pdf/cell-11-output-1.png}}

~

Es ist zu erkennen, dass der Klimaschrank beim Aufheizen auf die nächste
Zieltemperatur zunächst zu stark aufheizt, bevor die eingestellte
Temperatur für einige Zeit konstant gehalten wird. Die Temperatur von
140 °C wird nur kurz erreicht, es liegen aber kaum Messwerte vor.

\textbf{Bestimmen Sie nun den Nullpunktfehler für alle Thermoelemente.}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Wählen Sie für jedes Thermoelement die Bereiche der Datenreihe für die
  Temperaturstufen -10 bis 130 °C aus.
\item
  Bestimmen Sie für jede Temperaturstufe die gemessene Temperatur im
  Bereich der Datenreihe, in der die Referenztemperatur konstant
  gehalten wird.
\item
  Berechnen Sie den Nullpunktfehler für jeden Ausschnitt der Datenreihe
  und mitteln Sie die Ergebnisse für jedes Thermoelement.
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-tipps}: Lösungshinweise}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-tipps} 

Tipp 1: Lagemaße wie der Median, Mittelwert oder der Modus können eine
einfacher zu bestimmende Schätzgröße für den Nullpunktfehler sein.

Tipp 2: Gehen Sie schrittweise vor: Versuchen Sie zunächst, eine
Temperaturstufe eines Thermoelements zu isolieren und die gemessene
Temperatur im konstanten Bereich der Datenreihe zu bestimmen. Schreiben
Sie anschließend eine Funktion, um den Programmcode für mehrere
Thermoelemente und Temperaturstufen zu wiederholen.

Tipp 3: Eine gleichermaßen für 13 Temperaturstufen und 16 Thermoelemente
geeignete Lösung dürfte kaum zu finden sein. Manchmal wird ein Wert
gesucht, manchmal liegt der gesuchte Wert zwischen zwei Messwerten. Eine
geringfügige Unsicherheit kann durch die Automatisierung in Kauf
genommen werden.

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-te}: Musterlösung Thermoelemente}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-te} 

\textbf{Lösung für ein Thermoelement.}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Bereich der Datenreihe für eine Temperatur auswählen, z. B. 0 °C. Dazu
  grenzen wir die Messwerte grob um den gesuchten Wert \(0 \pm 2 °C\)
  ein.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Thermoelement 1}
\CommentTok{\#\# Messwerte grob um den gesuchten Wert 0 °C eingrenzen}
\NormalTok{gesuchter\_wert }\OperatorTok{=} \DecValTok{0}

\NormalTok{maske1 }\OperatorTok{=}\NormalTok{ klimaschrank[}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{].le(gesuchter\_wert }\OperatorTok{+} \DecValTok{2}\NormalTok{) }\CommentTok{\# le = kleiner gleich}
\NormalTok{maske2 }\OperatorTok{=}\NormalTok{ klimaschrank[}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{].ge(gesuchter\_wert }\OperatorTok{{-}} \DecValTok{2}\NormalTok{) }\CommentTok{\# ge = größer gleich}

\NormalTok{klimaschrank.loc[maske1 }\OperatorTok{*}\NormalTok{ maske2, }\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{].plot()}
\NormalTok{plt.xlabel(xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Index\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}°C\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/kalibrierung_files/figure-pdf/cell-12-output-1.png}}

~

In diesem Ausschnitt kann das Überschießen der Messwerte beobachtet
werden, bevor sich die Messwerte etwa bei + 1 °C einpendeln. Auch ist
der Anstieg zur folgenden Temperaturstufe zu erkennen.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Im zweiten Schritt sollen die Daten im konstanten Temperaturbereich
  ausgewählt werden. Dazu soll ein möglichst einfaches Kriterium
  verwendet werden: der häufigste im Ausschnitt vorkommende Wert, also
  der Modus. Dazu wird die Methode \texttt{pd.value\_counts()}
  verwendet, die eine absteigend sortierte Series der Häufigkeiten
  zurückgibt, wobei im Index die Werte gespeichert sind (siehe
  Beispiel). Der im Index gespeicherte häufigste Wert wird mit der
  Methode \texttt{pd.idxmax()} ausgelesen.
\end{enumerate}

\phantomsection\label{nte-valuecounts}
\begin{quote}
\textbf{Note~70.1: pd.value\_counts()}

Die Ausgabe von \texttt{pd.value\_counts()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{daten }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{])}
\NormalTok{daten.value\_counts()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3    5
4    2
1    1
2    1
5    1
Name: count, dtype: int64
\end{verbatim}
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Thermoelement 1}

\CommentTok{\#\# Messwerte grob um den gesuchten Wert 0 °C eingrenzen}
\NormalTok{maske1 }\OperatorTok{=}\NormalTok{ klimaschrank[}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{].le(gesuchter\_wert }\OperatorTok{+} \DecValTok{2}\NormalTok{) }\CommentTok{\# le = kleiner gleich}
\NormalTok{maske2 }\OperatorTok{=}\NormalTok{ klimaschrank[}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{].ge(gesuchter\_wert }\OperatorTok{{-}} \DecValTok{2}\NormalTok{) }\CommentTok{\# ge = größer gleich}

\CommentTok{\#\# häufigster Wert im eingegrenzten Temperaturbereich}
\NormalTok{modus\_bereich }\OperatorTok{=}\NormalTok{ klimaschrank.loc[maske1 }\OperatorTok{*}\NormalTok{ maske2, }\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{].value\_counts().idxmax()}

\CommentTok{\#\# Nullpunktfehler bestimmen}
\NormalTok{nullpunktfehler }\OperatorTok{=}\NormalTok{ modus\_bereich }\OperatorTok{{-}}\NormalTok{ gesuchter\_wert}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Nullpunktfehler: }\SpecialCharTok{\{}\NormalTok{nullpunktfehler}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\#\# plotten}
\NormalTok{klimaschrank.loc[maske1 }\OperatorTok{*}\NormalTok{ maske2, }\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{].plot()}
\NormalTok{plt.axhline(y }\OperatorTok{=}\NormalTok{ modus\_bereich, color }\OperatorTok{=} \StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}{-}{-}\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Modus\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Index\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}°C\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.legend()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Nullpunktfehler: 0.9
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/kalibrierung_files/figure-pdf/cell-14-output-2.png}}

~

Der Nullpunktfehler für Thermoelement 1 wird somit mit 0,9 °C bestimmt.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Um die Berechnung für die verschiedenen Temperaturstufen zu
  automatisieren, schreiben wir eine Funktion.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Eingabe: data = pd.Series, gesuchter\_wert = array like, schwellwert, puffer = Skalar}
\CommentTok{\# Verarbeitung: Elementweise werden die Werte in gesuchter\_Wert ± puffer in data gesucht}
\CommentTok{\# Verarbeitung: Die Differenz aus dem Modus jedes Datenausschnitts und dem gesuchten Wert wird als Nullpunktfehler interpretiert }
\CommentTok{\# Ausgabe: Wenn output = True wird DataFrame der gesuchten Werte und Nullpunktfehler ausgegeben, wenn output = False wird der mittlere Nullpunktefehler ausgegeben}

\KeywordTok{def}\NormalTok{ nullpunktfehler(data, gesuchte\_werte, puffer }\OperatorTok{=} \DecValTok{2}\NormalTok{, output }\OperatorTok{=} \VariableTok{False}\NormalTok{):}

  \CommentTok{\# Zielobjekt und Zähler anlegen}
\NormalTok{  ausgabe }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}Gesuchter Wert\textquotesingle{}}\NormalTok{: pd.Series(), }\StringTok{\textquotesingle{}Nullpunktfehler\textquotesingle{}}\NormalTok{: pd.Series()\})}
\NormalTok{  i }\OperatorTok{=} \DecValTok{0}

  \ControlFlowTok{for}\NormalTok{ gesuchter\_wert }\KeywordTok{in}\NormalTok{ gesuchte\_werte:}
    
    \CommentTok{\#\# Messwerte grob um den gesuchten Wert eingrenzen}
\NormalTok{    maske1 }\OperatorTok{=}\NormalTok{ data.le(gesuchter\_wert }\OperatorTok{+}\NormalTok{ puffer) }\CommentTok{\# le = kleiner gleich}
\NormalTok{    maske2 }\OperatorTok{=}\NormalTok{ data.ge(gesuchter\_wert }\OperatorTok{{-}}\NormalTok{ puffer) }\CommentTok{\# ge = größer gleich}

    \CommentTok{\#\# Kriterium häufigster Wert im eingegrenzten Temperaturbereich}
\NormalTok{    modus\_bereich }\OperatorTok{=}\NormalTok{ data.loc[maske1 }\OperatorTok{*}\NormalTok{ maske2].value\_counts().idxmax()}
    
    \CommentTok{\# Nullpunktfehler bestimmen}
\NormalTok{    nullpunktfehler }\OperatorTok{=}\NormalTok{ modus\_bereich }\OperatorTok{{-}}\NormalTok{ gesuchter\_wert}

    \CommentTok{\# Werte eintragen}
\NormalTok{    ausgabe.loc[i] }\OperatorTok{=}\NormalTok{ pd.Series([gesuchter\_wert, nullpunktfehler]).values}

    \CommentTok{\# Zähler erhöhen}
\NormalTok{    i }\OperatorTok{+=} \DecValTok{1}

  \CommentTok{\# Optional Ausgabe}
  \ControlFlowTok{if}\NormalTok{ output: }\CommentTok{\# output is True}
    \BuiltInTok{print}\NormalTok{(ausgabe)}

  \CommentTok{\# Rückgabe der gemittelten Nullpunktfehler}
  \ControlFlowTok{return}\NormalTok{ ausgabe[}\StringTok{\textquotesingle{}Nullpunktfehler\textquotesingle{}}\NormalTok{].mean()}
\end{Highlighting}
\end{Shaded}

Angewendet auf Thermoelement 1 (°C):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nullpunktfehler(data }\OperatorTok{=}\NormalTok{ klimaschrank[}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{],}
\NormalTok{                gesuchte\_werte }\OperatorTok{=}\NormalTok{ np.arange(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{, }\DecValTok{140}\NormalTok{, }\DecValTok{10}\NormalTok{),}
\NormalTok{                output }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
    Gesuchter Wert  Nullpunktfehler
0            -10.0              1.5
1              0.0              0.9
2             10.0              0.7
3             20.0              0.5
4             30.0              0.0
5             40.0             -0.4
6             50.0             -0.9
7             60.0             -1.2
8             70.0             -1.7
9             80.0             -2.0
10            90.0             -2.0
11           100.0             -1.6
12           110.0             -1.8
13           120.0             -1.7
14           130.0             -1.6
\end{verbatim}

\begin{verbatim}
np.float64(-0.7533333333333327)
\end{verbatim}

\textbf{Anwendung auf den Datensatz}

Im letzten Schritt wenden wir die Funktion spaltenweise auf den
DataFrame an.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# gibt pd.Series zurück}
\NormalTok{nullpunktfehler\_klimaschrank }\OperatorTok{=}\NormalTok{ klimaschrank.iloc[: , }\DecValTok{1}\NormalTok{:].}\BuiltInTok{apply}\NormalTok{(nullpunktfehler, axis }\OperatorTok{=} \DecValTok{0}\NormalTok{, gesuchte\_werte }\OperatorTok{=}\NormalTok{ np.arange(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{, }\DecValTok{140}\NormalTok{, }\DecValTok{10}\NormalTok{))}

\BuiltInTok{print}\NormalTok{(nullpunktfehler\_klimaschrank.}\BuiltInTok{round}\NormalTok{(}\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Thermoelement 1 (°C)    -0.753
Thermoelement 2 (°C)     0.027
Thermoelement 3 (°C)    -0.000
Thermoelement 4 (°C)     0.547
Thermoelement 5 (°C)     0.513
Thermoelement 6 (°C)    -0.240
Thermoelement 7 (°C)     0.073
Thermoelement 8 (°C)    -0.773
Thermoelement 9 (°C)    -0.373
Thermoelement 10 (°C)   -0.980
Thermoelement 11 (°C)   -0.900
Thermoelement 12 (°C)    0.533
Thermoelement 13 (°C)   -0.760
Thermoelement 14 (°C)   -0.580
Thermoelement 15 (°C)   -0.027
Thermoelement 16 (°C)   -0.987
dtype: float64
\end{verbatim}

\end{tcolorbox}

\section{Multiplikative Fehler: Der
Empfindlichkeitsfehler}\label{multiplikative-fehler-der-empfindlichkeitsfehler}

Als Empfindlichkeits- oder Spannfehler wird ein über den Wertebereich
(die Spanne) der gesuchten Größe zu- oder abnehmender Fehler bezeichnet.
Die relative Messabweichung \(\delta\) ist dabei konstant, die absolute
Messabweichung abhängig vom Messwert.
(\href{https://www.ics-schneider.de/wie-wirken-sich-nullpunktfehler-spannfehler-und-nichtlinearitaet-auf-die-genauigkeit-von-drucksensoren-aus/}{ics
Schneider Messtechnik})

\[
\text{Messwerte} = \text{wahre Werte} \cdot \text{Empfindlichkeitsfehler}
\]

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Daten erzeugen}
\NormalTok{messgröße }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{0}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\NormalTok{messwerte }\OperatorTok{=}\NormalTok{ messgröße }\OperatorTok{{-}}\NormalTok{ messgröße }\OperatorTok{/} \DecValTok{3}

\CommentTok{\# plotten}
\NormalTok{plt.plot(messgröße, marker }\OperatorTok{=} \StringTok{\textquotesingle{}o\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}wahrer Wert\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(messwerte, marker }\OperatorTok{=} \StringTok{\textquotesingle{}\^{}\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}gemessener Wert\textquotesingle{}}\NormalTok{)}

\CommentTok{\# füllen}
\NormalTok{plt.fill\_between(x }\OperatorTok{=}\NormalTok{ np.arange(messwerte.size), y1 }\OperatorTok{=}\NormalTok{ messgröße, y2 }\OperatorTok{=}\NormalTok{ messwerte, alpha }\OperatorTok{=} \FloatTok{0.2}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Empfindlichkeitsfehler\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Achsenbeschriftung}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Index\textquotesingle{}}\NormalTok{) }
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Merkmalsausprägung\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.legend()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/kalibrierung_files/figure-pdf/cell-18-output-1.png}}

\subsection{Empfindlichkeitsfehler
quantifizieren}\label{empfindlichkeitsfehler-quantifizieren}

Der Empfindlichkeitsfehler kann geschätzt werden, wenn Referenzwerte
bekannt sind. Dazu wird das Verhältnis der Größenänderung (des Anstiegs)
der gemessenen und der wahren Werte gebildet.

\[
\text{Empfindlichkeitsfehler} = \frac{\Delta \text{gemessene Werte}}{\Delta\text{wahre Werte}}
\]

Mit den vollständigen Beispieldaten geht es leicht (in dem Beispiel wird
eine Warnung wegen Division durch 0 unterdrückt):

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Empfindlichkeitsfehler beträgt: }\SpecialCharTok{\{}\BuiltInTok{round}\NormalTok{((np.nanmean((messwerte }\OperatorTok{/}\NormalTok{ messgröße)) }\OperatorTok{{-}} \DecValTok{1}\NormalTok{ ) }\OperatorTok{*} \DecValTok{100}\NormalTok{, }\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{ \%"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der Empfindlichkeitsfehler beträgt: -33.33 %
\end{verbatim}

Bei nur punktuellen Daten wird eine ideale Kennlinie geschätzt, mit der
der Empfindlichkeitsfehler geschätzt werden kann.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# bekannte Referenzwerte}
\NormalTok{x1 }\OperatorTok{=} \DecValTok{4}
\NormalTok{x2 }\OperatorTok{=} \DecValTok{8}
\NormalTok{y1 }\OperatorTok{=}\NormalTok{ messgröße[x1]}
\NormalTok{y2 }\OperatorTok{=}\NormalTok{ messgröße[x2]}

\CommentTok{\# ideale Kennlinie schätzen}
\NormalTok{lm\_kennlinie }\OperatorTok{=}\NormalTok{ poly.polyfit(x }\OperatorTok{=}\NormalTok{ [x1, x2], y }\OperatorTok{=}\NormalTok{ [y1, y2], deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{geschätzte\_ideale\_kennlinie }\OperatorTok{=}\NormalTok{ poly.polyval(x }\OperatorTok{=}\NormalTok{ np.arange(messwerte.size), c }\OperatorTok{=}\NormalTok{ lm\_kennlinie)}

\CommentTok{\# lineare Regression der Messwerte}
\NormalTok{lm\_messwerte }\OperatorTok{=}\NormalTok{ poly.polyfit(x }\OperatorTok{=}\NormalTok{ np.arange(messwerte.size), y }\OperatorTok{=}\NormalTok{ messwerte, deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}

\CommentTok{\# Berechnung Empfindlichkeitsfehler}
\NormalTok{spannfehler }\OperatorTok{=}\NormalTok{ lm\_messwerte[}\DecValTok{1}\NormalTok{] }\OperatorTok{/}\NormalTok{ lm\_kennlinie[}\DecValTok{1}\NormalTok{]}

\CommentTok{\# Ausgabe}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Anstieg der Messwerte: }\SpecialCharTok{\{}\BuiltInTok{round}\NormalTok{(lm\_messwerte[}\DecValTok{1}\NormalTok{], }\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Anstieg der idealen Kennlinie: }\SpecialCharTok{\{}\BuiltInTok{round}\NormalTok{(lm\_kennlinie[}\DecValTok{1}\NormalTok{], }\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Empfindlichkeitsfehler beträgt: }\SpecialCharTok{\{}\BuiltInTok{round}\NormalTok{((spannfehler }\OperatorTok{{-}} \DecValTok{1}\NormalTok{) }\OperatorTok{*} \DecValTok{100}\NormalTok{, }\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{ \%"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der Anstieg der Messwerte: 0.67
Der Anstieg der idealen Kennlinie: 1.0
Der Empfindlichkeitsfehler beträgt: -33.33 %
\end{verbatim}

Der Empfindlichkeitsfehler kann auch durch eine lineare Regression mit
den bekannten Referenzwerten als unabhängige Größe \(x\) und den
Messwerten als abhängige Größe \(y\) bestimmt werden. Der Anstieg der
Regressionsgeraden ist der Empfindlichkeitsfehler.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Empfindlichkeitsfehler bestimmen}
\NormalTok{lm\_referenzpunkte }\OperatorTok{=}\NormalTok{ poly.polyfit(x }\OperatorTok{=}\NormalTok{ [messgröße[x1], messgröße[x2]], y }\OperatorTok{=}\NormalTok{ [messwerte[x1], messwerte[x2]], deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{spannfehler }\OperatorTok{=}\NormalTok{ lm\_referenzpunkte[}\DecValTok{1}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Empfindlichkeitsfehler beträgt: }\SpecialCharTok{\{}\BuiltInTok{round}\NormalTok{((spannfehler }\OperatorTok{{-}} \DecValTok{1}\NormalTok{) }\OperatorTok{*} \DecValTok{100}\NormalTok{, }\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{ \%"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der Empfindlichkeitsfehler beträgt: -33.33 %
\end{verbatim}

Grafisch wird das Vorgehen deutlich.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Punkte und Linien}
\NormalTok{plt.plot([}\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{], [messgröße[}\DecValTok{0}\NormalTok{], messgröße[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]], marker }\OperatorTok{=} \StringTok{\textquotesingle{}none\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}dashed\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}ideale Kennlinie\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot([x1, x2], [y1, y2], marker }\OperatorTok{=} \StringTok{\textquotesingle{}o\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}none\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}bekannte Referenzwerte\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(messwerte, marker }\OperatorTok{=} \StringTok{\textquotesingle{}\^{}\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}gemessene Werte\textquotesingle{}}\NormalTok{)}

\CommentTok{\# füllen}
\NormalTok{plt.fill\_between(x }\OperatorTok{=}\NormalTok{ np.arange(messwerte.size), y1 }\OperatorTok{=}\NormalTok{ messgröße, y2 }\OperatorTok{=}\NormalTok{ messwerte, alpha }\OperatorTok{=} \FloatTok{0.2}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Empfindlichkeitsfehler\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.legend()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/kalibrierung_files/figure-pdf/cell-22-output-1.png}}

\subsection{Empfindlichkeitsfehler
korrigieren}\label{empfindlichkeitsfehler-korrigieren}

Der Empfindlichkeitsfehler wird durch die Division der Messwerte durch
den Empfindlichkeitsfehler korrigiert.

\[
\text{wahre Werte} = \frac{\text{Messwerte}}{\text{Empfindlichkeitsfehler}}
\]

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Daten erzeugen}
\NormalTok{messgröße }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{0}\NormalTok{, }\DecValTok{11}\NormalTok{) }\OperatorTok{+} \DecValTok{5}
\NormalTok{messwerte }\OperatorTok{=}\NormalTok{ messgröße }\OperatorTok{*} \FloatTok{1.07}

\CommentTok{\# bekannte Referenzpunkte }
\NormalTok{x1 }\OperatorTok{=} \DecValTok{2}
\NormalTok{x2 }\OperatorTok{=} \DecValTok{5}
\NormalTok{y1 }\OperatorTok{=}\NormalTok{ messgröße[x1]}
\NormalTok{y2 }\OperatorTok{=}\NormalTok{ messgröße[x2]}

\CommentTok{\# ideale Kennlinie schätzen}
\NormalTok{lm\_kennlinie }\OperatorTok{=}\NormalTok{ poly.polyfit(x }\OperatorTok{=}\NormalTok{ [x1, x2], y }\OperatorTok{=}\NormalTok{ [y1, y2], deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}

\CommentTok{\# lineare Funktion der Messwerte schätzen}
\NormalTok{lm\_messwerte }\OperatorTok{=}\NormalTok{ poly.polyfit(x }\OperatorTok{=}\NormalTok{ np.arange(messwerte.size), y }\OperatorTok{=}\NormalTok{ messwerte, deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}

\CommentTok{\# Empfindlichkeitsfehler bestimmen}
\NormalTok{spannfehler }\OperatorTok{=}\NormalTok{ lm\_messwerte[}\DecValTok{1}\NormalTok{] }\OperatorTok{/}\NormalTok{ lm\_kennlinie[}\DecValTok{1}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Empfindlichkeitsfehler beträgt: }\SpecialCharTok{\{}\NormalTok{( (spannfehler }\OperatorTok{{-}} \DecValTok{1}\NormalTok{) }\OperatorTok{*} \DecValTok{100}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{ \%}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# Empfindlichkeitsfehler korrigieren}
\NormalTok{korrigierte\_messwerte }\OperatorTok{=}\NormalTok{ messwerte }\OperatorTok{/}\NormalTok{ spannfehler}

\CommentTok{\# Ausgabe}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Wahre Werte:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{messgr}\SpecialCharTok{öß}\NormalTok{e}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Messwerte:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{messwerte}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Korrigierte Messwerte:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{korrigierte\_messwerte}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der Empfindlichkeitsfehler beträgt: 7.0 %

Wahre Werte:
[ 5  6  7  8  9 10 11 12 13 14 15]
Messwerte:
[ 5.35  6.42  7.49  8.56  9.63 10.7  11.77 12.84 13.91 14.98 16.05]
Korrigierte Messwerte:
[ 5.  6.  7.  8.  9. 10. 11. 12. 13. 14. 15.]
\end{verbatim}

\subsection{Übung
Empfindlichkeitsfehler}\label{uxfcbung-empfindlichkeitsfehler}

In einem Klimaschrank wurden 16 Thermoelemente einem Temperaturanstieg
von -10 °C bis 140 °C ausgesetzt. Die Messgenauigkeit des verwendeten
Datenloggers TCTempX16 liegt bei 0,01 °C, die Auflösung bei 0,1 °C.
\textbf{Für die Thermoelemente soll der Empfindlichkeitsfehler bestimmt
werden}.

Die Messdaten liegen in der Datei
`01-daten/kalibration\_tc\_lineare\_rampe.xlsx'. Die Daten können mit
dem folgenden Befehl eingelesen werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{klimaschrank }\OperatorTok{=}\NormalTok{ pd.read\_excel(io }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/kalibration\_tc\_lineare\_rampe.xlsx\textquotesingle{}}\NormalTok{, sheet\_name }\OperatorTok{=} \StringTok{\textquotesingle{}T15949 MultiChannel {-} Daten\textquotesingle{}}\NormalTok{, skiprows }\OperatorTok{=} \DecValTok{6}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(klimaschrank.info())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 2961 entries, 0 to 2960
Data columns (total 18 columns):
 #   Column                 Non-Null Count  Dtype         
---  ------                 --------------  -----         
 0   Datum                  2961 non-null   datetime64[ns]
 1   Zeit                   2961 non-null   datetime64[ns]
 2   Thermoelement 1 (°C)   2961 non-null   float64       
 3   Thermoelement 2 (°C)   2961 non-null   float64       
 4   Thermoelement 3 (°C)   2961 non-null   float64       
 5   Thermoelement 4 (°C)   2961 non-null   float64       
 6   Thermoelement 5 (°C)   2961 non-null   float64       
 7   Thermoelement 6 (°C)   2961 non-null   float64       
 8   Thermoelement 7 (°C)   2961 non-null   float64       
 9   Thermoelement 8 (°C)   2961 non-null   float64       
 10  Thermoelement 9 (°C)   2961 non-null   float64       
 11  Thermoelement 10 (°C)  2961 non-null   float64       
 12  Thermoelement 11 (°C)  2961 non-null   float64       
 13  Thermoelement 12 (°C)  2961 non-null   float64       
 14  Thermoelement 13 (°C)  2961 non-null   float64       
 15  Thermoelement 14 (°C)  2961 non-null   float64       
 16  Thermoelement 15 (°C)  2961 non-null   float64       
 17  Thermoelement 16 (°C)  2961 non-null   float64       
dtypes: datetime64[ns](2), float64(16)
memory usage: 416.5 KB
None
\end{verbatim}

Mit \texttt{klimaschrank.describe()} kann ein Überblick über die Daten
gewonnen werden (hier aus Platzgründen für die ersten 4 Spalten).

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(klimaschrank.iloc[: , }\DecValTok{0}\NormalTok{:}\DecValTok{4}\NormalTok{].describe())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
                            Datum                        Zeit  \
count                        2961                        2961   
mean   2026-01-15 14:43:19.065856  2026-01-15 14:43:19.065856   
min           2026-01-15 10:36:25         2026-01-15 10:36:25   
25%           2026-01-15 12:39:52         2026-01-15 12:39:52   
50%           2026-01-15 14:43:19         2026-01-15 14:43:19   
75%           2026-01-15 16:46:46         2026-01-15 16:46:46   
max           2026-01-15 18:50:13         2026-01-15 18:50:13   
std                           NaN                         NaN   

       Thermoelement 1 (°C)  Thermoelement 2 (°C)  
count           2961.000000           2961.000000  
mean              79.988011             81.124688  
min               -8.500000            -10.700000  
25%               41.300000             42.400000  
50%               94.400000             96.200000  
75%              117.200000            118.800000  
max              147.100000            148.700000  
std               45.318636             46.109421  
\end{verbatim}

Die Spalten Datum und Zeit enthalten die selben Informationen. Eine der
beiden Spalten kann deshalb entfernt werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{klimaschrank.drop(labels }\OperatorTok{=} \StringTok{\textquotesingle{}Datum\textquotesingle{}}\NormalTok{, axis }\OperatorTok{=} \DecValTok{1}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Betrachten wir den Verlauf der Daten für die ersten beiden
Thermoelemente. (In der Darstellung mit \texttt{pd.plot()} ist die
automatisch gewählte x-Achsenbeschriftung unansehnlich. Deshalb wird ein
Datenobjekt für die Darstellung angelegt und die Spalte `Zeit' auf die
Uhrzeit reduziert.)

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Darstellung mit automatischer Achsenbeschriftung}
\CommentTok{\# klimaschrank.iloc[: , 0:3].plot(x = \textquotesingle{}Zeit\textquotesingle{}, y = [\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}, \textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}])}

\NormalTok{plotting\_data }\OperatorTok{=}\NormalTok{ klimaschrank.copy()}
\NormalTok{plotting\_data[}\StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ plotting\_data[}\StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{].dt.time}

\NormalTok{plotting\_data.plot(x }\OperatorTok{=} \StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{, y }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{], grid }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{plt.ylabel(ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}° C\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/kalibrierung_files/figure-pdf/cell-27-output-1.png}}

~

Die Messung startet kurz vor der Aufheizphase. Etwa 16:40 Uhr wurde der
Klimaschrank abgeschaltet. Die Messung lief danach noch einige Zeit
weiter. Es müssen also der Start- und der Endpunkt der Aufheizphase
bestimmt werden.

In diesem Beispiel soll angenommen werden, dass bei der Messung kein
Nullpunktfehler vorliegt. Dazu suchen wir mit der Funktion aus
Tip~\ref{tip-te} passende Messreihen. Aus dem anfänglich konstanten
Bereich -10 °C wird der Nullpunktfehler bestimmt.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# gibt pd.Series zurück}
\NormalTok{nullpunktfehler\_klimaschrank }\OperatorTok{=}\NormalTok{ klimaschrank.iloc[: , }\DecValTok{1}\NormalTok{:].}\BuiltInTok{apply}\NormalTok{(nullpunktfehler, axis }\OperatorTok{=} \DecValTok{0}\NormalTok{, gesuchte\_werte }\OperatorTok{=}\NormalTok{ [}\OperatorTok{{-}}\DecValTok{10}\NormalTok{])}

\BuiltInTok{print}\NormalTok{(nullpunktfehler\_klimaschrank)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Thermoelement 1 (°C)     2.0
Thermoelement 2 (°C)    -0.2
Thermoelement 3 (°C)     2.0
Thermoelement 4 (°C)     0.0
Thermoelement 5 (°C)    -0.1
Thermoelement 6 (°C)     1.8
Thermoelement 7 (°C)     0.1
Thermoelement 8 (°C)     1.7
Thermoelement 9 (°C)     1.6
Thermoelement 10 (°C)    1.7
Thermoelement 11 (°C)    1.8
Thermoelement 12 (°C)   -0.1
Thermoelement 13 (°C)    1.6
Thermoelement 14 (°C)    1.9
Thermoelement 15 (°C)    0.0
Thermoelement 16 (°C)    1.8
dtype: float64
\end{verbatim}

Die Messreihen für Thermoelement 4 und Thermoelement 15 scheinen
geeignet zu sein. Schauen wir uns die Messreihen einmal an:

\section{Thermoelement 4}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Thermoelement 4}
\NormalTok{gesuchter\_wert }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{10}

\CommentTok{\#\# Messwerte grob um den gesuchten Wert 0 °C eingrenzen}
\NormalTok{maske1 }\OperatorTok{=}\NormalTok{ klimaschrank[}\StringTok{\textquotesingle{}Thermoelement 4 (°C)\textquotesingle{}}\NormalTok{].le(gesuchter\_wert }\OperatorTok{+} \DecValTok{2}\NormalTok{) }\CommentTok{\# le = kleiner gleich}
\NormalTok{maske2 }\OperatorTok{=}\NormalTok{ klimaschrank[}\StringTok{\textquotesingle{}Thermoelement 4 (°C)\textquotesingle{}}\NormalTok{].ge(gesuchter\_wert }\OperatorTok{{-}} \DecValTok{2}\NormalTok{) }\CommentTok{\# ge = größer gleich}

\CommentTok{\#\# häufigster Wert im eingegrenzten Temperaturbereich}
\NormalTok{modus\_bereich }\OperatorTok{=}\NormalTok{ klimaschrank.loc[maske1 }\OperatorTok{*}\NormalTok{ maske2, }\StringTok{\textquotesingle{}Thermoelement 4 (°C)\textquotesingle{}}\NormalTok{].value\_counts().idxmax()}

\CommentTok{\#\# Nullpunktfehler bestimmen}
\NormalTok{nullpunktfehler }\OperatorTok{=}\NormalTok{ modus\_bereich }\OperatorTok{{-}}\NormalTok{ gesuchter\_wert}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Nullpunktfehler: }\SpecialCharTok{\{}\NormalTok{nullpunktfehler}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\#\# plotten}
\NormalTok{klimaschrank.loc[maske1 }\OperatorTok{*}\NormalTok{ maske2, }\StringTok{\textquotesingle{}Thermoelement 4 (°C)\textquotesingle{}}\NormalTok{].plot()}
\NormalTok{plt.axhline(y }\OperatorTok{=}\NormalTok{ modus\_bereich, color }\OperatorTok{=} \StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}{-}{-}\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Modus\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Index\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}°C\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.legend()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Nullpunktfehler: 0.0
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/kalibrierung_files/figure-pdf/cell-29-output-2.png}}

\section{Thermoelement 15}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Thermoelement 15}
\NormalTok{gesuchter\_wert }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{10}

\CommentTok{\#\# Messwerte grob um den gesuchten Wert 0 °C eingrenzen}
\NormalTok{maske1 }\OperatorTok{=}\NormalTok{ klimaschrank[}\StringTok{\textquotesingle{}Thermoelement 15 (°C)\textquotesingle{}}\NormalTok{].le(gesuchter\_wert }\OperatorTok{+} \DecValTok{2}\NormalTok{) }\CommentTok{\# le = kleiner gleich}
\NormalTok{maske2 }\OperatorTok{=}\NormalTok{ klimaschrank[}\StringTok{\textquotesingle{}Thermoelement 15 (°C)\textquotesingle{}}\NormalTok{].ge(gesuchter\_wert }\OperatorTok{{-}} \DecValTok{2}\NormalTok{) }\CommentTok{\# ge = größer gleich}

\CommentTok{\#\# häufigster Wert im eingegrenzten Temperaturbereich}
\NormalTok{modus\_bereich }\OperatorTok{=}\NormalTok{ klimaschrank.loc[maske1 }\OperatorTok{*}\NormalTok{ maske2, }\StringTok{\textquotesingle{}Thermoelement 15 (°C)\textquotesingle{}}\NormalTok{].value\_counts().idxmax()}

\CommentTok{\#\# Nullpunktfehler bestimmen}
\NormalTok{nullpunktfehler }\OperatorTok{=}\NormalTok{ modus\_bereich }\OperatorTok{{-}}\NormalTok{ gesuchter\_wert}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Nullpunktfehler: }\SpecialCharTok{\{}\NormalTok{nullpunktfehler}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\#\# plotten}
\NormalTok{klimaschrank.loc[maske1 }\OperatorTok{*}\NormalTok{ maske2, }\StringTok{\textquotesingle{}Thermoelement 15 (°C)\textquotesingle{}}\NormalTok{].plot()}
\NormalTok{plt.axhline(y }\OperatorTok{=}\NormalTok{ modus\_bereich, color }\OperatorTok{=} \StringTok{\textquotesingle{}r\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}{-}{-}\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Modus\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Index\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}°C\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.legend()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Nullpunktfehler: 0.0
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/kalibrierung_files/figure-pdf/cell-30-output-2.png}}

\textbf{Bestimmen Sie den Empfindlichkeitsfehler für Thermoelement 4 und
Thermoelement 15. Das wahre Minimum der Temperatur betrage -10 °C und
das wahre Maximum betrage 140 °C.}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Bestimmen Sie den Startpunkt der Aufheizphase.
\item
  Bestimmen Sie den Endpunkt der Aufheizphase.
\item
  Schätzen Sie eine ideale Kennlinie von -10 °C bis 140 °C für die
  Aufheizphase.
\item
  Ermitteln und korrigieren Sie den Empfindlichkeitsfehler in den Daten.
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-spannfehler}: Musterlösung Empfindlichkeitsfehler}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-spannfehler} 

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Startpunkt ermitteln, indem die Position des letzten Werts -10 °C
  bestimmt wird.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{start4 }\OperatorTok{=}\NormalTok{ klimaschrank.loc[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}Thermoelement 4 (°C)\textquotesingle{}}\NormalTok{].eq(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{).idxmax()}
\NormalTok{start15 }\OperatorTok{=}\NormalTok{ klimaschrank.loc[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}Thermoelement 15 (°C)\textquotesingle{}}\NormalTok{].eq(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{).idxmax()}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Endpunkt ermitteln, indem die Position des Maximums bestimmt wird.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ende4 }\OperatorTok{=}\NormalTok{ klimaschrank.loc[:, }\StringTok{\textquotesingle{}Thermoelement 4 (°C)\textquotesingle{}}\NormalTok{].idxmax()}
\NormalTok{ende15 }\OperatorTok{=}\NormalTok{ klimaschrank.loc[:, }\StringTok{\textquotesingle{}Thermoelement 15 (°C)\textquotesingle{}}\NormalTok{].idxmax()}
\end{Highlighting}
\end{Shaded}

Ausgabe.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Messreihe Thermoelement 4 von Index }\SpecialCharTok{\{}\NormalTok{start4}\SpecialCharTok{\}}\SpecialStringTok{ bis Index }\SpecialCharTok{\{}\NormalTok{ende4}\SpecialCharTok{\}}\SpecialStringTok{."}\NormalTok{,}
      \SpecialStringTok{f"Messreihe Thermoelement 15 von Index }\SpecialCharTok{\{}\NormalTok{start15}\SpecialCharTok{\}}\SpecialStringTok{ bis Index }\SpecialCharTok{\{}\NormalTok{ende15}\SpecialCharTok{\}}\SpecialStringTok{."}\NormalTok{,}
\NormalTok{      sep }\OperatorTok{=} \StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Messreihe Thermoelement 4 von Index 36 bis Index 2187.
Messreihe Thermoelement 15 von Index 36 bis Index 2188.
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Ideale Kennlinie und lineare Funktion der Messwerte schätzen,
  Empfindlichkeitsfehler bestimmen.
\end{enumerate}

\section{Thermoelement 4}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# bekannte Referenzpunkte }
\NormalTok{x1 }\OperatorTok{=}\NormalTok{ start4}
\NormalTok{x2 }\OperatorTok{=}\NormalTok{ ende4}
\NormalTok{y1 }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{10}
\NormalTok{y2 }\OperatorTok{=} \DecValTok{140}

\CommentTok{\# ideale Kennlinie schätzen}
\NormalTok{lm\_kennlinie }\OperatorTok{=}\NormalTok{ poly.polyfit(x }\OperatorTok{=}\NormalTok{ [x1, x2], y }\OperatorTok{=}\NormalTok{ [y1, y2], deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}

\CommentTok{\# lineare Funktion der Messwerte schätzen}
\NormalTok{lm\_messwerte }\OperatorTok{=}\NormalTok{ poly.polyfit(x }\OperatorTok{=}\NormalTok{ np.arange(x1, x2 }\OperatorTok{+} \DecValTok{1}\NormalTok{), y }\OperatorTok{=}\NormalTok{ klimaschrank.loc[x1 : x2, }\StringTok{\textquotesingle{}Thermoelement 4 (°C)\textquotesingle{}}\NormalTok{], deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}

\CommentTok{\# Empfindlichkeitsfehler bestimmen}
\NormalTok{spannfehler }\OperatorTok{=}\NormalTok{ lm\_messwerte[}\DecValTok{1}\NormalTok{] }\OperatorTok{/}\NormalTok{ lm\_kennlinie[}\DecValTok{1}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Empfindlichkeitsfehler beträgt: }\SpecialCharTok{\{}\NormalTok{( ((lm\_messwerte[}\DecValTok{1}\NormalTok{] }\OperatorTok{/}\NormalTok{ lm\_kennlinie[}\DecValTok{1}\NormalTok{]) }\OperatorTok{{-}} \DecValTok{1}\NormalTok{) }\OperatorTok{*} \DecValTok{100}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{ \%"}\NormalTok{)}

\CommentTok{\# Empfindlichkeitsfehler korrigieren}
\NormalTok{klimaschrank.loc[ : , }\StringTok{\textquotesingle{}Thermoelement 4 (°C)\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ klimaschrank.loc[ : , }\StringTok{\textquotesingle{}Thermoelement 4 (°C)\textquotesingle{}}\NormalTok{].div(spannfehler)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der Empfindlichkeitsfehler beträgt: 6.66 %
\end{verbatim}

\section{Thermoelement 15}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# bekannte Referenzpunkte }
\NormalTok{x1 }\OperatorTok{=}\NormalTok{ start15}
\NormalTok{x2 }\OperatorTok{=}\NormalTok{ ende15}
\NormalTok{y1 }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{10}
\NormalTok{y2 }\OperatorTok{=} \DecValTok{140}

\CommentTok{\# ideale Kennlinie schätzen}
\NormalTok{lm\_kennlinie }\OperatorTok{=}\NormalTok{ poly.polyfit(x }\OperatorTok{=}\NormalTok{ [x1, x2], y }\OperatorTok{=}\NormalTok{ [y1, y2], deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}

\CommentTok{\# lineare Funktion der Messwerte schätzen}
\NormalTok{lm\_messwerte }\OperatorTok{=}\NormalTok{ poly.polyfit(x }\OperatorTok{=}\NormalTok{ np.arange(x1, x2 }\OperatorTok{+} \DecValTok{1}\NormalTok{), y }\OperatorTok{=}\NormalTok{ klimaschrank.loc[x1 : x2, }\StringTok{\textquotesingle{}Thermoelement 15 (°C)\textquotesingle{}}\NormalTok{], deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}

\CommentTok{\# Empfindlichkeitsfehler bestimmen}
\NormalTok{spannfehler }\OperatorTok{=}\NormalTok{ lm\_messwerte[}\DecValTok{1}\NormalTok{] }\OperatorTok{/}\NormalTok{ lm\_kennlinie[}\DecValTok{1}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Empfindlichkeitsfehler beträgt: }\SpecialCharTok{\{}\NormalTok{( ((lm\_messwerte[}\DecValTok{1}\NormalTok{] }\OperatorTok{/}\NormalTok{ lm\_kennlinie[}\DecValTok{1}\NormalTok{]) }\OperatorTok{{-}} \DecValTok{1}\NormalTok{) }\OperatorTok{*} \DecValTok{100}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{ \%"}\NormalTok{)}

\CommentTok{\# Empfindlichkeitsfehler korrigieren}
\NormalTok{klimaschrank.loc[ : , }\StringTok{\textquotesingle{}Thermoelement 15 (°C)\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ klimaschrank.loc[ : , }\StringTok{\textquotesingle{}Thermoelement 15 (°C)\textquotesingle{}}\NormalTok{].div(spannfehler)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der Empfindlichkeitsfehler beträgt: 5.62 %
\end{verbatim}

\end{tcolorbox}

\section{Nullpunkt- und
Empfindlichkeitsfehler}\label{nullpunkt--und-empfindlichkeitsfehler}

Absolute und multiplikative Abweichungen können gemeinsam auftreten.

\[
\text{Messwerte} = \text{wahre Werte} \cdot Empfindlichkeitsfehler + \text{Nullpunktfehler}
\]

In diesem Beispiel wird die absolute Messabweichung über den
dargestellten Wertebereich kleiner, da der Nullpunktfehler mit positivem
Vorzeichen und der Empfindlichkeitsfehler mit negativen Vorzeichen
auftreten.

\section{Grafik}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/kalibrierung_files/figure-pdf/cell-36-output-1.png}}

\section{Code}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Daten erzeugen}
\NormalTok{messgröße }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{0}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\NormalTok{messwerte }\OperatorTok{=}\NormalTok{ messgröße }\OperatorTok{+} \DecValTok{4} \OperatorTok{{-}}\NormalTok{ messgröße }\OperatorTok{/} \DecValTok{3}

\CommentTok{\# plotten}
\NormalTok{plt.plot(messgröße, marker }\OperatorTok{=} \StringTok{\textquotesingle{}o\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}wahrer Wert\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(messwerte, marker }\OperatorTok{=} \StringTok{\textquotesingle{}\^{}\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}gemessener Wert\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot([}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{], [messgröße[}\DecValTok{0}\NormalTok{], messwerte[}\DecValTok{0}\NormalTok{]], linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}dashed\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Nullpunktfehler\textquotesingle{}}\NormalTok{)}

\CommentTok{\# füllen}
\NormalTok{hilfslinie\_spannfehler }\OperatorTok{=}\NormalTok{ messwerte }\OperatorTok{{-}} \DecValTok{4}
\NormalTok{plt.fill\_between(x }\OperatorTok{=}\NormalTok{ np.arange(messwerte.size), y1 }\OperatorTok{=}\NormalTok{ messgröße, y2 }\OperatorTok{=}\NormalTok{ hilfslinie\_spannfehler, alpha }\OperatorTok{=} \FloatTok{0.2}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Empfindlichkeitsfehler\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Nullpunktfehler abtragen}
\NormalTok{plt.plot([}\DecValTok{4}\NormalTok{, }\DecValTok{4}\NormalTok{], [hilfslinie\_spannfehler[}\DecValTok{4}\NormalTok{] , messwerte[}\DecValTok{4}\NormalTok{]], linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}dashed\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot([}\DecValTok{8}\NormalTok{, }\DecValTok{8}\NormalTok{], [hilfslinie\_spannfehler[}\DecValTok{8}\NormalTok{], messwerte[}\DecValTok{8}\NormalTok{]], linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}dashed\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Achsenbeschriftung}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Index\textquotesingle{}}\NormalTok{) }
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Merkmalsausprägung\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.legend()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\subsection{Nullpunkt- und Empfindlichkeitsfehler
quantifizieren}\label{nullpunkt--und-empfindlichkeitsfehler-quantifizieren}

Aus mindestens zwei bekannten Referenzpunkten können mit linearer
Regression der Nullpunkt- und der Empfindlichkeitsfehler geschätzt
werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Daten erzeugen}
\NormalTok{messgröße }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{0}\NormalTok{, }\DecValTok{11}\NormalTok{) }\OperatorTok{*} \DecValTok{2} \OperatorTok{+} \DecValTok{7}
\NormalTok{messwerte }\OperatorTok{=}\NormalTok{ messgröße }\OperatorTok{+} \DecValTok{24} \OperatorTok{{-}}\NormalTok{ messgröße }\OperatorTok{/} \DecValTok{3}

\CommentTok{\# bekannte Referenzpunkte}
\NormalTok{x1 }\OperatorTok{=} \DecValTok{4}
\NormalTok{x2 }\OperatorTok{=} \DecValTok{8}
\NormalTok{y1 }\OperatorTok{=}\NormalTok{ messgröße[x1]}
\NormalTok{y2 }\OperatorTok{=}\NormalTok{ messgröße[x2]}

\CommentTok{\# lineare Regression mit x = Referenzwerte und y = Messwerte}
\NormalTok{lm\_referenzpunkte }\OperatorTok{=}\NormalTok{ poly.polyfit(x }\OperatorTok{=}\NormalTok{ [messgröße[x1], messgröße[x2]], y }\OperatorTok{=}\NormalTok{ [messwerte[x1], messwerte[x2]], deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(lm\_referenzpunkte, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\CommentTok{\#\# Nullpunktfehler bestimmen}
\NormalTok{nullpunktfehler }\OperatorTok{=}\NormalTok{ lm\_referenzpunkte[}\DecValTok{0}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Nullpunktfehler beträgt: }\SpecialCharTok{\{}\NormalTok{nullpunktfehler}\SpecialCharTok{.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\#\# Empfindlichkeitsfehler bestimmen}
\NormalTok{spannfehler }\OperatorTok{=}\NormalTok{ lm\_referenzpunkte[}\DecValTok{1}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Empfindlichkeitsfehler beträgt: }\SpecialCharTok{\{}\NormalTok{((spannfehler }\OperatorTok{{-}} \DecValTok{1}\NormalTok{) }\OperatorTok{*} \DecValTok{100}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{ \%"}\NormalTok{)}

\CommentTok{\#\# Alternativ: Empfindlichkeitsfehler bestimmen}
\CommentTok{\#\#\# ideale Kennlinie schätzen}
\NormalTok{lm\_kennlinie }\OperatorTok{=}\NormalTok{ poly.polyfit(x }\OperatorTok{=}\NormalTok{ [x1, x2], y }\OperatorTok{=}\NormalTok{ [y1, y2], deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\CommentTok{\# print(f"lm\_kennlinie: \{lm\_kennlinie\}")}

\CommentTok{\#\#\#lineare Regression der Messwerte}
\NormalTok{lm\_messwerte }\OperatorTok{=}\NormalTok{ poly.polyfit(x }\OperatorTok{=}\NormalTok{ np.arange(messwerte.size), y }\OperatorTok{=}\NormalTok{ messwerte, deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\CommentTok{\# print(f"lm\_messwerte: \{lm\_messwerte\}")}

\CommentTok{\#\#\# Empfindlichkeitsfehler bestimmen}
\NormalTok{spannfehler }\OperatorTok{=}\NormalTok{ lm\_messwerte[}\DecValTok{1}\NormalTok{] }\OperatorTok{/}\NormalTok{ lm\_kennlinie[}\DecValTok{1}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Empfindlichkeitsfehler beträgt: }\SpecialCharTok{\{}\NormalTok{((spannfehler }\OperatorTok{{-}} \DecValTok{1}\NormalTok{) }\OperatorTok{*} \DecValTok{100}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{ \%"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[24.          0.66666667] 

Der Nullpunktfehler beträgt: 24.0
Der Empfindlichkeitsfehler beträgt: -33.33 %
Der Empfindlichkeitsfehler beträgt: -33.33 %
\end{verbatim}

\subsection{Nullpunkt- und Empfindlichkeitsfehler
korrigieren}\label{nullpunkt--und-empfindlichkeitsfehler-korrigieren}

Bei der Korrektur von Nullpunkt- und Empfindlichkeitsfehler
unterscheidet sich das Vorgehen abhängig von der Reihenfolge der
vorgenommenen Korrekturen.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Zuerst wird der Nullpunktfehler korrigiert, danach der
  Empfindlichkeitsfehler.
\end{enumerate}

\[
korrigierte ~ Messwerte = \frac{(Messwerte - Nullpunktfehler)}{Empfindlichkeitsfehler}
\]

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Zuerst wird der Empfindlichkeitsfehler korrigiert, danach der
  Nullpunktfehler.
\end{enumerate}

\[
korrigierte ~ Messwerte = \frac{Messwerte}{Empfindlichkeitsfehler} - \frac{Nullpunktfehler}{Empfindlichkeitsfehler}
\]

Ein Beispiel:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Daten erzeugen}
\NormalTok{messgröße }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{0}\NormalTok{, }\DecValTok{11}\NormalTok{) }\OperatorTok{*} \DecValTok{2} \OperatorTok{+} \DecValTok{7}
\NormalTok{messwerte }\OperatorTok{=}\NormalTok{ messgröße }\OperatorTok{+} \DecValTok{4} \OperatorTok{{-}}\NormalTok{ messgröße }\OperatorTok{/} \DecValTok{3}

\CommentTok{\# bekannte Referenzpunkte}
\NormalTok{x1 }\OperatorTok{=} \DecValTok{4}
\NormalTok{x2 }\OperatorTok{=} \DecValTok{8}
\NormalTok{y1 }\OperatorTok{=}\NormalTok{ messgröße[x1]}
\NormalTok{y2 }\OperatorTok{=}\NormalTok{ messgröße[x2]}

\CommentTok{\# Ausgabe}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Wahre Werte:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{messgr}\SpecialCharTok{öß}\NormalTok{e}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Messwerte:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{messwerte}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{()}

\CommentTok{\# ideale Kennlinie schätz\# lineare Regression mit x = Referenzwerte und y = Messwerte}
\NormalTok{lm\_referenzpunkte }\OperatorTok{=}\NormalTok{ poly.polyfit(x }\OperatorTok{=}\NormalTok{ [messgröße[x1], messgröße[x2]], y }\OperatorTok{=}\NormalTok{ [messwerte[x1], messwerte[x2]], deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}

\CommentTok{\#\# Nullpunktfehler bestimmen}
\NormalTok{nullpunktfehler }\OperatorTok{=}\NormalTok{ lm\_referenzpunkte[}\DecValTok{0}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Nullpunktfehler beträgt: }\SpecialCharTok{\{}\NormalTok{nullpunktfehler}\SpecialCharTok{.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\#\# Empfindlichkeitsfehler bestimmen}
\NormalTok{spannfehler }\OperatorTok{=}\NormalTok{ lm\_referenzpunkte[}\DecValTok{1}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Empfindlichkeitsfehler beträgt: }\SpecialCharTok{\{}\NormalTok{spannfehler}\SpecialCharTok{.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{()}

\CommentTok{\# erst Nullpunktfehler, dann Empfindlichkeitsfehler korrigieren}
\NormalTok{korrigierte\_messwerte }\OperatorTok{=}\NormalTok{ messwerte }\OperatorTok{{-}}\NormalTok{ nullpunktfehler}
\NormalTok{korrigierte\_messwerte }\OperatorTok{=}\NormalTok{ korrigierte\_messwerte }\OperatorTok{/}\NormalTok{ spannfehler}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"erst Nullpunktfehler, dann Empfindlichkeitsfehler korrigiert:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{korrigierte\_messwerte}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# erst Empfindlichkeitsfehler, dann Nullpunkt korrigieren}
\NormalTok{korrigierte\_messwerte }\OperatorTok{=}\NormalTok{ messwerte }\OperatorTok{/}\NormalTok{ spannfehler}
\NormalTok{korrigierte\_messwerte }\OperatorTok{=}\NormalTok{ korrigierte\_messwerte }\OperatorTok{{-}}\NormalTok{ (nullpunktfehler }\OperatorTok{/}\NormalTok{ spannfehler)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"erst Empfindlichkeitsfehler, dann Nullpunktfehler korrigiert:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{korrigierte\_messwerte}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Wahre Werte:
[ 7  9 11 13 15 17 19 21 23 25 27]
Messwerte:
[ 8.66666667 10.         11.33333333 12.66666667 14.         15.33333333
 16.66666667 18.         19.33333333 20.66666667 22.        ]

Der Nullpunktfehler beträgt: 4.0
Der Empfindlichkeitsfehler beträgt: 0.67

erst Nullpunktfehler, dann Empfindlichkeitsfehler korrigiert:
[ 7.  9. 11. 13. 15. 17. 19. 21. 23. 25. 27.]
erst Empfindlichkeitsfehler, dann Nullpunktfehler korrigiert:
[ 7.  9. 11. 13. 15. 17. 19. 21. 23. 25. 27.]
\end{verbatim}

\section{Nichtlinearität:
Linearitätsfehler}\label{nichtlinearituxe4t-linearituxe4tsfehler}

Bei einer idealen Messung hängt der gesuchte Wert linear vom gemessenen
Wert ab. Viele analoge Sensoren reagieren aufgrund von
Materialeigenschaften oder abhängig von der Temperatur nicht linear auf
die gemessene Größe. Das heißt, die Messwerte sind nicht direkt
proportional zur Messgröße.

Dem kann zum einen durch die Anwendung von Kalibriermethoden wie der
Korrektionstabelle oder von nicht linearen Verfahren zur
Parameterschätzung, die im
\href{https://bausteine-der-datenanalyse.github.io/m-datenfitting-und-optimierung/output/book/}{Methodenbaustein
Datenfitting und Datenoptimierung} behandelt werden, begegnet werden.
Zum anderen können die Daten linear approximiert werden, um mit den
leichter zu handhabenden linearen Verfahren der Parameterschätzung
arbeiten zu können. Der dabei auftretende \textbf{Linearitätsfehler}
muss quantifiziert werden. Dieses Vorgehen wird hier vorgestellt.

\subsection{Beispiel Pt100}\label{sec-pt100}

Das Pt100 ist ein Platin-Widerstandsthermometer (Pt = Platin) mit einem
definierten Widerstandswert von \(100 \Omega\) bei einer Temperatur von
0°C (daher der Name Pt\textbf{100}). Der Widerstand eines Pt100 steigt
mit der Temperatur. Bei 100 °C beträgt der Widerstand beispielsweise
\(138,51 \Omega\). Der Zusammenhang zwischen der Eingangsgröße, dem
elektrischen Widerstand, und der so gemessenen Temperatur ist jedoch nur
näherungsweise linear.

Die Eigenschaften eines Pt100 Widerstandes sind in der Norm DIN EN IEC
60751 {[}@DIN60751{]} festgelegt. Dort wird der Zusammenhang durch zwei
Polynome für den Temperaturbereich von -200 °C bis 0 °C und für den
Temperaturbereich von 0 °C bis 850 °C beschrieben.

Für den Temperaturbereich --200 °C bis 0 °C: \[
R_T = R_0 \cdot \left(1 + A \cdot T + B \cdot T^2 + C \cdot (T - 100 ^\circ\text{C}) \cdot T^3\right)
\]

Für den Temperaturbereich von 0 °C bis +850 °C: \[
R_T = R_0 \cdot \left(1 + A \cdot T + B \cdot T^2\right)
\]

Dabei gilt:

\begin{itemize}
\item
  \(R_T\) ist der Widerstand bei der Temperatur \(T\),
\item
  \(R_0\) ist der Widerstand bei \(0^\circ\text{C}\),
\item
  \(A\), \(B\) und \(C\) sind Konstanten, die den spezifischen Charakter
  des Sensors beschreiben. Dabei sind:

  \begin{itemize}
  \tightlist
  \item
    \(A = 3.9083 \times 10^{-3} ~ {^\circ\text{C}}^{-1}\)
  \item
    \(B = -5.775 \times 10^{-7} ~ {^\circ\text{C}}^{-2}\)
  \item
    \(C = -4.183 \times 10^{-12} ~ {^\circ\text{C}}^{-4}\)
  \end{itemize}
\end{itemize}

{[}@DIN60751, S. 13{]}

Im Anhang der Norm befinden sich Tabellen, die die Beziehung zwischen
Temperatur und gemessenem Widerstand wiedergeben. Das Format der
Tabellen erlaubt es, aus einem gemessenen Widerstandswert schnell die
gemessene Temperatur zu ermitteln. Dazu sind in der ersten Spalte die
Temperaturen in Zehnerschritten, in den folgenden zehn Spalten die
Einerstelle eingetragen. Für Temperaturen unter Null ist die Einerstelle
jeweils zu subtrahieren (erkennbar am Vorzeichen \(-\)), für
Temperaturen über Null dagegen zu addieren (erkennbar am Vorzeichen
\(+\)). Eine zusammengefasste Darstellung finden Sie zum Beispiel
\href{https://s8b8d6a7.delivery.rocketcdn.me/wp-content/uploads/2022/08/Pt100-Tabelle-Screen.pdf}{hier}.

\begin{figure}

\centering{

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/00-bilder/pt100-table-din60751.png}}

}

\caption{\label{fig-pt100}Ausschnitt der Tabelle A.1}

\end{figure}%

{[}@DIN60751, S. 25{]}

Die Notation \(t_{90} / °C\) beruht auf der Internationalen
Temperaturskala ITS-90 von 1990, die Temperaturen \(T_{90}\) in Kelvin
und \(t_{90}\) in Grad Celsius definiert. Die Notation zeigt also an,
dass in der Tabelle Angaben in Grad Celsius stehen. (@DIN60751, S. 10)

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-pt100}: Pt100-Tabelle einlesen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-pt100} 

Für die Datenanalyse ist das tabellarische Format weniger geeignet. Die
\href{https://s8b8d6a7.delivery.rocketcdn.me/wp-content/uploads/2022/08/Pt100-Tabelle-Screen.pdf}{hier}
zusammengefasste Darstellung wurde in zwei CSV-Dateien kopiert.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dateipfad\_belowzero }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/pt100{-}table{-}below{-}zero.csv\textquotesingle{}}
\NormalTok{dateipfad\_abovezero }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/pt100{-}table{-}above{-}zero.csv\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

Die Dateien soll so eingelesen werden, dass der elektrische Widerstand
und die Temperatur jeweils eine aufsteigende Datenreihe bilden. Zunächst
betrachten wir die Datei mit mit Temperaturen unter 0 Grad Celsius.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# belowzero}
\NormalTok{belowzero }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ dateipfad\_belowzero, sep }\OperatorTok{=} \StringTok{\textquotesingle{},\textquotesingle{}}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(belowzero.head(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(belowzero.tail())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   Temperatur in °C Unnamed: 1 Unnamed: 2 Unnamed: 3 Unnamed: 4 Unnamed: 5  \
0               NaN          0         -1         -2         -3         -4   
1            -200.0      18,52        NaN        NaN        NaN        NaN   
2            -190.0      22,83       22,4      21,97      21,54      21,11   
3            -180.0       27,1      26,67      26,24      25,82      25,39   
4            -170.0      31,34      30,91      30,49      30,07      29,64   

  Unnamed: 6 Unnamed: 7 Unnamed: 8 Unnamed: 9 Unnamed: 10  
0         -5         -6         -7         -8          -9  
1        NaN        NaN        NaN        NaN         NaN  
2      20,68      20,25      19,82      19,38       18,95  
3      24,97      24,54      24,11      23,68       23,25  
4      29,22       28,8      28,37      27,95       27,52   

    Temperatur in °C Unnamed: 1 Unnamed: 2 Unnamed: 3 Unnamed: 4 Unnamed: 5  \
17             -40.0      84,27      83,87      83,48      83,08      82,69   
18             -30.0      88,22      87,83      87,43      87,04      86,64   
19             -20.0      92,16      91,77      91,37      90,98      90,59   
20             -10.0      96,09      95,69       95,3      94,91      94,52   
21               0.0        100      99,61      99,22      98,83      98,44   

   Unnamed: 6 Unnamed: 7 Unnamed: 8 Unnamed: 9 Unnamed: 10  
17      82,29      81,89       81,5       81,1        80,7  
18      86,25      85,85      85,46      85,06       84,67  
19      90,19       89,8       89,4      89,01       88,62  
20      94,12      93,73      93,34      92,95       92,55  
21      98,04      97,65      97,26      96,87       96,48  
\end{verbatim}

Es gibt 201 Werte (von -200 bis 0). Die Daten beginnen in der Zeile mit
dem Index 1 (wenn die erste Zeile als header eingelesen wird). Diese
enthält nur einen Eintrag in der Spalte `0'. Die folgenden Zeilen sind
von rechts nach links einzulesen. Das Dezimaltrennzeichen ist das
\texttt{,}. Das Einlesen der Daten von rechts nach links kann auf viele
Arten bewerkstelligt werden. Eine einzeilige Lösung beginnt damit, der
Methode \texttt{pd.iloc{[}::-1{]}} eine negative Schrittweite zu
übergeben.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(np.array([[}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{], [}\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{]]))}
\BuiltInTok{print}\NormalTok{(df, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(df.iloc[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   0  1  2
0  3  2  1
1  6  5  4 

   0  1  2
1  6  5  4
0  3  2  1
\end{verbatim}

Das führt dazu, dass die \emph{Zeilen} des DataFrame in umgekehrter
Reihenfolge ausgegeben werden. Um die \emph{Spalten} in umgekehrter
Reihenfolge auszugeben, wird der DataFrame mit der Methode \texttt{pd.T}
zwei mal transponiert.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df.T.iloc[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{].T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   2  1  0
0  1  2  3
1  4  5  6
\end{verbatim}

Mit der NumPy-Methode \texttt{np.flatten()} kann ein Array in eine
eindimensionale Struktur reduziert werden. Dafür wird mit der Methode
\texttt{pd.to\_numpy()} der DataFrame als NumPy-Array ausgegeben.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df.T.iloc[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{].T.to\_numpy())}
\BuiltInTok{print}\NormalTok{() }\CommentTok{\# leere Zeile}
\BuiltInTok{print}\NormalTok{(df.T.iloc[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{].T.to\_numpy().flatten())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[1 2 3]
 [4 5 6]]

[1 2 3 4 5 6]
\end{verbatim}

Versuchen wir es mit dem Kopf der Pt100-Daten.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{belowzero }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ dateipfad\_belowzero, sep }\OperatorTok{=} \StringTok{\textquotesingle{},\textquotesingle{}}\NormalTok{, decimal }\OperatorTok{=} \StringTok{\textquotesingle{},\textquotesingle{}}\NormalTok{, header }\OperatorTok{=} \DecValTok{0}\NormalTok{, skiprows }\OperatorTok{=} \DecValTok{1}\NormalTok{, index\_col }\OperatorTok{=} \DecValTok{0}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(belowzero.head())}
\BuiltInTok{print}\NormalTok{() }\CommentTok{\# leere Zeile}
\BuiltInTok{print}\NormalTok{(belowzero.head().T.iloc[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{].T.to\_numpy().flatten())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
          0     -1     -2     -3     -4     -5     -6     -7     -8     -9
-200  18.52    NaN    NaN    NaN    NaN    NaN    NaN    NaN    NaN    NaN
-190  22.83  22.40  21.97  21.54  21.11  20.68  20.25  19.82  19.38  18.95
-180  27.10  26.67  26.24  25.82  25.39  24.97  24.54  24.11  23.68  23.25
-170  31.34  30.91  30.49  30.07  29.64  29.22  28.80  28.37  27.95  27.52
-160  35.54  35.12  34.70  34.28  33.86  33.44  33.02  32.60  32.18  31.76

[  nan   nan   nan   nan   nan   nan   nan   nan   nan 18.52 18.95 19.38
 19.82 20.25 20.68 21.11 21.54 21.97 22.4  22.83 23.25 23.68 24.11 24.54
 24.97 25.39 25.82 26.24 26.67 27.1  27.52 27.95 28.37 28.8  29.22 29.64
 30.07 30.49 30.91 31.34 31.76 32.18 32.6  33.02 33.44 33.86 34.28 34.7
 35.12 35.54]
\end{verbatim}

Um die fehlenden Werte zu überspringen, wandeln wir das bisherige
Ergebnis wieder in eine \texttt{pd.Series()} um und verwenden die
Methode \texttt{pd.Series.dropna()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pd.Series(belowzero.head().T.iloc[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{].T.to\_numpy().flatten()).dropna()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
9     18.52
10    18.95
11    19.38
12    19.82
13    20.25
14    20.68
15    21.11
16    21.54
17    21.97
18    22.40
19    22.83
20    23.25
21    23.68
22    24.11
23    24.54
24    24.97
25    25.39
26    25.82
27    26.24
28    26.67
29    27.10
30    27.52
31    27.95
32    28.37
33    28.80
34    29.22
35    29.64
36    30.07
37    30.49
38    30.91
39    31.34
40    31.76
41    32.18
42    32.60
43    33.02
44    33.44
45    33.86
46    34.28
47    34.70
48    35.12
49    35.54
dtype: float64
\end{verbatim}

Und jetzt für die gesamte Datei:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{belowzero\_ohm }\OperatorTok{=}\NormalTok{ pd.Series(belowzero.T.iloc[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{].T.to\_numpy().flatten()).dropna()}
\BuiltInTok{print}\NormalTok{(belowzero\_ohm.head(), belowzero\_ohm.tail(), sep }\OperatorTok{=} \StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
9     18.52
10    18.95
11    19.38
12    19.82
13    20.25
dtype: float64
205     98.44
206     98.83
207     99.22
208     99.61
209    100.00
dtype: float64
\end{verbatim}

Die Temperatur können wir einfach durch ein range-Objekt erzeugen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{belowzero\_temperatur }\OperatorTok{=}\NormalTok{ pd.Series(}\BuiltInTok{range}\NormalTok{(}\OperatorTok{{-}}\DecValTok{200}\NormalTok{, }\DecValTok{1}\NormalTok{)) }\CommentTok{\# range stop ist exklusiv}
\BuiltInTok{print}\NormalTok{(belowzero\_temperatur.head(), belowzero\_temperatur.tail(), sep }\OperatorTok{=} \StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0   -200
1   -199
2   -198
3   -197
4   -196
dtype: int64
196   -4
197   -3
198   -2
199   -1
200    0
dtype: int64
\end{verbatim}

Für die Temperaturen oberhalb von 0 Grad kann das Vorgehen vereinfacht
werden, da die Datei gleich aufgebaut ist und die Werte aufsteigend
sortiert sind.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{abovezero }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=}\NormalTok{ dateipfad\_abovezero, sep }\OperatorTok{=} \StringTok{\textquotesingle{},\textquotesingle{}}\NormalTok{, decimal }\OperatorTok{=} \StringTok{\textquotesingle{},\textquotesingle{}}\NormalTok{, header }\OperatorTok{=} \DecValTok{0}\NormalTok{, skiprows }\OperatorTok{=} \DecValTok{1}\NormalTok{, index\_col }\OperatorTok{=} \DecValTok{0}\NormalTok{)}

\NormalTok{abovezero\_ohm }\OperatorTok{=}\NormalTok{ pd.Series(abovezero.to\_numpy().flatten()).dropna()}
\BuiltInTok{print}\NormalTok{(abovezero\_ohm.head(), abovezero\_ohm.tail(), sep }\OperatorTok{=} \StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0    100.00
1    100.39
2    100.78
3    101.17
4    101.56
dtype: float64
846    389.31
847    389.60
848    389.90
849    390.19
850    390.48
dtype: float64
\end{verbatim}

Beide Datensätze enthalten einen Eintrag für die Temperatur 0 Grad,
sodass dieser in der zweiten Datei entfernt werden kann.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{abovezero\_ohm }\OperatorTok{=}\NormalTok{ abovezero\_ohm[}\DecValTok{1}\NormalTok{:]}
\BuiltInTok{print}\NormalTok{(abovezero\_ohm.head(), abovezero\_ohm.tail(), sep }\OperatorTok{=} \StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1    100.39
2    100.78
3    101.17
4    101.56
5    101.95
dtype: float64
846    389.31
847    389.60
848    389.90
849    390.19
850    390.48
dtype: float64
\end{verbatim}

Die Temperatur wird wieder durch ein range-Objekt erzeugt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{abovezero\_temperatur }\OperatorTok{=}\NormalTok{ pd.Series(}\BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{851}\NormalTok{)) }\CommentTok{\# range stop ist exklusiv}
\end{Highlighting}
\end{Shaded}

Die aus beiden Datensätzen erzeugten Series können zusammengefasst
werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pt100 }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}Temperatur\textquotesingle{}}\NormalTok{: pd.concat([belowzero\_temperatur, abovezero\_temperatur], ignore\_index }\OperatorTok{=} \VariableTok{True}\NormalTok{), }\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{: pd.concat([belowzero\_ohm, abovezero\_ohm], ignore\_index }\OperatorTok{=} \VariableTok{True}\NormalTok{)\})}
\BuiltInTok{print}\NormalTok{(pt100.head(), pt100.tail(), sep }\OperatorTok{=} \StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(pt100.info())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   Temperatur    Ohm
0        -200  18.52
1        -199  18.95
2        -198  19.38
3        -197  19.82
4        -196  20.25
      Temperatur     Ohm
1046         846  389.31
1047         847  389.60
1048         848  389.90
1049         849  390.19
1050         850  390.48
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 1051 entries, 0 to 1050
Data columns (total 2 columns):
 #   Column      Non-Null Count  Dtype  
---  ------      --------------  -----  
 0   Temperatur  1051 non-null   int64  
 1   Ohm         1051 non-null   float64
dtypes: float64(1), int64(1)
memory usage: 16.6 KB
None
\end{verbatim}

\end{tcolorbox}

\subsection{Nichtlinearität
darstellen}\label{nichtlinearituxe4t-darstellen}

Mit den Daten aus Note~\ref{nte-pt100} kann die Nichtlinearität des
Sensors dargestellt werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(pt100[}\StringTok{\textquotesingle{}Temperatur\textquotesingle{}}\NormalTok{], pt100[}\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{], marker }\OperatorTok{=} \StringTok{\textquotesingle{}o\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}elektrischer Widerstand\textquotesingle{}}\NormalTok{, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{)}
\NormalTok{plt.plot([pt100[}\StringTok{\textquotesingle{}Temperatur\textquotesingle{}}\NormalTok{].iloc[}\DecValTok{0}\NormalTok{], pt100[}\StringTok{\textquotesingle{}Temperatur\textquotesingle{}}\NormalTok{].iloc[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]], [pt100[}\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{].iloc[}\DecValTok{0}\NormalTok{], pt100[}\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{].iloc[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]], linewidth }\OperatorTok{=} \DecValTok{2}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Referenzlinie\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.yticks(pt100[}\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{][::}\DecValTok{50}\NormalTok{])}\OperatorTok{;}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Temperatur in °C\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}elektrischer Widerstand in Ohm\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.legend()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/kalibrierung_files/figure-pdf/cell-53-output-1.png}}

~

Es fällt auf, dass die Daten einen Fehlwert enthalten. Die Position des
Fehlwerts wird mit zwei Pandas-Methoden bestimmt. \texttt{pd.diff()}
gibt die Differenz jedes Werts zu seinem Vorgänger zurück.
\texttt{pd.idxmin()} gibt den Zeilenindex (genauer das label) des
kleinsten Werts zurück. (Läge der Fehlwert oberhalb der Linie, würde
\texttt{pd.idxmax()} verwendet werden.)

\begin{Shaded}
\begin{Highlighting}[]
 \CommentTok{\# := ist der sog. Walross{-}Operator}
\BuiltInTok{print}\NormalTok{(( position\_fehlwert }\OperatorTok{:=}\NormalTok{ pt100[}\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{].diff().idxmin() ))}
\BuiltInTok{print}\NormalTok{(pt100.iloc[}\BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(position\_fehlwert }\OperatorTok{{-}} \DecValTok{2}\NormalTok{, position\_fehlwert }\OperatorTok{+} \DecValTok{3}\NormalTok{))])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
341
     Temperatur     Ohm
339         139  153.21
340         140  153.58
341         141   13.96
342         142  154.33
343         143  154.71
\end{verbatim}

Der korrekte Wert kann aus der DIN-Norm {[}@DIN60751, S. 26{]} abgelesen
werden (153,96). Man könnte den Wert aber auch interpolieren (siehe
Beispiel).

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-interpolieren}: Interpolation}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-interpolieren} 

Die einfachste Form der Interpolation ist die lineare Interpolation.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interpolate\_me }\OperatorTok{=}\NormalTok{ pt100.loc[position\_fehlwert }\OperatorTok{{-}} \DecValTok{1}\NormalTok{ : position\_fehlwert }\OperatorTok{+} \DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{].copy()}
\NormalTok{interpolate\_me[position\_fehlwert] }\OperatorTok{=}\NormalTok{ np.nan}
\BuiltInTok{print}\NormalTok{(interpolate\_me, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"linear interpolierter Wert:"}\NormalTok{, interpolate\_me.interpolate(), sep }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
340    153.58
341       NaN
342    154.33
Name: Ohm, dtype: float64 

linear interpolierter Wert:
340    153.580
341    153.955
342    154.330
Name: Ohm, dtype: float64
\end{verbatim}

Durch Runden wird das korrekte Ergebnis erreicht (darauf verlassen
sollte man sich aber nicht).

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"linear interpolierter Wert:"}\NormalTok{, interpolate\_me.interpolate().}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{), sep }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{korrekter\_wert }\OperatorTok{=}\NormalTok{ interpolate\_me.interpolate().}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)[position\_fehlwert]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
linear interpolierter Wert:
340    153.58
341    153.96
342    154.33
Name: Ohm, dtype: float64
\end{verbatim}

Eine andere Option ist die nichtlineare Interpolation (die nicht Inhalt
dieses Bausteins ist).

\phantomsection\label{nte-nonlinear}
\begin{quote}
\textbf{Note~70.3: Nichtlineare Interpolation}

Die nichtlineare Interpolation benötigt mehr Datenpunkte. Wir versuchen
die kubische Interpolation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interpolate\_me\_again }\OperatorTok{=}\NormalTok{ pt100.loc[position\_fehlwert }\OperatorTok{{-}} \DecValTok{3}\NormalTok{ : position\_fehlwert }\OperatorTok{+} \DecValTok{4}\NormalTok{, }\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{].copy()}
\NormalTok{interpolate\_me\_again[position\_fehlwert] }\OperatorTok{=}\NormalTok{ np.nan}
\BuiltInTok{print}\NormalTok{(}\StringTok{"polynomial interpolierter Wert:"}\NormalTok{, interpolate\_me\_again.interpolate(method }\OperatorTok{=} \StringTok{\textquotesingle{}polynomial\textquotesingle{}}\NormalTok{, order }\OperatorTok{=} \DecValTok{3}\NormalTok{), sep }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
polynomial interpolierter Wert:
338    152.830000
339    153.210000
340    153.580000
341    153.952213
342    154.330000
343    154.710000
344    155.080000
345    155.460000
Name: Ohm, dtype: float64
\end{verbatim}

Das Ergebnis ist ungenauer. Warum das so ist, erfahren Sie im
\href{https://bausteine-der-datenanalyse.github.io/m-datenfitting-und-optimierung/output/book/}{Methodenbaustein
Datenfitting und Datenoptimierung}.
\end{quote}

\end{tcolorbox}

Der Fehlwert (dessen Position in obigem Beispiel bestimmt wird) wird
korrigiert:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pt100.loc[position\_fehlwert, }\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ korrekter\_wert}
\BuiltInTok{print}\NormalTok{(pt100.loc[position\_fehlwert }\OperatorTok{{-}} \DecValTok{1}\NormalTok{ : position\_fehlwert }\OperatorTok{+} \DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
340    153.58
341    153.96
342    154.33
Name: Ohm, dtype: float64
\end{verbatim}

Sodann kann die Nichtlinearität erneut dargestellt werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(pt100[}\StringTok{\textquotesingle{}Temperatur\textquotesingle{}}\NormalTok{], pt100[}\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{], marker }\OperatorTok{=} \StringTok{\textquotesingle{}o\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}elektrischer Widerstand\textquotesingle{}}\NormalTok{, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{)}
\NormalTok{plt.plot([pt100[}\StringTok{\textquotesingle{}Temperatur\textquotesingle{}}\NormalTok{].iloc[}\DecValTok{0}\NormalTok{], pt100[}\StringTok{\textquotesingle{}Temperatur\textquotesingle{}}\NormalTok{].iloc[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]], [pt100[}\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{].iloc[}\DecValTok{0}\NormalTok{], pt100[}\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{].iloc[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]], linewidth }\OperatorTok{=} \DecValTok{2}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Referenzlinie\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.yticks(pt100[}\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{][::}\DecValTok{50}\NormalTok{])}\OperatorTok{;}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Temperatur in °C\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}elektrischer Widerstand in Ohm\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.legend()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/kalibrierung_files/figure-pdf/cell-59-output-1.png}}

\subsection{Nichtlinearität
quantifizieren}\label{nichtlinearituxe4t-quantifizieren}

Zwei Methoden zur Quantifizierung der Nichtliniearität sind die
Festpunkt- und die Toleranzbandmethode.

\subsubsection{Festpunktmethode}\label{festpunktmethode}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-festpunktmethode}: Festpunktmethode}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-festpunktmethode} 

Die Endpunkte der realen Kennlinie werden durch eine Gerade verbunden.
Der Linearitätsfehler ist das Maximum der Abweichung der Kennlinie zu
dieser Geraden. {[}@Dubbel2011, S. W2-W3 (S. 1661-1662){]}

\end{tcolorbox}

Dazu bestimmen wir zunächst die Vorhersagewerte einer Geraden durch die
Endpunkte.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lm }\OperatorTok{=}\NormalTok{ poly.polyfit(}
\NormalTok{  x }\OperatorTok{=}\NormalTok{ [pt100[}\StringTok{\textquotesingle{}Temperatur\textquotesingle{}}\NormalTok{].iloc[}\DecValTok{0}\NormalTok{], pt100[}\StringTok{\textquotesingle{}Temperatur\textquotesingle{}}\NormalTok{].iloc[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]],}
\NormalTok{  y }\OperatorTok{=}\NormalTok{ [pt100[}\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{].iloc[}\DecValTok{0}\NormalTok{], pt100[}\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{].iloc[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]],}
\NormalTok{  deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(lm.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)) }\CommentTok{\# intercept + slope}

\NormalTok{vorhersagewerte }\OperatorTok{=}\NormalTok{ poly.polyval(x }\OperatorTok{=}\NormalTok{ pt100[}\StringTok{\textquotesingle{}Temperatur\textquotesingle{}}\NormalTok{], c }\OperatorTok{=}\NormalTok{ lm)}

\NormalTok{plt.plot(pt100[}\StringTok{\textquotesingle{}Temperatur\textquotesingle{}}\NormalTok{], pt100[}\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{], marker }\OperatorTok{=} \StringTok{\textquotesingle{}o\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}elektrischer Widerstand\textquotesingle{}}\NormalTok{, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{)}
\NormalTok{plt.plot(pt100[}\StringTok{\textquotesingle{}Temperatur\textquotesingle{}}\NormalTok{], vorhersagewerte, linewidth }\OperatorTok{=} \DecValTok{2}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Vorhersagewerte endpunktverbindende Gerade\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.yticks(pt100[}\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{][::}\DecValTok{50}\NormalTok{])}\OperatorTok{;}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Temperatur in °C\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}elektrischer Widerstand in Ohm\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.legend()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[89.37  0.35]
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/kalibrierung_files/figure-pdf/cell-60-output-2.png}}

~

Aus der Differenz des gemessenen elektrischen Widerstands und der
linearen Vorhersagewerte kann der maximale Linearitätsfehler bestimmt
werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{linearitätsfehler\_festpunkt }\OperatorTok{=}\NormalTok{ (pt100[}\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ vorhersagewerte).}\BuiltInTok{abs}\NormalTok{().}\BuiltInTok{max}\NormalTok{()}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Linearitätsfehler nach Festpunktmethode: }\SpecialCharTok{\{}\NormalTok{linearit}\SpecialCharTok{ä}\NormalTok{tsfehler\_festpunkt}\SpecialCharTok{:.2f\}}\SpecialStringTok{ Ohm."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Linearitätsfehler nach Festpunktmethode: 16.43 Ohm.
\end{verbatim}

\subsubsection{Toleranzbandmethode}\label{toleranzbandmethode}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-toleranzbandmethode}: Toleranzbandmethode}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-toleranzbandmethode} 

Bei der Toleranzbandmethode wird eine Gerade so durch die Messpunkte
gelegt, dass die Summe der quadrierten Abweichungen der Messpunkte zu
dieser Geraden (Methode der kleinsten Quadrate) oder die größte einzelne
Abweichung
(\href{https://de.wikipedia.org/wiki/Tschebyschow-Polynom}{Tschebyscheff-Approximation})
minimiert wird. Die Größe des Linearitätsfehlers ist die maximale
senkrechte Entfernung der Kennlinie zu dieser Ausgleichsgeraden.
{[}@Dubbel2011, S. W3 (S. 1662){]}

\end{tcolorbox}

Das Prinzip der Methode der kleinsten Quadrate haben wir bereits
kennengelernt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lm }\OperatorTok{=}\NormalTok{ poly.polyfit(}
\NormalTok{  x }\OperatorTok{=}\NormalTok{ pt100[}\StringTok{\textquotesingle{}Temperatur\textquotesingle{}}\NormalTok{],}
\NormalTok{  y }\OperatorTok{=}\NormalTok{ pt100[}\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{],}
\NormalTok{  deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(lm.}\BuiltInTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)) }\CommentTok{\# intercept + slope}

\NormalTok{vorhersagewerte }\OperatorTok{=}\NormalTok{ poly.polyval(x }\OperatorTok{=}\NormalTok{ pt100[}\StringTok{\textquotesingle{}Temperatur\textquotesingle{}}\NormalTok{], c }\OperatorTok{=}\NormalTok{ lm)}

\NormalTok{plt.plot(pt100[}\StringTok{\textquotesingle{}Temperatur\textquotesingle{}}\NormalTok{], pt100[}\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{], marker }\OperatorTok{=} \StringTok{\textquotesingle{}o\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}elektrischer Widerstand\textquotesingle{}}\NormalTok{, alpha }\OperatorTok{=} \FloatTok{0.6}\NormalTok{)}
\NormalTok{plt.plot(pt100[}\StringTok{\textquotesingle{}Temperatur\textquotesingle{}}\NormalTok{], vorhersagewerte, linewidth }\OperatorTok{=} \DecValTok{2}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Regressionsgerade\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.yticks(pt100[}\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{][::}\DecValTok{50}\NormalTok{])}\OperatorTok{;}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Temperatur in °C\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}elektrischer Widerstand in Ohm\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.legend()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[100.67   0.35]
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/kalibrierung_files/figure-pdf/cell-62-output-2.png}}

~

Aus der Differenz des gemessenen elektrischen Widerstands und der
linearen Vorhersagewerte kann der maximale Linearitätsfehler (= das
größte Residuum) bestimmt werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{linearitätsfehler\_toleranzband }\OperatorTok{=}\NormalTok{ (pt100[}\StringTok{\textquotesingle{}Ohm\textquotesingle{}}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ vorhersagewerte).}\BuiltInTok{abs}\NormalTok{().}\BuiltInTok{max}\NormalTok{()}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Linearitätsfehler nach Toleranzbandmethode: }\SpecialCharTok{\{}\NormalTok{linearit}\SpecialCharTok{ä}\NormalTok{tsfehler\_toleranzband}\SpecialCharTok{:.2f\}}\SpecialStringTok{ Ohm."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Linearitätsfehler nach Toleranzbandmethode: 11.45 Ohm.
\end{verbatim}

\section{Die Zweipunktkalibrierung}\label{die-zweipunktkalibrierung}

Die Zweipunktkalibrierung ist ein praktisches Verfahren für die
Kalibrierung von Messdaten. Die Zweipunktkalibrierung erfolgt über das
bekannte wahre Minimum und das bekannte wahre Maximum einer Messreihe.

\[
a = \frac{(\text{wahres Maximum} - \text{wahres Minimum})}{(\text{Maximum Messwerte} - \text{Minimum Messwerte})}
\]

\[
b = \text{wahres Minimum} - a \cdot \text{Minimum Messwerte}
\]

\[
\text{kalibrierte Messwerte} = a \cdot \text{Messwerte} + b
\]

Die Variable \(a\) ist der Korrekturfaktor für den
Empfindlichkeitsfehler. Die Variable \(b\) ist die Nullpunktkorrektur,
nachdem der Empfindlichkeitsfehler korrigiert wurde.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Daten erzeugen}
\NormalTok{messgröße }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{0}\NormalTok{, }\DecValTok{11}\NormalTok{) }\OperatorTok{+} \DecValTok{7}
\NormalTok{messwerte }\OperatorTok{=}\NormalTok{ messgröße }\OperatorTok{+} \DecValTok{4} \OperatorTok{{-}}\NormalTok{ messgröße }\OperatorTok{/} \DecValTok{3}

\CommentTok{\# bekannte Referenzpunkte}
\NormalTok{wahres\_minimum }\OperatorTok{=}\NormalTok{ messgröße.}\BuiltInTok{min}\NormalTok{()}
\NormalTok{wahres\_maximum }\OperatorTok{=}\NormalTok{ messgröße.}\BuiltInTok{max}\NormalTok{()}

\CommentTok{\# Zweipunktkalibrierung}
\NormalTok{a }\OperatorTok{=}\NormalTok{ (wahres\_maximum }\OperatorTok{{-}}\NormalTok{ wahres\_minimum) }\OperatorTok{/}\NormalTok{ (messwerte.}\BuiltInTok{max}\NormalTok{() }\OperatorTok{{-}}\NormalTok{ messwerte.}\BuiltInTok{min}\NormalTok{())}
\NormalTok{b }\OperatorTok{=}\NormalTok{ wahres\_minimum }\OperatorTok{{-}}\NormalTok{ a }\OperatorTok{*}\NormalTok{ messwerte.}\BuiltInTok{min}\NormalTok{()}
\NormalTok{korrigierte\_messwerte }\OperatorTok{=}\NormalTok{ a }\OperatorTok{*}\NormalTok{ messwerte }\OperatorTok{+}\NormalTok{ b}

\CommentTok{\# Ausgabe}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Wahre Werte:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{messgr}\SpecialCharTok{öß}\NormalTok{e}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Messwerte:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{messwerte}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{()}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Zweipunktkalibrierung}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"a = }\SpecialCharTok{\{}\NormalTok{a}\SpecialCharTok{:.1f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"b = }\SpecialCharTok{\{}\NormalTok{b}\SpecialCharTok{:.1f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{a * messwerte + b}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{korrigierte\_messwerte}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{,}
\NormalTok{      sep }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Wahre Werte:
[ 7  8  9 10 11 12 13 14 15 16 17]
Messwerte:
[ 8.66666667  9.33333333 10.         10.66666667 11.33333333 12.
 12.66666667 13.33333333 14.         14.66666667 15.33333333]

Zweipunktkalibrierung
a = 1.5
b = -6.0

a * messwerte + b
[ 7.  8.  9. 10. 11. 12. 13. 14. 15. 16. 17.]
\end{verbatim}

Der Empfindlichkeitsfehler kann als \({1 \over a} - 1\) ermittelt
werden. Der Nullpunktfehler kann als \(-1 * {b \over a}\) ermittelt
werden.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Empfindlichkeitsfehler: }\SpecialCharTok{\{}\BuiltInTok{round}\NormalTok{( ((}\DecValTok{1} \OperatorTok{/}\NormalTok{ a) }\OperatorTok{{-}} \DecValTok{1}\NormalTok{) }\OperatorTok{*} \DecValTok{100}\NormalTok{, }\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{ \%"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Nullpunktfehler: }\SpecialCharTok{\{}\BuiltInTok{round}\NormalTok{(}\OperatorTok{{-}}\DecValTok{1} \OperatorTok{*}\NormalTok{ b }\OperatorTok{/}\NormalTok{ a, }\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Empfindlichkeitsfehler: -33.33 %
Nullpunktfehler: 4.0
\end{verbatim}

\chapter{Beispiel Eis kochen}\label{beispiel-eis-kochen}

In diesem Kapitel werden die praktischen Herausforderungen bei der
Auswertung von Messdaten demonstriert.

\section{Versuchsaufbau}\label{versuchsaufbau}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/00-bilder/versuchsaufbau-eis-kochen.png}}

}

\caption{Versuchsaufbau Eis kochen}

\end{figure}%

In einem thermodynamischen Feldlabor wurde ein induktives Heizelement
benutzt, um Eiswasser in einem metallischen Flüssigkeitsbehälter mit
hoher Wärmeleitfähigkeit zum Sieden zu bringen. Mit einer nichtleitenden
Halterung wurden zwei Thermoelemente eines Widerstandsthermometers
fixiert. Ein TCTempX16 zeichnete die Daten auf, die mit einem Gerät zur
automatisierten Datenverarbeitung ausgelesen wurden.

\section{Datei einlesen}\label{datei-einlesen}

Die Messreihe ist in der Datei `01-daten/Eis\_Messung\_1.xlsx' im
Tabellenblatt `T15949 MultiChannel - Daten' gespeichert.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{eis }\OperatorTok{=}\NormalTok{ pd.read\_excel(io }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/Eis\_Messung\_1.xlsx\textquotesingle{}}\NormalTok{, sheet\_name }\OperatorTok{=} \StringTok{\textquotesingle{}T15949 MultiChannel {-} Daten\textquotesingle{}}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(eis.head(n }\OperatorTok{=} \DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
           Gerätename:           Unnamed: 1  \
0  Gerätebeschreibung:                  NaN   
1       Serien-Nummer:                  NaN   
2           Geräte-ID:                  NaN   
3                  NaN                  NaN   
4                  NaN                  NaN   
5                Datum                 Zeit   
6  2025-09-25 16:12:00  2025-09-25 16:12:00   
7  2025-09-25 16:12:01  2025-09-25 16:12:01   
8  2025-09-25 16:12:02  2025-09-25 16:12:02   
9  2025-09-25 16:12:03  2025-09-25 16:12:03   

                                       TCTempX16  \
0  16-Kanal Thermoelement Temperatur-Datenlogger   
1                                         T15949   
2                                   MultiChannel   
3                                            NaN   
4                                        Kanal 2   
5                           Thermoelement 1 (°C)   
6                                              1   
7                                              1   
8                                              1   
9                                              1   

                                     TCTempX16.1  
0  16-Kanal Thermoelement Temperatur-Datenlogger  
1                                         T15949  
2                                   MultiChannel  
3                                            NaN  
4                                        Kanal 4  
5                           Thermoelement 2 (°C)  
6                                            0.5  
7                                            0.5  
8                                            0.5  
9                                            0.5  
\end{verbatim}

Das Einlesen und Bereinigen der Daten finden Sie in dem folgenden
Beispiel.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Note \ref*{nte-eis}: Datensatz einlesen \& bereinigen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutnte{nte-eis} 

Im Kopf des Tabellenblatts stehen Metadaten der Messung. Es gibt vier
Spalten mit Daten: Datum und Zeit sowie die Messreihen der beiden
Thermoelemente.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{eis }\OperatorTok{=}\NormalTok{ pd.read\_excel(io }\OperatorTok{=} \StringTok{\textquotesingle{}01{-}daten/Eis\_Messung\_1.xlsx\textquotesingle{}}\NormalTok{, sheet\_name }\OperatorTok{=} \StringTok{\textquotesingle{}T15949 MultiChannel {-} Daten\textquotesingle{}}\NormalTok{, skiprows }\OperatorTok{=} \DecValTok{6}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(eis.info())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 565 entries, 0 to 564
Data columns (total 4 columns):
 #   Column                Non-Null Count  Dtype         
---  ------                --------------  -----         
 0   Datum                 565 non-null    datetime64[ns]
 1   Zeit                  565 non-null    datetime64[ns]
 2   Thermoelement 1 (°C)  565 non-null    float64       
 3   Thermoelement 2 (°C)  565 non-null    float64       
dtypes: datetime64[ns](2), float64(2)
memory usage: 17.8 KB
None
\end{verbatim}

Die Daten wurden korrekt eingelesen. Mit der Methode
\texttt{pd.describe()} wird der Wertebereich der Spalten überprüft, um
numerisch kodierte fehlende oder fehlerhafte Werte zu identifizieren.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(eis.describe())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
                               Datum                           Zeit  \
count                            565                            565   
mean   2025-09-25 16:16:47.024778752  2025-09-25 16:16:47.024778752   
min              2025-09-25 16:12:00            2025-09-25 16:12:00   
25%              2025-09-25 16:14:25            2025-09-25 16:14:25   
50%              2025-09-25 16:16:47            2025-09-25 16:16:47   
75%              2025-09-25 16:19:09            2025-09-25 16:19:09   
max              2025-09-25 16:21:32            2025-09-25 16:21:32   
std                              NaN                            NaN   

       Thermoelement 1 (°C)  Thermoelement 2 (°C)  
count            565.000000            565.000000  
mean              53.581239             55.451858  
min              -11.000000             -4.100000  
25%               14.900000             20.300000  
50%               56.200000             58.300000  
75%               90.300000             91.200000  
max              149.800000            139.200000  
std               36.886184             36.542679  
\end{verbatim}

Die Spalten Datum und Zeit enthalten die selben Informationen. Eine der
beiden Spalten kann deshalb entfernt werden. Die Temperaturmessungen
sollten näher betrachtet werden. Eishaltiges Wasser, das zum Kochen
gebracht wird, sollte sich in einem Temperaturbereich von 0 bis 100 °C
bewegen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{eis.drop(labels }\OperatorTok{=} \StringTok{\textquotesingle{}Datum\textquotesingle{}}\NormalTok{, axis }\OperatorTok{=} \DecValTok{1}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Wir stellen den Datensatz grafisch dar.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{eis.plot(x }\OperatorTok{=} \StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{, y }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/beispiel-eiskochen_files/figure-pdf/cell-7-output-1.png}}

~

Etwa in der Mitte des Datensatzes verzeichnen beide Sensoren extreme
Fehlwerte. Diese sollen entfernt werden.

\textbf{Fehlwerte entfernen}

Zunächst betrachten wir den Bereich genauer.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n\_zeilen }\OperatorTok{=}\NormalTok{ eis.shape[}\DecValTok{0}\NormalTok{]}
\NormalTok{eis.iloc[}\BuiltInTok{int}\NormalTok{(n\_zeilen }\OperatorTok{*} \FloatTok{0.45}\NormalTok{): }\BuiltInTok{int}\NormalTok{(n\_zeilen }\OperatorTok{*} \FloatTok{0.65}\NormalTok{)].plot(x }\OperatorTok{=} \StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{, y }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/beispiel-eiskochen_files/figure-pdf/cell-8-output-1.png}}

~

In einem bestimmten Abschnitt scheinen keine gültigen Werte vorzuliegen
und diese sollen als ungültig markiert werden. Dazu betrachten wir
zunächst die typische Veränderung der Messwerte, also die Differenz
jedes Werts zu seinem Vorgänger mit der Methode
\texttt{pd.Series.diff()}. Ebenfalls wird die Veränderung in
studentisierten z-Werten ausgedrückt.

Die z-Werte werden mit der scipy-Funktion
\texttt{scipy.stats.zscore(a,\ ddof\ =\ 1,\ nan\_policy\ =\ \textquotesingle{}omit\textquotesingle{}))}
ermittelt. \texttt{a} steht für array-artige Daten, \texttt{ddof\ =\ 1}
spezifiziert die Stichprobenstandardabweichung und das Argument
\texttt{nan\_policy\ =\ \textquotesingle{}omit\textquotesingle{}} wird
verwendet, um mit dem Wert \texttt{np.nan} an der ersten Stelle arbeiten
zu können, der aus der Berechnung der Veränderung entsteht, da für den
ersten Wert einer Reihe kein gültiger Wert berechnet werden kann.

\phantomsection\label{wrn-diffinnpandpd}
\begin{quote}
\textbf{Warning~71.1: np.diff() und pd.diff()}

NumPy und Pandas verfügen über eine Funktion diff. Diese verhalten sich
standardmäßig unterschiedlich. Um die Länge einer Datenreihe mit
\texttt{np.diff()} zu erhalten, können die Parameter \texttt{prepend}
oder \texttt{append} verwendet werden, um der Datenreihe vor Ausführung
der Operation einen Wert voranzustellen oder einen Wert anzuhängen. So
bleiben die Länge der Datenreihe und die Indexpositionen der Werte
erhalten.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{array }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(np.diff(array))}
\NormalTok{series }\OperatorTok{=}\NormalTok{ pd.Series(array)}
\BuiltInTok{print}\NormalTok{(series.diff())}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, np.diff(array, prepend }\OperatorTok{=}\NormalTok{ np.nan))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[2 2 1]
0    NaN
1    2.0
2    2.0
3    1.0
dtype: float64

 [nan  2.  2.  1.]
\end{verbatim}
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# absolute Differenzen ermitteln}
\NormalTok{diff\_thermoelement1 }\OperatorTok{=}\NormalTok{ eis[}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{].diff()}
\NormalTok{diff\_thermoelement2 }\OperatorTok{=}\NormalTok{ eis[}\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{].diff()}

\CommentTok{\# absolute z{-}scores ermitteln}
\NormalTok{abs\_z\_score\_thermoelement1 }\OperatorTok{=}\NormalTok{ np.}\BuiltInTok{abs}\NormalTok{(scipy.stats.zscore(diff\_thermoelement1, ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{, nan\_policy }\OperatorTok{=} \StringTok{\textquotesingle{}omit\textquotesingle{}}\NormalTok{))}
\NormalTok{abs\_z\_score\_thermoelement2 }\OperatorTok{=}\NormalTok{ np.}\BuiltInTok{abs}\NormalTok{(scipy.stats.zscore(diff\_thermoelement2, ddof }\OperatorTok{=} \DecValTok{1}\NormalTok{, nan\_policy }\OperatorTok{=} \StringTok{\textquotesingle{}omit\textquotesingle{}}\NormalTok{))}

\CommentTok{\# plotten}
\NormalTok{fig }\OperatorTok{=}\NormalTok{ plt.figure(figsize }\OperatorTok{=}\NormalTok{ (}\FloatTok{7.5}\NormalTok{, }\FloatTok{7.5}\NormalTok{)) }\CommentTok{\# sharex = True}

\NormalTok{ax }\OperatorTok{=}\NormalTok{ fig.add\_subplot(}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{ax.plot(diff\_thermoelement1, color }\OperatorTok{=} \StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Thermoelement 1\textquotesingle{}}\NormalTok{)}
\NormalTok{ax.set\_xlabel(xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Index\textquotesingle{}}\NormalTok{)}
\NormalTok{ax.set\_ylabel(ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}Temperaturdifferenz in °C\textquotesingle{}}\NormalTok{)}
\NormalTok{ax.grid()}

\NormalTok{ax }\OperatorTok{=}\NormalTok{ fig.add\_subplot(}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{ax.plot(abs\_z\_score\_thermoelement1, color }\OperatorTok{=} \StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{)}
\NormalTok{ax.set\_xlabel(xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Index\textquotesingle{}}\NormalTok{)}
\NormalTok{ax.set\_ylabel(ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}absolute z{-}Werte\textquotesingle{}}\NormalTok{)}
\NormalTok{ax.grid()}

\NormalTok{ax }\OperatorTok{=}\NormalTok{ fig.add\_subplot(}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{ax.plot(diff\_thermoelement2, color }\OperatorTok{=} \StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Thermoelement 2\textquotesingle{}}\NormalTok{)}
\NormalTok{ax.set\_xlabel(xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Index\textquotesingle{}}\NormalTok{)}
\NormalTok{ax.set\_ylabel(ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}Temperaturdifferenz in °C\textquotesingle{}}\NormalTok{)}
\NormalTok{ax.grid()}

\NormalTok{ax }\OperatorTok{=}\NormalTok{ fig.add\_subplot(}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\NormalTok{ax.plot(abs\_z\_score\_thermoelement2, color }\OperatorTok{=} \StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{)}
\NormalTok{ax.set\_xlabel(xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Index\textquotesingle{}}\NormalTok{)}
\NormalTok{ax.set\_ylabel(ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}absolute z{-}Werte\textquotesingle{}}\NormalTok{)}
\NormalTok{ax.grid()}

\NormalTok{fig.legend(loc }\OperatorTok{=} \StringTok{\textquotesingle{}outside upper center\textquotesingle{}}\NormalTok{, ncols }\OperatorTok{=} \DecValTok{2}\NormalTok{,  bbox\_to\_anchor }\OperatorTok{=}\NormalTok{ (}\FloatTok{0.5}\NormalTok{, }\FloatTok{1.05}\NormalTok{)) }

\NormalTok{plt.tight\_layout()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/beispiel-eiskochen_files/figure-pdf/cell-10-output-1.png}}

~

Die Position der ungültigen Werte kann sowohl über eine sinnvolle
Schwelle der (absoluten) Temperaturveränderung oder der absoluten
z-Werte bestimmt werden. In diesem Fall verwenden wir die absolute
Temperaturveränderung und wählen den Schwellwert 10. Es wird die
Position des ersten und des letzten Werts, der oberhalb dieses
Schwellwerts liegt, bestimmt.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# absolute Änderung bestimmen}
\NormalTok{diff\_thermoelement1 }\OperatorTok{=}\NormalTok{ eis[}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{].diff().}\BuiltInTok{abs}\NormalTok{()}
\NormalTok{diff\_thermoelement2 }\OperatorTok{=}\NormalTok{ eis[}\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{].diff().}\BuiltInTok{abs}\NormalTok{()}

\CommentTok{\# Schwellwert festlegen und prüfen}
\NormalTok{schwellwert }\OperatorTok{=} \DecValTok{10}
\NormalTok{bool\_series\_thermoelement1 }\OperatorTok{=}\NormalTok{ diff\_thermoelement1 }\OperatorTok{\textgreater{}}\NormalTok{ schwellwert}
\NormalTok{bool\_series\_thermoelement2 }\OperatorTok{=}\NormalTok{ diff\_thermoelement2 }\OperatorTok{\textgreater{}}\NormalTok{ schwellwert}

\CommentTok{\# ersten und letzten Wert größer Schwellwert finden}
\CommentTok{\#\# Thermoelement 1}
\CommentTok{\#\#\# Wo steht nicht False?}
\CommentTok{\#\#\# np.nonzero() gibt ein Tupel zurück}
\CommentTok{\#\#\# Dieses enthält für jede Dimension ein array der Indexwerte}
\NormalTok{positionen\_thermoelement1 }\OperatorTok{=}\NormalTok{ np.nonzero(bool\_series\_thermoelement1)}

\CommentTok{\#\# Thermoelement 2}
\CommentTok{\#\#\# Wo steht nicht False?}
\CommentTok{\#\#\# np.nonzero() gibt ein Tupel zurück}
\CommentTok{\#\#\# Dieses enthält für jede Dimension ein array der Indexwerte}
\NormalTok{positionen\_thermoelement2 }\OperatorTok{=}\NormalTok{ np.nonzero(bool\_series\_thermoelement2)}

\CommentTok{\# Ausgabe}
\CommentTok{\#\# Thermoelement 1}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Thermoelement 1"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\DecValTok{51} \OperatorTok{*} \StringTok{"="}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Anzahl der Temperaturänderungen mit Betrag \textgreater{} 10:"}\NormalTok{, bool\_series\_thermoelement1.}\BuiltInTok{sum}\NormalTok{())}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Position des ersten Werts: }\SpecialCharTok{\{}\NormalTok{positionen\_thermoelement1[}\DecValTok{0}\NormalTok{][}\DecValTok{0}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Position des letzten Werts: }\SpecialCharTok{\{}\NormalTok{positionen\_thermoelement1[}\DecValTok{0}\NormalTok{][}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\#\# Thermoelement 2}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Thermoelement 2"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\DecValTok{51} \OperatorTok{*} \StringTok{"="}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Anzahl der Temperaturänderungen mit Betrag \textgreater{} 10:"}\NormalTok{, bool\_series\_thermoelement2.}\BuiltInTok{sum}\NormalTok{())}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Position des ersten Werts: }\SpecialCharTok{\{}\NormalTok{positionen\_thermoelement2[}\DecValTok{0}\NormalTok{][}\DecValTok{0}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Position des letzten Werts: }\SpecialCharTok{\{}\NormalTok{positionen\_thermoelement2[}\DecValTok{0}\NormalTok{][}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Thermoelement 1
===================================================
Anzahl der Temperaturänderungen mit Betrag > 10: 20
Die Position des ersten Werts: 310
Die Position des letzten Werts: 333

Thermoelement 2
===================================================
Anzahl der Temperaturänderungen mit Betrag > 10: 20
Die Position des ersten Werts: 310
Die Position des letzten Werts: 333
\end{verbatim}

Für beide Thermoelemente kann der gleiche Bereich als ungültig markiert
werden. Vor der weiteren Bearbeitung wird eine Kopie des aufgeräumten
Datensatzes erstellt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{von }\OperatorTok{=}\NormalTok{ positionen\_thermoelement1[}\DecValTok{0}\NormalTok{][}\DecValTok{0}\NormalTok{]}
\NormalTok{bis }\OperatorTok{=}\NormalTok{ positionen\_thermoelement1[}\DecValTok{0}\NormalTok{][}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
\NormalTok{eis.loc[von : bis, [}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{]] }\OperatorTok{=}\NormalTok{ np.nan}

\CommentTok{\# Kopie von eis anlegen}
\NormalTok{eis\_backup }\OperatorTok{=}\NormalTok{ eis.copy()}
\end{Highlighting}
\end{Shaded}

\end{tcolorbox}

\section{Daten darstellen}\label{daten-darstellen}

Der Datensatz wird dargestellt. (In der Darstellung mit
\texttt{pd.plot()} ist die automatisch gewählte x-Achsenbeschriftung
unansehnlich. Deshalb wird ein Datenobjekt für die Darstellung angelegt
und die Spalte `Zeit' auf die Uhrzeit reduziert.)

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Darstellung mit automatischer Achsenbeschriftung}
\CommentTok{\# eis.plot(x = \textquotesingle{}Zeit\textquotesingle{}, y = [\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}, \textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}], grid = True)}

\NormalTok{plotting\_data }\OperatorTok{=}\NormalTok{ eis.copy()}
\NormalTok{plotting\_data[}\StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ plotting\_data[}\StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{].dt.time}

\NormalTok{plotting\_data.plot(x }\OperatorTok{=} \StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{, y }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{], grid }\OperatorTok{=} \VariableTok{True}\NormalTok{, ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}°C\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/beispiel-eiskochen_files/figure-pdf/cell-13-output-1.png}}

\section{Referenzpunkte bestimmen}\label{referenzpunkte-bestimmen}

Für die Korrektur des Nullpunkt- und des Empfindlichkeitsfehlers sind
als Referenzpunkte die Temperaturen 0 und 100 Grad Celsius bekannt:
Solange Eis im Wasser schwimmt, hat es 0 °C, und bei 100 °C erreicht das
Wasser seinen Siedepunkt.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-100C} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-100C}: Siedetemperatur von Wasser}\vspace{3mm}

Die Siedetemperatur von Wasser ist abhängig vom Luftdruck und beträgt
100 °C bei 1013,25 hPa. In Deutschland liegt die tatsächliche
Siedetemperatur typischerweise etwas niedriger.

\end{minipage}%
\end{tcolorbox}

\subsection{0 °C}\label{c}

Für die wahre Temperatur 0 °C sind viele Messpunkte verfügbar. Schauen
wir uns die ersten 100 Messwerte an:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{eis.loc[}\DecValTok{0}\NormalTok{ : }\DecValTok{100}\NormalTok{, [}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{]].plot(xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Index\textquotesingle{}}\NormalTok{, ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}gemessene Temperatur in °C\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/beispiel-eiskochen_files/figure-pdf/cell-14-output-1.png}}

~

Der Zeitpunkt, ab dem die Wärmezufuhr beginnt, kann z. B. mit der
Methode \texttt{pd.diff()} ermittelt werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{eis.loc[}\DecValTok{0}\NormalTok{ : }\DecValTok{100}\NormalTok{, [}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{]].diff().plot(xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Index\textquotesingle{}}\NormalTok{, ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}Temperaturdifferenz in °C\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/beispiel-eiskochen_files/figure-pdf/cell-15-output-1.png}}

~

Da das Thermoelement 1 leichte Messabweichungen aufweist, wird ein
Schwellwert etwas größer als 0 gewählt. Damit wird die Position des
ersten Werts bestimmt, der oberhalb des Schwellwerts liegt.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# absolute Änderung bestimmen}
\NormalTok{diff\_thermoelement1 }\OperatorTok{=}\NormalTok{ eis.loc[}\DecValTok{0}\NormalTok{ : }\DecValTok{100}\NormalTok{, }\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{].diff().}\BuiltInTok{abs}\NormalTok{()}
\NormalTok{diff\_thermoelement2 }\OperatorTok{=}\NormalTok{ eis.loc[}\DecValTok{0}\NormalTok{ : }\DecValTok{100}\NormalTok{, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{].diff().}\BuiltInTok{abs}\NormalTok{()}

\CommentTok{\# Schwellwert festlegen und prüfen}
\NormalTok{schwellwert }\OperatorTok{=} \FloatTok{0.2}
\NormalTok{bool\_series\_thermoelement1 }\OperatorTok{=}\NormalTok{ diff\_thermoelement1 }\OperatorTok{\textgreater{}}\NormalTok{ schwellwert}
\NormalTok{bool\_series\_thermoelement2 }\OperatorTok{=}\NormalTok{ diff\_thermoelement2 }\OperatorTok{\textgreater{}}\NormalTok{ schwellwert}

\CommentTok{\# ersten Wert größer Schwellwert finden}
\CommentTok{\#\# Thermoelement 1}
\CommentTok{\#\#\# Wo steht nicht False?}
\CommentTok{\#\#\# np.nonzero() gibt ein Tupel zurück}
\CommentTok{\#\#\# Dieses enthält für jede Dimension ein array der Indexwerte}
\NormalTok{positionen\_thermoelement1 }\OperatorTok{=}\NormalTok{ np.nonzero(bool\_series\_thermoelement1)}

\CommentTok{\#\# Thermoelement 2}
\CommentTok{\#\#\# Wo steht nicht False?}
\CommentTok{\#\#\# np.nonzero() gibt ein Tupel zurück}
\CommentTok{\#\#\# Dieses enthält für jede Dimension ein array der Indexwerte}
\NormalTok{positionen\_thermoelement2 }\OperatorTok{=}\NormalTok{ np.nonzero(bool\_series\_thermoelement2)}

\CommentTok{\# Ausgabe}
\CommentTok{\#\# Thermoelement 1}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Thermoelement 1"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Position des ersten Werts: }\SpecialCharTok{\{}\NormalTok{positionen\_thermoelement1[}\DecValTok{0}\NormalTok{][}\DecValTok{0}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\#\# Thermoelement 2}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Thermoelement 2"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Die Position des ersten Werts: }\SpecialCharTok{\{}\NormalTok{positionen\_thermoelement2[}\DecValTok{0}\NormalTok{][}\DecValTok{0}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Thermoelement 1
Die Position des ersten Werts: 67

Thermoelement 2
Die Position des ersten Werts: 67
\end{verbatim}

Die Wärmezufuhr beginnt also bei dem Wert an Indexposition 67. Der
Nullpunkt der Messreihe liegt somit an der Indexposition 67 - 1.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{start\_wärmezufuhr }\OperatorTok{=} \DecValTok{67}
\NormalTok{start }\OperatorTok{=}\NormalTok{ start\_wärmezufuhr }\OperatorTok{{-}} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

\section{Nullpunktfehler
korrigieren}\label{nullpunktfehler-korrigieren-1}

Somit kann der Nullpunktfehler nun für beide Thermoelemente aus der
Differenz zwischen dem Mittelwert der gemessenen Werte bis
\emph{exklusiv} Indexposition 67 und dem wahren Wert 0 direkt berechnet
werden. Diese Position haben wir in der Variable start gespeichert, die
für beide Thermoelemente gilt.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-slicingmitloc} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-slicingmitloc}: Slicing mit pd.loc{[}{]}}\vspace{3mm}

Das Slicing mit \texttt{pd.loc{[}{]}} ist inklusiv.

\end{minipage}%
\end{tcolorbox}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nullpunktfehler\_thermoelement1 }\OperatorTok{=}\NormalTok{ eis.loc[}\DecValTok{0}\NormalTok{ : start, }\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{].mean() }\OperatorTok{{-}} \DecValTok{0}
\NormalTok{nullpunktfehler\_thermoelement2 }\OperatorTok{=}\NormalTok{ eis.loc[}\DecValTok{0}\NormalTok{ : start, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{].mean() }\OperatorTok{{-}} \DecValTok{0}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Nullpunktfehler von Thermoelement 1 beträgt: }\SpecialCharTok{\{}\NormalTok{nullpunktfehler\_thermoelement1}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Nullpunktfehler von Thermoelement 2 beträgt: }\SpecialCharTok{\{}\NormalTok{nullpunktfehler\_thermoelement2}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der Nullpunktfehler von Thermoelement 1 beträgt: 1.0
Der Nullpunktfehler von Thermoelement 2 beträgt: 0.48
\end{verbatim}

Damit kann der Nullpunktfehler für beide Messreihen korrigiert werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{eis[}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{] }\OperatorTok{{-}=}\NormalTok{ nullpunktfehler\_thermoelement1}
\NormalTok{eis[}\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{] }\OperatorTok{{-}=}\NormalTok{ nullpunktfehler\_thermoelement2}
\end{Highlighting}
\end{Shaded}

\subsection{100 °C}\label{c-1}

Auch für die wahre Temperatur 100 Grad sind viele Messpunkte verfügbar.
Wir wollen die letzten 120 Messwerte betrachten. Der Punkt, an dem das
Wasser siedet, ist jedoch nicht so einfach zu bestimmen. Starke
Messabweichungen erzeugen ein verrauschtes Bild. Um die grafische
Analyse zu erleichtern wurden für beide Messreihen der gleitende
Durchschnitt sowie der Mittelwert der geglätten Messreihen
eingezeichnet. Diese Methoden werden Methoden im
\href{https://bausteine-der-datenanalyse.github.io/m-datenfitting-und-optimierung/output/book/}{Methodenbaustein
Datenfitting und Datenoptimierung} vermittelt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{anzahl }\OperatorTok{=} \DecValTok{120}

\NormalTok{eis.loc[eis.shape[}\DecValTok{0}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ anzahl : , [}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{]].plot(alpha }\OperatorTok{=} \FloatTok{0.3}\NormalTok{, xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Index\textquotesingle{}}\NormalTok{, ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}gemessene Temperatur in °C\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.hlines(y }\OperatorTok{=} \DecValTok{100}\NormalTok{, xmin }\OperatorTok{=}\NormalTok{ eis.shape[}\DecValTok{0}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ anzahl, xmax }\OperatorTok{=}\NormalTok{ eis.shape[}\DecValTok{0}\NormalTok{], linestyles }\OperatorTok{=} \StringTok{\textquotesingle{}dashed\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}100 °C\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Daten glätten}
\NormalTok{window }\OperatorTok{=} \DecValTok{9}
\NormalTok{weights }\OperatorTok{=}\NormalTok{ np.ones(window) }\OperatorTok{/}\NormalTok{ window}
\NormalTok{thermoelement1\_glatt }\OperatorTok{=}\NormalTok{ np.convolve(eis[}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{], weights, mode }\OperatorTok{=} \StringTok{\textquotesingle{}valid\textquotesingle{}}\NormalTok{)}
\NormalTok{thermoelement2\_glatt }\OperatorTok{=}\NormalTok{ np.convolve(eis[}\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{], weights, mode }\OperatorTok{=} \StringTok{\textquotesingle{}valid\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.plot(eis.index[eis.shape[}\DecValTok{0}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ anzahl }\OperatorTok{+}\NormalTok{ (window}\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}\OperatorTok{//}\DecValTok{2}\NormalTok{ : }\OperatorTok{{-}}\NormalTok{(window}\OperatorTok{//}\DecValTok{2}\NormalTok{)], thermoelement1\_glatt[eis.shape[}\DecValTok{0}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ anzahl : ], label }\OperatorTok{=} \StringTok{\textquotesingle{}Thermoel. 1 geglättet\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(eis.index[eis.shape[}\DecValTok{0}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ anzahl }\OperatorTok{+}\NormalTok{ (window}\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}\OperatorTok{//}\DecValTok{2}\NormalTok{ : }\OperatorTok{{-}}\NormalTok{(window}\OperatorTok{//}\DecValTok{2}\NormalTok{)], thermoelement2\_glatt[eis.shape[}\DecValTok{0}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ anzahl : ], label }\OperatorTok{=} \StringTok{\textquotesingle{}Thermoel. 2 geglättet\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}C1\textquotesingle{}}\NormalTok{)}

\NormalTok{mittelwert\_der\_sensoren }\OperatorTok{=}\NormalTok{ (thermoelement1\_glatt[eis.shape[}\DecValTok{0}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ anzahl : ] }\OperatorTok{+}\NormalTok{ thermoelement2\_glatt[eis.shape[}\DecValTok{0}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ anzahl : ]) }\OperatorTok{/} \DecValTok{2}
\NormalTok{plt.plot(eis.index[eis.shape[}\DecValTok{0}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ anzahl }\OperatorTok{+}\NormalTok{ (window}\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}\OperatorTok{//}\DecValTok{2}\NormalTok{ : }\OperatorTok{{-}}\NormalTok{(window}\OperatorTok{//}\DecValTok{2}\NormalTok{)], mittelwert\_der\_sensoren, label }\OperatorTok{=} \StringTok{\textquotesingle{}geglätteter Mittelwert\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}dashed\textquotesingle{}}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.legend()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/beispiel-eiskochen_files/figure-pdf/cell-20-output-1.png}}

~

Behelfsweise bestimmen wir den Referenzpunkt für 100 °C, indem die Werte
zwischen dem Indexwert 500 und bis zu den letzten 10 Werten des
Datensatzes gemittelt werden. Anschließend wird der Index bestimmt, an
dem die Messwerte diesen Mittelwert erstmalig erreichen. (\emph{Hinweis:
Die Daten wurden bereits um den ermittelten Nullpunktfehler
korrigiert.})

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{thermoelement1\_max }\OperatorTok{=}\NormalTok{ eis[}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{].iloc[}\DecValTok{500}\NormalTok{ : }\OperatorTok{{-}}\DecValTok{10}\NormalTok{].mean()}
\NormalTok{thermoelement2\_max }\OperatorTok{=}\NormalTok{ eis[}\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{].iloc[}\DecValTok{500}\NormalTok{ : }\OperatorTok{{-}}\DecValTok{10}\NormalTok{].mean()}

\CommentTok{\# ge = greater or equal, idxmax = find first occurrence of maximum value (0 and 1)}
\NormalTok{ende\_thermoelement1 }\OperatorTok{=}\NormalTok{ eis[}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{].ge(thermoelement1\_max).idxmax()}
\NormalTok{ende\_thermoelement2 }\OperatorTok{=}\NormalTok{ eis[}\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{].ge(thermoelement2\_max).idxmax()}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Gemitteltes Maximum Thermoelement 1: }\SpecialCharTok{\{}\NormalTok{thermoelement1\_max}\SpecialCharTok{:.2f\}}\SpecialStringTok{ °C"}\NormalTok{,}
      \SpecialStringTok{f"Erstmalig erreicht an Position: }\SpecialCharTok{\{}\NormalTok{ende\_thermoelement1 }\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{, sep }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Gemitteltes Maximum Thermoelement 2: }\SpecialCharTok{\{}\NormalTok{thermoelement2\_max}\SpecialCharTok{:.2f\}}\SpecialStringTok{ °C"}\NormalTok{,}
      \SpecialStringTok{f"Erstmalig erreicht an Position: }\SpecialCharTok{\{}\NormalTok{ende\_thermoelement2 }\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{, sep }\OperatorTok{=} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Gemitteltes Maximum Thermoelement 1: 97.32 °C
Erstmalig erreicht an Position: 491
Gemitteltes Maximum Thermoelement 2: 99.93 °C
Erstmalig erreicht an Position: 476
\end{verbatim}

\section{Empfindlichkeitsfehler
korrigieren}\label{empfindlichkeitsfehler-korrigieren-1}

Mit den bekannten Start- und Endwerten kann der Empfindlichkeitsfehler
geschätzt werden. Als Referenzpunkte sind bekannt:

\begin{itemize}
\tightlist
\item
  Die Indexposition, an der die Wärmezufuhr beginnt und die in der
  Variable `start\_wärmezufuhr' gespeichert ist. An der Indexposition
  start\_wärmezufuhr - 1 beträgt die wahre Temperatur 0 °C. Der Index
  dieses Werts ist in der Variable `start' gespeichert (und ist für
  beide Thermoelemente identisch).
\item
  Die Indexposition, an der die Temperatur ihr Maximum erreicht. Solange
  Wasser im Topf ist, beträgt die wahre Temperatur 100 °C. Die Position
  dieses Werts konnte nur geschätzt werden und ist in den Variablen
  `ende\_thermoelement1' und `ende\_thermoelement1' gespeichert.
\end{itemize}

Thermoelement 1

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ende }\OperatorTok{=}\NormalTok{  ende\_thermoelement1}

\CommentTok{\# Empfindlichkeitsfehler bestimmen}
\NormalTok{lm\_referenzpunkte }\OperatorTok{=}\NormalTok{ poly.polyfit(x }\OperatorTok{=}\NormalTok{ [}\DecValTok{0}\NormalTok{, }\DecValTok{100}\NormalTok{], y }\OperatorTok{=}\NormalTok{ [eis.loc[start, }\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{], eis.loc[ende, }\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{]], deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{spannfehler\_thermoelement1 }\OperatorTok{=}\NormalTok{ lm\_referenzpunkte[}\DecValTok{1}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Empfindlichkeitsfehler beträgt: }\SpecialCharTok{\{}\BuiltInTok{round}\NormalTok{((spannfehler\_thermoelement1 }\OperatorTok{{-}} \DecValTok{1}\NormalTok{) }\OperatorTok{*} \DecValTok{100}\NormalTok{, }\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{ \%"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der Empfindlichkeitsfehler beträgt: -2.0 %
\end{verbatim}

Thermoelement 2

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ende }\OperatorTok{=}\NormalTok{  ende\_thermoelement2}

\CommentTok{\# Empfindlichkeitsfehler bestimmen}
\NormalTok{lm\_referenzpunkte }\OperatorTok{=}\NormalTok{ poly.polyfit(x }\OperatorTok{=}\NormalTok{ [}\DecValTok{0}\NormalTok{, }\DecValTok{100}\NormalTok{], y }\OperatorTok{=}\NormalTok{ [eis.loc[start, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{], eis.loc[ende, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{]], deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\NormalTok{spannfehler\_thermoelement2 }\OperatorTok{=}\NormalTok{ lm\_referenzpunkte[}\DecValTok{1}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der Empfindlichkeitsfehler beträgt: }\SpecialCharTok{\{}\BuiltInTok{round}\NormalTok{((spannfehler\_thermoelement2 }\OperatorTok{{-}} \DecValTok{1}\NormalTok{) }\OperatorTok{*} \DecValTok{100}\NormalTok{, }\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{ \%"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der Empfindlichkeitsfehler beträgt: 0.2 %
\end{verbatim}

Somit kann der Empfindlichkeitsfehler korrigiert werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Empfindlichkeitsfehler Thermoelement 1 korrigieren}
\NormalTok{eis[}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ eis[}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{].div(spannfehler\_thermoelement1)}
\NormalTok{eis[}\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ eis[}\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{].div(spannfehler\_thermoelement2)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Maximum kalibriertes Thermoelement 1: }\SpecialCharTok{\{}\NormalTok{eis[}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\BuiltInTok{max}\NormalTok{()}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Maximum kalibriertes Thermoelement 2: }\SpecialCharTok{\{}\NormalTok{eis[}\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\BuiltInTok{max}\NormalTok{()}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{,}
\NormalTok{      sep }\OperatorTok{=} \StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Maximum kalibriertes Thermoelement 1: 100.71
Maximum kalibriertes Thermoelement 2: 102.32
\end{verbatim}

Schauen wir uns die kalibrierten Daten erneut an:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plotting\_data }\OperatorTok{=}\NormalTok{ eis.copy()}
\NormalTok{plotting\_data[}\StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ plotting\_data[}\StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{].dt.time}

\NormalTok{plotting\_data.plot(x }\OperatorTok{=} \StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{, y }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{], grid }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{plt.xlabel(xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Index\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}° C\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/beispiel-eiskochen_files/figure-pdf/cell-25-output-1.png}}

\section{Linearitätsfehler
ermitteln}\label{linearituxe4tsfehler-ermitteln}

Die Daten wurden mit einem linearen Verfahren kalibriert, obwohl die
Messwerte nichtlinear sind. Der Linearitätsfehler soll quantifiziert
werden.

\subsubsection{Festpunktmethode}\label{festpunktmethode-2}

Thermoelement 1

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ende }\OperatorTok{=}\NormalTok{ ende\_thermoelement1}

\CommentTok{\# Endpunktverbindende Gerade schätzen}
\CommentTok{\# x muss bei Null beginnen}
\NormalTok{lm }\OperatorTok{=}\NormalTok{ poly.polyfit(}
\NormalTok{  x }\OperatorTok{=}\NormalTok{ [start }\OperatorTok{{-}}\NormalTok{ start, ende }\OperatorTok{{-}}\NormalTok{ start],}
\NormalTok{  y }\OperatorTok{=}\NormalTok{ [eis.loc[start, }\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{], eis.loc[ende, }\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{]],}
\NormalTok{  deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\CommentTok{\#\# print(lm.round(2)) \# intercept + slope}

\CommentTok{\# Vorhersagewerte schätzen}
\CommentTok{\#\# np.arange() ist exklusiv}
\NormalTok{vorhersagewerte }\OperatorTok{=}\NormalTok{ poly.polyval(x }\OperatorTok{=}\NormalTok{ np.arange(start }\OperatorTok{{-}}\NormalTok{ start, ende }\OperatorTok{{-}}\NormalTok{ start }\OperatorTok{+} \DecValTok{1}\NormalTok{), c }\OperatorTok{=}\NormalTok{ lm)}
\CommentTok{\#\#\# print(len(vorhersagewerte))}
\CommentTok{\#\#\# print(len(np.arange(eis.loc[start:ende, :].shape[0])))}

\CommentTok{\# Linearitätsfehler berechnen}
\NormalTok{linearitätsfehler\_festpunkt }\OperatorTok{=}\NormalTok{ eis.loc[start:ende, }\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{].sub(vorhersagewerte).}\BuiltInTok{abs}\NormalTok{().}\BuiltInTok{max}\NormalTok{()}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Linearitätsfehler nach Festpunktmethode: }\SpecialCharTok{\{}\NormalTok{linearit}\SpecialCharTok{ä}\NormalTok{tsfehler\_festpunkt}\SpecialCharTok{:.2f\}}\SpecialStringTok{ °C."}\NormalTok{)}

\CommentTok{\# grafische Darstellung}
\NormalTok{plt.plot(np.arange(eis.shape[}\DecValTok{0}\NormalTok{]),}
\NormalTok{         eis[}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{],}
\NormalTok{         label }\OperatorTok{=} \StringTok{\textquotesingle{}Thermoelement 1\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(np.arange(start, ende }\OperatorTok{+} \DecValTok{1}\NormalTok{),}
\NormalTok{         vorhersagewerte,}
\NormalTok{         label }\OperatorTok{=} \StringTok{\textquotesingle{}Festpunktmethode\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Position und Beschriftung der x{-}Achse setzen}
\NormalTok{plt.xticks(ticks }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{0}\NormalTok{, eis.shape[}\DecValTok{0}\NormalTok{], }\DecValTok{100}\NormalTok{), labels }\OperatorTok{=}\NormalTok{ eis[}\StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{].dt.time[::}\DecValTok{100}\NormalTok{]) }

\NormalTok{plt.xlabel(xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}° C\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.legend()}



\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Linearitätsfehler nach Festpunktmethode: 10.09 °C.
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/beispiel-eiskochen_files/figure-pdf/cell-26-output-2.png}}

~

Thermoelement 2

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ende }\OperatorTok{=}\NormalTok{ ende\_thermoelement2}

\CommentTok{\# Endpunktverbindende Gerade schätzen}
\CommentTok{\# x muss bei Null beginnen}
\NormalTok{lm }\OperatorTok{=}\NormalTok{ poly.polyfit(}
\NormalTok{  x }\OperatorTok{=}\NormalTok{ [start }\OperatorTok{{-}}\NormalTok{ start, ende }\OperatorTok{{-}}\NormalTok{ start],}
\NormalTok{  y }\OperatorTok{=}\NormalTok{ [eis.loc[start, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{], eis.loc[ende, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{]],}
\NormalTok{  deg }\OperatorTok{=} \DecValTok{1}\NormalTok{)}
\CommentTok{\#\# print(lm.round(2)) \# intercept + slope}

\CommentTok{\# Vorhersagewerte schätzen}
\CommentTok{\#\# np.arange() ist exklusiv}
\NormalTok{vorhersagewerte }\OperatorTok{=}\NormalTok{ poly.polyval(x }\OperatorTok{=}\NormalTok{ np.arange(start }\OperatorTok{{-}}\NormalTok{ start, ende }\OperatorTok{{-}}\NormalTok{ start }\OperatorTok{+} \DecValTok{1}\NormalTok{), c }\OperatorTok{=}\NormalTok{ lm)}
\CommentTok{\#\#\# print(len(vorhersagewerte))}
\CommentTok{\#\#\# print(len(np.arange(eis.loc[start:ende, :].shape[0])))}

\CommentTok{\# Linearitätsfehler berechnen}
\NormalTok{linearitätsfehler\_festpunkt }\OperatorTok{=}\NormalTok{ eis.loc[start:ende, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{].sub(vorhersagewerte).}\BuiltInTok{abs}\NormalTok{().}\BuiltInTok{max}\NormalTok{()}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Linearitätsfehler nach Festpunktmethode: }\SpecialCharTok{\{}\NormalTok{linearit}\SpecialCharTok{ä}\NormalTok{tsfehler\_festpunkt}\SpecialCharTok{:.2f\}}\SpecialStringTok{ °C."}\NormalTok{)}

\CommentTok{\# grafische Darstellung}
\NormalTok{plt.plot(np.arange(eis.shape[}\DecValTok{0}\NormalTok{]),}
\NormalTok{         eis[}\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{],}
\NormalTok{         label }\OperatorTok{=} \StringTok{\textquotesingle{}Thermoelement 2\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(np.arange(start, ende }\OperatorTok{+} \DecValTok{1}\NormalTok{),}
\NormalTok{         vorhersagewerte,}
\NormalTok{         label }\OperatorTok{=} \StringTok{\textquotesingle{}Festpunktmethode\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Position und Beschriftung der x{-}Achse setzen}
\NormalTok{plt.xticks(ticks }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{0}\NormalTok{, eis.shape[}\DecValTok{0}\NormalTok{], }\DecValTok{100}\NormalTok{), labels }\OperatorTok{=}\NormalTok{ eis[}\StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{].dt.time[::}\DecValTok{100}\NormalTok{]) }

\NormalTok{plt.xlabel(xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}° C\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.legend()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Linearitätsfehler nach Festpunktmethode: 10.95 °C.
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/beispiel-eiskochen_files/figure-pdf/cell-27-output-2.png}}

~

\subsubsection{Toleranzbandmethode}\label{toleranzbandmethode-2}

Für die Anwendung der Toleranzbandmethode wird die
\href{https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.linregress.html\#scipy.stats.linregress}{Funktion
linregress} aus dem Paket SciPy verwendet, da diese mit fehlenden Werten
umgehen kann.

\texttt{linregress(x,\ y,\ alternative=\textquotesingle{}two-sided\textquotesingle{},\ *,\ axis=0,\ nan\_policy=\textquotesingle{}propagate\textquotesingle{})}

Dafür wird der Parameter
\texttt{nan\_policy\ =\ \textquotesingle{}omit\textquotesingle{}}
gesetzt, wodurch Fehlwerte verworfen werden. Die Funktion gibt ein
LinregressResult-Objekt zurück, dass den Zugriff auf die
Regressionsobjekte über Attribute erlaubt. Für uns relevant sind die
Attribute \texttt{LinregressResult.intercept} und
\texttt{LinregressResult.slope}.

Thermoelement 1

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ende }\OperatorTok{=}\NormalTok{ ende\_thermoelement1}

\CommentTok{\# Regression durch die Messwerte}
\CommentTok{\# x muss bei Null beginnen}
\NormalTok{lm }\OperatorTok{=}\NormalTok{ scipy.stats.linregress(}
\NormalTok{  x }\OperatorTok{=}\NormalTok{ np.arange(start }\OperatorTok{{-}}\NormalTok{ start, ende }\OperatorTok{{-}}\NormalTok{ start }\OperatorTok{+} \DecValTok{1}\NormalTok{),}
\NormalTok{  y }\OperatorTok{=}\NormalTok{ eis.loc[start:ende, }\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{],}
\NormalTok{  nan\_policy }\OperatorTok{=} \StringTok{\textquotesingle{}omit\textquotesingle{}}\NormalTok{)}
\CommentTok{\# print(lm.intercept, lm.slope)}

\CommentTok{\# Vorhersagewerte schätzen}
\CommentTok{\#\# np.arange() ist exklusiv}
\NormalTok{vorhersagewerte }\OperatorTok{=}\NormalTok{ poly.polyval(x }\OperatorTok{=}\NormalTok{ np.arange(start }\OperatorTok{{-}}\NormalTok{ start, ende }\OperatorTok{{-}}\NormalTok{ start }\OperatorTok{+} \DecValTok{1}\NormalTok{), c }\OperatorTok{=}\NormalTok{ [lm.intercept, lm.slope])}

\CommentTok{\# Linearitätsfehler berechnen}
\NormalTok{linearitätsfehler\_toleranzband }\OperatorTok{=}\NormalTok{ eis.loc[start:ende, }\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{].sub(vorhersagewerte).}\BuiltInTok{abs}\NormalTok{().}\BuiltInTok{max}\NormalTok{()}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Linearitätsfehler nach Toleranzbandmethode: }\SpecialCharTok{\{}\NormalTok{linearit}\SpecialCharTok{ä}\NormalTok{tsfehler\_toleranzband}\SpecialCharTok{:.2f\}}\SpecialStringTok{ °C."}\NormalTok{)}

\CommentTok{\# grafische Darstellung}
\NormalTok{plt.plot(np.arange(eis.shape[}\DecValTok{0}\NormalTok{]),}
\NormalTok{         eis[}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{],}
\NormalTok{         label }\OperatorTok{=} \StringTok{\textquotesingle{}Thermoelement 1\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(np.arange(start, ende }\OperatorTok{+} \DecValTok{1}\NormalTok{),}
\NormalTok{         vorhersagewerte,}
\NormalTok{         label }\OperatorTok{=} \StringTok{\textquotesingle{}Toleranzbandmethode\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Position und Beschriftung der x{-}Achse setzen}
\NormalTok{plt.xticks(ticks }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{0}\NormalTok{, eis.shape[}\DecValTok{0}\NormalTok{], }\DecValTok{100}\NormalTok{), labels }\OperatorTok{=}\NormalTok{ eis[}\StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{].dt.time[::}\DecValTok{100}\NormalTok{]) }

\NormalTok{plt.xlabel(xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}° C\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.legend()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Linearitätsfehler nach Toleranzbandmethode: 8.22 °C.
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/beispiel-eiskochen_files/figure-pdf/cell-28-output-2.png}}

~

Thermoelement 2:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ende }\OperatorTok{=}\NormalTok{ ende\_thermoelement2}

\CommentTok{\# Regression durch die Messwerte}
\CommentTok{\# x muss bei Null beginnen}
\NormalTok{lm }\OperatorTok{=}\NormalTok{ scipy.stats.linregress(}
\NormalTok{  x }\OperatorTok{=}\NormalTok{ np.arange(start }\OperatorTok{{-}}\NormalTok{ start, ende }\OperatorTok{{-}}\NormalTok{ start }\OperatorTok{+} \DecValTok{1}\NormalTok{),}
\NormalTok{  y }\OperatorTok{=}\NormalTok{ eis.loc[start:ende, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{],}
\NormalTok{  nan\_policy }\OperatorTok{=} \StringTok{\textquotesingle{}omit\textquotesingle{}}\NormalTok{)}
\CommentTok{\# print(lm.intercept, lm.slope)}

\CommentTok{\# Vorhersagewerte schätzen}
\CommentTok{\#\# np.arange() ist exklusiv}
\NormalTok{vorhersagewerte }\OperatorTok{=}\NormalTok{ poly.polyval(x }\OperatorTok{=}\NormalTok{ np.arange(start }\OperatorTok{{-}}\NormalTok{ start, ende }\OperatorTok{{-}}\NormalTok{ start }\OperatorTok{+} \DecValTok{1}\NormalTok{), c }\OperatorTok{=}\NormalTok{ [lm.intercept, lm.slope])}

\CommentTok{\# Linearitätsfehler berechnen}
\NormalTok{linearitätsfehler\_toleranzband }\OperatorTok{=}\NormalTok{ eis.loc[start:ende, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{].sub(vorhersagewerte).}\BuiltInTok{abs}\NormalTok{().}\BuiltInTok{max}\NormalTok{()}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Linearitätsfehler nach Toleranzbandmethode: }\SpecialCharTok{\{}\NormalTok{linearit}\SpecialCharTok{ä}\NormalTok{tsfehler\_toleranzband}\SpecialCharTok{:.2f\}}\SpecialStringTok{ °C."}\NormalTok{)}

\CommentTok{\# grafische Darstellung}
\NormalTok{plt.plot(np.arange(eis.shape[}\DecValTok{0}\NormalTok{]),}
\NormalTok{         eis[}\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{],}
\NormalTok{         label }\OperatorTok{=} \StringTok{\textquotesingle{}Thermoelement 2\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(np.arange(start, ende }\OperatorTok{+} \DecValTok{1}\NormalTok{),}
\NormalTok{         vorhersagewerte,}
\NormalTok{         label }\OperatorTok{=} \StringTok{\textquotesingle{}Toleranzbandmethode\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Position und Beschriftung der x{-}Achse setzen}
\NormalTok{plt.xticks(ticks }\OperatorTok{=}\NormalTok{ np.arange(}\DecValTok{0}\NormalTok{, eis.shape[}\DecValTok{0}\NormalTok{], }\DecValTok{100}\NormalTok{), labels }\OperatorTok{=}\NormalTok{ eis[}\StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{].dt.time[::}\DecValTok{100}\NormalTok{]) }

\NormalTok{plt.xlabel(xlabel }\OperatorTok{=} \StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}° C\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.legend()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Linearitätsfehler nach Toleranzbandmethode: 6.78 °C.
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/beispiel-eiskochen_files/figure-pdf/cell-29-output-2.png}}

\section{Zweipunktkalibrierung}\label{zweipunktkalibrierung}

Für die Zweipunktkalibrierung stellen wir den in Note~\ref{nte-eis}
eingelesenen Datensatz wieder her.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{eis }\OperatorTok{=}\NormalTok{ eis\_backup.copy()}

\NormalTok{wahres\_minimum }\OperatorTok{=} \DecValTok{0}
\NormalTok{wahres\_maximum }\OperatorTok{=} \DecValTok{100}

\CommentTok{\# Thermoelement 1}
\NormalTok{ende }\OperatorTok{=}\NormalTok{ ende\_thermoelement1}

\NormalTok{a }\OperatorTok{=}\NormalTok{ (wahres\_maximum }\OperatorTok{{-}}\NormalTok{ wahres\_minimum) }\OperatorTok{/}\NormalTok{ (eis.loc[start:ende, }\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{].}\BuiltInTok{max}\NormalTok{() }\OperatorTok{{-}}\NormalTok{ eis.loc[start:ende, }\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{].}\BuiltInTok{min}\NormalTok{())}
\NormalTok{b }\OperatorTok{=}\NormalTok{ wahres\_minimum }\OperatorTok{{-}}\NormalTok{ a }\OperatorTok{*}\NormalTok{ eis.loc[start:ende, }\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{].}\BuiltInTok{min}\NormalTok{()}

\NormalTok{eis[}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ a }\OperatorTok{*}\NormalTok{ eis[}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{] }\OperatorTok{+}\NormalTok{ b}

\CommentTok{\#\# Ausgabe}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Thermoelement 1"}\NormalTok{,}
      \SpecialStringTok{f"a = }\SpecialCharTok{\{}\NormalTok{a}\SpecialCharTok{:.1f\}}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"b = }\SpecialCharTok{\{}\NormalTok{b}\SpecialCharTok{:.1f\}}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Nullpunktfehler: }\SpecialCharTok{\{}\BuiltInTok{round}\NormalTok{(}\OperatorTok{{-}}\DecValTok{1} \OperatorTok{*}\NormalTok{ b }\OperatorTok{/}\NormalTok{ a, }\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Empfindlichkeitsfehler: }\SpecialCharTok{\{}\BuiltInTok{round}\NormalTok{( ((}\DecValTok{1} \OperatorTok{/}\NormalTok{ a) }\OperatorTok{{-}} \DecValTok{1}\NormalTok{) }\OperatorTok{*} \DecValTok{100}\NormalTok{, }\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{ \%"}\NormalTok{,}
\NormalTok{      sep }\OperatorTok{=} \StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{()}

\CommentTok{\# Thermoelement 2}
\NormalTok{ende }\OperatorTok{=}\NormalTok{ ende\_thermoelement2}

\NormalTok{a }\OperatorTok{=}\NormalTok{ (wahres\_maximum }\OperatorTok{{-}}\NormalTok{ wahres\_minimum) }\OperatorTok{/}\NormalTok{ (eis.loc[start:ende, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{].}\BuiltInTok{max}\NormalTok{() }\OperatorTok{{-}}\NormalTok{ eis.loc[start:ende, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{].}\BuiltInTok{min}\NormalTok{())}
\NormalTok{b }\OperatorTok{=}\NormalTok{ wahres\_minimum }\OperatorTok{{-}}\NormalTok{ a }\OperatorTok{*}\NormalTok{ eis.loc[start:ende, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{].}\BuiltInTok{min}\NormalTok{()}

\NormalTok{eis[}\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ a }\OperatorTok{*}\NormalTok{ eis[}\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{] }\OperatorTok{+}\NormalTok{ b}

\CommentTok{\#\# Ausgabe}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Thermoelement 2"}\NormalTok{,}
      \SpecialStringTok{f"a = }\SpecialCharTok{\{}\NormalTok{a}\SpecialCharTok{:.1f\}}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"b = }\SpecialCharTok{\{}\NormalTok{b}\SpecialCharTok{:.1f\}}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Nullpunktfehler: }\SpecialCharTok{\{}\BuiltInTok{round}\NormalTok{(}\OperatorTok{{-}}\DecValTok{1} \OperatorTok{*}\NormalTok{ b }\OperatorTok{/}\NormalTok{ a, }\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Empfindlichkeitsfehler: }\SpecialCharTok{\{}\BuiltInTok{round}\NormalTok{( ((}\DecValTok{1} \OperatorTok{/}\NormalTok{ a) }\OperatorTok{{-}} \DecValTok{1}\NormalTok{) }\OperatorTok{*} \DecValTok{100}\NormalTok{, }\DecValTok{2}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{ \%"}\NormalTok{,}
\NormalTok{      sep }\OperatorTok{=} \StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}

\CommentTok{\# plotten}
\NormalTok{plotting\_data }\OperatorTok{=}\NormalTok{ eis.copy()}
\NormalTok{plotting\_data[}\StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ plotting\_data[}\StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{].dt.time}

\NormalTok{plotting\_data.plot(x }\OperatorTok{=} \StringTok{\textquotesingle{}Zeit\textquotesingle{}}\NormalTok{, y }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{], grid }\OperatorTok{=} \VariableTok{True}\NormalTok{, ylabel }\OperatorTok{=} \StringTok{\textquotesingle{}°C\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Thermoelement 1
a = 1.0
b = -1.0
Nullpunktfehler: 1.0
Empfindlichkeitsfehler: -2.0 %

Thermoelement 2
a = 1.0
b = -0.5
Nullpunktfehler: 0.5
Empfindlichkeitsfehler: 0.2 %
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/m-sensordatenanalyse/skript/beispiel-eiskochen_files/figure-pdf/cell-30-output-2.png}}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Maximum kalibriertes Thermoelement 1: }\SpecialCharTok{\{}\NormalTok{eis[}\StringTok{\textquotesingle{}Thermoelement 1 (°C)\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\BuiltInTok{max}\NormalTok{()}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{,}
      \SpecialStringTok{f"Maximum kalibriertes Thermoelement 2: }\SpecialCharTok{\{}\NormalTok{eis[}\StringTok{\textquotesingle{}Thermoelement 2 (°C)\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\BuiltInTok{max}\NormalTok{()}\SpecialCharTok{:.2f\}}\SpecialStringTok{"}\NormalTok{,}
\NormalTok{      sep }\OperatorTok{=} \StringTok{\textquotesingle{}}\CharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Maximum kalibriertes Thermoelement 1: 100.71
Maximum kalibriertes Thermoelement 2: 102.30
\end{verbatim}

\part{a-analyse-von-zeitdaten}

\chapter*{Preamble}\label{preamble-2}
\addcontentsline{toc}{chapter}{Preamble}

\markboth{Preamble}{Preamble}

\phantomsection\label{Lizenz}
\begin{figure}

\begin{minipage}{0.20\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/by.png}}\end{minipage}%
%
\begin{minipage}{0.80\linewidth}
Bausteine Computergestützter Datenanalyse. ``Zeitreihenanalyse'' von
Lukas Arnold, Simone Arnold, Florian Bagemihl, Matthias Baitsch, Marc
Fehr, Maik Poetzsch und Sebastian Seipel ist lizensiert unter
\href{https://creativecommons.org/licenses/by/4.0/deed.de}{CC BY 4.0}.
Das Werk ist abrufbar unter
\url{https://github.com/bausteine-der-datenanalyse/a-zeitreihenanalyse}.
Ausgenommen von der Lizenz sind alle Logos und anders gekennzeichneten
Inhalte. 2024\end{minipage}%

\end{figure}%

Zitiervorschlag

Arnold, Lukas, Simone Arnold, Matthias Baitsch, Marc Fehr, Maik
Poetzsch, und Sebastian Seipel. 2024. „Bausteine Computergestützter
Datenanalyse. Methodenbaustein Numerik``.
\url{https://github.com/bausteine-der-datenanalyse/a-zeitreihenanalyse}.

BibTeX-Vorlage

\begin{verbatim}
@misc{BCD-Styleguide-2024,
 title={Bausteine Computergestützter Datenanalyse. Methodenbaustein Numerik},
 author={Arnold, Lukas and Arnold, Simone and Baitsch, Matthias and Fehr, Marc and Poetzsch, Maik and Seipel, Sebastian},
 year={2024},
 url={https://github.com/bausteine-der-datenanalyse/a-zeitreihenanalyse}} 
\end{verbatim}

\chapter*{Intro}\label{intro-3}
\addcontentsline{toc}{chapter}{Intro}

\markboth{Intro}{Intro}

\section*{Voraussetzungen}\label{voraussetzungen-10}
\addcontentsline{toc}{section}{Voraussetzungen}

\markright{Voraussetzungen}

\begin{itemize}
\tightlist
\item
  Python-Grundlagen
\item
  NumPy (Arrays, grundlegende Operationen)
\item
  Matplotlib (Visualisierung)
\item
  Grundverständnis von Pandas (Series, DataFrame)
\end{itemize}

\section*{Verwendete Pakete und
Datensätze}\label{verwendete-pakete-und-datensuxe4tze-3}
\addcontentsline{toc}{section}{Verwendete Pakete und Datensätze}

\markright{Verwendete Pakete und Datensätze}

\subsection*{Pakete}\label{pakete-2}
\addcontentsline{toc}{subsection}{Pakete}

\begin{itemize}
\tightlist
\item
  \href{https://numpy.org/}{NumPy}
\item
  \href{https://matplotlib.org/}{Matplotlib}
\item
  \href{https://pandas.pydata.org/}{Pandas}
\end{itemize}

\subsection*{Datensätze}\label{datensuxe4tze-2}
\addcontentsline{toc}{subsection}{Datensätze}

\section*{Bearbeitungszeit}\label{bearbeitungszeit-3}
\addcontentsline{toc}{section}{Bearbeitungszeit}

\markright{Bearbeitungszeit}

Geschätzte Bearbeitungszeit: 2h

\section*{Lernziele}\label{lernziele-10}
\addcontentsline{toc}{section}{Lernziele}

\markright{Lernziele}

\begin{itemize}
\tightlist
\item
  Zeitreihen strukturiert vorverarbeiten (Zeitindex, Missing, Ausreißer)
\item
  Resampling und Alignment methodisch korrekt einsetzen
\item
  Glättung so wählen, dass sie zur Fragestellung passt
\item
  Trend und Saisonanteile erkennen und interpretieren
\item
  zeitliche Abhängigkeiten mit Lag/Autokorrelation diagnostizieren
\item
  Anomalien mit einfachen, begründbaren Regeln detektieren
\item
  Forecast-Baselines implementieren und mit Fehlermaßen bewerten
\end{itemize}

\chapter{1 Einordnung: Zeitreihen als
Messprozess}\label{einordnung-zeitreihen-als-messprozess}

\chapter{1 Einordnung: Zeitreihen als
Messprozess}\label{einordnung-zeitreihen-als-messprozess-1}

Eine Zeitreihe ist das Ergebnis eines \textbf{Messprozesses über die
Zeit}.

Typische Beispiele:

\begin{itemize}
\tightlist
\item
  Sensordaten
\item
  Energieverbrauch
\item
  Web-Traffic
\item
  Finanzdaten
\item
  Maschinendaten in Produktionsprozessen
\end{itemize}

Wichtig ist nicht nur der Zahlenwert selbst, sondern:

\begin{itemize}
\tightlist
\item
  \textbf{Abtastrate} (stündlich, minütlich, unregelmäßig?)
\item
  \textbf{Messqualität}
\item
  \textbf{Strukturelle Muster} (Trend, Periodik)
\item
  \textbf{Störungen} (Rauschen, Ausreißer)
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Merke}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Zeitreihenanalyse beginnt nicht mit einem Modell, sondern mit dem
Verständnis des Messprozesses.

\end{tcolorbox}

\section{1.1 Arbeitsdatensatz erzeugen}\label{arbeitsdatensatz-erzeugen}

Wir erstellen eine synthetische Zeitreihe mit:

\begin{itemize}
\tightlist
\item
  Trend\\
\item
  Tagesperiodik\\
\item
  Rauschen\\
\item
  Ausreißern
\end{itemize}

Diese Struktur ist typisch für reale technische Messdaten.

\section{Pandas (empfohlen)}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{rng }\OperatorTok{=}\NormalTok{ np.random.default\_rng(}\DecValTok{42}\NormalTok{)}

\CommentTok{\# Zeitindex: 14 Tage, stündliche Messung}
\NormalTok{t }\OperatorTok{=}\NormalTok{ pd.date\_range(}\StringTok{"2025{-}01{-}01"}\NormalTok{, periods}\OperatorTok{=}\DecValTok{24}\OperatorTok{*}\DecValTok{14}\NormalTok{, freq}\OperatorTok{=}\StringTok{"H"}\NormalTok{)}

\NormalTok{trend }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{3}\NormalTok{, }\BuiltInTok{len}\NormalTok{(t))}
\NormalTok{season }\OperatorTok{=} \FloatTok{0.8} \OperatorTok{*}\NormalTok{ np.sin(}\DecValTok{2}\OperatorTok{*}\NormalTok{np.pi}\OperatorTok{*}\NormalTok{(t.hour)}\OperatorTok{/}\DecValTok{24}\NormalTok{)}
\NormalTok{noise }\OperatorTok{=} \FloatTok{0.25} \OperatorTok{*}\NormalTok{ rng.normal(size}\OperatorTok{=}\BuiltInTok{len}\NormalTok{(t))}

\NormalTok{y }\OperatorTok{=} \DecValTok{10} \OperatorTok{+}\NormalTok{ trend }\OperatorTok{+}\NormalTok{ season }\OperatorTok{+}\NormalTok{ noise}
\NormalTok{y }\OperatorTok{=}\NormalTok{ pd.Series(y, index}\OperatorTok{=}\NormalTok{t, name}\OperatorTok{=}\StringTok{"signal"}\NormalTok{)}

\CommentTok{\# künstliche Ausreißer}
\NormalTok{y.iloc[}\DecValTok{50}\NormalTok{] }\OperatorTok{+=} \FloatTok{3.5}
\NormalTok{y.iloc[}\DecValTok{120}\NormalTok{] }\OperatorTok{{-}=} \FloatTok{2.8}

\NormalTok{y.plot()}
\NormalTok{plt.title(}\StringTok{"Zeitreihe (Trend + Saison + Rauschen)"}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{"Zeit"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"Wert"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_21101/3138279399.py:8: FutureWarning: 'H' is deprecated and will be removed in a future version, please use 'h' instead.
  t = pd.date_range("2025-01-01", periods=24*14, freq="H")
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/01-einleitung_files/figure-pdf/cell-2-output-2.png}}

\section{NumPy (Prinzip)}

Hier modellieren wir Zeit als einfachen Sample-Index.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{rng }\OperatorTok{=}\NormalTok{ np.random.default\_rng(}\DecValTok{42}\NormalTok{)}

\NormalTok{n }\OperatorTok{=} \DecValTok{24}\OperatorTok{*}\DecValTok{14}
\NormalTok{x }\OperatorTok{=}\NormalTok{ np.arange(n)}

\NormalTok{trend }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{3}\NormalTok{, n)}
\NormalTok{season }\OperatorTok{=} \FloatTok{0.8} \OperatorTok{*}\NormalTok{ np.sin(}\DecValTok{2}\OperatorTok{*}\NormalTok{np.pi}\OperatorTok{*}\NormalTok{(x }\OperatorTok{\%} \DecValTok{24}\NormalTok{)}\OperatorTok{/}\DecValTok{24}\NormalTok{)}
\NormalTok{noise }\OperatorTok{=} \FloatTok{0.25} \OperatorTok{*}\NormalTok{ rng.normal(size}\OperatorTok{=}\NormalTok{n)}

\NormalTok{y }\OperatorTok{=} \DecValTok{10} \OperatorTok{+}\NormalTok{ trend }\OperatorTok{+}\NormalTok{ season }\OperatorTok{+}\NormalTok{ noise}

\CommentTok{\# Ausreißer}
\NormalTok{y[}\DecValTok{50}\NormalTok{] }\OperatorTok{+=} \FloatTok{3.5}
\NormalTok{y[}\DecValTok{120}\NormalTok{] }\OperatorTok{{-}=} \FloatTok{2.8}

\NormalTok{plt.plot(y)}
\NormalTok{plt.title(}\StringTok{"Zeitreihe (NumPy, ohne Zeitindex)"}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{"Sample"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"Wert"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/01-einleitung_files/figure-pdf/cell-3-output-1.png}}

\section{1.2 Typische Analysefragen}\label{typische-analysefragen}

Bei Zeitreihen treten immer wieder ähnliche Fragestellungen auf:

\begin{itemize}
\tightlist
\item
  Gibt es einen \textbf{Trend}?
\item
  Existiert eine \textbf{Periodik} (z. B. Tages- oder Wochenmuster)?
\item
  Wie stark ist das \textbf{Rauschen}?
\item
  Gibt es \textbf{Anomalien}?
\item
  Wie kann ich zukünftige Werte grob abschätzen?
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Methodischer Blick}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Bevor Sie glätten oder modellieren:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Visualisieren\\
\item
  Zeitskala prüfen\\
\item
  Struktur erkennen\\
\item
  Erst dann weiter analysieren\\
\end{enumerate}

\end{tcolorbox}

\section{1.3 Strukturmodell einer
Zeitreihe}\label{strukturmodell-einer-zeitreihe}

Eine Zeitreihe lässt sich häufig konzeptionell darstellen als:

Signal = Trend + Saison + Rauschen + Ausreißer

Diese Zerlegung ist kein physikalisches Gesetz, sondern ein
\textbf{Denkmodell}, das hilft, Muster systematisch zu analysieren.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-warning-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame, coltitle=black, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Achtung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Nicht jedes wiederkehrende Muster ist automatisch „Saison''.\\
Regelmäßigkeit muss zur Abtastrate und zum Prozess plausibel passen.

\end{tcolorbox}

\section{1.4 Mini-Reflexion}\label{mini-reflexion}

Beantworten Sie:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Welche Periodik wurde hier modelliert?
\item
  Welche Rolle spielt die Abtastrate?
\item
  Würde eine tägliche Aggregation den Saisonanteil sichtbar oder
  unsichtbar machen?
\item
  Wie würden sich Ausreißer bei starker Glättung verhalten?
\end{enumerate}

Diese Fragen begleiten uns durch den gesamten Methodenbaustein.

\chapter{2 Vorverarbeitung \& Validierung einer
Zeitreihe}\label{vorverarbeitung-validierung-einer-zeitreihe}

\chapter{2 Vorverarbeitung \& Validierung einer
Zeitreihe}\label{vorverarbeitung-validierung-einer-zeitreihe-1}

Bevor eine Zeitreihe analysiert wird, muss sie \textbf{formal korrekt
und konsistent} sein.

Viele Fehler in späteren Analysen entstehen durch:

\begin{itemize}
\tightlist
\item
  unsortierte Zeitstempel
\item
  doppelte Zeitpunkte
\item
  fehlende Werte
\item
  unregelmäßige Abtastung
\item
  implizite Zeitlücken
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Merke}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Zeitreihenanalyse ist nur so gut wie die Datenbasis. Validierung ist
kein optionaler Schritt.

\end{tcolorbox}

\section{2.1 Beispiel-Zeitreihe mit
Problemen}\label{beispiel-zeitreihe-mit-problemen}

Wir erzeugen bewusst eine fehlerhafte Zeitreihe (unsortiert, Duplikate,
Missing Values).

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}

\NormalTok{rng }\OperatorTok{=}\NormalTok{ np.random.default\_rng(}\DecValTok{1}\NormalTok{)}

\NormalTok{t }\OperatorTok{=}\NormalTok{ pd.date\_range(}\StringTok{"2025{-}01{-}01"}\NormalTok{, periods}\OperatorTok{=}\DecValTok{24}\OperatorTok{*}\DecValTok{3}\NormalTok{, freq}\OperatorTok{=}\StringTok{"h"}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ pd.Series(}\DecValTok{10} \OperatorTok{+}\NormalTok{ rng.normal(size}\OperatorTok{=}\BuiltInTok{len}\NormalTok{(t)), index}\OperatorTok{=}\NormalTok{t, name}\OperatorTok{=}\StringTok{"signal"}\NormalTok{)}

\CommentTok{\# Probleme erzeugen}
\NormalTok{y }\OperatorTok{=}\NormalTok{ y.sample(frac}\OperatorTok{=}\DecValTok{1}\NormalTok{)                      }\CommentTok{\# unsortiert}
\NormalTok{y }\OperatorTok{=}\NormalTok{ pd.concat([y, y.iloc[}\DecValTok{5}\NormalTok{:}\DecValTok{8}\NormalTok{]])           }\CommentTok{\# Duplikate (append ist deprecated/entfernt)}
\NormalTok{y.iloc[}\DecValTok{10}\NormalTok{:}\DecValTok{15}\NormalTok{] }\OperatorTok{=}\NormalTok{ np.nan                    }\CommentTok{\# fehlende Werte}

\NormalTok{y.head()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2025-01-01 06:00:00    9.463047
2025-01-01 21:00:00    9.724397
2025-01-02 01:00:00    8.110987
2025-01-03 14:00:00    9.017812
2025-01-03 10:00:00    8.751251
Name: signal, dtype: float64
\end{verbatim}

\section{2.2 Schritt 1: Sortierung
sicherstellen}\label{schritt-1-sortierung-sicherstellen}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OperatorTok{=}\NormalTok{ y.sort\_index()}
\end{Highlighting}
\end{Shaded}

\section{2.3 Schritt 2: Duplikate erkennen und
behandeln}\label{schritt-2-duplikate-erkennen-und-behandeln}

Duplikate erkennen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dup\_mask }\OperatorTok{=}\NormalTok{ y.index.duplicated(keep}\OperatorTok{=}\VariableTok{False}\NormalTok{)}
\NormalTok{y[dup\_mask].head(}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2025-01-01 01:00:00    10.821618
2025-01-01 01:00:00    10.821618
2025-01-03 05:00:00     9.498560
2025-01-03 05:00:00     9.498560
2025-01-03 17:00:00     9.533250
2025-01-03 17:00:00     9.533250
Name: signal, dtype: float64
\end{verbatim}

Duplikate müssen methodisch entschieden behandelt werden, z. B.:

\begin{itemize}
\tightlist
\item
  Mittelwert pro Zeitstempel (typisch bei Messwerten)
\item
  ersten/letzten Wert behalten (typisch bei Status-Updates)
\item
  entfernen (wenn klar fehlerhaft)
\end{itemize}

Beispiel: Mittelwert pro Zeitstempel

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OperatorTok{=}\NormalTok{ y.groupby(level}\OperatorTok{=}\DecValTok{0}\NormalTok{).mean()}
\end{Highlighting}
\end{Shaded}

\section{2.4 Schritt 3: Fehlende Werte
analysieren}\label{schritt-3-fehlende-werte-analysieren}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y.isna().}\BuiltInTok{sum}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
np.int64(5)
\end{verbatim}

\subsection{Visualisierung der
Lücken}\label{visualisierung-der-luxfccken}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{y.plot(title}\OperatorTok{=}\StringTok{"Zeitreihe mit Missing Values"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/02-vorverarbeitung-validierung_files/figure-pdf/cell-7-output-1.png}}

\subsection{Behandlungsmöglichkeiten}\label{behandlungsmuxf6glichkeiten}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_ffill }\OperatorTok{=}\NormalTok{ y.ffill()}
\NormalTok{y\_interp }\OperatorTok{=}\NormalTok{ y.interpolate(}\StringTok{"time"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Entscheidungshilfe}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{itemize}
\tightlist
\item
  \texttt{ffill}: sinnvoll bei Zustandsdaten („gilt bis zur nächsten
  Messung``)
\item
  \texttt{interpolate("time")}: sinnvoll bei kontinuierlichen Messgrößen
\end{itemize}

\end{tcolorbox}

\section{2.5 Schritt 4: Abtastrate
prüfen}\label{schritt-4-abtastrate-pruxfcfen}

Ist die Zeitreihe regelmäßig?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diffs }\OperatorTok{=}\NormalTok{ y.index.to\_series().diff()}
\NormalTok{diffs.value\_counts().head()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0 days 01:00:00    71
Name: count, dtype: int64
\end{verbatim}

Wenn mehrere Zeitabstände auftreten → unregelmäßige Abtastung oder
Zeitlücken.

\section{2.6 Zeitlücken explizit
machen}\label{zeitluxfccken-explizit-machen}

Mit \texttt{asfreq} wird die erwartete Frequenz erzwungen. Fehlende
Zeitpunkte werden als NaN sichtbar.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_regular }\OperatorTok{=}\NormalTok{ y.asfreq(}\StringTok{"h"}\NormalTok{)}
\NormalTok{y\_regular.isna().}\BuiltInTok{sum}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
np.int64(5)
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-warning-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame, coltitle=black, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Achtung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Ohne explizite Frequenz können Zeitlücken unsichtbar bleiben.

\end{tcolorbox}

\section{2.7 Validierungs-Checkliste}\label{validierungs-checkliste}

Bevor Sie weiter analysieren:

\begin{itemize}
\tightlist
\item[$\square$]
  Index ist \texttt{DatetimeIndex}
\item[$\square$]
  Zeitreihe ist sortiert
\item[$\square$]
  Duplikate identifiziert und begründet behandelt
\item[$\square$]
  Fehlende Werte identifiziert und Strategie gewählt
\item[$\square$]
  Abtastrate geprüft
\item[$\square$]
  Frequenz (falls sinnvoll) explizit gesetzt
\end{itemize}

\section{2.8 Mini-Aufgabe}\label{mini-aufgabe}

Erzeugen Sie selbst eine Zeitreihe mit:

\begin{itemize}
\tightlist
\item
  unregelmäßiger Abtastung
\item
  5 fehlenden Zeitpunkten
\item
  3 Duplikaten
\end{itemize}

Implementieren Sie anschließend eine saubere Validierung gemäß
Checkliste.

\chapter{3 Resampling \& Alignment}\label{resampling-alignment}

\chapter{3 Resampling \& Alignment}\label{resampling-alignment-1}

Zeitreihen liegen häufig in unterschiedlichen Abtastraten vor oder
müssen auf eine andere Zeitskala transformiert werden.

Typische Gründe:

\begin{itemize}
\tightlist
\item
  Vergleich zweier Zeitreihen
\item
  Reduktion von Rauschen durch Aggregation
\item
  Anpassung an Reporting-Intervalle
\item
  Vorbereitung für Modellierung
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Merke}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Resampling bedeutet: Änderung der Zeitskala. Dabei muss entschieden
werden zwischen Aggregation und Interpolation.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{3.1 Ausgangszeitreihe
(stündlich)}\label{ausgangszeitreihe-stuxfcndlich}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{rng }\OperatorTok{=}\NormalTok{ np.random.default\_rng(}\DecValTok{2}\NormalTok{)}

\NormalTok{t }\OperatorTok{=}\NormalTok{ pd.date\_range(}\StringTok{"2025{-}01{-}01"}\NormalTok{, periods}\OperatorTok{=}\DecValTok{24}\OperatorTok{*}\DecValTok{5}\NormalTok{, freq}\OperatorTok{=}\StringTok{"H"}\NormalTok{)}
\NormalTok{y }\OperatorTok{=}\NormalTok{ pd.Series(}\DecValTok{10} \OperatorTok{+}\NormalTok{ rng.normal(size}\OperatorTok{=}\BuiltInTok{len}\NormalTok{(t)), index}\OperatorTok{=}\NormalTok{t, name}\OperatorTok{=}\StringTok{"signal"}\NormalTok{)}

\NormalTok{y.plot(title}\OperatorTok{=}\StringTok{"Stündliche Zeitreihe"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_21203/2493709333.py:7: FutureWarning: 'H' is deprecated and will be removed in a future version, please use 'h' instead.
  t = pd.date_range("2025-01-01", periods=24*5, freq="H")
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/03-resampling-alignment_files/figure-pdf/cell-2-output-2.png}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{3.2 Downsampling (Aggregation)}\label{downsampling-aggregation}

Wir aggregieren von Stunden auf Tage.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{daily\_mean }\OperatorTok{=}\NormalTok{ y.resample(}\StringTok{"D"}\NormalTok{).mean()}
\NormalTok{daily\_max }\OperatorTok{=}\NormalTok{ y.resample(}\StringTok{"D"}\NormalTok{).}\BuiltInTok{max}\NormalTok{()}

\NormalTok{ax }\OperatorTok{=}\NormalTok{ daily\_mean.plot(marker}\OperatorTok{=}\StringTok{"o"}\NormalTok{, label}\OperatorTok{=}\StringTok{"Tagesmittel"}\NormalTok{)}
\NormalTok{daily\_max.plot(ax}\OperatorTok{=}\NormalTok{ax, marker}\OperatorTok{=}\StringTok{"o"}\NormalTok{, label}\OperatorTok{=}\StringTok{"Tagesmaximum"}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.title(}\StringTok{"Downsampling: Stunden → Tage"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/03-resampling-alignment_files/figure-pdf/cell-3-output-1.png}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Entscheidungshilfe}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{itemize}
\tightlist
\item
  Mittelwert → glättet Schwankungen\\
\item
  Maximum → zeigt Extremwerte\\
\item
  Summe → sinnvoll bei Mengen (z.\,B. Energieverbrauch)
\end{itemize}

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{3.3 Upsampling (Interpolation)}\label{upsampling-interpolation}

Wir erhöhen die zeitliche Auflösung.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y\_2h }\OperatorTok{=}\NormalTok{ y.resample(}\StringTok{"2H"}\NormalTok{).mean()}
\NormalTok{y\_up }\OperatorTok{=}\NormalTok{ y\_2h.resample(}\StringTok{"H"}\NormalTok{).interpolate(}\StringTok{"time"}\NormalTok{)}

\NormalTok{ax }\OperatorTok{=}\NormalTok{ y\_2h.plot(marker}\OperatorTok{=}\StringTok{"o"}\NormalTok{, label}\OperatorTok{=}\StringTok{"2H (aggregiert)"}\NormalTok{)}
\NormalTok{y\_up.plot(ax}\OperatorTok{=}\NormalTok{ax, alpha}\OperatorTok{=}\FloatTok{0.7}\NormalTok{, label}\OperatorTok{=}\StringTok{"Interpoliert auf 1H"}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.title(}\StringTok{"Upsampling mit Interpolation"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_21203/2179676712.py:1: FutureWarning: 'H' is deprecated and will be removed in a future version, please use 'h' instead.
  y_2h = y.resample("2H").mean()
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_21203/2179676712.py:2: FutureWarning: 'H' is deprecated and will be removed in a future version, please use 'h' instead.
  y_up = y_2h.resample("H").interpolate("time")
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/03-resampling-alignment_files/figure-pdf/cell-4-output-2.png}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-warning-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame, coltitle=black, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Achtung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Interpolation erzeugt keine neuen Messinformationen, sondern modelliert
einen plausiblen Verlauf.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{3.4 Alignment zweier
Zeitreihen}\label{alignment-zweier-zeitreihen}

Zwei Zeitreihen mit unterschiedlicher Abtastrate:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t2 }\OperatorTok{=}\NormalTok{ pd.date\_range(}\StringTok{"2025{-}01{-}01"}\NormalTok{, periods}\OperatorTok{=}\DecValTok{24}\OperatorTok{*}\DecValTok{5}\NormalTok{, freq}\OperatorTok{=}\StringTok{"2H"}\NormalTok{)}
\NormalTok{y2 }\OperatorTok{=}\NormalTok{ pd.Series(}\DecValTok{5} \OperatorTok{+}\NormalTok{ rng.normal(size}\OperatorTok{=}\BuiltInTok{len}\NormalTok{(t2)), index}\OperatorTok{=}\NormalTok{t2, name}\OperatorTok{=}\StringTok{"signal2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_21203/3177252539.py:1: FutureWarning: 'H' is deprecated and will be removed in a future version, please use 'h' instead.
  t2 = pd.date_range("2025-01-01", periods=24*5, freq="2H")
\end{verbatim}

Zur gemeinsamen Analyse müssen beide Reihen dieselbe Frequenz haben.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y2\_aligned }\OperatorTok{=}\NormalTok{ y2.resample(}\StringTok{"H"}\NormalTok{).interpolate(}\StringTok{"time"}\NormalTok{)}

\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.concat([y, y2\_aligned], axis}\OperatorTok{=}\DecValTok{1}\NormalTok{)}

\NormalTok{df.plot(title}\OperatorTok{=}\StringTok{"Aligned Time Series"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_21203/1233815767.py:1: FutureWarning: 'H' is deprecated and will be removed in a future version, please use 'h' instead.
  y2_aligned = y2.resample("H").interpolate("time")
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/03-resampling-alignment_files/figure-pdf/cell-6-output-2.png}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Merke}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Alignment bedeutet: - gleiche Frequenz - gleicher Zeitbereich - gleiche
Zeitzone

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{3.5 Häufige Fehlerquellen}\label{huxe4ufige-fehlerquellen}

\begin{itemize}
\tightlist
\item
  Vergleiche ohne vorheriges Resampling
\item
  Mischung von lokaler Zeit und UTC
\item
  Aggregation ohne Berücksichtigung der Datentypen (z.\,B. Summe vs
  Mittelwert)
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{3.6 Mini-Aufgabe}\label{mini-aufgabe-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Erzeugen Sie eine minütliche Zeitreihe über 2 Tage.
\item
  Aggregieren Sie auf Stundenmittel.
\item
  Vergleichen Sie visuell:

  \begin{itemize}
  \tightlist
  \item
    Original
  \item
    Stundenmittel
  \end{itemize}
\item
  Interpretieren Sie den Informationsverlust.
\end{enumerate}

\chapter{4 Glättung \&
Rauschreduktion}\label{gluxe4ttung-rauschreduktion}

\chapter{4 Glättung \&
Rauschreduktion}\label{gluxe4ttung-rauschreduktion-1}

Glättung ist eine der wichtigsten Standardmethoden in der
Zeitreihenanalyse. Sie hilft dabei,

\begin{itemize}
\tightlist
\item
  Rauschen zu reduzieren,
\item
  Trend/Saison besser sichtbar zu machen,
\item
  eine \textbf{Baseline} zu definieren (z.\,B. für Anomalien).
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Merke}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Die Fensterbreite ist eine methodische Entscheidung: Sie sollte zur
\textbf{Zeitskala der Fragestellung} passen.

\end{tcolorbox}

\section{4.1 Beispielsignal}\label{beispielsignal}

Wir nutzen eine Zeitreihe mit Tagesmuster, Rauschen und einzelnen
Ausreißern.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{rng }\OperatorTok{=}\NormalTok{ np.random.default\_rng(}\DecValTok{42}\NormalTok{)}

\NormalTok{t }\OperatorTok{=}\NormalTok{ pd.date\_range(}\StringTok{"2025{-}01{-}01"}\NormalTok{, periods}\OperatorTok{=}\DecValTok{24}\OperatorTok{*}\DecValTok{10}\NormalTok{, freq}\OperatorTok{=}\StringTok{"H"}\NormalTok{)  }\CommentTok{\# 10 Tage stündlich}
\NormalTok{trend }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\BuiltInTok{len}\NormalTok{(t))}
\NormalTok{season }\OperatorTok{=} \FloatTok{0.9} \OperatorTok{*}\NormalTok{ np.sin(}\DecValTok{2}\OperatorTok{*}\NormalTok{np.pi}\OperatorTok{*}\NormalTok{(t.hour)}\OperatorTok{/}\DecValTok{24}\NormalTok{)}
\NormalTok{noise }\OperatorTok{=} \FloatTok{0.35} \OperatorTok{*}\NormalTok{ rng.normal(size}\OperatorTok{=}\BuiltInTok{len}\NormalTok{(t))}

\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.Series(}\DecValTok{10} \OperatorTok{+}\NormalTok{ trend }\OperatorTok{+}\NormalTok{ season }\OperatorTok{+}\NormalTok{ noise, index}\OperatorTok{=}\NormalTok{t, name}\OperatorTok{=}\StringTok{"signal"}\NormalTok{)}

\CommentTok{\# Ausreißer}
\NormalTok{s.iloc[}\DecValTok{30}\NormalTok{] }\OperatorTok{+=} \FloatTok{3.0}
\NormalTok{s.iloc[}\DecValTok{120}\NormalTok{] }\OperatorTok{{-}=} \FloatTok{2.5}

\NormalTok{s.plot(title}\OperatorTok{=}\StringTok{"Beispielsignal (roh)"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_21258/3372949856.py:7: FutureWarning: 'H' is deprecated and will be removed in a future version, please use 'h' instead.
  t = pd.date_range("2025-01-01", periods=24*10, freq="H")  # 10 Tage stündlich
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/04-glaettung_files/figure-pdf/cell-2-output-2.png}}

\section{4.2 Rolling Mean (gleitender
Mittelwert)}\label{rolling-mean-gleitender-mittelwert}

Rolling Mean ist die klassische Glättung: Mittelwert über ein Fenster.

\section{Pandas (empfohlen)}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{roll\_6h }\OperatorTok{=}\NormalTok{ s.rolling(}\StringTok{"6H"}\NormalTok{).mean()}
\NormalTok{roll\_24h }\OperatorTok{=}\NormalTok{ s.rolling(}\StringTok{"24H"}\NormalTok{).mean()}

\NormalTok{ax }\OperatorTok{=}\NormalTok{ s.plot(alpha}\OperatorTok{=}\FloatTok{0.45}\NormalTok{, label}\OperatorTok{=}\StringTok{"Signal"}\NormalTok{)}
\NormalTok{roll\_6h.plot(ax}\OperatorTok{=}\NormalTok{ax, label}\OperatorTok{=}\StringTok{"Rolling 6H"}\NormalTok{)}
\NormalTok{roll\_24h.plot(ax}\OperatorTok{=}\NormalTok{ax, label}\OperatorTok{=}\StringTok{"Rolling 24H"}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.title(}\StringTok{"Rolling Mean (Pandas)"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_21258/1470441625.py:1: FutureWarning: 'H' is deprecated and will be removed in a future version, please use 'h' instead.
  roll_6h = s.rolling("6H").mean()
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_21258/1470441625.py:2: FutureWarning: 'H' is deprecated and will be removed in a future version, please use 'h' instead.
  roll_24h = s.rolling("24H").mean()
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/04-glaettung_files/figure-pdf/cell-3-output-2.png}}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Entscheidungshilfe}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\begin{itemize}
\tightlist
\item
  \textbf{6H}: reduziert kurzfristiges Rauschen, Ereignisse bleiben
  sichtbar\\
\item
  \textbf{24H}: zeigt eher Grundniveau/Trend, dämpft Tagesmuster stark\\
\end{itemize}

\end{tcolorbox}

\section{NumPy (Prinzip)}

NumPy-Variante: Moving Average als Faltung (\texttt{convolve}).

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{y }\OperatorTok{=}\NormalTok{ s.to\_numpy()}

\KeywordTok{def}\NormalTok{ moving\_average(y, window):}
\NormalTok{    kernel }\OperatorTok{=}\NormalTok{ np.ones(window) }\OperatorTok{/}\NormalTok{ window}
    \ControlFlowTok{return}\NormalTok{ np.convolve(y, kernel, mode}\OperatorTok{=}\StringTok{"same"}\NormalTok{)}

\NormalTok{ma\_6 }\OperatorTok{=}\NormalTok{ moving\_average(y, }\DecValTok{6}\NormalTok{)}
\NormalTok{ma\_24 }\OperatorTok{=}\NormalTok{ moving\_average(y, }\DecValTok{24}\NormalTok{)}

\NormalTok{plt.plot(y, alpha}\OperatorTok{=}\FloatTok{0.45}\NormalTok{, label}\OperatorTok{=}\StringTok{"Signal"}\NormalTok{)}
\NormalTok{plt.plot(ma\_6, label}\OperatorTok{=}\StringTok{"MA 6 Samples"}\NormalTok{)}
\NormalTok{plt.plot(ma\_24, label}\OperatorTok{=}\StringTok{"MA 24 Samples"}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.title(}\StringTok{"Moving Average (NumPy)"}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{"Sample"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"Wert"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/04-glaettung_files/figure-pdf/cell-4-output-1.png}}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-warning-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame, coltitle=black, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Achtung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Bei der Faltung müssen Sie Randbehandlung bewusst akzeptieren (hier:
\texttt{mode="same"}). Pandas behandelt Randbereiche konsistent mit
\texttt{min\_periods} und NaNs.

\end{tcolorbox}

\section{4.3 EWMA (Exponentially Weighted Moving
Average)}\label{ewma-exponentially-weighted-moving-average}

EWMA glättet, gewichtet aber \textbf{neuere Werte stärker}.

\section{Pandas (empfohlen)}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ewm\_fast }\OperatorTok{=}\NormalTok{ s.ewm(span}\OperatorTok{=}\DecValTok{6}\NormalTok{, adjust}\OperatorTok{=}\VariableTok{False}\NormalTok{).mean()}
\NormalTok{ewm\_slow }\OperatorTok{=}\NormalTok{ s.ewm(span}\OperatorTok{=}\DecValTok{24}\NormalTok{, adjust}\OperatorTok{=}\VariableTok{False}\NormalTok{).mean()}

\NormalTok{ax }\OperatorTok{=}\NormalTok{ s.plot(alpha}\OperatorTok{=}\FloatTok{0.45}\NormalTok{, label}\OperatorTok{=}\StringTok{"Signal"}\NormalTok{)}
\NormalTok{ewm\_fast.plot(ax}\OperatorTok{=}\NormalTok{ax, label}\OperatorTok{=}\StringTok{"EWMA span=6"}\NormalTok{)}
\NormalTok{ewm\_slow.plot(ax}\OperatorTok{=}\NormalTok{ax, label}\OperatorTok{=}\StringTok{"EWMA span=24"}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.title(}\StringTok{"EWMA (Pandas)"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/04-glaettung_files/figure-pdf/cell-5-output-1.png}}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Merke}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

EWMA reagiert schneller auf Änderungen als Rolling Mean, weil ältere
Werte exponentiell weniger Einfluss haben.

\end{tcolorbox}

\section{NumPy (Prinzip)}

EWMA kann rekursiv berechnet werden:

{[} m\_t = \alpha \cdot y\_t + (1-\alpha)\cdot m\_\{t-1\} {]}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{y }\OperatorTok{=}\NormalTok{ s.to\_numpy()}

\KeywordTok{def}\NormalTok{ ewma(y, alpha):}
\NormalTok{    m }\OperatorTok{=}\NormalTok{ np.empty\_like(y, dtype}\OperatorTok{=}\BuiltInTok{float}\NormalTok{)}
\NormalTok{    m[}\DecValTok{0}\NormalTok{] }\OperatorTok{=}\NormalTok{ y[}\DecValTok{0}\NormalTok{]}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\BuiltInTok{len}\NormalTok{(y)):}
\NormalTok{        m[i] }\OperatorTok{=}\NormalTok{ alpha }\OperatorTok{*}\NormalTok{ y[i] }\OperatorTok{+}\NormalTok{ (}\DecValTok{1} \OperatorTok{{-}}\NormalTok{ alpha) }\OperatorTok{*}\NormalTok{ m[i}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
    \ControlFlowTok{return}\NormalTok{ m}

\NormalTok{m\_fast }\OperatorTok{=}\NormalTok{ ewma(y, alpha}\OperatorTok{=}\FloatTok{0.30}\NormalTok{)}
\NormalTok{m\_slow }\OperatorTok{=}\NormalTok{ ewma(y, alpha}\OperatorTok{=}\FloatTok{0.08}\NormalTok{)}

\NormalTok{plt.plot(y, alpha}\OperatorTok{=}\FloatTok{0.45}\NormalTok{, label}\OperatorTok{=}\StringTok{"Signal"}\NormalTok{)}
\NormalTok{plt.plot(m\_fast, label}\OperatorTok{=}\StringTok{"EWMA alpha=0.30"}\NormalTok{)}
\NormalTok{plt.plot(m\_slow, label}\OperatorTok{=}\StringTok{"EWMA alpha=0.08"}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.title(}\StringTok{"EWMA (NumPy)"}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{"Sample"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"Wert"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/04-glaettung_files/figure-pdf/cell-6-output-1.png}}

\section{4.4 Methodische Wahl: welches Verfahren
wann?}\label{methodische-wahl-welches-verfahren-wann}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Entscheidungshilfe}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\textbf{Rolling Mean} eignet sich gut, wenn\ldots{}\\
- Sie ein klar definiertes Zeitfenster mitteln wollen (z.\,B. „letzte
24h``).

\textbf{EWMA} eignet sich gut, wenn\ldots{}\\
- Sie eine smoothe Baseline wollen, die schneller auf Änderungen
reagiert.\\
- Sie Anomalien als Abweichung von einer dynamischen Baseline erkennen
möchten.

\end{tcolorbox}

\section{4.5 Mini-Aufgaben}\label{mini-aufgaben}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Fensterwahl:} Testen Sie Rolling-Fenster von 3H, 12H, 48H.

  \begin{itemize}
  \tightlist
  \item
    Welche Strukturen werden jeweils sichtbar bzw. verschwinden?
  \end{itemize}
\item
  \textbf{Anomalien \& Glättung:} Erhöhen Sie die Ausreißer-Amplitude.

  \begin{itemize}
  \tightlist
  \item
    Ab welcher Glättungsstärke „verschwindet`` der Ausreißer im
    geglätteten Signal?
  \end{itemize}
\item
  \textbf{EWMA-Empfindlichkeit:} Variieren Sie \texttt{span} (Pandas)
  bzw. \texttt{alpha} (NumPy).

  \begin{itemize}
  \tightlist
  \item
    Welche Parameter reagieren „schnell``, welche „träge``? Begründen
    Sie.
  \end{itemize}
\end{enumerate}

\chapter{5 Trend \& Saison}\label{trend-saison}

\chapter{5 Trend \& Saison}\label{trend-saison-1}

Viele Zeitreihen enthalten systematische Strukturen:

\begin{itemize}
\tightlist
\item
  \textbf{Trend}: langfristige Entwicklung (steigend/fallend)
\item
  \textbf{Saison}: periodisch wiederkehrendes Muster
\item
  \textbf{Residuum}: verbleibende Schwankung
\end{itemize}

Diese Zerlegung ist ein \textbf{Denkmodell}, das hilft, Struktur
systematisch zu analysieren.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Merke}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Trend beschreibt eine langsame Veränderung, Saison beschreibt eine
regelmäßige Wiederholung.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{5.1 Beispielsignal}\label{beispielsignal-1}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{rng }\OperatorTok{=}\NormalTok{ np.random.default\_rng(}\DecValTok{10}\NormalTok{)}

\NormalTok{t }\OperatorTok{=}\NormalTok{ pd.date\_range(}\StringTok{"2025{-}01{-}01"}\NormalTok{, periods}\OperatorTok{=}\DecValTok{24}\OperatorTok{*}\DecValTok{14}\NormalTok{, freq}\OperatorTok{=}\StringTok{"H"}\NormalTok{)}
\NormalTok{trend }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{4}\NormalTok{, }\BuiltInTok{len}\NormalTok{(t))}
\NormalTok{season }\OperatorTok{=} \FloatTok{1.2} \OperatorTok{*}\NormalTok{ np.sin(}\DecValTok{2}\OperatorTok{*}\NormalTok{np.pi}\OperatorTok{*}\NormalTok{(t.hour)}\OperatorTok{/}\DecValTok{24}\NormalTok{)}
\NormalTok{noise }\OperatorTok{=} \FloatTok{0.4} \OperatorTok{*}\NormalTok{ rng.normal(size}\OperatorTok{=}\BuiltInTok{len}\NormalTok{(t))}

\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.Series(}\DecValTok{20} \OperatorTok{+}\NormalTok{ trend }\OperatorTok{+}\NormalTok{ season }\OperatorTok{+}\NormalTok{ noise, index}\OperatorTok{=}\NormalTok{t, name}\OperatorTok{=}\StringTok{"signal"}\NormalTok{)}

\NormalTok{s.plot(title}\OperatorTok{=}\StringTok{"Signal mit Trend und Tages{-}Saison"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_21317/1321060591.py:7: FutureWarning: 'H' is deprecated and will be removed in a future version, please use 'h' instead.
  t = pd.date_range("2025-01-01", periods=24*14, freq="H")
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/05-trend-saison_files/figure-pdf/cell-2-output-2.png}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{5.2 Saison sichtbar machen}\label{saison-sichtbar-machen}

\subsection{Mittelwert pro Stunde}\label{mittelwert-pro-stunde}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{season\_hour }\OperatorTok{=}\NormalTok{ s.groupby(s.index.hour).mean()}

\NormalTok{season\_hour.plot(marker}\OperatorTok{=}\StringTok{"o"}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{"Durchschnittlicher Tagesverlauf (0–23h)"}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{"Stunde"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"Mittelwert"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/05-trend-saison_files/figure-pdf/cell-3-output-1.png}}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Interpretation}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Ein periodisches Muster in dieser Darstellung deutet auf Tages-Saison
hin.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{5.3 Trend schätzen (starke
Glättung)}\label{trend-schuxe4tzen-starke-gluxe4ttung}

\section{Pandas}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trend\_est }\OperatorTok{=}\NormalTok{ s.rolling(}\StringTok{"72H"}\NormalTok{).mean()}

\NormalTok{ax }\OperatorTok{=}\NormalTok{ s.plot(alpha}\OperatorTok{=}\FloatTok{0.4}\NormalTok{, label}\OperatorTok{=}\StringTok{"Signal"}\NormalTok{)}
\NormalTok{trend\_est.plot(ax}\OperatorTok{=}\NormalTok{ax, linewidth}\OperatorTok{=}\DecValTok{2}\NormalTok{, label}\OperatorTok{=}\StringTok{"Trend (Rolling 72H)"}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.title(}\StringTok{"Trend{-}Schätzung"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_21317/1951088130.py:1: FutureWarning: 'H' is deprecated and will be removed in a future version, please use 'h' instead.
  trend_est = s.rolling("72H").mean()
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/05-trend-saison_files/figure-pdf/cell-4-output-2.png}}

\section{NumPy (Prinzip)}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\NormalTok{y }\OperatorTok{=}\NormalTok{ s.to\_numpy()}

\KeywordTok{def}\NormalTok{ moving\_average(y, window):}
\NormalTok{    kernel }\OperatorTok{=}\NormalTok{ np.ones(window) }\OperatorTok{/}\NormalTok{ window}
    \ControlFlowTok{return}\NormalTok{ np.convolve(y, kernel, mode}\OperatorTok{=}\StringTok{"same"}\NormalTok{)}

\NormalTok{trend\_np }\OperatorTok{=}\NormalTok{ moving\_average(y, }\DecValTok{72}\NormalTok{)}

\NormalTok{plt.plot(y, alpha}\OperatorTok{=}\FloatTok{0.4}\NormalTok{, label}\OperatorTok{=}\StringTok{"Signal"}\NormalTok{)}
\NormalTok{plt.plot(trend\_np, linewidth}\OperatorTok{=}\DecValTok{2}\NormalTok{, label}\OperatorTok{=}\StringTok{"Trend (MA 72)"}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.title(}\StringTok{"Trend{-}Schätzung (NumPy)"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/05-trend-saison_files/figure-pdf/cell-5-output-1.png}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{5.4 Residuum berechnen (vereinfachte
Zerlegung)}\label{residuum-berechnen-vereinfachte-zerlegung}

Wir entfernen Trend und Saison grob:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{season\_map }\OperatorTok{=}\NormalTok{ s.index.hour.}\BuiltInTok{map}\NormalTok{(season\_hour)}
\NormalTok{residual }\OperatorTok{=}\NormalTok{ s }\OperatorTok{{-}}\NormalTok{ trend\_est }\OperatorTok{{-}}\NormalTok{ season\_map}

\NormalTok{residual.plot(title}\OperatorTok{=}\StringTok{"Residuum (vereinfachte Zerlegung)"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/05-trend-saison_files/figure-pdf/cell-6-output-1.png}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-warning-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame, coltitle=black, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Achtung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Diese Zerlegung ist didaktisch vereinfacht. In der Praxis existieren
robustere Verfahren (z. B. STL). Hier geht es um das Prinzip.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{5.5 Additives vs Multiplikatives
Modell}\label{additives-vs-multiplikatives-modell}

Additives Modell:

Signal = Trend + Saison + Rauschen

Multiplikatives Modell:

Signal = Trend × Saison × Rauschen

Multiplikative Modelle sind sinnvoll, wenn die Amplitude der Saison mit
dem Niveau wächst.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{5.6 Mini-Aufgaben}\label{mini-aufgaben-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Erhöhen Sie die Trendsteigung.

  \begin{itemize}
  \tightlist
  \item
    Wie beeinflusst das die Erkennung der Saison?
  \end{itemize}
\item
  Erzeugen Sie eine Wochen-Saison (Periodenlänge 7 Tage).

  \begin{itemize}
  \tightlist
  \item
    Wie würden Sie diese sichtbar machen?
  \end{itemize}
\item
  Testen Sie ein sehr großes Rolling-Fenster (z. B. 120H).

  \begin{itemize}
  \tightlist
  \item
    Welche Struktur bleibt übrig?
  \end{itemize}
\end{enumerate}

\chapter{6 Lags \& Autokorrelation}\label{lags-autokorrelation}

\chapter{6 Lags \& Autokorrelation}\label{lags-autokorrelation-1}

Zeitreihen unterscheiden sich von klassischen Datensätzen, weil
Beobachtungen \textbf{nicht unabhängig} sind.

Der Wert zum Zeitpunkt t hängt häufig von vorherigen Werten ab.

Diese zeitliche Abhängigkeit untersuchen wir mit:

\begin{itemize}
\tightlist
\item
  \textbf{Lags}
\item
  \textbf{Autokorrelation}
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Merke}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Zeitliche Abhängigkeit ist eine zentrale Eigenschaft von Zeitreihen.
Ohne sie gäbe es keine sinnvolle Prognose.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{6.1 Beispielsignal}\label{beispielsignal-2}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{rng }\OperatorTok{=}\NormalTok{ np.random.default\_rng(}\DecValTok{21}\NormalTok{)}

\NormalTok{t }\OperatorTok{=}\NormalTok{ pd.date\_range(}\StringTok{"2025{-}01{-}01"}\NormalTok{, periods}\OperatorTok{=}\DecValTok{24}\OperatorTok{*}\DecValTok{14}\NormalTok{, freq}\OperatorTok{=}\StringTok{"H"}\NormalTok{)}
\NormalTok{trend }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\BuiltInTok{len}\NormalTok{(t))}
\NormalTok{season }\OperatorTok{=} \FloatTok{0.8} \OperatorTok{*}\NormalTok{ np.sin(}\DecValTok{2}\OperatorTok{*}\NormalTok{np.pi}\OperatorTok{*}\NormalTok{(t.hour)}\OperatorTok{/}\DecValTok{24}\NormalTok{)}
\NormalTok{noise }\OperatorTok{=} \FloatTok{0.4} \OperatorTok{*}\NormalTok{ rng.normal(size}\OperatorTok{=}\BuiltInTok{len}\NormalTok{(t))}

\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.Series(}\DecValTok{15} \OperatorTok{+}\NormalTok{ trend }\OperatorTok{+}\NormalTok{ season }\OperatorTok{+}\NormalTok{ noise, index}\OperatorTok{=}\NormalTok{t, name}\OperatorTok{=}\StringTok{"signal"}\NormalTok{)}

\NormalTok{s.plot(title}\OperatorTok{=}\StringTok{"Beispielsignal"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_21355/1570465617.py:7: FutureWarning: 'H' is deprecated and will be removed in a future version, please use 'h' instead.
  t = pd.date_range("2025-01-01", periods=24*14, freq="H")
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/06-lags-autokorrelation_files/figure-pdf/cell-2-output-2.png}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{6.2 Lag-Features}\label{lag-features}

Ein Lag verschiebt die Zeitreihe nach hinten.

\section{Pandas}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lag\_1h }\OperatorTok{=}\NormalTok{ s.shift(}\DecValTok{1}\NormalTok{)}
\NormalTok{lag\_24h }\OperatorTok{=}\NormalTok{ s.shift(}\DecValTok{24}\NormalTok{)}

\NormalTok{df\_lags }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}
    \StringTok{"y"}\NormalTok{: s,}
    \StringTok{"lag\_1h"}\NormalTok{: lag\_1h,}
    \StringTok{"lag\_24h"}\NormalTok{: lag\_24h}
\NormalTok{\})}

\NormalTok{df\_lags.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
& y & lag\_1h & lag\_24h \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
2025-01-01 00:00:00 & 15.143509 & NaN & NaN \\
2025-01-01 01:00:00 & 15.817296 & 15.143509 & NaN \\
2025-01-01 02:00:00 & 14.697408 & 15.817296 & NaN \\
2025-01-01 03:00:00 & 16.258241 & 14.697408 & NaN \\
2025-01-01 04:00:00 & 15.697774 & 16.258241 & NaN \\
\end{longtable}

\section{NumPy (Prinzip)}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OperatorTok{=}\NormalTok{ s.to\_numpy()}

\NormalTok{lag1 }\OperatorTok{=}\NormalTok{ np.roll(y, }\DecValTok{1}\NormalTok{)}
\NormalTok{lag24 }\OperatorTok{=}\NormalTok{ np.roll(y, }\DecValTok{24}\NormalTok{)}

\NormalTok{lag1[}\DecValTok{0}\NormalTok{] }\OperatorTok{=}\NormalTok{ np.nan}
\NormalTok{lag24[:}\DecValTok{24}\NormalTok{] }\OperatorTok{=}\NormalTok{ np.nan}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Interpretation}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Ein hoher Zusammenhang zwischen y(t) und y(t-24) deutet auf eine
Tagesperiodik hin.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{6.3 Autokorrelation berechnen}\label{autokorrelation-berechnen}

Autokorrelation misst die Korrelation zwischen y(t) und y(t-k).

\section{Pandas}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lags }\OperatorTok{=} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{49}\NormalTok{)}
\NormalTok{ac }\OperatorTok{=}\NormalTok{ [s.corr(s.shift(k)) }\ControlFlowTok{for}\NormalTok{ k }\KeywordTok{in}\NormalTok{ lags]}

\NormalTok{plt.stem(}\BuiltInTok{list}\NormalTok{(lags), ac)}
\NormalTok{plt.title(}\StringTok{"Autokorrelation (1–48 Stunden)"}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{"Lag (h)"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"Korrelation"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/06-lags-autokorrelation_files/figure-pdf/cell-5-output-1.png}}

\section{NumPy (Prinzip)}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\NormalTok{y }\OperatorTok{=}\NormalTok{ s.to\_numpy()}
\NormalTok{y }\OperatorTok{=}\NormalTok{ y }\OperatorTok{{-}}\NormalTok{ np.nanmean(y)}

\KeywordTok{def}\NormalTok{ autocorr(y, k):}
    \ControlFlowTok{return}\NormalTok{ np.corrcoef(y[:}\OperatorTok{{-}}\NormalTok{k], y[k:])[}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{]}

\NormalTok{lags }\OperatorTok{=} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{49}\NormalTok{)}
\NormalTok{ac\_np }\OperatorTok{=}\NormalTok{ [autocorr(y, k) }\ControlFlowTok{for}\NormalTok{ k }\KeywordTok{in}\NormalTok{ lags]}

\NormalTok{plt.stem(}\BuiltInTok{list}\NormalTok{(lags), ac\_np)}
\NormalTok{plt.title(}\StringTok{"Autokorrelation (NumPy)"}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{"Lag"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{"Korrelation"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/06-lags-autokorrelation_files/figure-pdf/cell-6-output-1.png}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{6.4 Interpretation der
Autokorrelation}\label{interpretation-der-autokorrelation}

Typische Muster:

\begin{itemize}
\tightlist
\item
  Langsam abfallende Kurve → starker Trend
\item
  Periodische Peaks (z. B. bei 24, 48, 72) → Saison
\item
  Schneller Abfall gegen 0 → schwache Abhängigkeit
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-warning-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame, coltitle=black, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Achtung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Trend kann Autokorrelation künstlich erhöhen. Gegebenenfalls zuerst
detrenden oder differenzieren.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{6.5 Mini-Aufgaben}\label{mini-aufgaben-2}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Entfernen Sie den Trend (z. B. durch Rolling Mean).

  \begin{itemize}
  \tightlist
  \item
    Wie verändert sich die Autokorrelation?
  \end{itemize}
\item
  Erzeugen Sie eine Zeitreihe ohne Saison.

  \begin{itemize}
  \tightlist
  \item
    Wie sieht die Autokorrelationsfunktion aus?
  \end{itemize}
\item
  Erzeugen Sie reine Zufallsdaten.

  \begin{itemize}
  \tightlist
  \item
    Was erwarten Sie?
  \end{itemize}
\end{enumerate}

\chapter{7 Anomalien}\label{anomalien}

\chapter{7 Anomalien}\label{anomalien-1}

Anomalien sind Beobachtungen, die deutlich vom erwarteten Verhalten
abweichen.

In Zeitreihen bedeutet das:

\begin{itemize}
\tightlist
\item
  starke Abweichung vom Trend
\item
  starke Abweichung von saisonalem Muster
\item
  plötzliche Strukturbrüche
\end{itemize}

Wichtig ist: Anomalien sind \textbf{kontextabhängig}.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Merke}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Eine Anomalie ist keine rein statistische Eigenschaft. Sie ist eine
Abweichung vom erwarteten Prozessverhalten.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{7.1 Beispielsignal mit
Ausreißern}\label{beispielsignal-mit-ausreiuxdfern}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{rng }\OperatorTok{=}\NormalTok{ np.random.default\_rng(}\DecValTok{99}\NormalTok{)}

\NormalTok{t }\OperatorTok{=}\NormalTok{ pd.date\_range(}\StringTok{"2025{-}01{-}01"}\NormalTok{, periods}\OperatorTok{=}\DecValTok{24}\OperatorTok{*}\DecValTok{10}\NormalTok{, freq}\OperatorTok{=}\StringTok{"H"}\NormalTok{)}
\NormalTok{trend }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\BuiltInTok{len}\NormalTok{(t))}
\NormalTok{season }\OperatorTok{=} \FloatTok{0.8} \OperatorTok{*}\NormalTok{ np.sin(}\DecValTok{2}\OperatorTok{*}\NormalTok{np.pi}\OperatorTok{*}\NormalTok{(t.hour)}\OperatorTok{/}\DecValTok{24}\NormalTok{)}
\NormalTok{noise }\OperatorTok{=} \FloatTok{0.3} \OperatorTok{*}\NormalTok{ rng.normal(size}\OperatorTok{=}\BuiltInTok{len}\NormalTok{(t))}

\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.Series(}\DecValTok{10} \OperatorTok{+}\NormalTok{ trend }\OperatorTok{+}\NormalTok{ season }\OperatorTok{+}\NormalTok{ noise, index}\OperatorTok{=}\NormalTok{t, name}\OperatorTok{=}\StringTok{"signal"}\NormalTok{)}

\CommentTok{\# künstliche Anomalien}
\NormalTok{s.iloc[}\DecValTok{40}\NormalTok{] }\OperatorTok{+=} \DecValTok{4}
\NormalTok{s.iloc[}\DecValTok{120}\NormalTok{] }\OperatorTok{{-}=} \DecValTok{3}

\NormalTok{s.plot(title}\OperatorTok{=}\StringTok{"Signal mit Anomalien"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_21411/2246874237.py:7: FutureWarning: 'H' is deprecated and will be removed in a future version, please use 'h' instead.
  t = pd.date_range("2025-01-01", periods=24*10, freq="H")
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/07-anomalien_files/figure-pdf/cell-2-output-2.png}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{7.2 Globale Z-Score Methode}\label{globale-z-score-methode}

Wir standardisieren die gesamte Zeitreihe.

\section{Pandas}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OperatorTok{=}\NormalTok{ (s }\OperatorTok{{-}}\NormalTok{ s.mean()) }\OperatorTok{/}\NormalTok{ s.std()}
\NormalTok{anomalies }\OperatorTok{=}\NormalTok{ s[}\BuiltInTok{abs}\NormalTok{(z) }\OperatorTok{\textgreater{}} \DecValTok{3}\NormalTok{]}

\NormalTok{ax }\OperatorTok{=}\NormalTok{ s.plot(label}\OperatorTok{=}\StringTok{"Signal"}\NormalTok{)}
\NormalTok{anomalies.plot(ax}\OperatorTok{=}\NormalTok{ax, linestyle}\OperatorTok{=}\StringTok{"None"}\NormalTok{, marker}\OperatorTok{=}\StringTok{"o"}\NormalTok{, label}\OperatorTok{=}\StringTok{"Anomalie"}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.title(}\StringTok{"Anomalien (Z{-}Score)"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/07-anomalien_files/figure-pdf/cell-3-output-1.png}}

\section{NumPy}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OperatorTok{=}\NormalTok{ s.to\_numpy()}

\NormalTok{z\_np }\OperatorTok{=}\NormalTok{ (y }\OperatorTok{{-}}\NormalTok{ np.mean(y)) }\OperatorTok{/}\NormalTok{ np.std(y)}
\NormalTok{anomalies\_idx }\OperatorTok{=}\NormalTok{ np.where(np.}\BuiltInTok{abs}\NormalTok{(z\_np) }\OperatorTok{\textgreater{}} \DecValTok{3}\NormalTok{)[}\DecValTok{0}\NormalTok{]}

\NormalTok{plt.plot(y, label}\OperatorTok{=}\StringTok{"Signal"}\NormalTok{)}
\NormalTok{plt.scatter(anomalies\_idx, y[anomalies\_idx], label}\OperatorTok{=}\StringTok{"Anomalie"}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.title(}\StringTok{"Anomalien (NumPy Z{-}Score)"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/07-anomalien_files/figure-pdf/cell-4-output-1.png}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-warning-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame, coltitle=black, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Achtung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Z-Score funktioniert schlecht bei starkem Trend oder Saison, weil
globale Mittelwerte verzerren.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{7.3 Lokale Anomalie (Baseline +
Residuum)}\label{lokale-anomalie-baseline-residuum}

Statt globaler Standardisierung definieren wir eine lokale Baseline.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{baseline }\OperatorTok{=}\NormalTok{ s.ewm(span}\OperatorTok{=}\DecValTok{24}\NormalTok{, adjust}\OperatorTok{=}\VariableTok{False}\NormalTok{).mean()}
\NormalTok{residual }\OperatorTok{=}\NormalTok{ s }\OperatorTok{{-}}\NormalTok{ baseline}

\NormalTok{score }\OperatorTok{=}\NormalTok{ (residual }\OperatorTok{{-}}\NormalTok{ residual.mean()) }\OperatorTok{/}\NormalTok{ residual.std()}
\NormalTok{anomalies\_local }\OperatorTok{=}\NormalTok{ s[}\BuiltInTok{abs}\NormalTok{(score) }\OperatorTok{\textgreater{}} \DecValTok{3}\NormalTok{]}

\NormalTok{ax }\OperatorTok{=}\NormalTok{ s.plot(alpha}\OperatorTok{=}\FloatTok{0.6}\NormalTok{, label}\OperatorTok{=}\StringTok{"Signal"}\NormalTok{)}
\NormalTok{baseline.plot(ax}\OperatorTok{=}\NormalTok{ax, label}\OperatorTok{=}\StringTok{"Baseline"}\NormalTok{)}
\NormalTok{anomalies\_local.plot(ax}\OperatorTok{=}\NormalTok{ax, linestyle}\OperatorTok{=}\StringTok{"None"}\NormalTok{, marker}\OperatorTok{=}\StringTok{"o"}\NormalTok{, label}\OperatorTok{=}\StringTok{"Anomalie"}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.title(}\StringTok{"Lokale Anomalien (EWMA{-}Baseline)"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/07-anomalien_files/figure-pdf/cell-5-output-1.png}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Interpretation}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Lokale Verfahren sind robuster, wenn Trend oder Saison vorhanden sind.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{7.4
Rolling-Standardabweichung}\label{rolling-standardabweichung}

Anomalien können auch als starke Abweichung relativ zur lokalen Varianz
definiert werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rolling\_std }\OperatorTok{=}\NormalTok{ s.rolling(}\StringTok{"24H"}\NormalTok{).std()}
\NormalTok{rolling\_mean }\OperatorTok{=}\NormalTok{ s.rolling(}\StringTok{"24H"}\NormalTok{).mean()}

\NormalTok{upper }\OperatorTok{=}\NormalTok{ rolling\_mean }\OperatorTok{+} \DecValTok{3} \OperatorTok{*}\NormalTok{ rolling\_std}
\NormalTok{lower }\OperatorTok{=}\NormalTok{ rolling\_mean }\OperatorTok{{-}} \DecValTok{3} \OperatorTok{*}\NormalTok{ rolling\_std}

\NormalTok{ax }\OperatorTok{=}\NormalTok{ s.plot(label}\OperatorTok{=}\StringTok{"Signal"}\NormalTok{)}
\NormalTok{upper.plot(ax}\OperatorTok{=}\NormalTok{ax, linestyle}\OperatorTok{=}\StringTok{"{-}{-}"}\NormalTok{, label}\OperatorTok{=}\StringTok{"Upper Bound"}\NormalTok{)}
\NormalTok{lower.plot(ax}\OperatorTok{=}\NormalTok{ax, linestyle}\OperatorTok{=}\StringTok{"{-}{-}"}\NormalTok{, label}\OperatorTok{=}\StringTok{"Lower Bound"}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.title(}\StringTok{"Anomalien via Rolling{-}Bounds"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_21411/2083333883.py:1: FutureWarning: 'H' is deprecated and will be removed in a future version, please use 'h' instead.
  rolling_std = s.rolling("24H").std()
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_21411/2083333883.py:2: FutureWarning: 'H' is deprecated and will be removed in a future version, please use 'h' instead.
  rolling_mean = s.rolling("24H").mean()
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/07-anomalien_files/figure-pdf/cell-6-output-2.png}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{7.5 Strukturbruch vs
Ausreißer}\label{strukturbruch-vs-ausreiuxdfer}

Ein einzelner Peak → Ausreißer\\
Dauerhafte Niveauänderung → Strukturbruch

Beide erfordern unterschiedliche Interpretation.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Methodischer Hinweis}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Bevor Sie Anomalien markieren:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Trend prüfen\\
\item
  Saison prüfen\\
\item
  Baseline definieren\\
\item
  Schwellenwert begründen\\
\end{enumerate}

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{7.6 Mini-Aufgaben}\label{mini-aufgaben-3}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Entfernen Sie den Trend vor Anwendung des Z-Scores.

  \begin{itemize}
  \tightlist
  \item
    Wie verändert sich das Ergebnis?
  \end{itemize}
\item
  Verringern Sie den Schwellenwert von 3 auf 2.

  \begin{itemize}
  \tightlist
  \item
    Was passiert?
  \end{itemize}
\item
  Simulieren Sie einen dauerhaften Niveau-Sprung.

  \begin{itemize}
  \tightlist
  \item
    Wird dieser als Anomalie erkannt?
  \end{itemize}
\end{enumerate}

\chapter{8 Forecasting-Baselines \&
Bewertung}\label{forecasting-baselines-bewertung}

\chapter{8 Forecasting-Baselines \&
Bewertung}\label{forecasting-baselines-bewertung-1}

Bevor komplexe Modelle eingesetzt werden, sollten immer einfache
\textbf{Baseline-Modelle} definiert werden.

Baselines beantworten die Frage:

\begin{quote}
Ist mein Modell wirklich besser als eine einfache, nachvollziehbare
Strategie?
\end{quote}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Merke}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Ein komplexes Modell ist nur dann sinnvoll, wenn es robuste Baselines
klar übertrifft.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{8.1 Beispielzeitreihe}\label{beispielzeitreihe}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{rng }\OperatorTok{=}\NormalTok{ np.random.default\_rng(}\DecValTok{123}\NormalTok{)}

\NormalTok{t }\OperatorTok{=}\NormalTok{ pd.date\_range(}\StringTok{"2025{-}01{-}01"}\NormalTok{, periods}\OperatorTok{=}\DecValTok{24}\OperatorTok{*}\DecValTok{14}\NormalTok{, freq}\OperatorTok{=}\StringTok{"H"}\NormalTok{)}
\NormalTok{trend }\OperatorTok{=}\NormalTok{ np.linspace(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\BuiltInTok{len}\NormalTok{(t))}
\NormalTok{season }\OperatorTok{=} \FloatTok{0.9} \OperatorTok{*}\NormalTok{ np.sin(}\DecValTok{2}\OperatorTok{*}\NormalTok{np.pi}\OperatorTok{*}\NormalTok{(t.hour)}\OperatorTok{/}\DecValTok{24}\NormalTok{)}
\NormalTok{noise }\OperatorTok{=} \FloatTok{0.3} \OperatorTok{*}\NormalTok{ rng.normal(size}\OperatorTok{=}\BuiltInTok{len}\NormalTok{(t))}

\NormalTok{s }\OperatorTok{=}\NormalTok{ pd.Series(}\DecValTok{20} \OperatorTok{+}\NormalTok{ trend }\OperatorTok{+}\NormalTok{ season }\OperatorTok{+}\NormalTok{ noise, index}\OperatorTok{=}\NormalTok{t, name}\OperatorTok{=}\StringTok{"signal"}\NormalTok{)}

\NormalTok{s.plot(title}\OperatorTok{=}\StringTok{"Zeitreihe für Forecasting"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_21452/1656542722.py:7: FutureWarning: 'H' is deprecated and will be removed in a future version, please use 'h' instead.
  t = pd.date_range("2025-01-01", periods=24*14, freq="H")
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/08-forecasting-baselines_files/figure-pdf/cell-2-output-2.png}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{8.2 Train-Test-Split}\label{train-test-split}

Wir verwenden 80\% der Daten für Training und 20\% für Test.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{split }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\BuiltInTok{len}\NormalTok{(s) }\OperatorTok{*} \FloatTok{0.8}\NormalTok{)}

\NormalTok{train }\OperatorTok{=}\NormalTok{ s.iloc[:split]}
\NormalTok{test }\OperatorTok{=}\NormalTok{ s.iloc[split:]}

\NormalTok{train.index.}\BuiltInTok{min}\NormalTok{(), train.index.}\BuiltInTok{max}\NormalTok{(), test.index.}\BuiltInTok{min}\NormalTok{(), test.index.}\BuiltInTok{max}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
(Timestamp('2025-01-01 00:00:00'),
 Timestamp('2025-01-12 03:00:00'),
 Timestamp('2025-01-12 04:00:00'),
 Timestamp('2025-01-14 23:00:00'))
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{8.3 Naive Forecast}\label{naive-forecast}

Nächster Wert = letzter beobachteter Wert.

\section{Pandas}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{naive }\OperatorTok{=}\NormalTok{ test.copy()}
\NormalTok{naive[:] }\OperatorTok{=}\NormalTok{ train.iloc[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\section{NumPy}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OperatorTok{=}\NormalTok{ s.to\_numpy()}
\NormalTok{train\_np }\OperatorTok{=}\NormalTok{ y[:split]}
\NormalTok{test\_np }\OperatorTok{=}\NormalTok{ y[split:]}

\NormalTok{naive\_np }\OperatorTok{=}\NormalTok{ np.full\_like(test\_np, train\_np[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{8.4 Seasonal Naive (24
Stunden)}\label{seasonal-naive-24-stunden}

Nächster Wert = Wert von vor 24 Stunden.

\section{Pandas}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{seasonal\_naive }\OperatorTok{=}\NormalTok{ s.shift(}\DecValTok{24}\NormalTok{).iloc[split:]}
\end{Highlighting}
\end{Shaded}

\section{NumPy}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{seasonal\_naive\_np }\OperatorTok{=}\NormalTok{ y[split}\OperatorTok{{-}}\DecValTok{24}\NormalTok{:}\OperatorTok{{-}}\DecValTok{24}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{8.5 Moving Average Baseline}\label{moving-average-baseline}

Forecast = Mittelwert der letzten 24 Stunden.

\section{Pandas}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ma\_value }\OperatorTok{=}\NormalTok{ train.iloc[}\OperatorTok{{-}}\DecValTok{24}\NormalTok{:].mean()}
\NormalTok{ma\_forecast }\OperatorTok{=}\NormalTok{ test.copy()}
\NormalTok{ma\_forecast[:] }\OperatorTok{=}\NormalTok{ ma\_value}
\end{Highlighting}
\end{Shaded}

\section{NumPy}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ma\_value\_np }\OperatorTok{=}\NormalTok{ np.mean(train\_np[}\OperatorTok{{-}}\DecValTok{24}\NormalTok{:])}
\NormalTok{ma\_forecast\_np }\OperatorTok{=}\NormalTok{ np.full\_like(test\_np, ma\_value\_np)}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{8.6 Vergleich visualisieren}\label{vergleich-visualisieren}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.figure()}
\NormalTok{train.plot(label}\OperatorTok{=}\StringTok{"Train"}\NormalTok{)}
\NormalTok{test.plot(label}\OperatorTok{=}\StringTok{"Test"}\NormalTok{)}
\NormalTok{naive.plot(label}\OperatorTok{=}\StringTok{"Naive"}\NormalTok{)}
\NormalTok{seasonal\_naive.plot(label}\OperatorTok{=}\StringTok{"Seasonal Naive"}\NormalTok{)}
\NormalTok{ma\_forecast.plot(label}\OperatorTok{=}\StringTok{"MA(24)"}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.title(}\StringTok{"Forecast Baselines"}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-analyse-von-zeitdaten/skript/08-forecasting-baselines_files/figure-pdf/cell-10-output-1.png}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{8.7 Fehlermaße}\label{fehlermauxdfe}

Wir verwenden den Mean Absolute Error (MAE):

{[} MAE = \frac{1}{n} \sum \textbar y\_\{true\} - y\_\{pred\}\textbar{}
{]}

\section{Pandas}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ mae(y\_true, y\_pred):}
    \ControlFlowTok{return}\NormalTok{ np.mean(np.}\BuiltInTok{abs}\NormalTok{(y\_true }\OperatorTok{{-}}\NormalTok{ y\_pred))}

\BuiltInTok{print}\NormalTok{(}\StringTok{"MAE Naive:"}\NormalTok{, mae(test, naive))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"MAE Seasonal Naive:"}\NormalTok{, mae(test, seasonal\_naive))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"MAE MA(24):"}\NormalTok{, mae(test, ma\_forecast))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
MAE Naive: 0.6298837368696829
MAE Seasonal Naive: 0.3320412574311427
MAE MA(24): 0.6228787570177815
\end{verbatim}

\section{NumPy}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ mae\_np(y\_true, y\_pred):}
    \ControlFlowTok{return}\NormalTok{ np.mean(np.}\BuiltInTok{abs}\NormalTok{(y\_true }\OperatorTok{{-}}\NormalTok{ y\_pred))}

\BuiltInTok{print}\NormalTok{(}\StringTok{"MAE Naive:"}\NormalTok{, mae\_np(test\_np, naive\_np))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"MAE Seasonal:"}\NormalTok{, mae\_np(test\_np, seasonal\_naive\_np))}
\BuiltInTok{print}\NormalTok{(}\StringTok{"MAE MA(24):"}\NormalTok{, mae\_np(test\_np, ma\_forecast\_np))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
MAE Naive: 0.6298837368696829
MAE Seasonal: 0.3320412574311427
MAE MA(24): 0.6228787570177815
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{8.8 Interpretation}\label{interpretation}

Typische Beobachtungen:

\begin{itemize}
\tightlist
\item
  Bei starker Saison gewinnt häufig Seasonal Naive.
\item
  Bei schwachem Muster ist Naive oft überraschend stark.
\item
  Moving Average glättet, reagiert aber träge auf Trendänderungen.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Methodischer Hinweis}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Baseline-Vergleich ist keine Formalität, sondern eine
Qualitätskontrolle.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{8.9 Mini-Aufgaben}\label{mini-aufgaben-4}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Erhöhen Sie die Stärke der Saison.

  \begin{itemize}
  \tightlist
  \item
    Welche Baseline gewinnt?
  \end{itemize}
\item
  Entfernen Sie die Saison vollständig.

  \begin{itemize}
  \tightlist
  \item
    Welche Baseline wird besser?
  \end{itemize}
\item
  Fügen Sie einen starken Trend hinzu.

  \begin{itemize}
  \tightlist
  \item
    Wie reagieren die Modelle?
  \end{itemize}
\end{enumerate}

\chapter{9 Lernzielkontrolle}\label{lernzielkontrolle-3}

\chapter{9 Lernzielkontrolle}\label{lernzielkontrolle-4}

Nutzen Sie diese Checkliste zur Selbstüberprüfung.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{9.1 Fachliche Kompetenzen}\label{fachliche-kompetenzen}

Ich kann \ldots{}

\begin{itemize}
\tightlist
\item[$\square$]
  eine Zeitreihe methodisch einordnen (Messprozess, Abtastrate).
\item[$\square$]
  eine Zeitreihe validieren (Sortierung, Duplikate, Missing Values).
\item[$\square$]
  Resampling begründet einsetzen (Aggregation vs.~Interpolation).
\item[$\square$]
  Rolling Mean und EWMA unterscheiden und passend wählen.
\item[$\square$]
  Trend und Saison konzeptionell trennen.
\item[$\square$]
  Lag-Features erzeugen und interpretieren.
\item[$\square$]
  Autokorrelation interpretieren.
\item[$\square$]
  Anomalien global und lokal definieren.
\item[$\square$]
  Baseline-Forecasts implementieren.
\item[$\square$]
  Forecast-Modelle mit MAE bewerten.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{9.2 Verständnisfragen}\label{verstuxe4ndnisfragen}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Warum ist die Abtastrate für die Interpretation einer Saison
  entscheidend?
\item
  Wann ist Interpolation problematisch?
\item
  Warum kann ein Trend die Autokorrelation künstlich erhöhen?
\item
  Warum sind Baselines methodisch wichtig?
\item
  Wodurch unterscheidet sich ein Strukturbruch von einem Ausreißer?
\end{enumerate}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Hinweis}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Wenn mehrere Punkte unsicher sind, wiederholen Sie gezielt die
entsprechenden Kapitel und bearbeiten Sie die Übungsaufgaben.

\end{tcolorbox}

\chapter{10 Übung:
Zeitreihen-Workflow}\label{uxfcbung-zeitreihen-workflow}

\chapter{10 Übung:
Zeitreihen-Workflow}\label{uxfcbung-zeitreihen-workflow-1}

Diese Übung kombiniert mehrere Methoden aus dem Baustein.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Aufgabe 1: Eigene Zeitreihe
erzeugen}\label{aufgabe-1-eigene-zeitreihe-erzeugen}

Erzeugen Sie eine Zeitreihe mit:

\begin{itemize}
\tightlist
\item
  10 Tagen, stündlicher Abtastrate
\item
  Trend
\item
  Tages-Saison
\item
  Rauschen
\item
  mindestens 3 Anomalien
\end{itemize}

Visualisieren Sie die Zeitreihe.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Aufgabe 2: Validierung}\label{aufgabe-2-validierung}

Bauen Sie absichtlich Fehler ein:

\begin{itemize}
\tightlist
\item
  Duplikate
\item
  Missing Values
\item
  Unsortierte Zeitpunkte
\end{itemize}

Implementieren Sie eine saubere Validierung.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Aufgabe 3: Resampling}\label{aufgabe-3-resampling}

\begin{itemize}
\tightlist
\item
  Aggregieren Sie auf Tagesmittel.
\item
  Vergleichen Sie Original und Aggregation.
\item
  Interpretieren Sie Informationsverlust.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Aufgabe 4: Glättung}\label{aufgabe-4-gluxe4ttung}

\begin{itemize}
\tightlist
\item
  Testen Sie Rolling-Fenster von 6H, 24H, 72H.
\item
  Welche Struktur wird jeweils sichtbar?
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Aufgabe 5: Anomalien}\label{aufgabe-5-anomalien}

\begin{itemize}
\tightlist
\item
  Implementieren Sie eine EWMA-Baseline.
\item
  Detektieren Sie Anomalien.
\item
  Variieren Sie den Schwellenwert.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Aufgabe 6:
Forecast-Baselines}\label{aufgabe-6-forecast-baselines}

\begin{itemize}
\tightlist
\item
  Train-Test-Split (80/20)
\item
  Naive
\item
  Seasonal Naive (24H)
\item
  MA(24)
\end{itemize}

Vergleichen Sie die MAE-Werte und interpretieren Sie das Ergebnis.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-note-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, coltitle=black, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Abgabeformat (optional)}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Plots + kurze Interpretation (Stichpunkte).

\end{tcolorbox}

\chapter{11 Klausurfragen}\label{klausurfragen-1}

\chapter{11 Klausurfragen}\label{klausurfragen-2}

\section{Verständnisfragen}\label{verstuxe4ndnisfragen-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Definieren Sie eine Zeitreihe.
\item
  Was ist der Unterschied zwischen Aggregation und Interpolation?
\item
  Erklären Sie Rolling Mean und EWMA konzeptionell.
\item
  Was ist ein Lag-Feature?
\item
  Was misst die Autokorrelation?
\item
  Warum kann Trend die Autokorrelation beeinflussen?
\item
  Erklären Sie den Unterschied zwischen globaler und lokaler
  Anomalie-Detektion.
\item
  Was ist eine Forecast-Baseline?
\item
  Warum sind Baselines methodisch notwendig?
\item
  Was misst der MAE?
\end{enumerate}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Transferfragen}\label{transferfragen}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Sie erhalten Maschinendaten mit starker Wochenperiodik.

  \begin{itemize}
  \tightlist
  \item
    Welche Schritte würden Sie durchführen?
  \end{itemize}
\item
  Eine Zeitreihe zeigt plötzlich dauerhaft höhere Werte.

  \begin{itemize}
  \tightlist
  \item
    Ausreißer oder Strukturbruch? Begründen Sie.
  \end{itemize}
\item
  Zwei Zeitreihen sollen verglichen werden, eine minütlich, eine
  stündlich gemessen.

  \begin{itemize}
  \tightlist
  \item
    Welche Schritte sind notwendig?
  \end{itemize}
\end{enumerate}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-warning-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame, coltitle=black, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Hinweis zur Prüfungsvorbereitung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Begründen Sie Ihre Antworten stets methodisch. Reine Definitionen
reichen meist nicht aus.

\end{tcolorbox}

\part{a-energiedatenanalyse}

\chapter*{Preamble}\label{preamble-3}
\addcontentsline{toc}{chapter}{Preamble}

\markboth{Preamble}{Preamble}

\phantomsection\label{Lizenz}
\begin{figure}

\begin{minipage}{0.20\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/books/a-energiedatenanalyse/skript/00-bilder/CC-BY.pdf}}\end{minipage}%
%
\begin{minipage}{0.80\linewidth}
Bausteine Computergestützter Datenanalyse von Lukas Arnold, Simone
Arnold, Florian Bagemihl, Matthias Baitsch, Marc Fehr, Franca Hollmann,
Maik Poetzsch und Sebastian Seipel. Anwendungsbaustein
Energiedatenanalyse von Maik Poetzsch ist lizensiert unter
\href{https://creativecommons.org/licenses/by/4.0/deed.de}{CC BY 4.0}.
Das Werk ist abrufbar auf
\href{https://github.com/bausteine-der-datenanalyse/bcd-styleguide}{GitHub}.
Ausgenommen von der Lizenz sind alle Logos und anders gekennzeichneten
Inhalte. 2025\end{minipage}%

\end{figure}%

Zitiervorschlag

Arnold, Lukas, Simone Arnold, Florian Bagemihl, Matthias Baitsch, Marc
Fehr, Franca Hollmann, Maik Poetzsch, und Sebastian Seipel. 2025.
„Bausteine Computergestützter Datenanalyse. Anwendungsbaustein
Energiedatenanalyse``.
\url{https://github.com/bausteine-der-datenanalyse/a-energiedatenanalyse}.

BibTeX-Vorlage

\begin{verbatim}
@misc{BCD-a-ernergiedatenanalyse-2025,
 title={Bausteine Computergestützter Datenanalyse. Anwendungsbaustein Energiedatenanalyse},
 author={Arnold, Lukas and Arnold, Simone and Bagemihl, Florian and Baitsch, Matthias and Fehr, Marc and Hollmann, Franca and Poetzsch, Maik and Seipel, Sebastian},
 year={2025},
 url={https://github.com/bausteine-der-datenanalyse/a-energiedatenanalyse}} 
\end{verbatim}

\chapter*{Voraussetzungen}\label{voraussetzungen-11}
\addcontentsline{toc}{chapter}{Voraussetzungen}

\markboth{Voraussetzungen}{Voraussetzungen}

Die Bearbeitungszeit dieses Bausteins beträgt circa 10 Stunden. Für die
Bearbeitung dieses Bausteins werden folgende Bausteine vorausgesetzt und
die genannten Bibliotheken verwendet:

\begin{itemize}
\item
  Werkzeugbaustein Python

  \begin{itemize}
  \item
    Modul \href{https://docs.python.org/3/library/random.html}{random}
  \item
    Modul \href{https://pypi.org/project/pandas/}{Pandas}
  \item
    Modul \href{https://numpy.org/}{NumPy}
  \item
    Modul
    \href{https://matplotlib.org/3.5.3/api/_as_gen/matplotlib.pyplot.html}{matplotlib.pyplot}
  \end{itemize}
\item
  Methodenbaustein Einlesen strukturierter Datensätze
\end{itemize}

Im Baustein werden Strommarktdaten für das Jahr 2023 verwendet. Daten
für Deutschland werden von der Bundesnetzagentur bereitgestellt und sind
unter
\href{https://www.smard.de/home/downloadcenter/download-marktdaten/}{https://www.smard.de/}
abrufbar. Daten für Österreich werden von der Austrian Power Grid AG
bereitgestellt und sind unter
\href{https://markttransparenz.apg.at/de/markt/Markttransparenz/erzeugung/Erzeugung-pro-Typ}{https://markttransparenz.apg.at/}
abrufbar.

\chapter*{Lernziele}\label{lernziele-11}
\addcontentsline{toc}{chapter}{Lernziele}

\markboth{Lernziele}{Lernziele}

In diesen Baustein lernen Sie Methoden und Werkzeuge für die
Energiedatenanalyse kennen. Dabei bilden Prinzipien und Verfahren zur
Auslegung eines Stromspeichers einen inhaltlichen Schwerpunkt.

Die behandelten Methoden umfassen:

\begin{itemize}
\item
  beschreibende Datenanlyse
\item
  explorative Datenanalyse
\item
  schließende Datenanalyse
\item
  ergänzender Einsatz kennzahlenbasierter und visualisierender Methoden
\end{itemize}

Zu den vorgestellten Werkzeugen gehören:

\begin{itemize}
\item
  Visualisierung einer sortierten Jahresdauerlinie
\item
  Berechnung der Residual- und Restlast
\item
  Grenzstromanalyse
\item
  Größenbestimmung eines Stromspeichers unter Berücksichtigung des
  Wirkungsgrads und der Kappung von Erzeugungsspitzen, Berechnung der
  realisierten Zyklenzahl, Jahresgänge und des Potenzials auf dem
  Ausbaupfad erneuerbarer Energien
\end{itemize}

Schlagworte: vergleichende Analyse von Strommarktdaten, Daten
visualisieren, Speicherauslegung

\chapter{Energiedatenanalyse}\label{energiedatenanalyse}

\chapter{Hintergrund}\label{hintergrund}

Elektrischer Strom wird in Kraftwerken erzeugt und über das Stromnetz zu
den Stromverbrauchern transportiert. Stromerzeugung und -verbrauch
müssen dabei immer ausgeglichen sein. Der Anteil wetterabhängiger
erneuerbarer Einspeisung steigt, Strom kann bislang aber nicht
(kostengünstig) großtechnisch gespeichert werden. 2023 speisten die
Pumpspeicherkraftwerke in Deutschland bei einer Kapazität von 37,4 GWh
{[}@Heimerl-Kohler-2017-Pumpspeicher-in-Deutschland, S. 77{]} 11,1 TWh
Strom ein, was 2,4 Prozent des deutschen Stromverbrauchs von 458,3 TWh
entsprach {[}@energy-charts-strom{]}. Die Kraftwerkseinsatzplanung und
Speicherauslegung auf Basis von Erzeugungs- und Verbrauchsdaten ist
deshalb ein relevantes Anwendungsfeld für die Datenanalyse.\\
Die Bundesnetzagentur veröffentlicht auf
\href{https://www.smard.de/home/downloadcenter/download-marktdaten/}{https://www.smard.de/}
unter anderem Daten zu Stromerzeugung, -verbrauch und
Großhandelspreisen. (Hinweis: Kraftwerksdaten liegen für
Erzeugungseinheiten mit einer installierten Erzeugungsleistung von
mindestens 100 MW vor.)

\chapter{Daten einlesen}\label{daten-einlesen}

Die Strommarktdaten der Bundesnetzagentur müssen manuell auf
\href{https://www.smard.de/home/downloadcenter/download-marktdaten/}{https://www.smard.de/}
heruntergeladen werden. In diesem Skript werden Daten für das Jahr 2023
benutzt.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Daten
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Dateiname
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Installierte Erzeugungsleistung 2023 &
Installierte\_Erzeugungsleistung\_202301010000\_202401010000\_Jahr.csv \\
Realisierte Stromerzeugung 2023 &
Realisierte\_Erzeugung\_202301010000\_202401010000\_Viertelstunde.csv \\
Realisierter Stromverbrauch 2023 &
Realisierter\_Stromverbrauch\_202301010000\_202401010000\_Viertelstunde.csv \\
\end{longtable}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-SMARD} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-SMARD}: SMARD Daten herunterladen}\vspace{3mm}

\begin{figure}[H]

\begin{minipage}{0.50\linewidth}
Beim der Auswahl des Zeitraums auf Akzeptieren klicken.\end{minipage}%
%
\begin{minipage}{0.50\linewidth}
Daten zur installierten Leistung in Originalauflösung (Jahresbasis)
auswählen.\end{minipage}%
\newline
\begin{minipage}{0.50\linewidth}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/00-bilder/smard-accept.png}}

}

\subcaption{~}

\end{figure}%

\end{minipage}%
%
\begin{minipage}{0.50\linewidth}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/00-bilder/smard-installed-capacity-de.png}}

}

\subcaption{~}

\end{figure}%

\end{minipage}%
\newline
\begin{minipage}{\linewidth}
Das Datumsformat der Dateien ist abhängig von der auf der Internetseite
eingestellten Sprache (Deutsch/English).\end{minipage}%

\end{figure}%

\end{minipage}%
\end{tcolorbox}

Die semikolonseparierten Dateien werden als DataFrame mit dem Python
Modul Pandas eingelesen, das mit dem Kürzel \texttt{pd} importiert wird.
Dazu wird die Funktion \texttt{pd.read\_csv()} verwendet. Dabei werden:

\begin{itemize}
\item
  das Wert-, Tausender- und Dezimaltrennzeichen spezifiziert.\\
  \texttt{sep\ =\ ";",\ thousands\ =\ ".",\ decimal\ =\ ","}
\item
  die Spalten mit Datums- und Zeitangaben sowie das Datumsformat
  bestimmt.\\
  \texttt{parse\_dates\ =\ {[}0,\ 1{]},\ date\_format\ =\ "\%d.\%m.\%Y\ \%H:\%M"}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\NormalTok{pd.set\_option(}\StringTok{"display.precision"}\NormalTok{, }\DecValTok{2}\NormalTok{) }\CommentTok{\# Anzahl Nachkommastellen}
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\NormalTok{installierte\_leistung0 }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\StringTok{"01{-}daten/Installierte\_Erzeugungsleistung\_202301010000\_202401010000\_Jahr.csv"}\NormalTok{, }\OperatorTok{\textbackslash{}}
\NormalTok{sep }\OperatorTok{=} \StringTok{";"}\NormalTok{, thousands }\OperatorTok{=} \StringTok{"."}\NormalTok{, decimal }\OperatorTok{=} \StringTok{","}\NormalTok{, }\OperatorTok{\textbackslash{}}
\NormalTok{parse\_dates }\OperatorTok{=}\NormalTok{ [}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{], date\_format }\OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y"}\NormalTok{)}

\NormalTok{erzeugung0 }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\StringTok{"01{-}daten/Realisierte\_Erzeugung\_202301010000\_202401010000\_Viertelstunde.csv"}\NormalTok{, }\OperatorTok{\textbackslash{}}
\NormalTok{sep }\OperatorTok{=} \StringTok{";"}\NormalTok{, thousands }\OperatorTok{=} \StringTok{"."}\NormalTok{, decimal }\OperatorTok{=} \StringTok{","}\NormalTok{, }\OperatorTok{\textbackslash{}}
\NormalTok{parse\_dates }\OperatorTok{=}\NormalTok{ [}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{], date\_format }\OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y \%H:\%M"}\NormalTok{)}

\NormalTok{verbrauch0 }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\StringTok{"01{-}daten/Realisierter\_Stromverbrauch\_202301010000\_202401010000\_Viertelstunde.csv"}\NormalTok{, }\OperatorTok{\textbackslash{}}
\NormalTok{sep }\OperatorTok{=} \StringTok{";"}\NormalTok{, thousands }\OperatorTok{=} \StringTok{"."}\NormalTok{, decimal }\OperatorTok{=} \StringTok{","}\NormalTok{, }\OperatorTok{\textbackslash{}}
\NormalTok{parse\_dates }\OperatorTok{=}\NormalTok{ [}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{], date\_format }\OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y \%H:\%M"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Sehen Sie sich die Zeichenkette zur Spezifikation des Datumsformats an:
\texttt{"\%d.\%m.\%Y\ \%H:\%M"}. Können Sie anhand der
\href{https://docs.python.org/3/library/datetime.html\#strftime-and-strptime-behavior}{Dokumentation}
bestimmen, welches Format die Datumsangaben in der Datei haben? Welches
Format hat der 14. April 2023 um Viertel nach zwei nachmittags?

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-datumsformat}: Lösung Datumsformat}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-datumsformat} 

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Kürzel & Bedeutung \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\%d. & Tag als zweistellige Ganzzahl mit Trennzeichen ``.'' \\
\%m. & Monat (ggf. mit führender Null) mit Trennzeichen ``.'' \\
\%Y & Jahr als vierstellige Ganzzahl mit Trennzeichen '' '' \\
\%H: & Stunde als zweistellige Ganzzahl mit Trennzeichen ``:'' \\
\%M & Minute als zweistellige Ganzzahl \\
\end{longtable}

\textbf{Lösung}: 14.04.2023 14:15

\end{tcolorbox}

\chapter{Daten organisieren}\label{daten-organisieren}

Vor der Datenanalyse sollte überprüft werden, ob die Daten korrekt
eingelesen wurden. Dies bedeutet zum einen, zu kontrollieren, ob der
Datentyp aller Spalten richtig erkannt wurde. Ob die Spaltentypen einer
Datei korrekt eingelesen wurden, können Sie in Python mit dem Befehl
\texttt{df.dtypes} überprüfen. Hier der Output des Befehls für den
DataFrame \texttt{erzeugung0}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Spalten:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{erzeugung0}\SpecialCharTok{.}\NormalTok{dtypes}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Spalten:
Datum von                                            datetime64[ns]
Datum bis                                            datetime64[ns]
Biomasse [MWh] Originalauflösungen                          float64
Wasserkraft [MWh] Originalauflösungen                       float64
Wind Offshore [MWh] Originalauflösungen                     float64
Wind Onshore [MWh] Originalauflösungen                      float64
Photovoltaik [MWh] Originalauflösungen                      float64
Sonstige Erneuerbare [MWh] Originalauflösungen              float64
Kernenergie [MWh] Originalauflösungen                       float64
Braunkohle [MWh] Originalauflösungen                        float64
Steinkohle [MWh] Originalauflösungen                        float64
Erdgas [MWh] Originalauflösungen                            float64
Pumpspeicher [MWh] Originalauflösungen                      float64
Sonstige Konventionelle [MWh] Originalauflösungen           float64
dtype: object
\end{verbatim}

~

Viele der Spaltennamen enthalten die Zeichenkette ''
Originalauflösungen'', die der Übersichtlichkeit wegen entfernt werden
kann (führendes Leerzeichen beachten). Auf diese Weise könnte auch die
Einheitenangabe {[}MWh{]} entfernt werden, falls diese als störend
empfunden wird.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Zeichenkette " Originalauflösungen" entfernen}
\NormalTok{installierte\_leistung0.columns }\OperatorTok{=}\NormalTok{ installierte\_leistung0.columns.}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{" Originalauflösungen"}\NormalTok{, repl }\OperatorTok{=} \StringTok{""}\NormalTok{)}

\NormalTok{erzeugung0.columns }\OperatorTok{=}\NormalTok{ erzeugung0.columns.}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{" Originalauflösungen"}\NormalTok{, repl }\OperatorTok{=} \StringTok{""}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Spalten:}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{erzeugung0}\SpecialCharTok{.}\NormalTok{dtypes}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{verbrauch0.columns }\OperatorTok{=}\NormalTok{ verbrauch0.columns.}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{" Originalauflösungen"}\NormalTok{, repl }\OperatorTok{=} \StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Spalten:
Datum von                        datetime64[ns]
Datum bis                        datetime64[ns]
Biomasse [MWh]                          float64
Wasserkraft [MWh]                       float64
Wind Offshore [MWh]                     float64
Wind Onshore [MWh]                      float64
Photovoltaik [MWh]                      float64
Sonstige Erneuerbare [MWh]              float64
Kernenergie [MWh]                       float64
Braunkohle [MWh]                        float64
Steinkohle [MWh]                        float64
Erdgas [MWh]                            float64
Pumpspeicher [MWh]                      float64
Sonstige Konventionelle [MWh]           float64
dtype: object
\end{verbatim}

~

Zum anderen sollten die eingelesenen Daten betrachtet werden, um Fehler
etwa bei der Umwandlung von Dezimal- und Tausendertrennzeichen, des
Datumsformats oder eine unerwartete Anzahl fehlender Werte und sonstige
Auffälligkeiten zu identifizieren. Dazu sollten nicht nur die ersten
Zeilen des Datensatzes, sondern auch Ausschnitte aus der Mitte und dem
Ende kontrolliert werden. Dafür ist der Befehl
\texttt{pd.concat({[}a,\ b,\ c{]})} nützlich, dem eine Liste von
Indexbereichen übergeben werden kann (siehe zweiter und dritter Reiter
im folgenden Panel).

\section{installierte Leistung}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# der DataFrame installierte\_leistung0 hat nur 1 Zeile}
\NormalTok{installierte\_leistung0}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllllllllll@{}}
\toprule\noalign{}
& Datum von & Datum bis & Biomasse {[}MW{]} & Wasserkraft {[}MW{]} &
Wind Offshore {[}MW{]} & Wind Onshore {[}MW{]} & Photovoltaik {[}MW{]} &
Sonstige Erneuerbare {[}MW{]} & Kernenergie {[}MW{]} & Braunkohle
{[}MW{]} & Steinkohle {[}MW{]} & Erdgas {[}MW{]} & Pumpspeicher {[}MW{]}
& Sonstige Konventionelle {[}MW{]} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2023-01-01 & 2024-01-01 & 8467.0 & 5049.0 & 8129.0 & 57590.0 &
63066.0 & 440.0 & 4056.0 & 17692.0 & 18127.0 & 31808.0 & 9379.0 &
8958.0 \\
\end{longtable}

\section{realisierte Erzeugung}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pd.concat([erzeugung0.head(}\DecValTok{2}\NormalTok{), }\OperatorTok{\textbackslash{}}
\NormalTok{erzeugung0.iloc[}\BuiltInTok{len}\NormalTok{(erzeugung0)}\OperatorTok{//}\DecValTok{2}\NormalTok{:(}\BuiltInTok{len}\NormalTok{(erzeugung0)}\OperatorTok{//}\DecValTok{2}\OperatorTok{+}\DecValTok{2}\NormalTok{)], }\OperatorTok{\textbackslash{}}
\NormalTok{erzeugung0.tail(}\DecValTok{2}\NormalTok{)])}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllllllllllll@{}}
\toprule\noalign{}
& Datum von & Datum bis & Biomasse {[}MWh{]} & Wasserkraft {[}MWh{]} &
Wind Offshore {[}MWh{]} & Wind Onshore {[}MWh{]} & Photovoltaik
{[}MWh{]} & Sonstige Erneuerbare {[}MWh{]} & Kernenergie {[}MWh{]} &
Braunkohle {[}MWh{]} & Steinkohle {[}MWh{]} & Erdgas {[}MWh{]} &
Pumpspeicher {[}MWh{]} & Sonstige Konventionelle {[}MWh{]} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2023-01-01 00:00:00 & 2023-01-01 00:15:00 & 1094.25 & 320.0 & 684.25
& 7145.75 & 0.50 & 32.25 & 615.25 & 962.75 & 517.00 & 429.75 & 13.50 &
307.25 \\
1 & 2023-01-01 00:15:00 & 2023-01-01 00:30:00 & 1091.25 & 317.5 & 743.50
& 7158.25 & 0.25 & 32.25 & 614.75 & 963.25 & 518.00 & 429.50 & 9.75 &
307.25 \\
17520 & 2023-07-02 13:00:00 & 2023-07-02 13:15:00 & 955.25 & 317.5 &
736.00 & 4228.50 & 6832.75 & 25.25 & 0.00 & 795.00 & 216.75 & 546.00 &
0.75 & 264.75 \\
17521 & 2023-07-02 13:15:00 & 2023-07-02 13:30:00 & 956.75 & 321.5 &
693.75 & 3885.25 & 6961.25 & 25.25 & 0.00 & 791.00 & 215.00 & 545.00 &
0.00 & 266.00 \\
35038 & 2023-12-31 23:30:00 & 2023-12-31 23:45:00 & 1053.25 & 412.5 &
1479.25 & 7544.25 & 0.50 & 24.00 & 0.00 & 845.25 & 444.50 & 683.00 &
122.75 & 348.50 \\
35039 & 2023-12-31 23:45:00 & 2024-01-01 00:00:00 & 1051.50 & 404.0 &
1469.00 & 7480.50 & 0.50 & 24.00 & 0.00 & 840.75 & 442.25 & 679.00 &
58.25 & 348.00 \\
\end{longtable}

\section{realisierter Verbrauch}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pd.concat([verbrauch0.head(}\DecValTok{2}\NormalTok{), }\OperatorTok{\textbackslash{}}
\NormalTok{verbrauch0.iloc[}\BuiltInTok{len}\NormalTok{(verbrauch0)}\OperatorTok{//}\DecValTok{2}\NormalTok{:(}\BuiltInTok{len}\NormalTok{(verbrauch0)}\OperatorTok{//}\DecValTok{2}\OperatorTok{+}\DecValTok{2}\NormalTok{)], }\OperatorTok{\textbackslash{}}
\NormalTok{verbrauch0.tail(}\DecValTok{2}\NormalTok{)])}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}llllll@{}}
\toprule\noalign{}
& Datum von & Datum bis & Gesamt (Netzlast) {[}MWh{]} & Residuallast
{[}MWh{]} & Pumpspeicher {[}MWh{]} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 2023-01-01 00:00:00 & 2023-01-01 00:15:00 & 9720.75 & 1890.25 &
424.75 \\
1 & 2023-01-01 00:15:00 & 2023-01-01 00:30:00 & 9641.25 & 1739.25 &
443.50 \\
17520 & 2023-07-02 13:00:00 & 2023-07-02 13:15:00 & 11564.00 & -233.25 &
1147.75 \\
17521 & 2023-07-02 13:15:00 & 2023-07-02 13:30:00 & 11536.25 & -4.00 &
1223.25 \\
35038 & 2023-12-31 23:30:00 & 2023-12-31 23:45:00 & 10495.75 & 1471.75 &
470.00 \\
35039 & 2023-12-31 23:45:00 & 2024-01-01 00:00:00 & 10289.25 & 1339.25 &
528.00 \\
\end{longtable}

~

Schließlich ist eine Plausibilitätskontrolle der Daten sinnvoll.
Einleitend wurde der deutsche Gesamtstromverbrauch im Jahr 2023 genannt,
der 458,3 TWh beträgt. Der Stromverbrauch und die Summe der
Stromerzeugung sollten diesem Wert ungefähr entsprechen.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# exclude columns with datetime}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Stromverbrauch in Millionen MWh:}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\OperatorTok{\textbackslash{}}
\NormalTok{verbrauch0.}\BuiltInTok{sum}\NormalTok{(numeric\_only }\OperatorTok{=} \VariableTok{True}\NormalTok{) }\OperatorTok{//}\NormalTok{ (}\DecValTok{1000} \OperatorTok{*} \DecValTok{1000}\NormalTok{), sep }\OperatorTok{=} \StringTok{""}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Stromerzeugung in Millionen MWh"}\NormalTok{, }\OperatorTok{\textbackslash{}}
\NormalTok{erzeugung0.}\BuiltInTok{sum}\NormalTok{(numeric\_only }\OperatorTok{=} \VariableTok{True}\NormalTok{).}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{//}\NormalTok{ (}\DecValTok{1000} \OperatorTok{*} \DecValTok{1000}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Stromverbrauch in Millionen MWh:
Gesamt (Netzlast) [MWh]    458.0
Residuallast [MWh]         260.0
Pumpspeicher [MWh]          14.0
dtype: float64

Stromerzeugung in Millionen MWh 448.0
\end{verbatim}

~

Wenn alle Dateien korrekt eingelesen wurden, können Arbeitsdateien mit
dem Befehl \texttt{df.copy()} angelegt werden. Dadurch bleiben die
Rohdaten immer verfügbar und können bei Bedarf, beispielsweise nach
einem versehentlichen Überschreiben der Arbeitsdateien, erneut geladen
werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{erzeugung }\OperatorTok{=}\NormalTok{ erzeugung0.copy()}
\NormalTok{verbrauch }\OperatorTok{=}\NormalTok{ verbrauch0.copy()}
\NormalTok{installierte\_leistung }\OperatorTok{=}\NormalTok{ installierte\_leistung0.copy()}
\end{Highlighting}
\end{Shaded}

\chapter{Beschreibende Datenanalyse}\label{beschreibende-datenanalyse}

Mit Methoden der beschreibenden Statistik kann ein Überblick über die
Datensätze und die Daten gewonnen werden. Dieser Schritt dient
insbesondere auch dazu, mögliche Fehler und Auffälligkeiten im Datensatz
zu identifizieren. Hierbei gewonnene Befunde können im der folgenden
explorativen und schließenden Datenanalyse vertieft werden.

Einen ersten Überblick über die Daten liefert die Methode
\texttt{pd.DataFrame.describe()}, die die Verteilung der Daten
beschreibt. Durch das Argument \texttt{include\ =\ {[}np.number{]}} kann
die Ausgabe auf Spalten mit numerischen Daten beschränkt werden, das
heißt, die Spalten mit Datumsinformationen werden ausgeschlossen.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der DataFrame erzeugung hat }\SpecialCharTok{\{}\NormalTok{erzeugung}\SpecialCharTok{.}\NormalTok{shape[}\DecValTok{0}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{ Zeilen und }\SpecialCharTok{\{}\NormalTok{erzeugung}\SpecialCharTok{.}\NormalTok{shape[}\DecValTok{1}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{ Spalten.}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\NormalTok{erzeugung.describe(include }\OperatorTok{=}\NormalTok{ [np.number])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Der DataFrame erzeugung hat 35040 Zeilen und 14 Spalten.
\end{verbatim}

\begin{longtable}[]{@{}lllllllllllll@{}}
\toprule\noalign{}
& Biomasse {[}MWh{]} & Wasserkraft {[}MWh{]} & Wind Offshore {[}MWh{]} &
Wind Onshore {[}MWh{]} & Photovoltaik {[}MWh{]} & Sonstige Erneuerbare
{[}MWh{]} & Kernenergie {[}MWh{]} & Braunkohle {[}MWh{]} & Steinkohle
{[}MWh{]} & Erdgas {[}MWh{]} & Pumpspeicher {[}MWh{]} & Sonstige
Konventionelle {[}MWh{]} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
count & 35040.00 & 35040.00 & 35040.00 & 35040.00 & 35040.00 & 35040.00
& 35040.00 & 35040.00 & 35040.00 & 35040.00 & 35040.00 & 35040.00 \\
mean & 1079.50 & 411.50 & 671.23 & 3389.91 & 1590.11 & 33.32 & 192.37 &
2221.58 & 1134.42 & 1431.02 & 318.19 & 330.81 \\
std & 80.16 & 83.08 & 457.65 & 2627.46 & 2470.00 & 7.69 & 305.80 &
939.80 & 838.85 & 682.72 & 425.94 & 39.99 \\
min & 892.50 & 249.75 & 0.00 & 30.25 & 0.25 & 21.75 & 0.00 & 634.25 &
170.25 & 373.00 & 0.00 & 208.50 \\
25\% & 1017.50 & 334.00 & 259.00 & 1237.25 & 0.50 & 25.50 & 0.00 &
1396.25 & 506.75 & 893.25 & 38.00 & 304.50 \\
50\% & 1066.75 & 420.50 & 612.25 & 2657.00 & 24.88 & 32.50 & 0.00 &
2111.25 & 814.75 & 1300.00 & 110.75 & 337.00 \\
75\% & 1133.25 & 481.00 & 1040.56 & 5017.19 & 2466.50 & 39.25 & 535.00 &
3000.31 & 1501.00 & 1810.75 & 443.00 & 356.00 \\
max & 1293.25 & 618.25 & 1910.00 & 12039.50 & 10361.25 & 51.25 & 771.00
& 4121.75 & 3814.00 & 4169.25 & 2399.00 & 512.50 \\
\end{longtable}

~

Aus der beschreibenden Statistik der Daten kann beispielsweise entnommen
werden, dass Onshore Wind den größten Beitrag zur Stromerzeugung
lieferte. Ebenfalls ist auffällig, dass weder Onshore Wind noch
Photovoltaik eine minimale Erzeugung von 0 aufweisen, was jedoch für
Wind Offshore und Kernenergie der Fall ist.

\section{Visualisieren}\label{visualisieren}

Die Auswertung der beschreibenden Statistik für 12 verschiedene
Erzeugungsformen erfordert jedoch Konzentration. Komplexe Informationen
sollten deshalb grafisch aufbereitet werden.

Einen schnellen Überblick beispielsweise über die Verteilung der
Gesamterzeugungsleistung nach Erzeugungsart verschafft ein Kreis- bzw.
Ringdiagramm. Allerdings hat dieser Diagrammtyp den Nachteil, dass
dieser mit steigender Anzahl von Merkmalsausprägungen (bzw. hier
darzustellenden Merkmalen) schnell unübersichtlich wird und Winkel kaum
exakt abgelesen werden können.

Im folgenden, mit der Methode \texttt{pd.DataFrame.plot.pie()}
erstellten Ringdiagramm wurde deshalb zum einen die automatische
Annotation der Anteilswerte mit dem entsprechenden Formatierungsstring
\texttt{autopct=\textquotesingle{}\%1.1f\%\%\textquotesingle{}}
aktiviert. Zum anderen wurde die Reihenfolge der Spalten im DataFrame
getauscht, da sich die Prozentangaben und Beschriftungen kleiner
Kreissegmente andernfalls überlappen. Außerdem wurde für die
Beschriftung der Segmente die Zeichkette '' {[}MWh{]}'' aus den
Spaltennamen gekürzt. Dies verbessert zwar die Lesbarkeit des Diagramms.
Das ist aber nicht der Grund, weshalb die Zeichenkette entfernt wurde.\\
\textbf{Was denken Sie, was der Grund dafür ist?}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-Ringdiagramm}: Lösung Kreisdiagramm}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-Ringdiagramm} 

Das Kreis- bzw. Ringdiagramm stellt Anteilswerte dar und ist deshalb
einheitenlos.

\end{tcolorbox}

Die Details der Ploterstellung können Sie dem zweiten Reiter entnehmen.

\section{Plotten mit Pandas}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-11-output-1.png}}

}

\caption{Anteil an der Stromerzeugung}

\end{figure}%

\section{Code für Pandas}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# plot the pie first try {-} Sonstige Erneuerbare [MWh] overlaps with Kernenergie [MWh] and Pumpspeicher [MWh]}
\CommentTok{\# erzeugung.sum(numeric\_only = True).plot.pie(colormap = "Blues", startangle = 90, rotatelabels = True, explode = explosion)}

\CommentTok{\# rearrange columns, remove " [MWh]"}
\NormalTok{plotting\_data }\OperatorTok{=}\NormalTok{ erzeugung.copy()}
\NormalTok{column\_to\_move }\OperatorTok{=}\NormalTok{ plotting\_data.pop(}\StringTok{"Kernenergie [MWh]"}\NormalTok{)}
\NormalTok{plotting\_data.insert(}\DecValTok{4}\NormalTok{, }\StringTok{"Kernenergie [MWh]"}\NormalTok{, column\_to\_move)}

\NormalTok{column\_to\_move }\OperatorTok{=}\NormalTok{ plotting\_data.pop(}\StringTok{"Pumpspeicher [MWh]"}\NormalTok{)}
\NormalTok{plotting\_data.insert(}\DecValTok{10}\NormalTok{, }\StringTok{"Pumpspeicher [MWh]"}\NormalTok{, column\_to\_move)}

\NormalTok{plotting\_data.columns }\OperatorTok{=}\NormalTok{ plotting\_data.columns.}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{" [MWh]"}\NormalTok{, repl }\OperatorTok{=} \StringTok{""}\NormalTok{)}

\CommentTok{\# plot the pie}
\NormalTok{ax }\OperatorTok{=}\NormalTok{ plotting\_data.}\BuiltInTok{sum}\NormalTok{(numeric\_only }\OperatorTok{=} \VariableTok{True}\NormalTok{).plot.pie(colormap }\OperatorTok{=} \StringTok{"Blues"}\NormalTok{, startangle }\OperatorTok{=} \DecValTok{90}\NormalTok{, rotatelabels }\OperatorTok{=} \VariableTok{False}\NormalTok{, autopct}\OperatorTok{=}\StringTok{\textquotesingle{}}\SpecialCharTok{\%1.1f\%\%}\StringTok{\textquotesingle{}}\NormalTok{, pctdistance }\OperatorTok{=} \FloatTok{0.6}\NormalTok{, textprops }\OperatorTok{=} \BuiltInTok{dict}\NormalTok{(size }\OperatorTok{=} \DecValTok{7}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{), wedgeprops }\OperatorTok{=}\NormalTok{ \{}\StringTok{"linewidth"}\NormalTok{: }\FloatTok{0.5}\NormalTok{, }\StringTok{"edgecolor"}\NormalTok{: }\StringTok{"white"}\NormalTok{\})}

\CommentTok{\# make a donut}
\NormalTok{circle }\OperatorTok{=}\NormalTok{ plt.Circle((}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{), radius }\OperatorTok{=} \FloatTok{0.7}\NormalTok{, color }\OperatorTok{=} \StringTok{"white"}\NormalTok{)}
\NormalTok{ax.add\_patch(circle)}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\subsection{Daten aggregieren}\label{daten-aggregieren}

Aufgrund der zahlreichen Merkmale erschließt sich aus der deskriptiven
und visuellen Beschreibung der Erzeugungsleistung nicht unbedingt ein
prägnanter Befund. Eine Möglichkeit, um Daten besser zu verstehen,
besteht darin, ähnliche Merkmale zusammenzufassen. Im Folgenden werden
erneuerbare und konventionelle (mit fossilen Brennstoffen betriebene)
Erzeugungsarten für die Darstellung der Anteilswerte in einem
Ringdiagramm zusammengefasst. Beide Gruppen werden zusätzlich in einem
Balkendiagramm dargestellt. Für die Darstellung wird das Modul
\texttt{matplotlib.pyplot} verwendet. Die Details der Ploterstellung
können Sie dem zweiten Reiter entnehmen.

\section{Plotten mit matplotlib}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-13-output-1.png}}

}

\caption{Absolute Stromerzeugung und relative Anteile nach
Erzeugungstyp}

\end{figure}%

\section{Code für matplotlib}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Erneuerbare und Konventionelle bestimmen, jeweils summieren}

\CommentTok{\#\# Erneuerbare}
\NormalTok{plotting\_data }\OperatorTok{=}\NormalTok{ erzeugung.copy()}
\NormalTok{plotting\_data.drop(columns }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Datum von\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Datum bis\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Biomasse [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wasserkraft [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Offshore [MWh]\textquotesingle{}}\NormalTok{,}
\StringTok{\textquotesingle{}Wind Onshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Photovoltaik [MWh]\textquotesingle{}}\NormalTok{,}
\StringTok{\textquotesingle{}Sonstige Erneuerbare [MWh]\textquotesingle{}}\NormalTok{], inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{) }\CommentTok{\# Datumsspalten entfernen, inplace = False liefert eine Kopie und tut deshalb ohne Objektzuweisung \textquotesingle{}nichts\textquotesingle{}}
\NormalTok{erneuerbare }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Biomasse [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wasserkraft [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Offshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Onshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Photovoltaik [MWh]\textquotesingle{}}\NormalTok{,}
\StringTok{\textquotesingle{}Sonstige Erneuerbare [MWh]\textquotesingle{}}\NormalTok{]}
\NormalTok{plotting\_data[}\StringTok{"Erneuerbare"}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung[erneuerbare].}\BuiltInTok{sum}\NormalTok{(axis }\OperatorTok{=} \StringTok{\textquotesingle{}columns\textquotesingle{}}\NormalTok{)}

\CommentTok{\#\# Konventionelle}
\NormalTok{plotting\_data.drop(columns }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Braunkohle [MWh]\textquotesingle{}}\NormalTok{,  }\StringTok{\textquotesingle{}Steinkohle [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Erdgas [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Sonstige Konventionelle [MWh]\textquotesingle{}}\NormalTok{], inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{konventionelle }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Braunkohle [MWh]\textquotesingle{}}\NormalTok{,  }\StringTok{\textquotesingle{}Steinkohle [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Erdgas [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Sonstige Konventionelle [MWh]\textquotesingle{}}\NormalTok{]}
\NormalTok{plotting\_data[}\StringTok{"Konventionelle"}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung[konventionelle].}\BuiltInTok{sum}\NormalTok{(axis }\OperatorTok{=} \StringTok{\textquotesingle{}columns\textquotesingle{}}\NormalTok{)}

\CommentTok{\# rearrange columns, remove " [MWh]"}
\NormalTok{plotting\_data }\OperatorTok{=}\NormalTok{ plotting\_data[[}\StringTok{\textquotesingle{}Erneuerbare\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Pumpspeicher [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Konventionelle\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Kernenergie [MWh]\textquotesingle{}}\NormalTok{]]}
\NormalTok{plotting\_data.columns }\OperatorTok{=}\NormalTok{ plotting\_data.columns.}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{" [MWh]"}\NormalTok{, repl }\OperatorTok{=} \StringTok{""}\NormalTok{)}

\CommentTok{\# zur Kontrolle {-} axis = columns addiert die Spalten zeilenweise}
\CommentTok{\#\# print(erneuerbare)}
\CommentTok{\#\# print(erzeugung[erneuerbare].sum(axis = \textquotesingle{}columns\textquotesingle{}))}
\CommentTok{\#\# print(plotting\_data.columns)}
\CommentTok{\#\# print(plotting\_data[0:3])}

\CommentTok{\# Grafik mit drei subplots erzeugen}
\NormalTok{plt.figure(figsize }\OperatorTok{=}\NormalTok{ (}\FloatTok{7.5}\NormalTok{, }\FloatTok{7.5}\NormalTok{))}

\NormalTok{nrows }\OperatorTok{=} \DecValTok{4}
\NormalTok{ncols }\OperatorTok{=} \DecValTok{2}
\NormalTok{font\_size }\OperatorTok{=} \DecValTok{8}

\CommentTok{\# value for shared x{-}axis on barplots}
\NormalTok{x\_lim }\OperatorTok{=}\NormalTok{ erzeugung.}\BuiltInTok{sum}\NormalTok{(numeric\_only }\OperatorTok{=} \VariableTok{True}\NormalTok{).}\BuiltInTok{max}\NormalTok{() }\OperatorTok{*} \FloatTok{1.1}

\CommentTok{\# array of colors}
\NormalTok{my\_colors }\OperatorTok{=}\NormalTok{ plt.get\_cmap(}\StringTok{\textquotesingle{}Blues\textquotesingle{}}\NormalTok{)(np.linspace(}\FloatTok{0.2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\BuiltInTok{len}\NormalTok{(plotting\_data.}\BuiltInTok{sum}\NormalTok{())))}

\CommentTok{\# plot the pie, use 4 out of 8 panels = middle 2 rows}
\NormalTok{ax }\OperatorTok{=}\NormalTok{ plt.subplot(nrows, ncols, (}\DecValTok{3}\NormalTok{, }\DecValTok{6}\NormalTok{))}
\NormalTok{plt.pie(x }\OperatorTok{=}\NormalTok{ plotting\_data.}\BuiltInTok{sum}\NormalTok{(), colors }\OperatorTok{=}\NormalTok{ my\_colors, startangle }\OperatorTok{=} \DecValTok{350}\NormalTok{, labels }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(plotting\_data.columns), autopct}\OperatorTok{=}\StringTok{\textquotesingle{}}\SpecialCharTok{\%1.1f\%\%}\StringTok{\textquotesingle{}}\NormalTok{, pctdistance }\OperatorTok{=} \FloatTok{0.5}\NormalTok{, textprops }\OperatorTok{=} \BuiltInTok{dict}\NormalTok{(size }\OperatorTok{=}\NormalTok{ font\_size }\OperatorTok{+} \DecValTok{1}\NormalTok{), wedgeprops }\OperatorTok{=}\NormalTok{ \{}\StringTok{"linewidth"}\NormalTok{: }\FloatTok{0.5}\NormalTok{, }\StringTok{"edgecolor"}\NormalTok{: }\StringTok{"white"}\NormalTok{\})}

\CommentTok{\# make a donut}
\NormalTok{circle }\OperatorTok{=}\NormalTok{ plt.Circle((}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{), radius }\OperatorTok{=} \FloatTok{0.65}\NormalTok{, color }\OperatorTok{=} \StringTok{"white"}\NormalTok{)}
\NormalTok{ax.add\_patch(circle)}

\CommentTok{\# top row unstacked barplot }
\NormalTok{plt.subplot(nrows, ncols, (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\NormalTok{erzeugung[erneuerbare].}\BuiltInTok{sum}\NormalTok{().sort\_values(ascending }\OperatorTok{=} \VariableTok{False}\NormalTok{).plot.barh(fontsize }\OperatorTok{=}\NormalTok{ font\_size, xlim }\OperatorTok{=}\NormalTok{ (}\DecValTok{0}\NormalTok{, x\_lim), color }\OperatorTok{=}\NormalTok{ my\_colors[}\DecValTok{0}\NormalTok{], edgecolor }\OperatorTok{=} \StringTok{\textquotesingle{}darkgrey\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{"Erneuerbare"}\NormalTok{, fontsize }\OperatorTok{=}\NormalTok{ font\_size }\OperatorTok{+} \DecValTok{2}\NormalTok{)}

\CommentTok{\# bottom row unstacked barplot }
\NormalTok{plt.subplot(nrows, ncols, (}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{))}
\NormalTok{erzeugung[konventionelle].}\BuiltInTok{sum}\NormalTok{().sort\_values(ascending }\OperatorTok{=} \VariableTok{False}\NormalTok{).plot.barh(fontsize }\OperatorTok{=}\NormalTok{ font\_size, xlim }\OperatorTok{=}\NormalTok{ (}\DecValTok{0}\NormalTok{, x\_lim), color }\OperatorTok{=}\NormalTok{ my\_colors[}\DecValTok{2}\NormalTok{], edgecolor }\OperatorTok{=} \StringTok{\textquotesingle{}darkgrey\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.title(}\StringTok{"Konventionelle"}\NormalTok{, fontsize }\OperatorTok{=}\NormalTok{ font\_size }\OperatorTok{+} \DecValTok{2}\NormalTok{)}

\NormalTok{plt.tight\_layout()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

~

Durch die Aggregation ähnlicher Stromerzeugungsarten wurde das
Ringdiagramm auf vier Erzeugungsarten reduziert. Die mit nur geringen
Anteilen an der Gesamtstromerzeugung beteiligten Erzeugungsarten
Pumpspeicher und Kernenergie treten dadurch gegenüber der
Einzeldarstellung aller Erzeugungsarten deutlich hervor. Auf dieser
Grundlage kann diskutiert werden, ob die gezeigte Aggregation zweckmäßig
ist. So könnte einerseits die Kernenergie den Konventionellen
zugeschlagen werden, wenn für diese Gruppe nicht auf das Merkmal einer
Erzeugung mit fossilen Brennstoffen, sondern auf das Prinzip thermischer
Dampfexpansion abgestellt wird. Andererseits sollte die Erzeugung durch
Pumpspeicher kritisch hinterfragt werden. Dieser Aspekt wird im
folgenden Abschnitt diskutiert.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-komplexe-grafiken} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-komplexe-grafiken}: Hinweis}\vspace{3mm}

Komplexe Grafiken, wie die hier gezeigte, sollten im Allgemeinen sparsam
eingesetzt werden, da sie schwer zu erfassen und zu interpretieren sind.
Die Zweck der Grafik und die wesentlichen Schlussfolgerungen sollten
deshalb im Text erläutert werden.

Tipp: Stellen Sie sich vor, Sie würden die Grafik spontan einem:einer
Freund:in zeigen, die Ihre Arbeit nicht gelesen hat. Wie würden Sie
Ihrer:Ihrem Freund:in die Grafik erklären? Schreiben Sie es in Ihrer
Arbeit auf.

\end{minipage}%
\end{tcolorbox}

\subsection{Erzeugung, Speicherung,
Einspeisung}\label{erzeugung-speicherung-einspeisung}

Pumpspeicherkraftwerke sind Energiespeicher, die keine Primärenergie
erzeugen, sondern den von anderen Erzeugern produzierten Strom speichern
und bei Bedarf wieder ins Netz einspeisen. Welche Erzeuger Strom zum
Befüllen der Pumpspeicher lieferten, wird in
Chapter~\ref{sec-explorative-datenanalyse} untersucht. Die realisierte
Netzeinspeisung von Pumpspeicherkraftwerken entspricht der um die
Verluste beim Ein- und Ausspeichern (sowie ggf. Speicherverluste wie
Verdunstung, Versickerung) verminderten Energieerzeugung anderer
Stromerzeuger. Der Wirkungsgrad der Pumpspeicherkraftwerke kann mit den
vorliegenden Daten für das Jahr 2023 berechnet werden.\\
\textbf{Wie hoch war der Wirkungsgrad der Pumpspeicherkraftwerke 2023?}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-wirkungsgrad-pumpspeicher}: Lösung Wirkungsgrad Pumpspeicher}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-wirkungsgrad-pumpspeicher} 

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Summe Erzeugung Pumpspeicher: }\SpecialCharTok{\{}\NormalTok{erzeugung[}\StringTok{"Pumpspeicher [MWh]"}\NormalTok{]}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Summe Verbrauch Pumpspeicher: }\SpecialCharTok{\{}\NormalTok{verbrauch[}\StringTok{"Pumpspeicher [MWh]"}\NormalTok{]}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"}\SpecialCharTok{\{}\DecValTok{41} \OperatorTok{*} \StringTok{"="}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Wirkungsgrad in Prozent: }\CharTok{\textbackslash{}t\textbackslash{}t\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{( erzeugung[}\StringTok{"Pumpspeicher [MWh]"}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ verbrauch[}\StringTok{"Pumpspeicher [MWh]"}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() ) }\OperatorTok{*} \DecValTok{100}\SpecialCharTok{:,.2f\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Summe Erzeugung Pumpspeicher: 11,149,398.50
Summe Verbrauch Pumpspeicher: 14,095,632.75
=========================================
Wirkungsgrad in Prozent:            79.10
\end{verbatim}

\end{tcolorbox}

Die tatsächlich realisierte Stromerzeugung ist deshalb die von der
Bundesnetzagentur veröffentlichte kumulierte Stromerzeugung der
Pumpspeicherkraftwerke zuzüglich der Speicherverluste. Die
Bundesnetzagentur führt diesen Wert im Datensatz Stromverbrauch. Im
folgenden Programmcode wird der ``Walross''-Operator \texttt{:=}
benutzt, der Objektzuweisungen innerhalb von Anweisungen (hier die
Anweisung print()) erlaubt. Dadurch Code knapper gefasst werden (die
Lesbarkeit nimmt aber ab). Mit dem Walross-Operator durchgeführte
Zuweisungen müssen in runde Klammern eingefasst werden:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Speicherverluste:}\CharTok{\textbackslash{}t\textbackslash{}t\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{ (speicherverluste }\OperatorTok{:=}\NormalTok{ ( verbrauch[}\StringTok{"Pumpspeicher [MWh]"}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{{-}}\NormalTok{ erzeugung[}\StringTok{"Pumpspeicher [MWh]"}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() ) }\OperatorTok{/}\NormalTok{ (}\DecValTok{1000} \OperatorTok{*} \DecValTok{1000}\NormalTok{) )}\SpecialCharTok{:\textgreater{}6.2f\}}\SpecialStringTok{ TWh}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"kumulierte Stromerzeugung:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{ ( kumulierte\_erzeugung }\OperatorTok{:=}\NormalTok{ erzeugung.}\BuiltInTok{sum}\NormalTok{(numeric\_only }\OperatorTok{=} \VariableTok{True}\NormalTok{).}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{//}\NormalTok{ (}\DecValTok{1000} \OperatorTok{*} \DecValTok{1000}\NormalTok{) )}\SpecialCharTok{:,.2f\}}\SpecialStringTok{ TWh}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Summe:}\CharTok{\textbackslash{}t\textbackslash{}t\textbackslash{}t\textbackslash{}t\textbackslash{}t\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{speicherverluste }\OperatorTok{+}\NormalTok{ kumulierte\_erzeugung}\SpecialCharTok{:,.2f\}}\SpecialStringTok{ TWh}\CharTok{\textbackslash{}n\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Speicherverluste:             2.95 TWh
kumulierte Stromerzeugung:  448.00 TWh
Summe:                      450.95 TWh

\end{verbatim}

Die Differenz zwischen tatsächlich realisierter und von der
Bundesnetzagentur veröffentlichter Stromerzeugung beträgt knapp 3 TWh,
also weniger als 1 Prozent der Gesamtstromerzeugung. In anderen Ländern
ist die korrekte Zuordnung der Daten auch betragsmäßig relevant. In
Österreich spielen Pumpspeicherkraftwerke eine bedeutende Rolle im
Strommix.

\section{Aufgabe beschreibende
Datenanalyse}\label{sec-aufgabe-beschreibende-Datenanalyse}

\begin{figure}[H]

{\centering \includegraphics[width=0.8\linewidth,height=\textheight,keepaspectratio]{books/a-energiedatenanalyse/skript/00-bilder/Schlegeisspeicher_von_Friesenberghaus_von_Klaus_Kettner_CC_BY-SA_3.0.png}

}

\caption{~}

\end{figure}%

Blick vom Schlegeisspeicher von Höhenweg aus. von Klaus Kettner steht
unter der Lizenz
\href{https://creativecommons.org/licenses/by-sa/3.0/deed.de}{CC BY-SA
3.0} und ist abrufbar auf
\href{https://commons.wikimedia.org/w/index.php?curid=20380105}{Wikimedia}.
Das Bild wurde zugeschnitten und im Format PNG gespeichert. 2012.

~

Wie die Bundesnetzagentur veröffentlicht auch die Austrian Power Grid AG
(APG) Strommarktdaten unter
\href{https://markttransparenz.apg.at/de/markt/Markttransparenz/erzeugung/Erzeugung-pro-Typ}{https://markttransparenz.apg.at/}.
Unter dem Link können Erzeugungsdaten für das Jahr 2023 heruntergeladen
werden.

Diesem Skript ist folgende Datei angefügt.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Daten
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Dateiname
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Realisierte Stromerzeugung 2023 &
AGPT\_2022-12-31T23\_00\_00Z\_2023-12-31T23\_00\_00Z\_15M\_de\_2024-06-10T09\_32\_38Z.csv \\
\end{longtable}

~

\textbf{Lesen Sie die österreichischen Erzeugungsdaten ein und
visualisieren Sie die Anteile der Erzeugungstypen. Was fällt Ihnen im
Datensatz auf?}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-Strommarkt-Austria} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-Strommarkt-Austria}: Markttranzparenzdaten Österreich herunterladen}\vspace{3mm}

Nach der Auswahl des Zeitraums auf Exportieren klicken, dann erscheint
die Schaltfläche Download.

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/00-bilder/APG-erzeugungsdaten-2023-de.png}}

}

\caption{~}

\end{figure}%

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/00-bilder/english/APG-generation-data-2023-en.png}}

}

\caption{~}

\end{figure}%

Das Datumsformat der Dateien ist abhängig von der auf der Internetseite
eingestellten Sprache (Deutsch/English).

\end{minipage}%
\end{tcolorbox}

~

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-Austria}: Tipp Erzeugungsdaten und Musterlösung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-Austria} 

Der österreichische Datensatz unterscheidet sich zum einen dadurch, dass
die Leistung statt der erzeugten Energie angegeben wird. (Das ist für
die Visualisierung der Erzeugungsanteile unerheblich.) Der Datensatz
unterscheidet sich aber noch in einer anderen Hinsicht.

Tipp: Wenn Ihnen in der Ausgabe der Methode \texttt{.describe()} nicht
alle Spalten angezeigt werden, versuchen Sie, den DataFrame in zwei oder
mehr Teilen auszugeben. Beispielsweise:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(df.iloc[ :, }\DecValTok{0}\NormalTok{:}\DecValTok{5}\NormalTok{].describe(include }\OperatorTok{=}\NormalTok{ np.number))}
\BuiltInTok{print}\NormalTok{(df.iloc[ :, }\DecValTok{5}\NormalTok{:}\DecValTok{10}\NormalTok{].describe(include }\OperatorTok{=}\NormalTok{ np.number))}
\BuiltInTok{print}\NormalTok{(df.iloc[ :, }\DecValTok{10}\NormalTok{:}\DecValTok{15}\NormalTok{].describe(include }\OperatorTok{=}\NormalTok{ np.number))}
\end{Highlighting}
\end{Shaded}

\begin{quote}
\textbf{Musterlösung Strommarktdaten Österreich}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\CommentTok{\# Deklarieren der Anzahl der Nachkommastellen}
\NormalTok{pd.set\_option(}\StringTok{"display.precision"}\NormalTok{, }\DecValTok{2}\NormalTok{)}

\CommentTok{\# Datensatz wird eingelesen und in der Variable erzeugung0 gespeichert}

\CommentTok{\# !}
\CommentTok{\# Für die eigene Anwendung muss der Dateipfad an den korrekten Speicherort der runtergeladenen .csv Datei angepasst werden. }
\CommentTok{\# !}

\NormalTok{erzeugung0\_austria\_ms }\OperatorTok{=}\NormalTok{ pd.read\_csv(}\StringTok{"01{-}daten/AGPT\_2022{-}12{-}31T23\_00\_00Z\_2023{-}12{-}31T23\_00\_00Z\_15M\_de\_2024{-}06{-}10T09\_32\_38Z.csv"}\NormalTok{, }
\NormalTok{                                     sep }\OperatorTok{=} \StringTok{";"}\NormalTok{, thousands }\OperatorTok{=} \StringTok{"."}\NormalTok{, decimal }\OperatorTok{=} \StringTok{","}\NormalTok{, parse\_dates }\OperatorTok{=}\NormalTok{ [}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{], date\_format }\OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(erzeugung0\_austria\_ms.head(}\DecValTok{10}\NormalTok{))}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Der DataFrame erzeugung\_austria\_ms hat }\SpecialCharTok{\{}\NormalTok{erzeugung0\_austria\_ms}\SpecialCharTok{.}\NormalTok{shape[}\DecValTok{0}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{ Zeilen und }\SpecialCharTok{\{}\NormalTok{erzeugung0\_austria\_ms}\SpecialCharTok{.}\NormalTok{shape[}\DecValTok{1}\NormalTok{]}\SpecialCharTok{\}}\SpecialStringTok{ Spalten."}\NormalTok{)}

\CommentTok{\# Eckdaten des Datensatzes werden kurz "zusammengefasst"}
\BuiltInTok{print}\NormalTok{(erzeugung0\_austria\_ms.describe(include }\OperatorTok{=}\NormalTok{ [np.number]))}
\CommentTok{\# Da der Datensatz relativ viele Spalten besitzt, können möglicherweise (je nach Bildschirmauflösung) nicht alle Spalten im Terminal angezeigt werden}
\CommentTok{\# und die mittleren werden daher mit "..." abgekürzt.}
\CommentTok{\# In dem Fall müssen die Spalten passend unterteilt werden, sodass man sich mit der Methode .describe() auch wirklich alle Spalten anschauen und beschreiben lassen kann:}
\BuiltInTok{print}\NormalTok{(erzeugung0\_austria\_ms.iloc[:, }\DecValTok{0}\NormalTok{:}\DecValTok{5}\NormalTok{].describe(include}\OperatorTok{=}\NormalTok{[np.number]))}
\BuiltInTok{print}\NormalTok{(erzeugung0\_austria\_ms.iloc[:, }\DecValTok{5}\NormalTok{:}\DecValTok{10}\NormalTok{].describe(include}\OperatorTok{=}\NormalTok{[np.number]))}
\BuiltInTok{print}\NormalTok{(erzeugung0\_austria\_ms.iloc[:, }\DecValTok{10}\NormalTok{:}\DecValTok{15}\NormalTok{].describe(include}\OperatorTok{=}\NormalTok{[np.number]))}

\CommentTok{\# Kopie des Datensatzes wird angelegt}
\NormalTok{erzeugung\_austria\_ms\_c }\OperatorTok{=}\NormalTok{ erzeugung0\_austria\_ms}

\CommentTok{\# Spalten mit den Uhrzeitdaten werden gelöscht}
\NormalTok{erzeugung\_austria\_ms\_c }\OperatorTok{=}\NormalTok{ erzeugung\_austria\_ms\_c.drop(columns}\OperatorTok{=}\NormalTok{[}\StringTok{"Zeit von [CET/CEST]"}\NormalTok{,}\StringTok{"Zeit bis [CET/CEST]"}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(erzeugung\_austria\_ms\_c.head(}\DecValTok{5}\NormalTok{))}
\CommentTok{\# Die Zeichenkette "[MW]" wird aus den Spalten entfernt}
\NormalTok{erzeugung\_austria\_ms\_c.columns }\OperatorTok{=}\NormalTok{ erzeugung\_austria\_ms\_c.columns.}\BuiltInTok{str}\NormalTok{.replace(pat}\OperatorTok{=}\StringTok{" [MW]"}\NormalTok{, repl}\OperatorTok{=}\StringTok{""}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(erzeugung\_austria\_ms\_c.head(}\DecValTok{5}\NormalTok{))}

\CommentTok{\# mögliche Plausibilisierung: die .csv Datei in Excel ansehen. Es sollte auffallen, dass sich in der Spalte der Pumpspeicher sowohl}
\CommentTok{\# Positiv{-} als auch Negativwerte befinden. Sieht man auch, wenn man genau auf die beschriebenen Werte der .describe() Methode achtet}
\CommentTok{\# Nun wird geprüft, ob sich negative Werte in den Erzeugungsleistungen befinden:}
\NormalTok{check\_minus\_werte }\OperatorTok{=}\NormalTok{ (erzeugung\_austria\_ms\_c }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{).}\BuiltInTok{any}\NormalTok{().}\BuiltInTok{any}\NormalTok{()}
\ControlFlowTok{if}\NormalTok{ check\_minus\_werte }\OperatorTok{==} \VariableTok{True}\NormalTok{:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"FEHLER: Es befinden sich negative Werte unter den Erzeugungswerten."}\NormalTok{)}

\CommentTok{\# negative Werte in der Spalte "Pumpspeicher" werden auf 0 gesetzt}
\NormalTok{erzeugung\_austria\_ms\_c[}\StringTok{"Pumpspeicher"}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung\_austria\_ms\_c[}\StringTok{"Pumpspeicher"}\NormalTok{].clip(lower}\OperatorTok{=}\DecValTok{0}\NormalTok{)}

\CommentTok{\# Spalten mit Summe 0 entfernen}
\CommentTok{\# Ansatz: Jede Spalte wird darauf geprüft, ob die Summe ihrer Werte Null ist. Falls ja, wird diese Spalte mit der .drop Methode aus dem neuen Dataframe gelöscht}
\CommentTok{\# dadurch verschwinden 3 Spalten mit der Summe Null. Geothermie wird immer noch als 0,0 \% angezeigt, da der Wert sehr klein ist (nicht erkennbar bei einer Nachkommastelle)}
\NormalTok{spalten\_weg }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ erzeugung\_austria\_ms\_c.columns:}
    \ControlFlowTok{if}\NormalTok{ erzeugung\_austria\_ms\_c[i].}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{==} \DecValTok{0}\NormalTok{:}
\NormalTok{        spalten\_weg.append(i)}
\NormalTok{erzeugung\_austria\_ms\_c }\OperatorTok{=}\NormalTok{ erzeugung\_austria\_ms\_c.drop(columns}\OperatorTok{=}\NormalTok{spalten\_weg)}
\BuiltInTok{print}\NormalTok{(erzeugung\_austria\_ms\_c.head(}\DecValTok{10}\NormalTok{))}

\CommentTok{\# um die Lesbarkeit der sehr kleinen Teilstücke des Kreisdiagramms zu verbessern, werden die Segmente anders angeordnet.}
\CommentTok{\# Dafür wird die Reihenfolgeder Spalten im Dataframe umsortiert, sodass das größte Segment auf das kleinste Segment der Liste folgt, und so weiter}
\NormalTok{sortierte\_spalten }\OperatorTok{=}\NormalTok{ erzeugung\_austria\_ms\_c.}\BuiltInTok{sum}\NormalTok{().sort\_values().index}

\NormalTok{neue\_reihenfolge }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(sortierte\_spalten) }\OperatorTok{//} \DecValTok{2}\NormalTok{):}
\NormalTok{    neue\_reihenfolge.append(sortierte\_spalten[i])}
\NormalTok{    neue\_reihenfolge.append(sortierte\_spalten[}\OperatorTok{{-}}\NormalTok{(i}\OperatorTok{+}\DecValTok{1}\NormalTok{)])}

\CommentTok{\# falls eine ungerade Anzahl an Spalten existiert:}
\ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(sortierte\_spalten) }\OperatorTok{\%} \DecValTok{2} \OperatorTok{!=} \DecValTok{0}\NormalTok{:}
\NormalTok{    neue\_reihenfolge.append(sortierte\_spalten[}\BuiltInTok{len}\NormalTok{(sortierte\_spalten) }\OperatorTok{//} \DecValTok{2}\NormalTok{])}

\NormalTok{erzeugung\_austria\_ms\_c }\OperatorTok{=}\NormalTok{ erzeugung\_austria\_ms\_c[neue\_reihenfolge]}

\NormalTok{plt.figure(figsize }\OperatorTok{=}\NormalTok{ (}\DecValTok{7}\NormalTok{, }\DecValTok{7}\NormalTok{))}
\NormalTok{new\_plot }\OperatorTok{=}\NormalTok{ erzeugung\_austria\_ms\_c.}\BuiltInTok{sum}\NormalTok{(numeric\_only}\OperatorTok{=}\VariableTok{True}\NormalTok{).plot.pie(colormap }\OperatorTok{=} \StringTok{"Blues"}\NormalTok{, startangle}\OperatorTok{=}\DecValTok{90}\NormalTok{, rotatelabels}\OperatorTok{=}\VariableTok{False}\NormalTok{, wedgeprops }\OperatorTok{=}\NormalTok{ \{}\StringTok{"linewidth"}\NormalTok{:}\DecValTok{1}\NormalTok{, }\StringTok{"edgecolor"}\NormalTok{:}\StringTok{"white"}\NormalTok{\}, autopct}\OperatorTok{=}\StringTok{\textquotesingle{}}\SpecialCharTok{\%1.1f\%\%}\StringTok{\textquotesingle{}}\NormalTok{, pctdistance}\OperatorTok{=}\FloatTok{0.6}\NormalTok{, textprops}\OperatorTok{=}\BuiltInTok{dict}\NormalTok{(size}\OperatorTok{=}\DecValTok{7}\NormalTok{))}

\CommentTok{\# make a donut}
\NormalTok{circle }\OperatorTok{=}\NormalTok{ plt.Circle((}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{), radius }\OperatorTok{=} \FloatTok{0.7}\NormalTok{, color }\OperatorTok{=} \StringTok{"white"}\NormalTok{)}
\NormalTok{new\_plot.add\_patch(circle)}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   Zeit von [CET/CEST]  Zeit bis [CET/CEST]  Wind [MW]  Solar [MW]  \
0  01.01.2023 00:00:00  01.01.2023 00:15:00     1000.0         0.0   
1  01.01.2023 00:15:00  01.01.2023 00:30:00      964.0         0.0   
2  01.01.2023 00:30:00  01.01.2023 00:45:00      956.0         0.0   
3  01.01.2023 00:45:00  01.01.2023 01:00:00      992.0         0.0   
4  01.01.2023 01:00:00  01.01.2023 01:15:00      880.0         0.0   
5  01.01.2023 01:15:00  01.01.2023 01:30:00      888.0         0.0   
6  01.01.2023 01:30:00  01.01.2023 01:45:00      948.0         0.0   
7  01.01.2023 01:45:00  01.01.2023 02:00:00      968.0         0.0   
8  01.01.2023 02:00:00  01.01.2023 02:15:00      956.0         0.0   
9  01.01.2023 02:15:00  01.01.2023 02:30:00      952.0         0.0   

   Biomasse [MW]  Gas [MW]  Kohle [MW]  Öl [MW]  Geothermie [MW]  \
0          240.0      27.6         0.0      0.0             0.07   
1          240.0      27.6         0.0      0.0             0.07   
2          240.0      28.0         0.0      0.0             0.07   
3          240.0      27.6         0.0      0.0             0.07   
4          240.0      27.6         0.0      0.0             0.07   
5          240.0      28.4         0.0      0.0             0.07   
6          240.0      28.8         0.0      0.0             0.07   
7          240.0      28.0         0.0      0.0             0.07   
8          240.0      28.8         0.0      0.0             0.07   
9          240.0      28.4         0.0      0.0             0.07   

   Pumpspeicher [MW]  Lauf- und Schwellwasser [MW]  Speicher [MW]  \
0            -1404.8                        2291.6           70.4   
1            -1532.8                        2283.2           66.8   
2            -1544.4                        2240.0          100.4   
3            -1579.6                        2199.6           77.6   
4            -1590.8                        2234.8           63.2   
5            -1602.8                        2229.2           73.6   
6            -1572.0                        2211.2           69.2   
7            -1579.2                        2194.8           70.8   
8            -1649.6                        2202.8           75.2   
9            -1702.0                        2172.4           65.6   

   Sonstige Erneuerbare [MW]  Müll [MW]  Andere [MW]  
0                        0.0      100.0         22.0  
1                        0.0      100.0         22.0  
2                        0.0      100.0         22.0  
3                        0.0      100.0         22.0  
4                        0.0      100.0         22.0  
5                        0.0      100.0         22.0  
6                        0.0      100.0         22.0  
7                        0.0      100.0         22.0  
8                        0.0      100.0         22.0  
9                        0.0      100.0         22.0  
Der DataFrame erzeugung_austria_ms hat 35040 Zeilen und 15 Spalten.
       Wind [MW]  Solar [MW]  Biomasse [MW]  Gas [MW]  Kohle [MW]  Öl [MW]  \
count   35040.00    35040.00       35040.00  35040.00     35040.0  35040.0   
mean      942.84      268.01         159.94    736.68         0.0      0.0   
std       884.56      421.28          64.30    799.65         0.0      0.0   
min         4.00        0.00          52.00      0.00         0.0      0.0   
25%       204.00        0.00         100.00      0.40         0.0      0.0   
50%       644.00       20.00         156.00    472.00         0.0      0.0   
75%      1484.00      392.00         216.00   1273.60         0.0      0.0   
max      3400.00     2028.00         312.00   3599.60         0.0      0.0   

       Geothermie [MW]  Pumpspeicher [MW]  Lauf- und Schwellwasser [MW]  \
count         3.50e+04           35040.00                      35040.00   
mean          7.20e-02             283.53                       3477.12   
std           1.39e-17            1101.68                       1032.45   
min           7.20e-02           -2082.80                       1375.60   
25%           7.20e-02            -451.20                       2591.60   
50%           7.20e-02             181.60                       3516.00   
75%           7.20e-02            1010.40                       4131.20   
max           7.20e-02            3160.80                       6290.40   

       Speicher [MW]  Sonstige Erneuerbare [MW]  Müll [MW]  Andere [MW]  
count       35040.00                    35040.0    35040.0      35040.0  
mean          488.40                        0.0      100.0         22.0  
std           301.89                        0.0        0.0          0.0  
min            16.00                        0.0      100.0         22.0  
25%           248.00                        0.0      100.0         22.0  
50%           424.40                        0.0      100.0         22.0  
75%           686.00                        0.0      100.0         22.0  
max          1434.40                        0.0      100.0         22.0  
       Wind [MW]  Solar [MW]  Biomasse [MW]
count   35040.00    35040.00       35040.00
mean      942.84      268.01         159.94
std       884.56      421.28          64.30
min         4.00        0.00          52.00
25%       204.00        0.00         100.00
50%       644.00       20.00         156.00
75%      1484.00      392.00         216.00
max      3400.00     2028.00         312.00
       Gas [MW]  Kohle [MW]  Öl [MW]  Geothermie [MW]  Pumpspeicher [MW]
count  35040.00     35040.0  35040.0         3.50e+04           35040.00
mean     736.68         0.0      0.0         7.20e-02             283.53
std      799.65         0.0      0.0         1.39e-17            1101.68
min        0.00         0.0      0.0         7.20e-02           -2082.80
25%        0.40         0.0      0.0         7.20e-02            -451.20
50%      472.00         0.0      0.0         7.20e-02             181.60
75%     1273.60         0.0      0.0         7.20e-02            1010.40
max     3599.60         0.0      0.0         7.20e-02            3160.80
       Lauf- und Schwellwasser [MW]  Speicher [MW]  Sonstige Erneuerbare [MW]  \
count                      35040.00       35040.00                    35040.0   
mean                        3477.12         488.40                        0.0   
std                         1032.45         301.89                        0.0   
min                         1375.60          16.00                        0.0   
25%                         2591.60         248.00                        0.0   
50%                         3516.00         424.40                        0.0   
75%                         4131.20         686.00                        0.0   
max                         6290.40        1434.40                        0.0   

       Müll [MW]  Andere [MW]  
count    35040.0      35040.0  
mean       100.0         22.0  
std          0.0          0.0  
min        100.0         22.0  
25%        100.0         22.0  
50%        100.0         22.0  
75%        100.0         22.0  
max        100.0         22.0  
   Wind [MW]  Solar [MW]  Biomasse [MW]  Gas [MW]  Kohle [MW]  Öl [MW]  \
0     1000.0         0.0          240.0      27.6         0.0      0.0   
1      964.0         0.0          240.0      27.6         0.0      0.0   
2      956.0         0.0          240.0      28.0         0.0      0.0   
3      992.0         0.0          240.0      27.6         0.0      0.0   
4      880.0         0.0          240.0      27.6         0.0      0.0   

   Geothermie [MW]  Pumpspeicher [MW]  Lauf- und Schwellwasser [MW]  \
0             0.07            -1404.8                        2291.6   
1             0.07            -1532.8                        2283.2   
2             0.07            -1544.4                        2240.0   
3             0.07            -1579.6                        2199.6   
4             0.07            -1590.8                        2234.8   

   Speicher [MW]  Sonstige Erneuerbare [MW]  Müll [MW]  Andere [MW]  
0           70.4                        0.0      100.0         22.0  
1           66.8                        0.0      100.0         22.0  
2          100.4                        0.0      100.0         22.0  
3           77.6                        0.0      100.0         22.0  
4           63.2                        0.0      100.0         22.0  
     Wind  Solar  Biomasse   Gas  Kohle   Öl  Geothermie  Pumpspeicher  \
0  1000.0    0.0     240.0  27.6    0.0  0.0        0.07       -1404.8   
1   964.0    0.0     240.0  27.6    0.0  0.0        0.07       -1532.8   
2   956.0    0.0     240.0  28.0    0.0  0.0        0.07       -1544.4   
3   992.0    0.0     240.0  27.6    0.0  0.0        0.07       -1579.6   
4   880.0    0.0     240.0  27.6    0.0  0.0        0.07       -1590.8   

   Lauf- und Schwellwasser  Speicher  Sonstige Erneuerbare   Müll  Andere  
0                   2291.6      70.4                   0.0  100.0    22.0  
1                   2283.2      66.8                   0.0  100.0    22.0  
2                   2240.0     100.4                   0.0  100.0    22.0  
3                   2199.6      77.6                   0.0  100.0    22.0  
4                   2234.8      63.2                   0.0  100.0    22.0  
FEHLER: Es befinden sich negative Werte unter den Erzeugungswerten.
     Wind  Solar  Biomasse   Gas  Geothermie  Pumpspeicher  \
0  1000.0    0.0     240.0  27.6        0.07           0.0   
1   964.0    0.0     240.0  27.6        0.07           0.0   
2   956.0    0.0     240.0  28.0        0.07           0.0   
3   992.0    0.0     240.0  27.6        0.07           0.0   
4   880.0    0.0     240.0  27.6        0.07           0.0   
5   888.0    0.0     240.0  28.4        0.07           0.0   
6   948.0    0.0     240.0  28.8        0.07           0.0   
7   968.0    0.0     240.0  28.0        0.07           0.0   
8   956.0    0.0     240.0  28.8        0.07           0.0   
9   952.0    0.0     240.0  28.4        0.07           0.0   

   Lauf- und Schwellwasser  Speicher   Müll  Andere  
0                   2291.6      70.4  100.0    22.0  
1                   2283.2      66.8  100.0    22.0  
2                   2240.0     100.4  100.0    22.0  
3                   2199.6      77.6  100.0    22.0  
4                   2234.8      63.2  100.0    22.0  
5                   2229.2      73.6  100.0    22.0  
6                   2211.2      69.2  100.0    22.0  
7                   2194.8      70.8  100.0    22.0  
8                   2202.8      75.2  100.0    22.0  
9                   2172.4      65.6  100.0    22.0  
\end{verbatim}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-18-output-2.png}}

}

\caption{Anteil an der Stromerzeugung in Österreich}

\end{figure}%

Musterlösung von Marc Sönnecken. Für die Kompatibilität mit diesem
Skript wurden der Dateipfad und die Objektbezeichnungen angepasst. Für
die Barrierefreiheit wurden die Grafikgröße geändert, die Farbpalette
geändert, ein weißer Innenkreis ergänzt und die Position der
Prozentwerte angepasst.
\end{quote}

\end{tcolorbox}

\chapter{Explorative Datenanalyse}\label{sec-explorative-datenanalyse}

Explorative Datenanalyse bedeutet, Fragen an die vorliegenden Daten zu
stellen und diese mittels datenanalytischer Methoden zu beantworten. Die
so gewonnenen Erkenntnisse können helfen, die Fragen zu verfeinern oder
neue Fragen zu generieren. Es handelt sich also um einen iterativen
Prozess. Dadurch soll vor allem ein tieferes Verständnis der Daten
gewonnen werden. {[}@R-for-Data-Science, Kapitel 10 Exploratory data
analysis{]}

\section{Hintergrund:
Grenzstromanalyse}\label{hintergrund-grenzstromanalyse}

Im vorliegenden Fall wird die explorative Auseinandersetzung mit dem
Datensatz von der Frage strukturiert, welche Erzeuger Strom lieferten,
um \emph{zusätzlich} zur Netzlast die Pumpspeicher zu befüllen. Es soll
also bestimmt werden, welche Stromerzeuger an den Zeitpunkten, an denen
die Pumpspeicher befüllt wurden, in der Lage waren, zusätzliche Leistung
bereitzustellen. Dieser zusätzliche Strom kann kurz als Grenzstrom
bezeichnet werden.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-Grenzstrom}: Grenzstrom}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-Grenzstrom} 

Grenzbetrachtungen untersuchen die Bedingungen, die bei der Produktion
oder dem Verbrauch einer zusätzlichen Einheit herrschen. Eine
Grenzbetrachtung unterscheidet sich dadurch von einer
Durchschnittsbetrachtung, die den Effekt einer Mengenänderung auf alle
Einheiten untersucht. Der Grenzstrom bezeichnet eine zusätzliche Einheit
Strom.

Beispielsweise bestehe die momentane Stromerzeugung in Höhe von 100
Einheiten aus 60 Einheiten Solarstrom und, weil die solare Produktion
nicht ausreicht, zusätzlich aus 40 Einheiten Kohlestrom. In diesem Fall
enthält jede Einheit Strom durchschnittlich 0,4 Anteile Kohlestrom.
Werden nun weitere 20 Einheiten Strom nachgefragt, so müssen diese durch
eine zusätzliche Kohleverstromung bedient werden. In der
Durchschnittsbetrachtung beträgt der Strommix nun aus 60 Einheiten
Solarstrom und 40 + 20 = 60 Einheiten Kohlestrom. Dadurch verändert sich
der durchschnittliche Anteil der Kohle an der Stromproduktion von 0,4
auf 0,5.

In der Grenzbetrachtung beträgt der Kohleanteil des zusätzlich
verbrauchten Stroms 20 von 20 Einheiten, also 1.

\end{tcolorbox}

\section{Hintergrund: Einspeisevorrang erneuerbarer
Energien}\label{hintergrund-einspeisevorrang-erneuerbarer-energien}

In Deutschland gilt seit dem Jahr 2000 das Erneuerbare-Energien-Gesetz,
das ursprünglich als Gesetz für den Vorrang Erneuerbarer Energien
eingeführt wurde
\href{https://dip.bundestag.de/vorgang/gesetz-f\%C3\%BCr-den-vorrang-erneuerbarer-energien-erneuerbare-energien-gesetz-eeg-sowie/111957}{Dokumentations-
und Informationssystem für Parlamentsmaterialien}. Dieses regelte in § 3
den Einspeisevorrang erneuerbarer Energien:

\begin{figure}

\begin{minipage}{0.05\linewidth}
~\end{minipage}%
%
\begin{minipage}{0.90\linewidth}
\textbf{Abnahme- und Vergütungspflicht}\\
(1) Netzbetreiber sind verpflichtet, Anlagen zur Erzeugung von Strom
nach § 2 an ihr Netz anzuschließen, den gesamten angebotenen Strom aus
diesen Anlagen vorrangig abzunehmen und den eingespeisten Strom nach §§
4 bis 8 zu vergüten.\end{minipage}%
%
\begin{minipage}{0.05\linewidth}
~\end{minipage}%
\newline
\begin{minipage}{\linewidth}
~\\
Gesetz für den Vorrang Erneuerbarer Energien
(Erneuerbare-Energien-Gesetz -- EEG) sowie zur Änderung des
Energiewirtschaftsgesetzes und des Mineralölsteuergesetzes.
Bundesgesetzblatt Jahrgang 2000 Teil I Nr. 13, ausgegeben zu Bonn am 31.
März 2000.
\href{https://www.bgbl.de/xaver/bgbl/start.xav?startbk=Bundesanzeiger_BGBl&start=//*\%5b@attr_id=\%27bgbl100s0305.pdf\%27\%5d\#__bgbl__\%2F\%2F*\%5B\%40attr_id\%3D\%27bgbl100s0305.pdf\%27\%5D__1718177313490}{Bundesanzeiger}\end{minipage}%

\end{figure}%

~

Als erneuerbare Energien klassifizierte Erzeuger speisen vorrangig in
das Netz ein. Dies sind nach der aktuellen Fassung des Gesetztes:

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\item
  Wasserkraft einschließlich der Wellen-, Gezeiten-, Salzgradienten- und
  Strömungsenergie,
\item
  Windenergie,
\item
  solare Strahlungsenergie,
\item
  Geothermie,
\item
  Energie aus Biomasse einschließlich Biogas, Biomethan, Deponiegas und
  Klärgas sowie aus dem biologisch abbaubaren Anteil von Abfällen aus
  Haushalten und Industrie
\end{enumerate}

Gesetz für den Ausbau erneuerbarer Energien (Erneuerbare-Energien-Gesetz
- EEG 2023). § 3 Begriffsbestimmungen.
\url{https://www.gesetze-im-internet.de/eeg_2014/__3.html}

~

Die nicht erneuerbaren Erzeuger arbeiten im Lastfolgebetrieb zur Deckung
der Restlast, das heißt der Netzlast abzüglich der erneuerbaren
Erzeugungsleistung. Dies bedeutet, dass zwei Szenarien zu unterscheiden
sind:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Überschuss an erneuerbaren Energien: Der Stromverbrauch wird
  vollständig durch die Erzeugung erneuerbarer Energien gedeckt und es
  besteht ein Erzeugungsüberschuss (bzw. Erzeuger wurden abgeregelt),
  aus dem zusätzlicher Stromverbrauch bedient werden kann.
\item
  Strommix aus erneuerbarer Einspeisung und Lastfolgebetrieb nicht
  erneuerbarer Erzeuger: Erneuerbare Energien speisen mit voller
  Leistung ein, die Restlast und zusätzlicher Stromverbrauch wird von
  nicht erneuerbaren Erzeugern gedeckt.
\end{enumerate}

Welches Szenario im Stromnetz zu einem bestimmten Zeitpunkt besteht,
lässt sich also an der Restlast ablesen.

\section{Residual- und Restlast
bestimmen}\label{residual--und-restlast-bestimmen}

Die Bundesnetzagentur veröffentlicht im Datensatz zum realisierten
Stromverbrauch Netzlast, Residuallast und den Stromverbrauch durch
Pumpspeicherkraftwerke.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(verbrauch.}\BuiltInTok{sum}\NormalTok{(numeric\_only }\OperatorTok{=} \VariableTok{True}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Gesamt (Netzlast) [MWh]    4.58e+08
Residuallast [MWh]         2.60e+08
Pumpspeicher [MWh]         1.41e+07
dtype: float64
\end{verbatim}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-Residuallast}: Residuallast}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-Residuallast} 

``Die Residuallast {[}\ldots{]} entspricht dem gesamten Realisierten
Stromverbrauch, abzüglich der Einspeisung von Photovoltaik-, Wind
Onshore- und Wind Offshore-Anlagen.''
\href{https://www.smard.de/resource/blob/212924/61a75e052eddb43a8d3cc4c6e1653fa3/smard-benutzerhandbuch-02-2024-data.pdf}{SMARD.de
Benutzerhandbuch (S. 53)}

\end{tcolorbox}

~

Die nicht durch erneuerbare Energien bediente Restlast ist die Differenz
aus Stromverbrauch und der Erzeugung durch erneuerbare Energien. Die
Restlast ist folglich kleiner als die von der Bundesnetzagentur
veröffentlichte Residuallast. Residual- und Restlast können aus der
Differenz von Netzlast und der entsprechenden erneuerbaren
Stromerzeugung berechnet werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{erneuerbare }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Biomasse [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wasserkraft [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Offshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Onshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Photovoltaik [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Sonstige Erneuerbare [MWh]\textquotesingle{}}\NormalTok{]}
\NormalTok{PV\_WindOnshore\_WindOffshore }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Wind Offshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Onshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Photovoltaik [MWh]\textquotesingle{}}\NormalTok{] }

\NormalTok{plotting\_data }\OperatorTok{=}\NormalTok{ pd.DataFrame()}
\NormalTok{plotting\_data[}\StringTok{"Netzlast [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ verbrauch[}\StringTok{"Gesamt (Netzlast) [MWh]"}\NormalTok{].copy() }
\NormalTok{plotting\_data[}\StringTok{"volatile EE [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung[PV\_WindOnshore\_WindOffshore].}\BuiltInTok{sum}\NormalTok{(axis }\OperatorTok{=} \StringTok{"columns"}\NormalTok{).copy()}
\NormalTok{plotting\_data[}\StringTok{"Erneuerbare [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung[erneuerbare].}\BuiltInTok{sum}\NormalTok{(axis }\OperatorTok{=} \StringTok{"columns"}\NormalTok{).copy()}

\NormalTok{plotting\_data[}\StringTok{"Residuallast BNetzA [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ verbrauch[}\StringTok{"Residuallast [MWh]"}\NormalTok{].copy()}
\NormalTok{plotting\_data[}\StringTok{"Residuallast [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ plotting\_data[}\StringTok{"Netzlast [MWh]"}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ plotting\_data[}\StringTok{"volatile EE [MWh]"}\NormalTok{]}
\NormalTok{plotting\_data[}\StringTok{"Restlast [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ plotting\_data[}\StringTok{"Netzlast [MWh]"}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ plotting\_data[}\StringTok{"Erneuerbare [MWh]"}\NormalTok{]}

\NormalTok{plotting\_data.head()}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}lllllll@{}}
\toprule\noalign{}
& Netzlast {[}MWh{]} & volatile EE {[}MWh{]} & Erneuerbare {[}MWh{]} &
Residuallast BNetzA {[}MWh{]} & Residuallast {[}MWh{]} & Restlast
{[}MWh{]} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 9720.75 & 7830.50 & 9277.00 & 1890.25 & 1890.25 & 443.75 \\
1 & 9641.25 & 7902.00 & 9343.00 & 1739.25 & 1739.25 & 298.25 \\
2 & 9609.50 & 8119.50 & 9559.50 & 1490.00 & 1490.00 & 50.00 \\
3 & 9565.00 & 7919.00 & 9362.25 & 1646.00 & 1646.00 & 202.75 \\
4 & 9473.50 & 8107.75 & 9540.50 & 1365.75 & 1365.75 & -67.00 \\
\end{longtable}

~

Die von der Bundesnetzagentur veröffentlichte Residuallast
\texttt{Residuallast\ BNetzA\ {[}MWh{]}} entspricht nach der Betrachtung
der ersten Zeilen der selbst berechneten Residuallast
\texttt{Residuallast\ {[}MWh{]}}. Ob dies für die gesamte Zeitreihe
gilt, kann leicht mit der Methode \texttt{pd.Series.equals()} überprüft
werden, die einen boolschen Wahrheitswert, d.~h. True oder False,
zurückgibt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plotting\_data[}\StringTok{\textquotesingle{}Residuallast BNetzA [MWh]\textquotesingle{}}\NormalTok{].equals(plotting\_data[}\StringTok{\textquotesingle{}Residuallast [MWh]\textquotesingle{}}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
True
\end{verbatim}

Somit kann die redundante Spalte entfernt werden.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plotting\_data.drop([}\StringTok{\textquotesingle{}Residuallast BNetzA [MWh]\textquotesingle{}}\NormalTok{], axis }\OperatorTok{=} \StringTok{\textquotesingle{}columns\textquotesingle{}}\NormalTok{, inplace }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\section{Jahresgang grafisch
darstellen}\label{jahresgang-grafisch-darstellen}

Die Netzlast, die Erzeugung durch erneuerbare Energien sowie die
Residual- und Restlast sollen im Jahresgang dargestellt werden. Zur
besseren Darstellung wird nur jeder 100. Wert eingezeichnet.

\section{Netzlast im Jahresgang}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-24-output-1.png}}

}

\caption{Netzlast im Jahresgang}

\end{figure}%

\section{Code für den Plot}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Position und Inhalt der x{-}Achsenbeschriftung finden}
\NormalTok{monate }\OperatorTok{=}\NormalTok{ erzeugung[}\StringTok{"Datum von"}\NormalTok{].dt.month.unique().tolist() }\CommentTok{\# gibt die Zahlen 1{-}12 aus}

\CommentTok{\#\# mit Pandas}
\NormalTok{monate\_index }\OperatorTok{=}\NormalTok{ erzeugung[}\OperatorTok{\textasciitilde{}}\NormalTok{erzeugung[}\StringTok{"Datum von"}\NormalTok{].dt.month.duplicated()].index}
\NormalTok{monatsnamen }\OperatorTok{=}\NormalTok{ erzeugung[}\StringTok{"Datum von"}\NormalTok{].iloc[monate\_index].dt.strftime(}\StringTok{"\%B"}\NormalTok{) }

\CommentTok{\#\# alternativ mit einer Listenoperation}
\CommentTok{\# monate\_index = []}
\CommentTok{\# monatsnamen = []}

\CommentTok{\# for i in monate:}
\CommentTok{\#   monate\_index.append(erzeugung.index[erzeugung["Datum von"].dt.month == i].min())}
\CommentTok{\#   monatsnamen.append(erzeugung["Datum von"].iloc[monate\_index[i {-} 1]].strftime("\%B"))}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# plotten jedes 100. Werts}
\NormalTok{plotting\_data[::}\DecValTok{100}\NormalTok{].plot(figsize }\OperatorTok{=}\NormalTok{ (}\DecValTok{9}\NormalTok{, }\DecValTok{8}\NormalTok{), subplots }\OperatorTok{=} \VariableTok{True}\NormalTok{, sharey }\OperatorTok{=} \VariableTok{True}\NormalTok{, xlim }\OperatorTok{=}\NormalTok{ (plotting\_data.index.}\BuiltInTok{min}\NormalTok{() }\OperatorTok{{-}}\NormalTok{ (}\BuiltInTok{len}\NormalTok{(plotting\_data.index) }\OperatorTok{/} \DecValTok{100}\NormalTok{), plotting\_data.index.}\BuiltInTok{max}\NormalTok{() }\OperatorTok{*} \FloatTok{1.01}\NormalTok{), rot }\OperatorTok{=} \DecValTok{45}\NormalTok{, grid }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{plt.ylim(top }\OperatorTok{=} \DecValTok{20000}\NormalTok{)}
\NormalTok{plt.minorticks\_off()}
\NormalTok{plt.xticks(monate\_index, monatsnamen)}\OperatorTok{;}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

Es ist zu erkennen, dass die Netzlast dauerhaft oberhalb von 9.000 MWh
liegt. Darüber hinausgehend schwankt die Netzlast im Monatsgang stark
und erreicht Werte von bis zu 19.000 MWh. In jedem Monat werden
Leistungen nahe des absoluten Minimums und Maximums erreicht. Im Sommer
ist die Netzlast im Allgemeinen etwas niedriger als im Winter.\\
Die Stromerzeugung durch erneuerbare Energien, die im zweiten subplot
(volatile EE {[}MWh{]}) dargestellt ist, ist stark volatil. Phasen hoher
Produktion wechseln sich mit Phasen geringer Produktion ab und dauern
jeweils nur einige Tage und höchstens für zwei Wochen an. Dies geht
maßgeblich auf die Stromerzeugung durch Photovoltaik und Off- und
Onshore Wind zurück, deren deutschlandweit kombinierte
Erzeugungsleistung häufig nahe Null liegt, um anschließend ein (lokales)
Produktionsmaximum zu erreichen. Im dritten subplot (Erneuerbare
{[}MWh{]}) ist zu erkennen, dass die zusätzliche Einspeisung weniger
volatiler erneuerbarer Energien wie Biomasse und Wasserkraft
vergleichsweise gering ist. Dadurch ist die über alle erneuerbaren
Erzeugungsformen summierte Stromerzeugung zwar nie Null, erreicht aber
häufig eine geringe Gesamtleistung. Gleichwohl gibt es auch kurze Phasen
erneuerbarer Vollversorgung bzw. Überschussproduktion, wie am Jahresgang
der nicht erneuerbaren Restlast abzulesen ist.

Für die Frage nach der Herkunft des in den Pumpspeicherkraftwerken
gespeicherten Stroms kann bereits durch die graphische Darstellung
gefolgert werden, dass dieser überwiegend durch nicht erneuerbare
Stromerzeuger erzeugt wurde, da die Restlast nur selten Null oder
negativ ist.

Der Jahresgang der Restlast gleicht dem Erzeugungsverlauf der volatilen
erneuerbaren Energien. Dies stellt für die konventionellen Kraftwerke
eine Herausforderung dar. Dieser Aspekt wird im nächsten Abschnitt
vertieft.

Zunächst aber eine kleine Aufgabe:\\
\textbf{Wie würde sich eine Verdopplung der erneuerbaren Erzeugung auf
die Restlast auswirken? Stellen Sie den Effekt auf vergleichbare Weise
grafisch dar (z. B. durch eine zusätzliche Spalte `Netzlast - 2x EE').}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-verdopplung-EE}: Musterlösung Verdopplung EE}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-verdopplung-EE} 

\section{Plot}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-27-output-1.png}}

}

\caption{Musterlösung Verdopplung EE}

\end{figure}%

\section{Code}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plotting\_data\_2EE }\OperatorTok{=}\NormalTok{ plotting\_data.copy()}
\NormalTok{plotting\_data\_2EE[}\StringTok{"2x EE"}\NormalTok{] }\OperatorTok{=}\NormalTok{ plotting\_data\_2EE[}\StringTok{"Erneuerbare [MWh]"}\NormalTok{] }\OperatorTok{*} \DecValTok{2}
\NormalTok{plotting\_data\_2EE[}\StringTok{"Netzlast {-} 2x EE"}\NormalTok{] }\OperatorTok{=}\NormalTok{ plotting\_data\_2EE[}\StringTok{"Netzlast [MWh]"}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ plotting\_data\_2EE[}\StringTok{"2x EE"}\NormalTok{]}
\NormalTok{plotting\_data\_2EE }\OperatorTok{=}\NormalTok{ plotting\_data\_2EE[[}\StringTok{"Netzlast [MWh]"}\NormalTok{, }\StringTok{"Netzlast {-} 2x EE"}\NormalTok{]]}

\CommentTok{\# plotten jedes 100. Werts}
\NormalTok{plotting\_data\_2EE[::}\DecValTok{100}\NormalTok{].plot(figsize }\OperatorTok{=}\NormalTok{ (}\DecValTok{9}\NormalTok{, }\DecValTok{6}\NormalTok{), subplots }\OperatorTok{=} \VariableTok{True}\NormalTok{, sharey }\OperatorTok{=} \VariableTok{True}\NormalTok{, xlim }\OperatorTok{=}\NormalTok{ (plotting\_data\_2EE.index.}\BuiltInTok{min}\NormalTok{() }\OperatorTok{{-}}\NormalTok{ (}\BuiltInTok{len}\NormalTok{(plotting\_data\_2EE.index)) }\OperatorTok{/} \DecValTok{100}\NormalTok{, plotting\_data\_2EE.index.}\BuiltInTok{max}\NormalTok{() }\OperatorTok{*} \FloatTok{1.01}\NormalTok{), rot }\OperatorTok{=} \DecValTok{45}\NormalTok{, grid }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{plt.minorticks\_off()}
\NormalTok{plt.xticks(monate\_index, monatsnamen)}\OperatorTok{;}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\section{Mögliche Interpretation}

Die Netzlast abzüglich der verdoppelten erneuerbaren Stromerzeugung
nähert sich einer symmetrischen Verteilung um die Nullinie an. Das
heißt, Phasen erneuerbarer Über- und Unterproduktion halten sich
ungefähr die Waage.

\end{tcolorbox}

\section{Hintergrund: Grund-, Mittel und
Spitzenlast}\label{hintergrund-grund--mittel-und-spitzenlast}

Nicht alle Erzeuer sind aus technischen oder aus wirtschaftlichen
Gründen gleichermaßen für den Lastfolgebetrieb geeignet. Beispielsweise
sind Kohlekraftwerke weniger flexibel regelbar als Gaskraftwerke.
Kernkraftwerke werden aufgrund ihrer hohen Fix- und geringen variablen
Kosten bevorzugt im Grundlastbetrieb betrieben. Im Stromnetz werden drei
Einsatzprofile für Kraftwerke unterschieden: Grundlast, Mittellast und
Spitzenlast.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-Grund-Mittel-Spitzenlast}: Grund-, Mittel- und Spitzenlast}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-Grund-Mittel-Spitzenlast} 

\begin{itemize}
\item
  Grundlast: Die im Jahresgang dauerhaft nachgefragte Leistung.\\
  Kraftwerkstypen: Braunkohle, Kernkraft, Laufwasser
\item
  Mittellast: Über die Grundlast hinausgehende, im Tages- und Jahresgang
  planbar nachgefragte Leistung.\\
  Kraftwerkstypen: Gas-und-Dampfturbinen-Kraftwerk, Steinkohle
\item
  Spitzenlast: Über die Mittellast hinausgehende, im Tages- und
  Jahresgang nur kurzzeitig oder ungeplant nachgefragte Leistung.\\
  Kraftwerkstypen: Gaskraftwerke, Pumpspeicherkraftwerke
\end{itemize}

ISPEX AG: \href{https://www.ispex.de/lexikon/grundlast/}{Grundlast},
\href{https://www.ispex.de/lexikon/mittellast/}{Mittellast},
\href{https://www.ispex.de/lexikon/spitzenlast/}{Spitzenlast}

Grünwald, Reinhard / Caviezel, Claudio 2017: Lastfolgefähigkeit
deutscher Kernkraftwerke. Monitoring. Büro für Technikfolgen-Abschätzung
beim Deutschen Bundestag (TAB). doi:
\href{https://publikationen.bibliothek.kit.edu/1000102277}{10.5445/IR/1000102277}.
Seite 16.

\end{tcolorbox}

Für die Frage, welche Kraftwerke den Grenzstrom zur Befüllung der
Pumpspeicherkraftwerke liefern, ist insbesondere die Unterscheidung von
im Grundlastbetrieb operierenden Kraftwerken einerseits sowie von im
Mittellast- und Spitzenlastbetrieb arbeitenden Kraftwerken andererseits
relevant. In Grundlast operierende Kraftwerke fahren 24 Stunden am Tag
in Volllast. Beispielsweise erreichte Kernenergie im Jahr 2021 mit 8.070
Jahresvolllaststunden beinahe einen durchgehenden Volllastbetrieb
\href{https://de.statista.com/statistik/daten/studie/37610/umfrage/jahresvolllaststunden-deutscher-kraftwerke-im-jahr-2009/}{statista}.
In Volllast betriebene Kraftwerke können nicht mehr auf zusätzliche
Stromnachfrage reagieren. Dies bleibt im Mittel- und Spitzenlastbetrieb
arbeitenden Kraftwerken überlassen.

Somit können durch die Unterscheidung von in Grundlast und von in
Mittel- bzw. Spitzenlast betriebenen Kraftwerkstypen die
Kraftwerkstypen, die den zur Befüllung der Pumpspeicherkraftwerken
erforderlichen Strom lieferten, eingegrenzt werden.

Die Auslastung eines Kraftwerks (bzw. einer Gruppe von Kraftwerken) kann
mittels seiner Jahresvolllaststunden quantifiziert werden.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-Jahresvolllaststunden}: Jahresvolllaststunden}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-Jahresvolllaststunden} 

Die Jahresvolllaststunden geben an, wie viel der 8.760 Stunden eines
Jahres ein Kraftwerk bei maximaler Leistung laufen müsste, um seine
Jahresproduktion zu erzeugen.
\href{https://de.statista.com/statistik/daten/studie/37610/umfrage/jahresvolllaststunden-deutscher-kraftwerke-im-jahr-2009/}{statista}

\[
Jahresvolllaststunden ~ in ~ h = \frac{Summe ~ erzeugten ~ Stroms ~ in ~ MWh}{installierte ~ Leistung ~ in ~ MW}
\]

\end{tcolorbox}

Die Jahresvolllaststunden können wie folgt berechnet werden. Die
Anwendung der Methode \texttt{.sum} auf den Datensatz
installierte\_leistung ist nicht erforderlich, da dieser nur eine Zeile
hat. Die Methode \texttt{.sum} erlaubt es aber, über den Parameter
\texttt{numeric\_only\ =\ True} die Datumsspalten auszuschließen.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# print(f"\{erzeugung.sum(numeric\_only = True)\}\textbackslash{}n")}
\CommentTok{\# print(installierte\_leistung.sum(numeric\_only = True), "\textbackslash{}n")}

\CommentTok{\# Für die Division müssen die Indizes zurücksetzt werden}
\NormalTok{jahresvolllaststunden }\OperatorTok{=}\NormalTok{ erzeugung.}\BuiltInTok{sum}\NormalTok{(numeric\_only }\OperatorTok{=} \VariableTok{True}\NormalTok{).reset\_index(drop }\OperatorTok{=} \VariableTok{True}\NormalTok{).divide(installierte\_leistung.}\BuiltInTok{sum}\NormalTok{(numeric\_only }\OperatorTok{=} \VariableTok{True}\NormalTok{).reset\_index(drop }\OperatorTok{=} \VariableTok{True}\NormalTok{))}

\CommentTok{\# Index neu setzen}
\NormalTok{jahresvolllaststunden.index }\OperatorTok{=}\NormalTok{ erzeugung.}\BuiltInTok{sum}\NormalTok{(numeric\_only }\OperatorTok{=} \VariableTok{True}\NormalTok{).index.}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{" [MWh]"}\NormalTok{, repl }\OperatorTok{=} \StringTok{" [h]"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n\textbackslash{}n}\SpecialStringTok{Jahresvolllaststunden}\CharTok{\textbackslash{}n\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{jahresvolllaststunden}\SpecialCharTok{.}\NormalTok{sort\_values(ascending }\OperatorTok{=} \VariableTok{False}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}


Jahresvolllaststunden

Biomasse [h]                   4467.41
Braunkohle [h]                 4399.96
Wind Offshore [h]              2893.34
Wasserkraft [h]                2855.83
Sonstige Erneuerbare [h]       2653.47
Steinkohle [h]                 2192.86
Wind Onshore [h]               2062.55
Kernenergie [h]                1661.92
Erdgas [h]                     1576.42
Sonstige Konventionelle [h]    1293.98
Pumpspeicher [h]               1188.76
Photovoltaik [h]                883.48
dtype: float64
\end{verbatim}

Die Berechnung der Jahresstunden zeigt, dass kein Kraftwerkstyp auch nur
annähernd in Volllast lief. Die höchste Auslastung weisen Biomasse und
Braunkohle auf. Biomasse ist umgerechnet in 51 Prozent der 8760
Jahresstunden in Volllast gelaufen, Braunkohle in 50 Prozent.
Demgegenüber erreichte der klassische Grundlasterzeuger Kernenergie nur
25 Prozent. Die in Deutschland hauptsächlich für den Mittellastbetrieb
eingesetzte Steinkohle erreichte 19 Prozent. Das Jahr 2023 war
insbesondere für die Kernenergie ein ungewöhnliches Jahr.

Deshalb wird der Jahresgang ausgewählter konventioneller Erzeuger
dargestellt. Um eine hohe Auflösung zu erreichen, wird eine Darstellung
auf Monatsbasis gewählt.

\section{Beispiel-Code Kernenergie}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plotting\_data }\OperatorTok{=}\NormalTok{ erzeugung.copy()}

\NormalTok{erzeuger }\OperatorTok{=} \StringTok{"Kernenergie"}

\NormalTok{fig }\OperatorTok{=}\NormalTok{ plt.figure(figsize }\OperatorTok{=}\NormalTok{ (}\DecValTok{8}\NormalTok{, }\DecValTok{12}\NormalTok{))}
\NormalTok{fig.suptitle(erzeuger, fontsize }\OperatorTok{=} \DecValTok{12}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{13}\NormalTok{):}
\NormalTok{  plotting\_data\_monthly }\OperatorTok{=}\NormalTok{ plotting\_data[plotting\_data[}\StringTok{\textquotesingle{}Datum von\textquotesingle{}}\NormalTok{].dt.month }\OperatorTok{==}\NormalTok{ i]}
\NormalTok{  ax }\OperatorTok{=}\NormalTok{ fig.add\_subplot(}\DecValTok{12}\NormalTok{, }\DecValTok{1}\NormalTok{, i)}
\NormalTok{  ax.plot(plotting\_data\_monthly[erzeuger }\OperatorTok{+} \StringTok{" [MWh]"}\NormalTok{])}
\NormalTok{  plt.margins(x }\OperatorTok{=} \FloatTok{0.01}\NormalTok{)}
\NormalTok{  ax.set\_ylabel(ylabel }\OperatorTok{=} \StringTok{"MWh"}\NormalTok{)}
 
  \CommentTok{\# Titel erzeugen}
\NormalTok{  plt.title(label }\OperatorTok{=}\NormalTok{ plotting\_data\_monthly[}\StringTok{\textquotesingle{}Datum von\textquotesingle{}}\NormalTok{].head(}\DecValTok{1}\NormalTok{).dt.strftime(}\StringTok{\textquotesingle{}\%B\textquotesingle{}}\NormalTok{).item(), fontsize }\OperatorTok{=} \DecValTok{10}\NormalTok{)}
  
  \CommentTok{\# xticks erzeugen}
\NormalTok{  tage\_index }\OperatorTok{=}\NormalTok{ plotting\_data\_monthly[}\OperatorTok{\textasciitilde{}}\NormalTok{plotting\_data\_monthly[}\StringTok{"Datum von"}\NormalTok{].dt.day.duplicated()].index}
\NormalTok{  tagesnamen }\OperatorTok{=}\NormalTok{ plotting\_data\_monthly[}\StringTok{"Datum von"}\NormalTok{].dt.day.unique() }
\NormalTok{  plt.xticks(tage\_index, tagesnamen, fontsize }\OperatorTok{=} \DecValTok{8}\NormalTok{)}

\NormalTok{plt.tight\_layout()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\section{Kernenergie}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-31-output-1.png}}

}

\caption{Jahresgang Kernenergie}

\end{figure}%

\section{Braunkohle}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-32-output-1.png}}

}

\caption{Jahresgang Braunkohle}

\end{figure}%

\section{Steinkohle}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-33-output-1.png}}

}

\caption{Jahresgang Steinkohle}

\end{figure}%

\section{Erdgas}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-34-output-1.png}}

}

\caption{Jahresgang Erdgas}

\end{figure}%

Im Reiter Kernenergie ist zu erkennen, dass 2023 die letzten deutschen
Atomkraftwerke Emsland, Isar 2 und Neckarwestheim 2 vom Netz genommen
wurden. Für diese wurde im Herbst 2022 aufgrund der Energiekrise ein
über den ursprünglichen Abschalttermin zum 31. Dezember 2022
hinausgehender Streckbetrieb beschlossen.
\href{https://www.bmwk.de/Redaktion/DE/Pressemitteilungen/2023/04/20230413-deutschland-beendet-das-zeitalter-der-atomkraft.html}{BMWK}

\textbf{Bis zu welchem Tag wurde der Streckbetrieb genehmigt? Bestimmen
Sie den Zeitpunkt der Abschaltung anhand des Datensatzes erzeugung.
Geben Sie den Zeitpunkt über die Spalte `Datum bis' in deutscher
Datumsformtierung `TT. Monat YYYY um HH:MM Uhr' aus.}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-abschaltung-akw}: Lösungshinweis und Musterlösung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-abschaltung-akw} 

Mit der Abschaltung erreichte die Stromproduktion durch Kernenergie den
Wert 0. Die Abschaltung wurde in der Periode vollendet, die der ersten
Periode mit der Stromproduktion durch Kernenergie mit dem Wert 0
vorausging.

Die Ausgabe einer als datetime formatierten Spalten können Sie mit der
Methode
\href{https://pandas.pydata.org/docs/reference/api/pandas.Series.dt.strftime.html}{pandas.Series.dt.strftime}
formatieren.

\phantomsection\label{tip-abschaltung-akw}
\begin{quote}
\textbf{Tip~99.2: Musterlösung}

In der graphischen Darstellung des Jahresgangs wurde nur jeder 100. Wert
geplottet, sodass es möglich ist, dass die Stromerzeugung bereits vor
der endgültigen Abschaltung den Wert Null erreichte. Es ist deshalb
zuverlässiger, den Datensatz rückwärts zu durchsuchen.

In der Vorwärtssuche wird mit der Methode \texttt{.eq()}die Position des
ersten Auftretens des Werts 0 bestimmt und 1 subtrahiert. In der
Rückwärtssuche wird mit der Methode \texttt{.gt()} die Position des
ersten Werts bestimmt, der größer als 0 ist.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Vorwärtssuche: erzeugung[\textquotesingle{}Kernenergie [MWh]\textquotesingle{}].eq(0).idxmax() {-} 1}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{erzeugung[}\StringTok{\textquotesingle{}Kernenergie [MWh]\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{eq(}\DecValTok{0}\NormalTok{)}\SpecialCharTok{.}\NormalTok{idxmax() }\OperatorTok{{-}} \DecValTok{1}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# rückwärts}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Rückwärtssuche: position := erzeugung[\textquotesingle{}Kernenergie [MWh]\textquotesingle{}].iloc[::{-}1].gt(0).idxmax()}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{ ( position }\OperatorTok{:=}\NormalTok{ erzeugung[}\StringTok{\textquotesingle{}Kernenergie [MWh]\textquotesingle{}}\NormalTok{].iloc[::}\OperatorTok{{-}}\DecValTok{1}\NormalTok{].gt(}\DecValTok{0}\NormalTok{).idxmax() ) }\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"erzeugung[\textquotesingle{}Datum bis\textquotesingle{}].iloc[position].strftime(\textquotesingle{}\%d. \%B \%Y um \%H:\%M Uhr\textquotesingle{})}\CharTok{\textbackslash{}n}\SpecialCharTok{\{}\NormalTok{erzeugung[}\StringTok{\textquotesingle{}Datum bis\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\NormalTok{iloc[position]}\SpecialCharTok{.}\NormalTok{strftime(}\StringTok{\textquotesingle{}}\SpecialCharTok{\%d}\StringTok{. \%B \%Y um \%H:\%M Uhr\textquotesingle{}}\NormalTok{)}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Vorwärtssuche: erzeugung['Kernenergie [MWh]'].eq(0).idxmax() - 1
10075

Rückwärtssuche: position := erzeugung['Kernenergie [MWh]'].iloc[::-1].gt(0).idxmax()
10075

erzeugung['Datum bis'].iloc[position].strftime('%d. %B %Y um %H:%M Uhr')
16. April 2023 um 00:00 Uhr
\end{verbatim}
\end{quote}

\end{tcolorbox}

Die Berechnung der Jahresvolllaststunden und die Visualisierung der
Jahresgänge zeigen, dass es durch den hohen Anteil volatiler
erneuerbarer Stromerzeugung im deutschen Stromsystem keine Grundlast
mehr gibt, die von konventionellen Erzeugern bedient werden kann. Dies
bedeutet, dass alle nicht erneuerbaren Erzeuger im Lastfolgebetrieb
arbeiten. Dies kann am Beispiel der Steinkohle verdeutlicht werden,
deren erzielte Jahresvolllaststunden näher an der klassischen
Spitzenlasterzeugung aus Erdgas als an der Mittellasterzeugung durch
Braunkohle liegt. Die Auslastung eines Stromerzeugers kann mit einer
sortierten Jahresdauerlinie dargestellt werden.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-Jahresdauerlinie}: sortierte Jahresdauerlinie}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-Jahresdauerlinie} 

Die sortierte Jahresdauerlinie ist ein Diagramm der absteigend
sortierten Daten.

\url{https://www.youtube.com/watch?v=rMxYJuGqR4s}

Energietechnik. 2 Einführung. 2.13 Sortierte Jahresdauerlinie von Henrik
te Heesen ist lizensiert unter
\href{https://creativecommons.org/licenses/by-sa/3.0/deed.de}{CC BY-SA
3.0} und abrufbar auf
\href{https://www.youtube.com/watch?v=rMxYJuGqR4s}{YouTube}.

\end{tcolorbox}

\section{Plot}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-36-output-1.png}}

}

\caption{sortierte Jahresdauerlinie ausgewählter konventioneller
Erzeuger}

\end{figure}%

\section{Code für den Plot}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Daten nach Tag gruppieren und durch Mittelwertbildung auf Tagesbasis aggregieren.}
\NormalTok{braunkohle\_daily }\OperatorTok{=}\NormalTok{ erzeugung[}\StringTok{\textquotesingle{}Braunkohle [MWh]\textquotesingle{}}\NormalTok{].groupby(erzeugung[}\StringTok{"Datum von"}\NormalTok{].dt.dayofyear).mean()}
\NormalTok{steinkohle\_daily }\OperatorTok{=}\NormalTok{ erzeugung[}\StringTok{\textquotesingle{}Steinkohle [MWh]\textquotesingle{}}\NormalTok{].groupby(erzeugung[}\StringTok{"Datum von"}\NormalTok{].dt.dayofyear).mean()}
\NormalTok{erdgas\_daily }\OperatorTok{=}\NormalTok{ erzeugung[}\StringTok{\textquotesingle{}Erdgas [MWh]\textquotesingle{}}\NormalTok{].groupby(erzeugung[}\StringTok{"Datum von"}\NormalTok{].dt.dayofyear).mean()}

\CommentTok{\#\# Zur Kontrolle}
\CommentTok{\#\# print(erzeugung["Datum von"].dt.dayofyear)}
\CommentTok{\#\# print(f"\textbackslash{}n\textbackslash{}nbraunkohle\_daily.head()\textbackslash{}n\{braunkohle\_daily.head()\}\textbackslash{}n\textbackslash{}n"}
\CommentTok{\#\#       f"Zum Vergleich:\textbackslash{}nerzeugung[\textquotesingle{}Braunkohle [MWh]\textquotesingle{}].iloc[[0, 1, 95, 96]]\textbackslash{}n\{erzeugung[\textquotesingle{}Braunkohle [MWh]\textquotesingle{}].iloc[[0, 1, 95, 96]]\}\textbackslash{}n\textbackslash{}n"}
\CommentTok{\#\#       f"erzeugung[\textquotesingle{}Braunkohle [MWh]\textquotesingle{}].iloc[0:96].mean()\textbackslash{}n\{erzeugung[\textquotesingle{}Braunkohle [MWh]\textquotesingle{}].iloc[0:96].mean()\}") }

\CommentTok{\# Liniendiagramm plotten}
\CommentTok{\# Index um 1 verschieben, weil Index mit 0 beginnt, aber die Anzahl der Tage dargestellt wird.}
\NormalTok{linienstärke }\OperatorTok{=} \DecValTok{5}
\NormalTok{plt.figure(figsize }\OperatorTok{=}\NormalTok{ (}\DecValTok{8}\NormalTok{, }\DecValTok{4}\NormalTok{))}

\NormalTok{braunkohle\_daily }\OperatorTok{=}\NormalTok{ braunkohle\_daily.sort\_values(ascending }\OperatorTok{=} \VariableTok{False}\NormalTok{, ignore\_index }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{braunkohle\_daily.index }\OperatorTok{+=} \DecValTok{1}
\NormalTok{braunkohle\_daily.plot.line(lw }\OperatorTok{=}\NormalTok{ linienstärke, color }\OperatorTok{=} \StringTok{\textquotesingle{}brown\textquotesingle{}}\NormalTok{, alpha }\OperatorTok{=} \FloatTok{0.5}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Braunkohle\textquotesingle{}}\NormalTok{)}

\NormalTok{steinkohle\_daily }\OperatorTok{=}\NormalTok{ steinkohle\_daily.sort\_values(ascending }\OperatorTok{=} \VariableTok{False}\NormalTok{, ignore\_index }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{steinkohle\_daily.index }\OperatorTok{+=} \DecValTok{1}
\NormalTok{steinkohle\_daily.plot.line(lw }\OperatorTok{=}\NormalTok{ linienstärke, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, alpha }\OperatorTok{=} \FloatTok{0.5}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Steinkohle\textquotesingle{}}\NormalTok{)}

\NormalTok{erdgas\_daily }\OperatorTok{=}\NormalTok{ erdgas\_daily.sort\_values(ascending }\OperatorTok{=} \VariableTok{False}\NormalTok{, ignore\_index }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{erdgas\_daily.index }\OperatorTok{+=} \DecValTok{1}
\NormalTok{erdgas\_daily.plot.line(lw }\OperatorTok{=}\NormalTok{ linienstärke, color }\OperatorTok{=} \StringTok{\textquotesingle{}lightskyblue\textquotesingle{}}\NormalTok{, alpha }\OperatorTok{=} \FloatTok{0.5}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Erdgas\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.title(label }\OperatorTok{=} \StringTok{"sortierte Jahresdauerlinie für ausgewählte konventionelle Erzeuger"}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.legend()}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}durchschnittliche Stromerzeugung in MWh}\CharTok{\textbackslash{}n}\StringTok{(auf Viertelstundenbasis)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Anzahl Tage pro Jahr\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.margins(x }\OperatorTok{=} \FloatTok{0.02}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

Beim Vergleich der erzielten Jahresvolllaststunden konnte festgestellt
werden, dass die Auslastung der Steinkohle eher der des
Spitzenlasterzeugers Erdgas als des Mittellasterzeugers Braunkohle
entspricht. In der grafischen Darstellung der sortierten
Jahresdauerlinien wird darüber hinaus deutlich, dass das
Erzeugungsprofil der Steinkohle dem der Braunkohle sogar weniger ähnelt
als dem von Erdgas.

Bisher wurde ausschließlich die Erzeugung durch konventionelle
Kraftwerke betrachtet. Biomasse und Braunkohle erreichen vergleichbare
Jahresvolllaststunden, sodass ein Vergleich beider Erzeuger interessant
sein könnte.\\
\textbf{Stellen Sie den Jahresgang und die Jahresdauerlinien für
Biomasse und Braunkohle dar.}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-erzeugungsprofile-biomasse-braunkohle}: Musterlösung Erzeugungsprofile von Biomasse und Braunkohle}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-erzeugungsprofile-biomasse-braunkohle} 

\section{Code}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\CommentTok{\# Deklarieren der Anzahl der Nachkommastellen}
\NormalTok{pd.set\_option(}\StringTok{"display.precision"}\NormalTok{, }\DecValTok{2}\NormalTok{)}

\CommentTok{\# Datensätze werden eingelesen}

\CommentTok{\# !}
\CommentTok{\# Für die eigene Anwendung muss der Dateipfad an den korrekten Speicherort der runtergeladenen .csv Datei angepasst werden. }
\CommentTok{\# !}

\NormalTok{erzeugung0\_ms }\OperatorTok{=}\NormalTok{ pd.read\_csv(}\StringTok{"01{-}daten/Realisierte\_Erzeugung\_202301010000\_202401010000\_Viertelstunde.csv"}\NormalTok{, }\OperatorTok{\textbackslash{}}
\NormalTok{sep }\OperatorTok{=} \StringTok{";"}\NormalTok{, thousands }\OperatorTok{=} \StringTok{"."}\NormalTok{, decimal }\OperatorTok{=} \StringTok{","}\NormalTok{, parse\_dates }\OperatorTok{=}\NormalTok{  [}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{], date\_format }\OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y \%H:\%M"}\NormalTok{)}

\CommentTok{\# Zeichenkette " Originalauflösungen" entfernen}
\NormalTok{erzeugung0\_ms.columns }\OperatorTok{=}\NormalTok{ erzeugung0\_ms.columns.}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{" Originalauflösungen"}\NormalTok{, repl }\OperatorTok{=} \StringTok{""}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(erzeugung0\_ms.head(}\DecValTok{10}\NormalTok{))}

\CommentTok{\# Daten der zu betrachtenden Erzeugungsarten nach Tag gruppieren und durch Mittelwertbildung auf Tagesbasis aggregieren}
\NormalTok{braunkohle\_daily\_ms }\OperatorTok{=}\NormalTok{ erzeugung0\_ms[}\StringTok{\textquotesingle{}Braunkohle [MWh]\textquotesingle{}}\NormalTok{].groupby(erzeugung0\_ms[}\StringTok{"Datum von"}\NormalTok{].dt.dayofyear).mean()}
\NormalTok{biomasse\_daily\_ms }\OperatorTok{=}\NormalTok{ erzeugung0\_ms[}\StringTok{\textquotesingle{}Biomasse [MWh]\textquotesingle{}}\NormalTok{].groupby(erzeugung0\_ms[}\StringTok{"Datum von"}\NormalTok{].dt.dayofyear).mean()}

\CommentTok{\# Liniendiagramm plotten}
\NormalTok{linienstärke }\OperatorTok{=} \DecValTok{5}
\NormalTok{plt.figure(figsize }\OperatorTok{=}\NormalTok{ (}\DecValTok{8}\NormalTok{, }\DecValTok{4}\NormalTok{))}

\NormalTok{braunkohle\_daily\_ms }\OperatorTok{=}\NormalTok{ braunkohle\_daily\_ms.sort\_values(ascending }\OperatorTok{=} \VariableTok{False}\NormalTok{, ignore\_index }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{braunkohle\_daily\_ms.index }\OperatorTok{+=} \DecValTok{1}
\NormalTok{braunkohle\_daily\_ms.plot.line(lw }\OperatorTok{=}\NormalTok{ linienstärke, color }\OperatorTok{=} \StringTok{\textquotesingle{}brown\textquotesingle{}}\NormalTok{, alpha }\OperatorTok{=} \FloatTok{0.5}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Braunkohle\textquotesingle{}}\NormalTok{)}

\NormalTok{biomasse\_daily\_ms }\OperatorTok{=}\NormalTok{ biomasse\_daily\_ms.sort\_values(ascending }\OperatorTok{=} \VariableTok{False}\NormalTok{, ignore\_index }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{biomasse\_daily\_ms.index }\OperatorTok{+=} \DecValTok{1}
\NormalTok{biomasse\_daily\_ms.plot.line(lw }\OperatorTok{=}\NormalTok{ linienstärke, color }\OperatorTok{=} \StringTok{\textquotesingle{}greenyellow\textquotesingle{}}\NormalTok{, alpha }\OperatorTok{=} \FloatTok{0.5}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Biomasse\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.title(label }\OperatorTok{=} \StringTok{"sortierte Jahresdauerlinie für ausgewählte Erzeuger"}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.legend()}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}durchschnittliche Stromerzeugung in MWh}\CharTok{\textbackslash{}n}\StringTok{(auf Viertelstundenbasis)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Anzahl Tage pro Jahr\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.margins(x }\OperatorTok{=} \FloatTok{0.02}\NormalTok{)}

\CommentTok{\# Lastgang: Hier den Erzeugungstyp auswählen, je nachdem, welcher Lastgang geplottet werden soll. Der andere wird auskommentiert}
\NormalTok{erzeuger }\OperatorTok{=} \StringTok{"Biomasse"}
\CommentTok{\#erzeuger = "Braunkohle"}

\NormalTok{fig }\OperatorTok{=}\NormalTok{ plt.figure(figsize }\OperatorTok{=}\NormalTok{ (}\DecValTok{8}\NormalTok{, }\DecValTok{12}\NormalTok{))}
\NormalTok{fig.suptitle(erzeuger, fontsize }\OperatorTok{=} \DecValTok{12}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{13}\NormalTok{):}
\NormalTok{  plotting\_data\_monthly }\OperatorTok{=}\NormalTok{ erzeugung0\_ms[erzeugung0\_ms[}\StringTok{\textquotesingle{}Datum von\textquotesingle{}}\NormalTok{].dt.month }\OperatorTok{==}\NormalTok{ i]}
\NormalTok{  ax }\OperatorTok{=}\NormalTok{ fig.add\_subplot(}\DecValTok{12}\NormalTok{, }\DecValTok{1}\NormalTok{, i)}
\NormalTok{  ax.plot(plotting\_data\_monthly[erzeuger }\OperatorTok{+} \StringTok{" [MWh]"}\NormalTok{])}
\NormalTok{  plt.margins(x }\OperatorTok{=} \FloatTok{0.01}\NormalTok{)}
\NormalTok{  ax.set\_ylabel(ylabel }\OperatorTok{=} \StringTok{"MWh"}\NormalTok{)}
 
  \CommentTok{\# Titel erzeugen}
\NormalTok{  plt.title(label }\OperatorTok{=}\NormalTok{ plotting\_data\_monthly[}\StringTok{\textquotesingle{}Datum von\textquotesingle{}}\NormalTok{].head(}\DecValTok{1}\NormalTok{).dt.strftime(}\StringTok{\textquotesingle{}\%B\textquotesingle{}}\NormalTok{).item(), fontsize }\OperatorTok{=} \DecValTok{10}\NormalTok{)}
  
  \CommentTok{\# xticks erzeugen}
\NormalTok{  tage\_index }\OperatorTok{=}\NormalTok{ plotting\_data\_monthly[}\OperatorTok{\textasciitilde{}}\NormalTok{plotting\_data\_monthly[}\StringTok{"Datum von"}\NormalTok{].dt.day.duplicated()].index}
\NormalTok{  tagesnamen }\OperatorTok{=}\NormalTok{ plotting\_data\_monthly[}\StringTok{"Datum von"}\NormalTok{].dt.day.unique() }
\NormalTok{  plt.xticks(tage\_index, tagesnamen, fontsize }\OperatorTok{=} \DecValTok{8}\NormalTok{)}

\NormalTok{plt.tight\_layout()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\section{Text-Output}

\begin{verbatim}
            Datum von           Datum bis  Biomasse [MWh]  Wasserkraft [MWh]  \
0 2023-01-01 00:00:00 2023-01-01 00:15:00         1094.25             320.00   
1 2023-01-01 00:15:00 2023-01-01 00:30:00         1091.25             317.50   
2 2023-01-01 00:30:00 2023-01-01 00:45:00         1090.25             317.25   
3 2023-01-01 00:45:00 2023-01-01 01:00:00         1089.25             321.50   
4 2023-01-01 01:00:00 2023-01-01 01:15:00         1085.25             315.25   
5 2023-01-01 01:15:00 2023-01-01 01:30:00         1087.75             304.75   
6 2023-01-01 01:30:00 2023-01-01 01:45:00         1086.50             303.50   
7 2023-01-01 01:45:00 2023-01-01 02:00:00         1085.25             304.25   
8 2023-01-01 02:00:00 2023-01-01 02:15:00         1080.25             308.25   
9 2023-01-01 02:15:00 2023-01-01 02:30:00         1084.25             305.50   

   Wind Offshore [MWh]  Wind Onshore [MWh]  Photovoltaik [MWh]  \
0               684.25             7145.75                0.50   
1               743.50             7158.25                0.25   
2               817.00             7302.25                0.25   
3               814.50             7104.25                0.25   
4               785.50             7322.00                0.25   
5               898.50             7332.75                0.25   
6               943.75             7259.75                0.25   
7               958.25             7390.50                0.25   
8              1009.75             7229.00                0.50   
9               967.00             7421.75                0.25   

   Sonstige Erneuerbare [MWh]  Kernenergie [MWh]  Braunkohle [MWh]  \
0                       32.25             615.25            962.75   
1                       32.25             614.75            963.25   
2                       32.50             615.00            966.50   
3                       32.50             614.50            966.75   
4                       32.25             614.50            969.00   
5                       32.25             614.75            965.75   
6                       32.25             614.75            967.50   
7                       32.25             614.75            964.25   
8                       32.25             615.00            963.00   
9                       32.25             614.75            967.00   

   Steinkohle [MWh]  Erdgas [MWh]  Pumpspeicher [MWh]  \
0            517.00        429.75               13.50   
1            518.00        429.50                9.75   
2            517.00        432.00                9.75   
3            515.50        430.50                9.75   
4            513.25        391.25               26.50   
5            514.00        389.50               45.00   
6            513.75        393.75               50.50   
7            511.00        393.50               50.50   
8            509.75        391.50               41.25   
9            509.00        394.50               40.75   

   Sonstige Konventionelle [MWh]  
0                         307.25  
1                         307.25  
2                         308.25  
3                         306.00  
4                         306.75  
5                         305.00  
6                         302.00  
7                         304.50  
8                         303.00  
9                         303.75  
\end{verbatim}

\section{Jahresgang Biomasse}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-40-output-1.png}}

}

\caption{Jahresgang Biomasse}

\end{figure}%

\section{Jahresgang Braunkohle}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-41-output-1.png}}

}

\caption{Jahresgang Biomasse}

\end{figure}%

\section{Sortierte Jahresdauerlinien}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-42-output-1.png}}

}

\caption{Sortierte Jahresdauerlinien für ausgewählte Erzeuger}

\end{figure}%

Musterlösung von Marc Sönnecken. Der Code und die durch Abschnitte des
Codes erzeugten Outputs wurden in Reiter aufgeteilt. Für die
Kompatibilität mit diesem Skript wurden der Dateipfad und die
Objektbezeichnungen angepasst. Für die Barrierefreiheit wurden die
verwendeten Farben angepasst.

\end{tcolorbox}

\section{Bestimmung des in den Pumpspeichern gespeicherten
Stroms}\label{sec-Pumpspeicherinhalt}

In den bisherigen Betrachtungen wurde gezeigt, dass zwei grundsätzliche
Szenarien im Stromnetz zu unterscheiden sind:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Restlast Null oder negativ: Grenzstrom wird von erneuerbaren Energien
  produziert.
\item
  Restlast positiv: Grenzstrom wird von konventionellen Energien im
  Lastfolgebetrieb produziert.
\end{enumerate}

Den Jahresgang des Stromverbrauchs durch Pumpspeicher und das jeweils
bestehende Szenario zeigt folgender Graph, der jeden 100. Wert der
Datenreihe
\texttt{verbrauch{[}\textquotesingle{}Pumpspeicher\ {[}MWh{]}\textquotesingle{}{]}}
darstellt.

\section{Plot}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-43-output-1.png}}

}

\caption{Einspeicherung in Pumpspeicherkraftwerke 2023}

\end{figure}%

\section{Code für den Plot}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Restlast berechnen}
\NormalTok{erneuerbare }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Biomasse [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wasserkraft [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Offshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Onshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Photovoltaik [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Sonstige Erneuerbare [MWh]\textquotesingle{}}\NormalTok{]}

\NormalTok{restlast }\OperatorTok{=}\NormalTok{ pd.DataFrame()}
\NormalTok{restlast[}\StringTok{"Netzlast [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ verbrauch[}\StringTok{"Gesamt (Netzlast) [MWh]"}\NormalTok{].copy() }
\NormalTok{restlast[}\StringTok{"Erneuerbare [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung[erneuerbare].}\BuiltInTok{sum}\NormalTok{(axis }\OperatorTok{=} \StringTok{"columns"}\NormalTok{).copy()}
\NormalTok{restlast[}\StringTok{"Restlast [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ restlast[}\StringTok{"Netzlast [MWh]"}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ restlast[}\StringTok{"Erneuerbare [MWh]"}\NormalTok{]}
\NormalTok{restlast }\OperatorTok{=}\NormalTok{ restlast[}\StringTok{"Restlast [MWh]"}\NormalTok{]}

\CommentTok{\# xticks berechnen}
\NormalTok{monate\_index }\OperatorTok{=}\NormalTok{ erzeugung[}\OperatorTok{\textasciitilde{}}\NormalTok{erzeugung[}\StringTok{"Datum von"}\NormalTok{].dt.month.duplicated()].index}
\NormalTok{monatsnamen }\OperatorTok{=}\NormalTok{ erzeugung[}\StringTok{"Datum von"}\NormalTok{].iloc[monate\_index].dt.strftime(}\StringTok{"\%B"}\NormalTok{) }

\CommentTok{\# plotten jedes n. Werts}
\NormalTok{schritt }\OperatorTok{=} \DecValTok{100}
\NormalTok{verbrauch[}\StringTok{\textquotesingle{}Pumpspeicher [MWh]\textquotesingle{}}\NormalTok{][::schritt].plot(figsize }\OperatorTok{=}\NormalTok{ (}\DecValTok{9}\NormalTok{, }\DecValTok{6}\NormalTok{), xlim }\OperatorTok{=}\NormalTok{ (verbrauch.index.}\BuiltInTok{min}\NormalTok{() }\OperatorTok{{-}}\NormalTok{ (}\BuiltInTok{len}\NormalTok{(verbrauch.index) }\OperatorTok{/} \DecValTok{100}\NormalTok{), verbrauch.index.}\BuiltInTok{max}\NormalTok{() }\OperatorTok{*} \FloatTok{1.01}\NormalTok{), rot }\OperatorTok{=} \DecValTok{45}\NormalTok{, grid }\OperatorTok{=} \VariableTok{True}\NormalTok{, label }\OperatorTok{=} \StringTok{""}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Einspeicherung [MWh]\textquotesingle{}}\NormalTok{, fontsize }\OperatorTok{=} \DecValTok{12}\NormalTok{)}
\NormalTok{plt.suptitle(}\StringTok{\textquotesingle{}Einspeicherung in Pumpspeicherkraftwerke 2023\textquotesingle{}}\NormalTok{)}

\CommentTok{\# xticks eintragen}
\NormalTok{plt.minorticks\_off()}
\NormalTok{plt.xticks(monate\_index, monatsnamen)}\OperatorTok{;}

\CommentTok{\# Kurve unterlegen: plt.fill\_between bietet einen praktischen Parameter where}
\NormalTok{plt.fill\_between(x }\OperatorTok{=}\NormalTok{ verbrauch[}\StringTok{\textquotesingle{}Pumpspeicher [MWh]\textquotesingle{}}\NormalTok{].index[::schritt], y1 }\OperatorTok{=}\NormalTok{ verbrauch[}\StringTok{\textquotesingle{}Pumpspeicher [MWh]\textquotesingle{}}\NormalTok{][::schritt], label }\OperatorTok{=} \StringTok{\textquotesingle{}konventionelle Einspeicherung\textquotesingle{}}\NormalTok{) }\CommentTok{\# , where = restlast[::schritt] \textgreater{} 0 führt zu weißen Stellen}
\NormalTok{plt.fill\_between(x }\OperatorTok{=}\NormalTok{ verbrauch[}\StringTok{\textquotesingle{}Pumpspeicher [MWh]\textquotesingle{}}\NormalTok{].index[::schritt], y1 }\OperatorTok{=}\NormalTok{ verbrauch[}\StringTok{\textquotesingle{}Pumpspeicher [MWh]\textquotesingle{}}\NormalTok{][::schritt], where }\OperatorTok{=}\NormalTok{ restlast[::schritt] }\OperatorTok{\textless{}=} \DecValTok{0}\NormalTok{, color }\OperatorTok{=} \StringTok{\textquotesingle{}greenyellow\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}erneuerbare Einspeicherung\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.legend()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

Die Grafik spiegelt die bei der Bestimmung der Residual- und Restlast
gewonnene Erkenntnis wider, dass mit dem im Jahr 2023 realisierten
Strommix zusätzliche Stromnachfrage vorwiegend konventionell bedient
wird.\\
\textbf{Wie sähe die Grafik aus, wenn die Einspeisung aus erneuerbaren
Energien doppelt so hoch ausgefallen wäre?}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-pumpspeicher}: Musterlösung Einspeicherung bei doppelter erneuerbarer Erzeugung}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-pumpspeicher} 

Für die Berechnung genügt es, die summierte Stromerzeugung aus
erneuerbaren Energien mit 2 zu multiplizieren.

\begin{verbatim}
restlast = pd.DataFrame()
restlast["Netzlast [MWh]"] = verbrauch["Gesamt (Netzlast) [MWh]"].copy() 
restlast["Erneuerbare [MWh]"] = erzeugung[erneuerbare].sum(axis = "columns").copy()
restlast["Restlast [MWh]"] = restlast["Netzlast [MWh]"] - 2 * restlast["Erneuerbare [MWh]"]
restlast = restlast["Restlast [MWh]"]
\end{verbatim}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-45-output-1.png}}

}

\caption{Einspeicherung in Pumpspeicherkraftwerke 2023}

\end{figure}%

\end{tcolorbox}

\section{Aufgabe explorative
Datenanalyse}\label{aufgabe-explorative-datenanalyse}

\begin{figure}[H]

{\centering \includegraphics[width=0.8\linewidth,height=\textheight,keepaspectratio]{books/a-energiedatenanalyse/skript/00-bilder/960px-StauseeMooserboden_von_Tigerente_CC_BY-SA_3.0.jpg}

}

\caption{~}

\end{figure}%

Ober- und Hauptstufe der Kraftwerksgruppe: Mooser- und Wasserfallboden
mit Karlingerkees links oben, im Hintergrund rechts der Großvenediger
von Tigerente ist lizensiert unter
\href{https://creativecommons.org/licenses/by-sa/3.0/de/deed.de}{CC
BY-SA 3.0} und abrufbar auf
\href{https://commons.wikimedia.org/w/index.php?curid=4595972}{wikimedia.org}.
2008

~

\textbf{Stellen Sie den Jahresgang der Pumpspeicher in Österreich 2023
dar.} Hinweise zum Herunterladen der Daten finden Sie in Abschnitt
Section~\ref{sec-aufgabe-beschreibende-Datenanalyse}.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\quartocalloutwrn{wrn-Datumsspalte-Austria} 

\vspace{-3mm}\textbf{Warning \ref*{wrn-Datumsspalte-Austria}: Zeitumstellung im österreichischen Datensatz}\vspace{3mm}

Im österreichischen Datensatz wird durch die Umstellung von Sommer- auf
Winterzeit am letzten Sonntag im Oktober die Stunde 2 Uhr morgens
doppelt eingetragen (dafür fehlt eine Stunde bei der Umstellung von
Winter- auf Sommerzeit am letzten Sonntag im März). Die doppelte Stunde
wird im Datensatz mit 2A bzw. 2B gekennzeichnet. (Mitteilung Austrian
Power Grid AG vom 13.08.2024)

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/00-bilder/erzeugung-aut-zeitumstellung.png}}

}

\caption{Zeitumstellung im österreichischen Datensatz}

\end{figure}%

Damit die Datumsspalten korrekt eingelesen werden können, müssen die
Einträge bereinigt werden. Eine Möglichkeit besteht darin, die
Zeichenfolgen ``2A'' und ``2B'' mit der Methode \texttt{str.replace()}
durch ``02'' zu ersetzen (wodurch eine Dublette im Datensatz erzeugt
wird).

\begin{quote}
\textbf{Musterlösung korrektes Einlesen mit Hilfe von str.replace()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{erzeugung\_austria }\OperatorTok{=}\NormalTok{ pd.read\_csv(filepath\_or\_buffer }\OperatorTok{=} \StringTok{"01{-}daten/AGPT\_2022{-}12{-}31T23\_00\_00Z\_2023{-}12{-}31T23\_00\_00Z\_15M\_de\_2024{-}06{-}10T09\_32\_38Z.csv"}\NormalTok{,}
\NormalTok{                            sep }\OperatorTok{=} \StringTok{";"}\NormalTok{, decimal }\OperatorTok{=} \StringTok{","}\NormalTok{, thousands }\OperatorTok{=} \StringTok{"."}\NormalTok{)}

\CommentTok{\# string replace \& als Datum einlesen}
\CommentTok{\#\# Spalte Zeit von [CET/CEST]}
\NormalTok{erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{].}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{\textquotesingle{}2A\textquotesingle{}}\NormalTok{, repl }\OperatorTok{=} \StringTok{\textquotesingle{}02\textquotesingle{}}\NormalTok{)}
\NormalTok{erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{].}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{\textquotesingle{}2B\textquotesingle{}}\NormalTok{, repl }\OperatorTok{=} \StringTok{\textquotesingle{}02\textquotesingle{}}\NormalTok{)}

\NormalTok{erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ pd.to\_datetime(erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{], }\BuiltInTok{format} \OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y \%H:\%M:\%S"}\NormalTok{)}

\CommentTok{\#\# Spalte Zeit bis [CET/CEST]}
\NormalTok{erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{].}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{\textquotesingle{}2A\textquotesingle{}}\NormalTok{, repl }\OperatorTok{=} \StringTok{\textquotesingle{}02\textquotesingle{}}\NormalTok{)}
\NormalTok{erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{].}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{\textquotesingle{}2B\textquotesingle{}}\NormalTok{, repl }\OperatorTok{=} \StringTok{\textquotesingle{}02\textquotesingle{}}\NormalTok{)}

\NormalTok{erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ pd.to\_datetime(erzeugung\_austria[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{], }\BuiltInTok{format} \OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y \%H:\%M:\%S"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(erzeugung\_austria.dtypes)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Zeit von [CET/CEST]             datetime64[ns]
Zeit bis [CET/CEST]             datetime64[ns]
Wind [MW]                              float64
Solar [MW]                             float64
Biomasse [MW]                          float64
Gas [MW]                               float64
Kohle [MW]                             float64
Öl [MW]                                float64
Geothermie [MW]                        float64
Pumpspeicher [MW]                      float64
Lauf- und Schwellwasser [MW]           float64
Speicher [MW]                          float64
Sonstige Erneuerbare [MW]              float64
Müll [MW]                              float64
Andere [MW]                            float64
dtype: object
\end{verbatim}
\end{quote}

\end{minipage}%
\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Musterlösung Aufgabe explorative Datenanalyse}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\section{Code}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}

\CommentTok{\# Deklarieren der Anzahl der Nachkommastellen}
\NormalTok{pd.set\_option(}\StringTok{"display.precision"}\NormalTok{, }\DecValTok{2}\NormalTok{)}

\CommentTok{\# Datensatz wird eingelesen und in der Variable erzeugung0\_austria\_ms gespeichert}

\CommentTok{\# !}
\CommentTok{\# Für die eigene Anwendung muss der Dateipfad an den korrekten Speicherort der runtergeladenen .csv Datei angepasst werden. }
\CommentTok{\# !}
\NormalTok{erzeugung0\_austria\_ms }\OperatorTok{=}\NormalTok{ pd.read\_csv(}\StringTok{"01{-}daten/AGPT\_2022{-}12{-}31T23\_00\_00Z\_2023{-}12{-}31T23\_00\_00Z\_15M\_de\_2024{-}06{-}10T09\_32\_38Z.csv"}\NormalTok{, }
\NormalTok{                                     sep }\OperatorTok{=} \StringTok{";"}\NormalTok{, thousands }\OperatorTok{=} \StringTok{"."}\NormalTok{, decimal }\OperatorTok{=} \StringTok{","}\NormalTok{, parse\_dates }\OperatorTok{=}\NormalTok{ [}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{], date\_format }\OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y \%H:\%M"}\NormalTok{)}
                                     
\CommentTok{\# string replace \& als Datum einlesen}
\CommentTok{\#\# Spalte Zeit von [CET/CEST]}
\NormalTok{erzeugung0\_austria\_ms[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung0\_austria\_ms[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{].}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{\textquotesingle{}2A\textquotesingle{}}\NormalTok{, repl }\OperatorTok{=} \StringTok{\textquotesingle{}02\textquotesingle{}}\NormalTok{)}
\NormalTok{erzeugung0\_austria\_ms[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung0\_austria\_ms[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{].}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{\textquotesingle{}2B\textquotesingle{}}\NormalTok{, repl }\OperatorTok{=} \StringTok{\textquotesingle{}02\textquotesingle{}}\NormalTok{)}

\NormalTok{erzeugung0\_austria\_ms[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ pd.to\_datetime(erzeugung0\_austria\_ms[}\StringTok{\textquotesingle{}Zeit von [CET/CEST]\textquotesingle{}}\NormalTok{], }\BuiltInTok{format} \OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y \%H:\%M:\%S"}\NormalTok{)}

\CommentTok{\#\# Spalte Zeit bis [CET/CEST]}
\NormalTok{erzeugung0\_austria\_ms[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung0\_austria\_ms[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{].}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{\textquotesingle{}2A\textquotesingle{}}\NormalTok{, repl }\OperatorTok{=} \StringTok{\textquotesingle{}02\textquotesingle{}}\NormalTok{)}
\NormalTok{erzeugung0\_austria\_ms[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung0\_austria\_ms[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{].}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{\textquotesingle{}2B\textquotesingle{}}\NormalTok{, repl }\OperatorTok{=} \StringTok{\textquotesingle{}02\textquotesingle{}}\NormalTok{)}

\NormalTok{erzeugung0\_austria\_ms[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ pd.to\_datetime(erzeugung0\_austria\_ms[}\StringTok{\textquotesingle{}Zeit bis [CET/CEST]\textquotesingle{}}\NormalTok{], }\BuiltInTok{format} \OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y \%H:\%M:\%S"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(erzeugung0\_austria\_ms.dtypes)}
\BuiltInTok{print}\NormalTok{(erzeugung0\_austria\_ms.head(}\DecValTok{10}\NormalTok{))}

\CommentTok{\# Kopie des Datensatzes wird angelegt}
\NormalTok{erzeugung\_c\_austria\_ms }\OperatorTok{=}\NormalTok{ erzeugung0\_austria\_ms.copy()}

\NormalTok{plotting\_data\_ms }\OperatorTok{=}\NormalTok{ erzeugung\_c\_austria\_ms.copy()}

\NormalTok{erzeuger }\OperatorTok{=} \StringTok{"Pumpspeicher"}

\NormalTok{fig }\OperatorTok{=}\NormalTok{ plt.figure(figsize }\OperatorTok{=}\NormalTok{ (}\FloatTok{7.5}\NormalTok{, }\DecValTok{12}\NormalTok{))}
\NormalTok{fig.suptitle(erzeuger, fontsize }\OperatorTok{=} \DecValTok{12}\NormalTok{)}

\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{13}\NormalTok{):}
\NormalTok{  plotting\_data\_monthly\_ms }\OperatorTok{=}\NormalTok{ plotting\_data\_ms[plotting\_data\_ms[}\StringTok{"Zeit von [CET/CEST]"}\NormalTok{].dt.month }\OperatorTok{==}\NormalTok{ i]}
\NormalTok{  ax }\OperatorTok{=}\NormalTok{ fig.add\_subplot(}\DecValTok{12}\NormalTok{, }\DecValTok{1}\NormalTok{, i)}
\NormalTok{  ax.plot(plotting\_data\_monthly\_ms[erzeuger }\OperatorTok{+} \StringTok{" [MW]"}\NormalTok{])}
\NormalTok{  plt.margins(x }\OperatorTok{=} \FloatTok{0.01}\NormalTok{)}
\NormalTok{  ax.set\_ylabel(ylabel }\OperatorTok{=} \StringTok{"MW"}\NormalTok{)}
 
  \CommentTok{\# Titel erzeugen}
\NormalTok{  plt.title(label }\OperatorTok{=}\NormalTok{ plotting\_data\_monthly\_ms[}\StringTok{"Zeit von [CET/CEST]"}\NormalTok{].head(}\DecValTok{1}\NormalTok{).dt.strftime(}\StringTok{\textquotesingle{}\%B\textquotesingle{}}\NormalTok{).item(), fontsize }\OperatorTok{=} \DecValTok{10}\NormalTok{)}
  
  \CommentTok{\# xticks erzeugen}
\NormalTok{  tage\_index }\OperatorTok{=}\NormalTok{ plotting\_data\_monthly\_ms[}\OperatorTok{\textasciitilde{}}\NormalTok{plotting\_data\_monthly\_ms[}\StringTok{"Zeit von [CET/CEST]"}\NormalTok{].dt.day.duplicated()].index}
\NormalTok{  tagesnamen }\OperatorTok{=}\NormalTok{ plotting\_data\_monthly\_ms[}\StringTok{"Zeit von [CET/CEST]"}\NormalTok{].dt.day.unique() }
\NormalTok{  plt.xticks(tage\_index, tagesnamen, fontsize }\OperatorTok{=} \DecValTok{8}\NormalTok{)}

\NormalTok{plt.tight\_layout()}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\section{Plot}

\begin{verbatim}
Zeit von [CET/CEST]             datetime64[ns]
Zeit bis [CET/CEST]             datetime64[ns]
Wind [MW]                              float64
Solar [MW]                             float64
Biomasse [MW]                          float64
Gas [MW]                               float64
Kohle [MW]                             float64
Öl [MW]                                float64
Geothermie [MW]                        float64
Pumpspeicher [MW]                      float64
Lauf- und Schwellwasser [MW]           float64
Speicher [MW]                          float64
Sonstige Erneuerbare [MW]              float64
Müll [MW]                              float64
Andere [MW]                            float64
dtype: object
  Zeit von [CET/CEST] Zeit bis [CET/CEST]  Wind [MW]  Solar [MW]  \
0 2023-01-01 00:00:00 2023-01-01 00:15:00     1000.0         0.0   
1 2023-01-01 00:15:00 2023-01-01 00:30:00      964.0         0.0   
2 2023-01-01 00:30:00 2023-01-01 00:45:00      956.0         0.0   
3 2023-01-01 00:45:00 2023-01-01 01:00:00      992.0         0.0   
4 2023-01-01 01:00:00 2023-01-01 01:15:00      880.0         0.0   
5 2023-01-01 01:15:00 2023-01-01 01:30:00      888.0         0.0   
6 2023-01-01 01:30:00 2023-01-01 01:45:00      948.0         0.0   
7 2023-01-01 01:45:00 2023-01-01 02:00:00      968.0         0.0   
8 2023-01-01 02:00:00 2023-01-01 02:15:00      956.0         0.0   
9 2023-01-01 02:15:00 2023-01-01 02:30:00      952.0         0.0   

   Biomasse [MW]  Gas [MW]  Kohle [MW]  Öl [MW]  Geothermie [MW]  \
0          240.0      27.6         0.0      0.0             0.07   
1          240.0      27.6         0.0      0.0             0.07   
2          240.0      28.0         0.0      0.0             0.07   
3          240.0      27.6         0.0      0.0             0.07   
4          240.0      27.6         0.0      0.0             0.07   
5          240.0      28.4         0.0      0.0             0.07   
6          240.0      28.8         0.0      0.0             0.07   
7          240.0      28.0         0.0      0.0             0.07   
8          240.0      28.8         0.0      0.0             0.07   
9          240.0      28.4         0.0      0.0             0.07   

   Pumpspeicher [MW]  Lauf- und Schwellwasser [MW]  Speicher [MW]  \
0            -1404.8                        2291.6           70.4   
1            -1532.8                        2283.2           66.8   
2            -1544.4                        2240.0          100.4   
3            -1579.6                        2199.6           77.6   
4            -1590.8                        2234.8           63.2   
5            -1602.8                        2229.2           73.6   
6            -1572.0                        2211.2           69.2   
7            -1579.2                        2194.8           70.8   
8            -1649.6                        2202.8           75.2   
9            -1702.0                        2172.4           65.6   

   Sonstige Erneuerbare [MW]  Müll [MW]  Andere [MW]  
0                        0.0      100.0         22.0  
1                        0.0      100.0         22.0  
2                        0.0      100.0         22.0  
3                        0.0      100.0         22.0  
4                        0.0      100.0         22.0  
5                        0.0      100.0         22.0  
6                        0.0      100.0         22.0  
7                        0.0      100.0         22.0  
8                        0.0      100.0         22.0  
9                        0.0      100.0         22.0  
\end{verbatim}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-48-output-2.png}}

}

\caption{Jahresgang der Pumpspeicher in Österreich 2023}

\end{figure}%

Musterlösung von Marc Sönnecken. Für die Kompatibilität mit diesem
Skript wurden der Dateipfad und die Objektbezeichnungen angepasst sowie
die Grafikbreite reduziert.

\end{tcolorbox}

\chapter{Schließende Datenanalyse}\label{schlieuxdfende-datenanalyse}

Schließende Datenanalyse bedeutet, auf Grundlage der Daten Rückschlüsse
zu ziehen. Die schließende Datenanalyse unterscheidet sich von der
beschreibenden und explorativen Datenanalyse dadurch, dass Daten nicht
nur betrachtet und zueinander ins Verhältnis gesetzt werden, sondern
neue Daten erzeugt werden.

Bei der explorativen Analyse der Erzeugungsdaten konnte festgestellt
werden, dass im Jahr 2023 punktuell bereits eine Vollversorgung aus
erneuerbaren Energien erreicht wird. Aus der Betrachtung der
verdoppelten erneuerbaren Stromerzeugung des Jahres 2023 (siehe
Tip~\ref{tip-verdopplung-EE}) kann geschlussfolgert werden, dass mit
zunehmenden Ausbau der erneuerbaren Stromproduktion Phasen erneuerbarer
Überproduktion immer häufiger der Fall sein werden. Die Perspektive
regelmäßiger erneuerbarer Produktionsüberschüsse begründet einen Bedarf
für Stromspeicher, um Strom aus Phasen der Überproduktion in Phasen mit
positiver Restlast nutzbar zu machen.

In diesem Abschnitt wird der daraus resultierende Speicherbedarf
betrachtet.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\vspace{-3mm}\textbf{Hinweis}\vspace{3mm}

Die folgenden Rechnungen finden im sogenannten „Kupferplattenmodell``
auf der Grundlage der von der Bundesnetzgentur veröffentlichten
Aggregatdaten zur Stromerzeugung und zum Stromverbrauch statt. In der
Realität spielen die verfügbaren Kapazitäten zum Stromtransport eine
wichtige Rolle bei der Auslegung eines Stromsystems. Diese werden hier
aber nur insoweit berücksichtigt, als dass die Daten die tatsächlich
realisierte Stromerzeugung im deutschen Stromsystem widerspiegeln. So
wird auch die Abregelung erneuerbarer Stromerzeugung vernachlässigt.
Diese betrug im Rahmen des Netzengpassmanagements im ersten Quartal 2023
5,29 Prozent der erneuerbaren Erzeugung
(\href{https://dserver.bundestag.de/btd/20/090/2009016.pdf}{Deutscher
Bundestag Drucksache 20/9016, S. 2}).

Ebenfalls bleibt der Stromhandel zum Ausland unberücksichtigt (siehe
Differenz Netzlast und Stromerzeugung).

\end{minipage}%
\end{tcolorbox}

\section{Hintergrund: Ausbaupfad erneuerbarer
Energien}\label{hintergrund-ausbaupfad-erneuerbarer-energien}

In Deutschland begann der Ausbau erneuerbarer Energien in den 1990er
Jahren. Seit dem Beginn der 2000er Jahre stieg die erneuerbare
Stromerzeugung weitgehend kontinuierlich an.

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/00-bilder/ren-strom-d-vq-ccbysa40.png}}

}

\caption{Regenerative Strom­erzeugung in Deutschland seit 1990}

\end{figure}%

Regenerative Strom­erzeugung in Deutschland seit 1990 von Volker
Quaschning nach Daten der AG Energiebilanzen
(\href{https://ag-energiebilanzen.de/wp-content/uploads/2024/04/STRERZ_Abg_02_2024_korr.xlsx}{Stromerzeugung
nach Energieträgern (Strommix) von 1990 bis 2022 (in TWh) Deutschland
insgesamt (XLSX)}) ist lizensiert unter
\href{http://creativecommons.org/licenses/by-sa/4.0/}{CC BY-SA 4.0} und
abrufbar unter
\url{https://www.volker-quaschning.de/datserv/ren-Strom-D/index.php}.
2023

~

Das Erneuerbare-Energien Gesetz legt in Paragraph 4 Ausbaupfade für die
installierte Leistung von Solarenergie, Windenergie an Land sowie für
Biomasse fest. Der Ausbaupfad für Windenergie auf See ist in Paragraph 1
des Windenergie-auf-See-Gesetzes geregelt.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\vspace{-3mm}\textbf{Gesetzliche Grundlagen des erneuerbaren Ausbaupfads}\vspace{3mm}

\begin{figure}[H]

\begin{minipage}{0.05\linewidth}
~\end{minipage}%
%
\begin{minipage}{0.90\linewidth}
\textbf{§ 4 Ausbaupfad}\\
{[}\ldots{]}\\
1. eine Steigerung der installierten Leistung von Windenergieanlagen an
Land auf\\
a) 69 Gigawatt im Jahr 2024,\\
b) 84 Gigawatt im Jahr 2026,\\
c) 99 Gigawatt im Jahr 2028,\\
d) 115 Gigawatt im Jahr 2030,\\
e) 157 Gigawatt im Jahr 2035 und\\
f) 160 Gigawatt im Jahr 2040\\
{[}\ldots{]}\\
2. eine Steigerung der installierten Leistung von Windenergieanlagen auf
See nach Maßgabe des Windenergie-auf-See-Gesetzes,\\
3. eine Steigerung der installierten Leistung von Solaranlagen auf\\
a) 88 Gigawatt im Jahr 2024,\\
b) 128 Gigawatt im Jahr 2026,\\
c) 172 Gigawatt im Jahr 2028,\\
d) 215 Gigawatt im Jahr 2030,\\
e) 309 Gigawatt im Jahr 2035 und\\
f) 400 Gigawatt im Jahr 2040\\
{[}\ldots{]}\\
4. eine installierte Leistung von Biomasseanlagen von 8 400 Megawatt im
Jahr 2030.\end{minipage}%
%
\begin{minipage}{0.05\linewidth}
~\end{minipage}%
\newline
\begin{minipage}{\linewidth}
Gesetz für den Ausbau erneuerbarer Energien (Erneuerbare-Energien-Gesetz
- EEG 2023)
\href{https://www.gesetze-im-internet.de/eeg_2014/__4.html}{Bundesministerium
der Justiz}\end{minipage}%
\newline
\begin{minipage}{\linewidth}
~\end{minipage}%
\newline
\begin{minipage}{0.05\linewidth}
~\end{minipage}%
%
\begin{minipage}{0.90\linewidth}
\textbf{§ 1 Zweck und Ziel des Gesetzes}\\
{[}\ldots{]}\\
(2) Ziel dieses Gesetzes ist es, die installierte Leistung von
Windenergieanlagen auf See, die an das Netz angeschlossen werden, auf
insgesamt mindestens 30 Gigawatt bis zum Jahr 2030, auf insgesamt
mindestens 40 Gigawatt bis zum Jahr 2035 und auf insgesamt mindestens 70
Gigawatt bis zum Jahr 2045 zu steigern.\end{minipage}%
%
\begin{minipage}{0.05\linewidth}
~\end{minipage}%
\newline
\begin{minipage}{\linewidth}
Gesetz zur Entwicklung und Förderung der Windenergie auf See
(Windenergie-auf-See-Gesetz - WindSeeG)
\href{https://www.gesetze-im-internet.de/windseeg/BJNR231000016.html}{Bundesministerium
der Justiz}\end{minipage}%

\end{figure}%

\end{minipage}%
\end{tcolorbox}

Die Ausbauziele der Bundesregierung legen für das Jahr 2030 bzw. 2035
eine installierte Leistung fest in Höhe von:

\begin{itemize}
\item
  115 GW Wind an Land bis 2030, 157 GW bis 2035,
\item
  30 GW Wind auf See bis 2030, 40 GW bis 2035,
\item
  215 GW Solar bis 2030, 309 GW bis 2035 sowie
\item
  8,4 GW Biomasse.
\end{itemize}

Dies bedeutet einen geplanten Zubau der installierten Leistung gemessen
an der installierten Leistung im Jahr 2023 von:

\begin{codelisting}

\caption{\label{lst-zubaufaktoren}}

\centering{

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Wind an Land 2030:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{( zubaufaktor\_windonshore\_2030 }\OperatorTok{:=} \DecValTok{115} \OperatorTok{/}\NormalTok{ (installierte\_leistung[}\StringTok{\textquotesingle{}Wind Onshore [MW]\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/} \DecValTok{1000}\NormalTok{) )}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Wind auf See 2030:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{( zubaufaktor\_windoffshore\_2030 }\OperatorTok{:=} \DecValTok{30} \OperatorTok{/}\NormalTok{ (installierte\_leistung[}\StringTok{\textquotesingle{}Wind Offshore [MW]\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/} \DecValTok{1000}\NormalTok{) )}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Solar 2030:}\CharTok{\textbackslash{}t\textbackslash{}t\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{( zubaufaktor\_solar\_2030 }\OperatorTok{:=} \DecValTok{215} \OperatorTok{/}\NormalTok{ (installierte\_leistung[}\StringTok{\textquotesingle{}Photovoltaik [MW]\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/} \DecValTok{1000}\NormalTok{) )}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Biomasse 2030:}\CharTok{\textbackslash{}t\textbackslash{}t}\SpecialCharTok{\{}\FloatTok{8.4} \OperatorTok{/}\NormalTok{ (installierte\_leistung[}\StringTok{\textquotesingle{}Biomasse [MW]\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/} \DecValTok{1000}\NormalTok{)}\SpecialCharTok{:,.2f\}}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n\textbackslash{}n}\SpecialStringTok{Wind an Land 2035:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{( zubaufaktor\_windonshore\_2035 }\OperatorTok{:=} \DecValTok{157} \OperatorTok{/}\NormalTok{ (installierte\_leistung[}\StringTok{\textquotesingle{}Wind Onshore [MW]\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/} \DecValTok{1000}\NormalTok{) )}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Wind auf See 2035:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{( zubaufaktor\_windoffshore\_2035 }\OperatorTok{:=} \DecValTok{40} \OperatorTok{/}\NormalTok{ (installierte\_leistung[}\StringTok{\textquotesingle{}Wind Offshore [MW]\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/} \DecValTok{1000}\NormalTok{) )}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Solar 2035:}\CharTok{\textbackslash{}t\textbackslash{}t\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{( zubaufaktor\_solar\_2035 }\OperatorTok{:=} \DecValTok{309} \OperatorTok{/}\NormalTok{ (installierte\_leistung[}\StringTok{\textquotesingle{}Photovoltaik [MW]\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/} \DecValTok{1000}\NormalTok{) )}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Biomasse 2035:}\CharTok{\textbackslash{}t\textbackslash{}t}\SpecialCharTok{\{}\FloatTok{8.4} \OperatorTok{/}\NormalTok{ (installierte\_leistung[}\StringTok{\textquotesingle{}Biomasse [MW]\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/} \DecValTok{1000}\NormalTok{)}\SpecialCharTok{:,.2f\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Wind an Land 2030:  2.00
Wind auf See 2030:  3.69
Solar 2030:         3.41
Biomasse 2030:      0.99


Wind an Land 2035:  2.73
Wind auf See 2035:  4.92
Solar 2035:         4.90
Biomasse 2035:      0.99
\end{verbatim}

}

\end{codelisting}%

Bis 2030 soll die Produktion durch Windkraftanlagen an Land verdoppelt
sowie durch Windkraftanlagen auf See und durch Photovoltaik
verdreieinhalbfacht werden. Bis 2035 soll Windkraft an Land fast
verdreifacht, Wind auf See und Photovoltaik verfünffacht werden.
Biomasse soll nicht weiter ausgebaut werden. Die Zubaufaktoren werden
jeweils in einem Objekt gespeichert.

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\vspace{-3mm}\textbf{Netzentwicklungsplan Strom}\vspace{3mm}

Neben der Erzeugungsleistung soll auch das Stromübertragungsnetz
ausgebaut werden. Die Planungen werden im Netzentwicklungsplan Strom
festgehalten, der alle zwei Jahre von den vier
Übertragungsnetzbetreibern in Abstimmung mit der Bundesnetzagentur
aktualisiert wird.

Der aktuelle und die bisherigen Netzentwicklungspläne können unter
\url{https://www.netzentwicklungsplan.de/} abgerufen werden.

\end{minipage}%
\end{tcolorbox}

\section{Hintergrund: Stromspeicher}\label{hintergrund-stromspeicher}

Stromspeicher speichern die Stromerzeugung in Überschussphasen, um die
Energie in Phasen der Unterdeckung wieder abzugeben. Verschiedene Arten
von Stromspeichern und ihre Einsatzgebiete werden im folgenden Video
vorgestellt. Die Speichertypen unterscheiden sich grundlegend
hinsichtlich ihrer Kapazität sowie der Lade- bzw. Entladeleistung.

\url{https://www.youtube.com/watch?v=yiJ1vAAJnVA}

Energietechnik. 14 Energiespeicherung. 14.02 Kennzahlen von Henrik te
Heesen ist lizensiert unter
\href{https://creativecommons.org/licenses/by-sa/3.0/deed.de}{CC BY-SA
3.0} und abrufbar auf
\href{https://www.youtube.com/watch?v=yiJ1vAAJnVA}{YouTube}. 2020

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-important-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-important-color-frame, coltitle=black, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Important \ref*{imp-Kenngrößen-Stromspeicher}: Ausgewählte Kenngrößen von Stromspeichern}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocalloutimp{imp-Kenngrößen-Stromspeicher} 

\begin{itemize}
\item
  Nominale Speicherkapazität: Energiemenge, die dem Stromspeicher
  entnommen werden kann.
\item
  Nutzbare Speicherkapazität: Beschädigungsfrei nutzbarer Anteil der
  nominalen Speicherkapazität.
\item
  Entladetiefe (Depth of Discharge, DoD): Differenz zwischen maximal und
  minimal erlaubten Ladezustand.
\item
  Ladezustand (State of Charge, SoC): Verhältnis der aktuell
  gespeicherten Energie zur nominalen Kapazität, i. d.~R. in Prozent
  angegeben.
\item
  Effizienz: Wirkungsgrad bei der Speicherung (Be- und Entladen und
  Speicherverluste wie Selbstentladung)
\end{itemize}

Weitere Kenngrößen werden im folgenden Video vorgestellt:

\url{https://www.youtube.com/watch?v=0-PRS2naETE}

Energietechnik. 14 Energiespeicherung. 14.03 Kenngrößen und
Begriffsdefinitionen von Henrik te Heesen ist lizensiert unter
\href{https://creativecommons.org/licenses/by-sa/3.0/deed.de}{CC BY-SA
3.0} und abrufbar auf
\href{https://www.youtube.com/watch?v=0-PRS2naETE}{YouTube}. 2020

\end{tcolorbox}

\section{Speichergröße berechnen}\label{speichergruxf6uxdfe-berechnen}

Im Folgenden werden Grundprinzipien der Speicherauslegung und die
entsprechenden Verfahren zu ihrer Berechnung entwickelt. Grundlage aller
Überlegungen ist die Restlastkurve. Werte kleiner als Null entsprechen
einer erneuerbaren Überschussproduktion, Werte größer als Null einer
durch Lastfolgekraftwerke oder Speicher zu bedienenden Netzlast. Die
Restlast wird wie folgt bestimmt:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{erneuerbare }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Biomasse [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wasserkraft [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Offshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Onshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Photovoltaik [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Sonstige Erneuerbare [MWh]\textquotesingle{}}\NormalTok{]}

\NormalTok{restlast }\OperatorTok{=}\NormalTok{ pd.DataFrame()}
\NormalTok{restlast[}\StringTok{"Netzlast [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ verbrauch[}\StringTok{"Gesamt (Netzlast) [MWh]"}\NormalTok{].copy() }
\NormalTok{restlast[}\StringTok{"Erneuerbare [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung[erneuerbare].}\BuiltInTok{sum}\NormalTok{(axis }\OperatorTok{=} \StringTok{"columns"}\NormalTok{).copy()}
\NormalTok{restlast[}\StringTok{"Restlast [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ restlast[}\StringTok{"Netzlast [MWh]"}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ restlast[}\StringTok{"Erneuerbare [MWh]"}\NormalTok{]}
\NormalTok{restlast }\OperatorTok{=}\NormalTok{ restlast[}\StringTok{"Restlast [MWh]"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Um die Größenordnung der Berechnungen besser einordnen zu können, wird
die Speichergröße zur bestehenden Pumpspeicherkapazität von 37,4 GWh ins
Verhältnis gesetzt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pumpspeicherkapazität\_MWh }\OperatorTok{=} \FloatTok{37.4} \OperatorTok{*} \DecValTok{1000}
\end{Highlighting}
\end{Shaded}

~

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-Testdaten}: Funktionsentwicklung mit Testdaten}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-Testdaten} 

Die im Folgenden entwickelten Funktionen bieten in der Regel eine Option
zur Ausgabe der Rechenergebnisse, die aber aufgrund der Länge der
vorliegenden Datenreihe zur Restlast nicht sinnvoll darstellbar sind.
Dadurch sind die Datenreihe selbst wie auch die Zwischen- und
Endergebnisse durchgeführter Berechnungen sowie vorhandene Fehler nicht
zu überblicken. Für die Funktionsentwicklung empfiehlt es sich daher,
mit Testdaten zu arbeiten. Auf diese Weise werden Berechnungen schneller
durchgeführt und Zwischenergebnisse und Ergebnisse können bei Bedarf zur
Überprüfung ausgegeben werden. Die nachfolgenden Funktionen wurden mit
zufällig generierten Testdaten entwickelt.

Im folgenden Code-Block wird eine Restlastkurve aus zehn zufälligen
Werten erzeugt. Durch Anpassen der Werte für a und b kann das Ergebnis
gesteuert werden. In der Ausgabe ist die Summe der Datenreihe
festgehalten. Ein negativer Wert bedeutet, dass über die simulierte
Restlastkurve eine Überschussproduktion erneuerbarer Energien herrscht.
Ein positiver Wert bedeutet, dass über die simulierte Restlastkurve die
positive Restlast größer als die erneuerbare Überschussproduktion ist.

Im Code-Block wird außerdem eine statische Datenreihe angelegt. Diese
dient dazu, Testdaten festzuhalten, die zu Fehlern geführt haben. Dazu
wird die Datenreihe random\_data in Listenform ausgegeben, sodass diese
durch Kopieren und Einfügen in die statische Datenreihe eingesetzt
werden kann.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ random }\ImportTok{as}\NormalTok{ rd}

\NormalTok{random\_data }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{10}\NormalTok{):}
\NormalTok{  random\_data.append(rd.randint(a }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{20}\NormalTok{, b }\OperatorTok{=} \DecValTok{20}\NormalTok{))}

\NormalTok{random\_data }\OperatorTok{=}\NormalTok{ pd.Series(random\_data, dtype }\OperatorTok{=} \StringTok{\textquotesingle{}float\textquotesingle{}}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"random\_data: }\SpecialCharTok{\{}\BuiltInTok{list}\NormalTok{(random\_data)}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{Summe random\_data: }\SpecialCharTok{\{}\NormalTok{random\_data}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{static\_data }\OperatorTok{=}\NormalTok{ pd.Series([}\DecValTok{8}\NormalTok{, }\OperatorTok{{-}}\DecValTok{14}\NormalTok{, }\OperatorTok{{-}}\DecValTok{7}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\OperatorTok{{-}}\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{, }\OperatorTok{{-}}\DecValTok{20}\NormalTok{, }\OperatorTok{{-}}\DecValTok{2}\NormalTok{, }\DecValTok{12}\NormalTok{], dtype }\OperatorTok{=} \StringTok{\textquotesingle{}float\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
random_data: [8.0, 16.0, 4.0, 15.0, -16.0, -19.0, -12.0, 13.0, 14.0, -5.0]
Summe random_data: 18.0
\end{verbatim}

\end{tcolorbox}

\subsection{Überschuss oder Defizit erneuerbarer
Energien}\label{uxfcberschuss-oder-defizit-erneuerbarer-energien}

Die erforderliche Größe des Stromspeichers ist einerseits abhängig von
dem Verhältnis aus der Menge der erneuerbaren Überschussproduktion und
der aus dem Speicher zu bedienenden Restlast. Andererseits spielt der
Wirkungsgrad η (griechischer Buchstabe Eta) des Speichers beim Ein- und
Ausspeichern von Strom eine Rolle.

\begin{figure}

\begin{minipage}{0.50\linewidth}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-53-output-1.png}}

\end{minipage}%
%
\begin{minipage}{0.50\linewidth}

\begin{description}
\tightlist
\item[Erneuerbare Stromproduktion: Überschuss oder Defizit?]
Ist die Summe der erneuerbaren Überschussproduktion kleiner als die aus
dem Speicher zu bedienende Restlast, entspricht die erforderliche
Speichergröße der Summe der erneuerbaren Überschussproduktion.

Ist die Summe der erneuerbaren Überschussproduktion größer als die aus
dem Speicher zu bedienende Restlast, entspricht die erforderliche
Speichergröße der Summe der zu bedienenden Restlast.

Ob ein Überschuss oder ein Defizit erneuerbarer Stromproduktion
vorliegt, kann am Vorzeichen der summierten Restlast abgelesen werden.
Ein negatives Vorzeichen entspricht einem erneuerbaren Stromüberschuss,
ein positives Vorzeichen einem erneuerbaren Stromdefizit.
\end{description}

\end{minipage}%
\newline
\begin{minipage}{0.50\linewidth}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-54-output-1.png}}

\end{minipage}%
%
\begin{minipage}{0.50\linewidth}

\begin{description}
\tightlist
\item[Wirkungsgrad]
Der Einspeicherwirkungsgrad vermindert den verfügbaren Überschussstrom.
Ist die Summe der erneuerbaren Überschussproduktion kleiner als die aus
dem Speicher zu bedienende Restlast, kann der Speicher um den
Einspeicherwirkungsgrad kleiner dimensioniert werden.

Der Ausspeicherwirkungsgrad (inklusive Speicherverluste) erhöht die
durch den Speicher zu bedienende Last. Ist die Summe der erneuerbaren
Überschussproduktion größer als die aus dem Speicher zu bedienende
Restlast, muss der Speicher um den Ausspeicherwirkungsgrad größer
dimensioniert werden.
\end{description}

\end{minipage}%

\end{figure}%

\subsubsection{Berechnung}\label{berechnung}

Ob im Jahresgang Phasen erneuerbarer Überproduktion oder Phasen
positiver Restlast vorherrschen, kann mit den folgenden Funktionen
bestimmt werden.

\section{ohne Wirkungsgrad}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# EE{-}Überschuss feststellen}
\CommentTok{\#\# Eingabe: data = pd.Series(data, dtype = \textquotesingle{}float\textquotesingle{})}
\CommentTok{\#\# Verarbeitung: über die pd.Series wird die Summe gebildet}
\CommentTok{\#\# Ausgabe: zurückgegeben wird der Wahrheitswert von data.sum() \textless{} 0}

\KeywordTok{def}\NormalTok{ prüfe\_EE\_Überschuss(data):}
  
  \ControlFlowTok{return}\NormalTok{ data.}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{\textless{}} \DecValTok{0}

\NormalTok{prüfe\_EE\_Überschuss(restlast)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
np.False_
\end{verbatim}

\section{mit Wirkungsgrad}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# EE{-}Überschuss feststellen, gegeben einen Ein{-} und Ausspeicherungswirkungsgrad}
\CommentTok{\#\# Eingabe: data = pd.Series(data, dtype = \textquotesingle{}float\textquotesingle{}), einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1}
\CommentTok{\#\# Verarbeitung: Werte kleiner 0 werden mit dem Einspeicherwirkungsgrad multipliziert}
\CommentTok{\#\# Verarbeitung: Werte größer 0 werden durch den Ausspeicherwirkungsgrad geteilt}
\CommentTok{\#\# Verarbeitung: über die pd.Series wird die Summe gebildet}
\CommentTok{\#\# Ausgabe: zurückgegeben wird der Wahrheitswert von data\_wirkungsgrad\_bereinigt.sum() \textless{} 0}

\KeywordTok{def}\NormalTok{ prüfe\_EE\_Überschuss(data, einspeicherwirkungsgrad }\OperatorTok{=} \DecValTok{1}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \DecValTok{1}\NormalTok{):}
\NormalTok{  data\_wirkungsgrad\_bereinigt }\OperatorTok{=}\NormalTok{ data.copy()}

\NormalTok{  data\_wirkungsgrad\_bereinigt[data\_wirkungsgrad\_bereinigt }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{] }\OperatorTok{=}\NormalTok{ data\_wirkungsgrad\_bereinigt[data\_wirkungsgrad\_bereinigt }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{] }\OperatorTok{*}\NormalTok{ einspeicherwirkungsgrad}
\NormalTok{  data\_wirkungsgrad\_bereinigt[data\_wirkungsgrad\_bereinigt }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{] }\OperatorTok{=}\NormalTok{ data\_wirkungsgrad\_bereinigt[data\_wirkungsgrad\_bereinigt }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{] }\OperatorTok{/}\NormalTok{ ausspeicherwirkungsgrad}
  
  \ControlFlowTok{return}\NormalTok{ data\_wirkungsgrad\_bereinigt.}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{\textless{}} \DecValTok{0}

\NormalTok{prüfe\_EE\_Überschuss(restlast, einspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
np.False_
\end{verbatim}

Wie aus der Grenzstromanalyse im Abschnitt
Section~\ref{sec-Pumpspeicherinhalt} bekannt, herrschte im Jahr 2023
kein Überschuss an erneuerbarer Stromproduktion.

\subsection{Zyklik}\label{zyklik}

Im Zeitraum eines Jahres beeinflusst die Reihenfolge von Phasen mit
erneuerbaren Überschüssen und mit positiver Restlast, wie groß ein
Speicher ausgelegt werden muss.

\begin{figure}

\begin{minipage}{0.50\linewidth}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-57-output-1.png}}

\end{minipage}%
%
\begin{minipage}{0.50\linewidth}

\begin{description}
\tightlist
\item[Reihenfolgeabhängigkeit]
Wird nur ein einziges Jahr betrachtet, entscheidet die Reihenfolge von
erneuerbarer Über- und Unterproduktion, wie viel Strom eingespeichert
werden kann. Im ungünstigsten Fall liegt im ersten Halbjahr eine
positive Restlast vor (der Speicher ist aber noch leer) und im zweiten
Halbjahr herrscht erneuerbare Überproduktion (die im zweiten Halbjahr
nicht mehr abgenommen werden würde).

Die Reihenfolgeabhängigkeit kann aufgelöst werden, indem zwei
aufeinanderfolgende Jahresgänge betrachtet werden. Im ersten Jahr wird
der Speicher leer ans Netz angeschlossen. Das zweite Jahr beginnt der
Speicher gefüllt durch die Überschussproduktion aus dem Vorjahr.
\end{description}

\end{minipage}%
\newline
\begin{minipage}{0.50\linewidth}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-58-output-1.png}}

\end{minipage}%
%
\begin{minipage}{0.50\linewidth}

\begin{description}
\tightlist
\item[Anzahl Vollzyklen]
Die erforderliche Größe des Stromspeichers ist abhängig von der
Verteilung der Restlast und der realisierten Anzahl Vollzyklen. Ein
Vollzyklus bedeutet, dass ein Speicher vollständig geladen und wieder
entladen wird.

Im ungünstigsten Fall wird nur ein einziger Lade- / Entladezyklus
gefahren. In diesem Fall entspricht die erforderliche Speichergröße der
Summe der erneuerbaren Überschussproduktion.

Je häufiger sich Lade- und Entladezyklen abwechseln, desto geringer ist
die erforderliche Speichergröße. Diese entspricht der Summe der
erneuerbaren Überschussproduktion geteilt durch die Anzahl der
Vollzyklen.
\end{description}

\end{minipage}%
\newline
\begin{minipage}{0.50\linewidth}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-59-output-1.png}}

\end{minipage}%
%
\begin{minipage}{0.50\linewidth}

\begin{description}
\tightlist
\item[Teilzyklen]
Auch die Verteilung auftretender Teilzyklen reduziert die erforderliche
Speichergröße.

Ist die Summe der erneuerbaren Überschussproduktion kleiner als die
durch den Speicher zu bedienende Restlast, entspricht die erforderliche
Speichergröße dem Minimum der kummulierten Summe der Restlast, wenn
diese niemals größer 0 gesetzt wird (das Überschreiten wäre der Moment,
in dem der Speicher leer ist).

Ist die Summe der erneuerbaren Überschussproduktion größer als die durch
den Speicher zu bedienende Restlast, entspricht die erforderliche
Speichergröße dem Maximum der kummulierten Summe der Restlast, wenn
diese niemals kleiner 0 gesetzt wird (das Unterschreiten wäre der
Moment, in dem der Speicher überdimensioniert ist).
\end{description}

\end{minipage}%

\end{figure}%

\subsubsection{Berechnung}\label{berechnung-1}

Die Speichergröße wird aus dem Jahresgang der Restlast berechnet. Um
nicht vom Zeitpunkt abhängig zu sein, an dem der Speicher an das Netz
angeschlossen wird, wird der Datensatz zwei mal durchlaufen (auflösen
der Reihenfolgeabhängigkeit). Die erforderliche Speichergröße wird
mittels der kummulierten Summe der Restlast berechnet. Wenn die Summe
der erneuerbaren Überschussproduktion kleiner als die Summe der durch
den Speicher zu bedienenden Restlast ist, wird die kummulierte Summe
niemals größer 0 gesetzt. Denn das Überschreiten dieser oberen Grenze
wäre der Moment, in dem der Speicher leer ist und positive Restlast
nicht mehr bedient werden kann. Ist dagegen die Summe der erneuerbaren
Überschussproduktion größer als die Summe der durch den Speicher zu
bedienenden Restlast, wird die kummulierte Summe niemals kleiner 0
gesetzt. Denn das Unterschreiten dieser Grenze wäre der Moment, in dem
der Speicher überdimensioniert ist und Energie vorgehalten wird, die im
Jahresgang niemals durch eine positive Restlast verbraucht wird.

\section{ohne Wirkungsgrad}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Speichergröße berechnen}
\CommentTok{\#\# Eingabe: data = pd.Series(data, dtype = \textquotesingle{}float\textquotesingle{}), output = False}
\CommentTok{\#\# Verarbeitung: aufrufen der Funktion prüfe\_EE\_Überschuss, um zwischen oberer Grenze = 0 (Speicher ist leer) und unterer Grenze = 0 (Speicher ist überdimensioniert) zu unterscheiden}
\CommentTok{\#\# Verarbeitung: data wird zwei mal zu data\_x2 verkettet. Für data\_x2 wird die bei 0 gekappte kumulierte Summe berechnet und die Speichergröße berechnet.}
\CommentTok{\#\# Ausgabe: wenn output = False wird die Speichergröße (float) zurückgegeben, wenn output = True werden die Summe von data und die Speichergröße mit print() ausgegeben}

\KeywordTok{def}\NormalTok{ berechne\_speichergröße(data, output }\OperatorTok{=} \VariableTok{False}\NormalTok{):}

\NormalTok{  data\_x2 }\OperatorTok{=}\NormalTok{ pd.concat([data, data])}

\NormalTok{  überschuss }\OperatorTok{=}\NormalTok{ prüfe\_EE\_Überschuss(data)}
  
  \ControlFlowTok{if}\NormalTok{ überschuss:}
    
    \CommentTok{\# gekappte kumulierte Summe berechnen}
\NormalTok{    capped\_cumsum }\OperatorTok{=}\NormalTok{ []}
\NormalTok{    summe }\OperatorTok{=} \DecValTok{0}

    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ data\_x2:}
\NormalTok{      summe }\OperatorTok{+=}\NormalTok{ i }

      \CommentTok{\# Untergrenze prüfen}
      \ControlFlowTok{if}\NormalTok{ summe }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{:}
\NormalTok{        summe }\OperatorTok{=} \DecValTok{0}
      
\NormalTok{      capped\_cumsum.append(summe)}

\NormalTok{    speichergröße }\OperatorTok{=} \BuiltInTok{max}\NormalTok{(capped\_cumsum)}
  
  \ControlFlowTok{else}\NormalTok{:}

    \CommentTok{\# gekappte kumulierte Summe berechnen}
\NormalTok{    capped\_cumsum }\OperatorTok{=}\NormalTok{ []}
\NormalTok{    summe }\OperatorTok{=} \DecValTok{0}

    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ data\_x2:}
\NormalTok{      summe }\OperatorTok{+=}\NormalTok{ i}

      \CommentTok{\# Obergrenze prüfen}
      \ControlFlowTok{if}\NormalTok{ summe }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{:}
\NormalTok{        summe }\OperatorTok{=} \DecValTok{0}
      
\NormalTok{      capped\_cumsum.append(summe)}

\NormalTok{    speichergröße }\OperatorTok{=} \BuiltInTok{abs}\NormalTok{(}\BuiltInTok{min}\NormalTok{(capped\_cumsum))}

  \ControlFlowTok{if}\NormalTok{ output: }\CommentTok{\# output = True}

    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Summe data: }\SpecialCharTok{\{}\NormalTok{data}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{Speichergröße: }\SpecialCharTok{\{}\NormalTok{speichergr}\SpecialCharTok{öß}\NormalTok{e}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
    
  \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# output = False}
    \ControlFlowTok{return}\NormalTok{ speichergröße}
  
\NormalTok{speicher\_2023 }\OperatorTok{=}\NormalTok{ berechne\_speichergröße(restlast, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"erforderliche Speichergröße 2023: }\SpecialCharTok{\{}\NormalTok{speicher\_2023}\SpecialCharTok{:,.1f\}}\SpecialStringTok{ MWh}\CharTok{\textbackslash{}n}\SpecialStringTok{Dies entspricht }\SpecialCharTok{\{}\NormalTok{speicher\_2023 }\OperatorTok{/}\NormalTok{ pumpspeicherkapazit}\SpecialCharTok{ä}\NormalTok{t\_MWh}\SpecialCharTok{:,.1f\}}\SpecialStringTok{ Pumpspeicheräquivalenten."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
erforderliche Speichergröße 2023: 119,667.0 MWh
Dies entspricht 3.2 Pumpspeicheräquivalenten.
\end{verbatim}

\section{mit Wirkungsgrad}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Speichergröße berechnen}
\CommentTok{\#\# Eingabe: data = pd.Series(data, dtype = \textquotesingle{}float\textquotesingle{}), einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, output = False}
\CommentTok{\#\# Verarbeitung: aufrufen der Funktion prüfe\_EE\_Überschuss, um zwischen oberer Grenze = 0 (Speicher ist leer) und unterer Grenze = 0 (Speicher ist überdimensioniert) zu unterscheiden}
\CommentTok{\#\# Verarbeitung: data wird zwei mal zu data\_x2 verkettet. Für data\_x2 wird die bei 0 gekappte kumulierte Summe berechnet und die Speichergröße berechnet.}
\CommentTok{\#\# Ausgabe: wenn output = False wird die Speichergröße (float) zurückgegeben, wenn output = True werden die Summe von data und die Speichergröße mit print() ausgegeben}

\KeywordTok{def}\NormalTok{ berechne\_speichergröße(data, einspeicherwirkungsgrad }\OperatorTok{=} \DecValTok{1}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \DecValTok{1}\NormalTok{, output }\OperatorTok{=} \VariableTok{False}\NormalTok{):}

\NormalTok{  data\_x2 }\OperatorTok{=}\NormalTok{ pd.concat([data, data])}

\NormalTok{  überschuss }\OperatorTok{=}\NormalTok{ prüfe\_EE\_Überschuss(data, einspeicherwirkungsgrad, ausspeicherwirkungsgrad)}
  
  \ControlFlowTok{if}\NormalTok{ überschuss:}
    
    \CommentTok{\# gekappte kumulierte Summe berechnen}
\NormalTok{    capped\_cumsum }\OperatorTok{=}\NormalTok{ []}
\NormalTok{    summe }\OperatorTok{=} \DecValTok{0}

    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ data\_x2:}
      \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{:}
\NormalTok{        summe }\OperatorTok{+=}\NormalTok{ i }\OperatorTok{*}\NormalTok{ einspeicherwirkungsgrad}
      \ControlFlowTok{else}\NormalTok{:}
\NormalTok{        summe }\OperatorTok{+=}\NormalTok{ i }\OperatorTok{/}\NormalTok{ ausspeicherwirkungsgrad}

      \CommentTok{\# Untergrenze prüfen}
      \ControlFlowTok{if}\NormalTok{ summe }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{:}
\NormalTok{        summe }\OperatorTok{=} \DecValTok{0}
      
\NormalTok{      capped\_cumsum.append(summe)}

\NormalTok{    speichergröße }\OperatorTok{=} \BuiltInTok{max}\NormalTok{(capped\_cumsum)}
  
  \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# Unterproduktion}

    \CommentTok{\# gekappte kumulierte Summe berechnen}
\NormalTok{    capped\_cumsum }\OperatorTok{=}\NormalTok{ []}
\NormalTok{    summe }\OperatorTok{=} \DecValTok{0}

    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ data\_x2:}
      \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{:}
\NormalTok{        summe }\OperatorTok{+=}\NormalTok{ i }\OperatorTok{*}\NormalTok{ einspeicherwirkungsgrad}
      \ControlFlowTok{else}\NormalTok{:}
\NormalTok{        summe }\OperatorTok{+=}\NormalTok{ i }\OperatorTok{/}\NormalTok{ ausspeicherwirkungsgrad}

      \CommentTok{\# Obergrenze prüfen}
      \ControlFlowTok{if}\NormalTok{ summe }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{:}
\NormalTok{        summe }\OperatorTok{=} \DecValTok{0}
      
\NormalTok{      capped\_cumsum.append(summe)}

\NormalTok{    speichergröße }\OperatorTok{=} \BuiltInTok{abs}\NormalTok{(}\BuiltInTok{min}\NormalTok{(capped\_cumsum))}

  \ControlFlowTok{if}\NormalTok{ output: }\CommentTok{\# output = True}

    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Summe data: }\SpecialCharTok{\{}\NormalTok{data}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{Speichergröße: }\SpecialCharTok{\{}\NormalTok{speichergr}\SpecialCharTok{öß}\NormalTok{e}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

  \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# output = False}
    \ControlFlowTok{return}\NormalTok{ speichergröße}

\NormalTok{speicher\_2023 }\OperatorTok{=}\NormalTok{ berechne\_speichergröße(restlast, einspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"erforderliche Speichergröße 2023: }\SpecialCharTok{\{}\NormalTok{speicher\_2023}\SpecialCharTok{:,.1f\}}\SpecialStringTok{ MWh}\CharTok{\textbackslash{}n}\SpecialStringTok{Dies entspricht }\SpecialCharTok{\{}\NormalTok{speicher\_2023 }\OperatorTok{/}\NormalTok{ pumpspeicherkapazit}\SpecialCharTok{ä}\NormalTok{t\_MWh}\SpecialCharTok{:,.1f\}}\SpecialStringTok{ Pumpspeicheräquivalenten."}\NormalTok{)   }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
erforderliche Speichergröße 2023: 102,674.5 MWh
Dies entspricht 2.7 Pumpspeicheräquivalenten.
\end{verbatim}

\subsubsection{Jahresgang des Speichers}\label{jahresgang-des-speichers}

Nachdem die Speichergröße bestimmt wurde, kann der Jahresgang des
Speichers für das erste und das zweite Jahr berechnet sowie grafisch
dargestellt werden. Der Jahresgang des Speichers für das zweite Jahr ist
das stabile Gleichgewicht, mit dem eine gegebene Restlastkurve beliebig
oft durchlaufen werden kann.

\begin{itemize}
\item
  Eingabe: Der Funktion wird eine Restlastkurve übergeben. Außerdem kann
  eine Speichergröße übergeben werden, andernfalls wird diese durch
  Aufruf der Funktion \texttt{berechne\_speichergröße()} ermittelt.
\item
  Verarbeitung: Beginnend mit einem leeren Speicher wird die
  Restlastdatenreihe zwei mal elementweise durchlaufen. Negative Werte
  werden in den Speicher übertragen, bis die Speicherkapazität erreicht
  wurde. Positive Werte werden dem Speicher entnommen, bis der Ladestand
  des Speichers Null beträgt. In der um Ein- und
  Ausspeicherwirkungsgrade erweiterten Funktion werden eingespeicherte
  Werte mit dem Einspeicherwirkungsgrad (0.9) multipliziert und
  ausgespeicherte Werte durch den Ausspeicherwirkungsgrad (0.9) geteilt.
\item
  Ausgabe: Die Funktion gibt, wenn \texttt{output\ =\ False} ist, ein
  Tupel zurück. An Position 0 ist die Speichergröße gespeichert, an
  Position 1 der Jahresgang in Jahr 1 als pd.Series, an Position 2 der
  Jahresgang in Jahr 2 als pd.Series. Die Jahresgänge werden im
  Folgenden Panel grafisch dargestellt. Wenn `output = True', werden die
  kumulierte Summe der Restlast und die Speichergröße sowie die
  übergebene Restlastkurve, die Ladestände und freie Kapazität des
  Speichers im Jahresgang für Jahr 1 und Jahr 2 mit \texttt{print()}
  ausgegeben - dies ist in der Regel nur für Testdaten sinnvoll.
\end{itemize}

\section{ohne Wirkungsgrad}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Jahresgang des Speichers berechnen}
\CommentTok{\#\# Eingabe: data = pd.Series(data, dtype = \textquotesingle{}float\textquotesingle{}), speichergröße = {-}1, output = False}
\CommentTok{\#\# Verarbeitung: Wenn speichergröße = {-}1 wird die Speichergröße mit der Funktion berechne\_speichergröße(data) ermittelt}
\CommentTok{\#\# Verarbeitung: data wird zwei mal zu data\_x2 verkettet.}
\CommentTok{\#\# Verarbeitung: Anhand der Speichergröße werden der Ladestand und die freie Kapazität des Speichers für alle Werte von data für Jahr1 und alle Folgejahre berechnet.}
\CommentTok{\#\# Ausgabe: Wenn output False ist, wird ein Tupel aus speichergröße (float), Ladestand Jahr1 (pd.Series), Ladestand Jahr2 (pd.Series) zurückgegeben.}
\CommentTok{\#\# Ausgabe: Wenn output True, werden die kumulierte Summe der Restlast, die Speichergröße, die Restlastkurve, die Ladestände und freie Kapazität des Speichers im Jahresgang für Jahr 1 und Jahr 2 mit ausgegeben}

\KeywordTok{def}\NormalTok{ jahresgang\_speicher\_berechnen(data, speichergröße }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{1}\NormalTok{, output }\OperatorTok{=} \VariableTok{False}\NormalTok{):}

\NormalTok{  data\_x2 }\OperatorTok{=}\NormalTok{ pd.concat([data, data])}

  \ControlFlowTok{if}\NormalTok{ speichergröße }\OperatorTok{==} \OperatorTok{{-}}\DecValTok{1}\NormalTok{:}
\NormalTok{    speichergröße }\OperatorTok{=}\NormalTok{ berechne\_speichergröße(data) }

\CommentTok{\# Jahresgang des Speichers berechnen}
\NormalTok{  jahresgang\_speicher }\OperatorTok{=}\NormalTok{ []}
\NormalTok{  ladestand\_speicher }\OperatorTok{=}\NormalTok{ []}
\NormalTok{  freie\_speicherkapazität }\OperatorTok{=}\NormalTok{ speichergröße }\CommentTok{\# der speicher ist leer}
  \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ data\_x2:}

    \ControlFlowTok{if}\NormalTok{ (speichergröße }\OperatorTok{{-}}\NormalTok{ freie\_speicherkapazität) }\OperatorTok{{-}}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{: }\CommentTok{\# last ohne vorherige Einspeicherung kann nicht bedient werden}
\NormalTok{      freie\_speicherkapazität }\OperatorTok{=}\NormalTok{ speichergröße}

    \ControlFlowTok{elif}\NormalTok{ freie\_speicherkapazität }\OperatorTok{+}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{: }\CommentTok{\# wenn der Speicher voll ist, muss Überschuss verworfen werden.}
\NormalTok{      freie\_speicherkapazität }\OperatorTok{=} \DecValTok{0}
      
    \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# Ein{-}/Ausspeicherung}
\NormalTok{      freie\_speicherkapazität }\OperatorTok{+=}\NormalTok{ i}

\NormalTok{    jahresgang\_speicher.append(freie\_speicherkapazität)}
\NormalTok{    ladestand\_speicher.append(speichergröße }\OperatorTok{{-}}\NormalTok{ freie\_speicherkapazität)}

  \ControlFlowTok{if}\NormalTok{ output: }\CommentTok{\# output = True}

\NormalTok{    dataset }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}Restlast\textquotesingle{}}\NormalTok{: data, }\StringTok{\textquotesingle{}Ladestand Jahr1\textquotesingle{}}\NormalTok{: ladestand\_speicher[ : }\BuiltInTok{len}\NormalTok{(jahresgang\_speicher) }\OperatorTok{//} \DecValTok{2}\NormalTok{ ], }\StringTok{\textquotesingle{}freie Kapazität Jahr1\textquotesingle{}}\NormalTok{: jahresgang\_speicher[ : }\BuiltInTok{len}\NormalTok{(jahresgang\_speicher) }\OperatorTok{//} \DecValTok{2}\NormalTok{ ], }\StringTok{\textquotesingle{}Ladestand Folgejahre\textquotesingle{}}\NormalTok{: ladestand\_speicher[ }\BuiltInTok{len}\NormalTok{(jahresgang\_speicher) }\OperatorTok{//} \DecValTok{2}\NormalTok{ : ], }\StringTok{\textquotesingle{}freie Kapazität Folgejahre\textquotesingle{}}\NormalTok{: jahresgang\_speicher[ }\BuiltInTok{len}\NormalTok{(jahresgang\_speicher) }\OperatorTok{//} \DecValTok{2}\NormalTok{ : ]\})}

    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Summe data: }\SpecialCharTok{\{}\NormalTok{data}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{Speichergröße: }\SpecialCharTok{\{}\NormalTok{speichergr}\SpecialCharTok{öß}\NormalTok{e}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(dataset)}

  \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# output = False}
    \ControlFlowTok{return}\NormalTok{ speichergröße, pd.Series(ladestand\_speicher[ : }\BuiltInTok{len}\NormalTok{(jahresgang\_speicher) }\OperatorTok{//} \DecValTok{2}\NormalTok{ ]), pd.Series(ladestand\_speicher[ }\BuiltInTok{len}\NormalTok{(jahresgang\_speicher) }\OperatorTok{//} \DecValTok{2}\NormalTok{ : ])}

\NormalTok{speicher\_2023 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_berechnen(restlast, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\section{Plot ohne Wirkungsgrad}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-63-output-1.png}}

}

\caption{Restlast 2023 und Jahresgang eines Speichers mit Wirkungsgrad
1}

\end{figure}%

\section{Code für den Plot ohne Wirkungsgrad}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Daten einlesen}
\NormalTok{jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ speicher\_2023[}\DecValTok{1}\NormalTok{]}
\NormalTok{jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ speicher\_2023[}\DecValTok{2}\NormalTok{]}

\CommentTok{\# xticks erzeugen}
\NormalTok{monate\_index }\OperatorTok{=}\NormalTok{ erzeugung[}\OperatorTok{\textasciitilde{}}\NormalTok{erzeugung[}\StringTok{"Datum von"}\NormalTok{].dt.month.duplicated()].index}
\NormalTok{monatsnamen }\OperatorTok{=}\NormalTok{ erzeugung[}\StringTok{"Datum von"}\NormalTok{].iloc[monate\_index].dt.strftime(}\StringTok{"\%B"}\NormalTok{) }

\CommentTok{\# Grafik mit drei subplots erzeugen}
\NormalTok{font\_size }\OperatorTok{=} \DecValTok{10}

\NormalTok{fig, (ax1, ax2, ax3) }\OperatorTok{=}\NormalTok{ plt.subplots(}\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, figsize }\OperatorTok{=}\NormalTok{ (}\FloatTok{7.5}\NormalTok{, }\DecValTok{6}\NormalTok{), height\_ratios }\OperatorTok{=}\NormalTok{ [}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{], sharex }\OperatorTok{=} \VariableTok{True}\NormalTok{, layout }\OperatorTok{=} \StringTok{\textquotesingle{}tight\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.suptitle(}\StringTok{\textquotesingle{}Restlast 2023 und Jahresgang eines Speichers mit Wirkungsgrad 1\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xticks(monate\_index, monatsnamen, rotation }\OperatorTok{=} \DecValTok{45}\NormalTok{)}\OperatorTok{;}
\NormalTok{plt.minorticks\_off()}
\NormalTok{plt.setp([ax1, ax2, ax3], xlim }\OperatorTok{=}\NormalTok{ (restlast.index.}\BuiltInTok{min}\NormalTok{() }\OperatorTok{{-}} \BuiltInTok{len}\NormalTok{(restlast.index) }\OperatorTok{/} \DecValTok{100}\NormalTok{, restlast.index.}\BuiltInTok{max}\NormalTok{() }\OperatorTok{*} \FloatTok{1.01}\NormalTok{))}
\NormalTok{plt.setp([ax2, ax3], ylim }\OperatorTok{=}\NormalTok{ (}\DecValTok{0}\NormalTok{, }\BuiltInTok{max}\NormalTok{(}\BuiltInTok{max}\NormalTok{(jahresgang\_speicher\_jahr1), }\BuiltInTok{max}\NormalTok{(jahresgang\_speicher\_jahr2)) }\OperatorTok{*} \FloatTok{1.1}\NormalTok{))}

\CommentTok{\#\# plot restlast}
\NormalTok{ax1.plot(restlast, label }\OperatorTok{=} \StringTok{"Restlast"}\NormalTok{)}
\NormalTok{ax1.grid()}
\NormalTok{ax1.set\_ylabel(}\StringTok{\textquotesingle{}MWh\textquotesingle{}}\NormalTok{)}
\NormalTok{ax1.legend()}

\CommentTok{\#\# plot jahresgang\_speicher\_jahr1}
\NormalTok{ax2.plot(jahresgang\_speicher\_jahr1, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}{-}\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Stromspeicher Jahr 1\textquotesingle{}}\NormalTok{)}
\NormalTok{ax2.grid()}
\NormalTok{ax2.set\_ylabel(}\StringTok{\textquotesingle{}MWh\textquotesingle{}}\NormalTok{)}
\NormalTok{ax2.legend()}

\CommentTok{\#\# plot jahresgang\_speicher\_jahr2}
\NormalTok{ax3.plot(jahresgang\_speicher\_jahr2, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}{-}\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Stromspeicher Jahr 2\textquotesingle{}}\NormalTok{)}
\NormalTok{ax3.tick\_params(axis }\OperatorTok{=} \StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{, rotation }\OperatorTok{=} \DecValTok{45}\NormalTok{)}
\NormalTok{ax3.set\_ylabel(}\StringTok{\textquotesingle{}MWh\textquotesingle{}}\NormalTok{)}
\NormalTok{ax3.grid()}
\NormalTok{ax3.legend()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\section{mit Wirkungsgrad}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Jahresgang des Speichers berechnen}
\CommentTok{\#\# Eingabe: data = pd.Series(data, dtype = \textquotesingle{}float\textquotesingle{}), speichergröße = {-}1, einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, output = False}
\CommentTok{\#\# Verarbeitung: Wenn speichergröße = {-}1 wird die Speichergröße mit der Funktion berechne\_speichergröße(data) ermittelt}
\CommentTok{\#\# Verarbeitung: data wird zwei mal zu data\_x2 verkettet.}
\CommentTok{\#\# Verarbeitung: Anhand der Speichergröße werden der Ladestand und die freie Kapazität des Speichers für alle Werte von data für Jahr1 und alle Folgejahre berechnet.}
\CommentTok{\#\# Ausgabe: Wenn output False ist, wird ein Tupel aus speichergröße (float), Ladestand Jahr1 (pd.Series), Ladestand Jahr2 (pd.Series) zurückgegeben.}
\CommentTok{\#\# Ausgabe: Wenn output True, werden die kumulierte Summe der Restlast, die Speichergröße, die Restlastkurve, die Ladestände und freie Kapazität des Speichers im Jahresgang für Jahr 1 und Jahr 2 mit ausgegeben}

\KeywordTok{def}\NormalTok{ jahresgang\_speicher\_berechnen(data, speichergröße }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{1}\NormalTok{, einspeicherwirkungsgrad }\OperatorTok{=} \DecValTok{1}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \DecValTok{1}\NormalTok{, output }\OperatorTok{=} \VariableTok{False}\NormalTok{):}

\NormalTok{  data\_x2 }\OperatorTok{=}\NormalTok{ pd.concat([data, data])}

  \ControlFlowTok{if}\NormalTok{ speichergröße }\OperatorTok{==} \OperatorTok{{-}}\DecValTok{1}\NormalTok{:}
\NormalTok{    speichergröße }\OperatorTok{=}\NormalTok{ berechne\_speichergröße(data, einspeicherwirkungsgrad, ausspeicherwirkungsgrad) }

\NormalTok{  jahresgang\_speicher }\OperatorTok{=}\NormalTok{ []}
\NormalTok{  ladestand\_speicher }\OperatorTok{=}\NormalTok{ []}
\NormalTok{  freie\_speicherkapazität }\OperatorTok{=}\NormalTok{ speichergröße }\CommentTok{\# der speicher ist leer }
  \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ data\_x2:}

    \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{: }\CommentTok{\# Restlast}

      \CommentTok{\# last ohne entsprechende vorherige Einspeicherung kann nicht vollständig bedient werden, der Speicher ist dann leer}
      \ControlFlowTok{if}\NormalTok{ (speichergröße }\OperatorTok{{-}}\NormalTok{ freie\_speicherkapazität) }\OperatorTok{{-}}\NormalTok{ i }\OperatorTok{/}\NormalTok{ ausspeicherwirkungsgrad }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{:}
\NormalTok{        freie\_speicherkapazität }\OperatorTok{=}\NormalTok{ speichergröße}

      \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# Ausspeicherung}
\NormalTok{        freie\_speicherkapazität }\OperatorTok{+=}\NormalTok{ i }\OperatorTok{/}\NormalTok{ ausspeicherwirkungsgrad }\CommentTok{\# hier kann zu viel ausgespeichert werden}
        \ControlFlowTok{if}\NormalTok{ freie\_speicherkapazität }\OperatorTok{\textgreater{}}\NormalTok{ speichergröße:}
\NormalTok{          freie\_speicherkapazität }\OperatorTok{=}\NormalTok{ speichergröße}
    
    \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# i \textless{}= 0 EE{-}Überschuss}
      
      \CommentTok{\# wenn der Speicher voll ist, muss Überschuss verworfen werden.}
      \ControlFlowTok{if}\NormalTok{ freie\_speicherkapazität }\OperatorTok{+}\NormalTok{ i }\OperatorTok{*}\NormalTok{ einspeicherwirkungsgrad }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{: }
\NormalTok{        freie\_speicherkapazität }\OperatorTok{=} \DecValTok{0}
      
      \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# Einspeicherung}
\NormalTok{        freie\_speicherkapazität }\OperatorTok{+=}\NormalTok{ i }\OperatorTok{*}\NormalTok{ einspeicherwirkungsgrad}

\NormalTok{    jahresgang\_speicher.append(freie\_speicherkapazität)}
\NormalTok{    ladestand\_speicher.append(speichergröße }\OperatorTok{{-}}\NormalTok{ freie\_speicherkapazität)}

  \ControlFlowTok{if}\NormalTok{ output: }\CommentTok{\# output = True}

\NormalTok{    dataset }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}Restlast\textquotesingle{}}\NormalTok{: data, }\StringTok{\textquotesingle{}Ladestand Jahr1\textquotesingle{}}\NormalTok{: ladestand\_speicher[ : }\BuiltInTok{len}\NormalTok{(jahresgang\_speicher) }\OperatorTok{//} \DecValTok{2}\NormalTok{ ], }\StringTok{\textquotesingle{}freie Kapazität Jahr1\textquotesingle{}}\NormalTok{: jahresgang\_speicher[ : }\BuiltInTok{len}\NormalTok{(jahresgang\_speicher) }\OperatorTok{//} \DecValTok{2}\NormalTok{ ], }\StringTok{\textquotesingle{}Ladestand Folgejahre\textquotesingle{}}\NormalTok{: ladestand\_speicher[ }\BuiltInTok{len}\NormalTok{(jahresgang\_speicher) }\OperatorTok{//} \DecValTok{2}\NormalTok{ : ], }\StringTok{\textquotesingle{}freie Kapazität Folgejahre\textquotesingle{}}\NormalTok{: jahresgang\_speicher[ }\BuiltInTok{len}\NormalTok{(jahresgang\_speicher) }\OperatorTok{//} \DecValTok{2}\NormalTok{ : ]\})}

    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Summe data: }\SpecialCharTok{\{}\NormalTok{data}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{Speichergröße: }\SpecialCharTok{\{}\NormalTok{speichergr}\SpecialCharTok{öß}\NormalTok{e}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(dataset)}

  \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# output = False}
    \ControlFlowTok{return}\NormalTok{ speichergröße, pd.Series(ladestand\_speicher[ : }\BuiltInTok{len}\NormalTok{(jahresgang\_speicher) }\OperatorTok{//} \DecValTok{2}\NormalTok{ ]), pd.Series(ladestand\_speicher[ }\BuiltInTok{len}\NormalTok{(jahresgang\_speicher) }\OperatorTok{//} \DecValTok{2}\NormalTok{ : ])}

\NormalTok{speicher\_2023\_wirkungsgrad\_90\_90 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_berechnen(restlast, einspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\section{Plot mit Wirkungsgrad}

\begin{figure}[H]

{\centering \pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-66-output-1.png}}

}

\caption{Restlast 2023 und Jahresgang eines Speichers mit Ein- und
Ausspeicherwirkungsgrad 0.9}

\end{figure}%

\section{Code für den Plot mit Wirkungsgrad}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Daten einlesen}
\NormalTok{jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ speicher\_2023\_wirkungsgrad\_90\_90[}\DecValTok{1}\NormalTok{]}
\NormalTok{jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ speicher\_2023\_wirkungsgrad\_90\_90[}\DecValTok{2}\NormalTok{]}

\CommentTok{\# xticks erzeugen}
\NormalTok{monate\_index }\OperatorTok{=}\NormalTok{ erzeugung[}\OperatorTok{\textasciitilde{}}\NormalTok{erzeugung[}\StringTok{"Datum von"}\NormalTok{].dt.month.duplicated()].index}
\NormalTok{monatsnamen }\OperatorTok{=}\NormalTok{ erzeugung[}\StringTok{"Datum von"}\NormalTok{].iloc[monate\_index].dt.strftime(}\StringTok{"\%B"}\NormalTok{) }

\CommentTok{\# Grafik mit drei subplots erzeugen}
\NormalTok{font\_size }\OperatorTok{=} \DecValTok{10}

\NormalTok{fig, (ax1, ax2, ax3) }\OperatorTok{=}\NormalTok{ plt.subplots(}\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, figsize }\OperatorTok{=}\NormalTok{ (}\FloatTok{7.5}\NormalTok{, }\DecValTok{6}\NormalTok{), height\_ratios }\OperatorTok{=}\NormalTok{ [}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{], sharex }\OperatorTok{=} \VariableTok{True}\NormalTok{, layout }\OperatorTok{=} \StringTok{\textquotesingle{}tight\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.suptitle(}\StringTok{\textquotesingle{}Restlast 2023 und Jahresgang eines Speichers mit Ein{-} und Ausspeicherwirkungsgrad 0.9\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xticks(monate\_index, monatsnamen, rotation }\OperatorTok{=} \DecValTok{45}\NormalTok{)}\OperatorTok{;}
\NormalTok{plt.minorticks\_off()}
\NormalTok{plt.setp([ax1, ax2, ax3], xlim }\OperatorTok{=}\NormalTok{ (restlast.index.}\BuiltInTok{min}\NormalTok{() }\OperatorTok{{-}} \BuiltInTok{len}\NormalTok{(restlast.index) }\OperatorTok{/} \DecValTok{100}\NormalTok{, restlast.index.}\BuiltInTok{max}\NormalTok{() }\OperatorTok{*} \FloatTok{1.01}\NormalTok{))}
\NormalTok{plt.setp([ax2, ax3], ylim }\OperatorTok{=}\NormalTok{ (}\DecValTok{0}\NormalTok{, }\BuiltInTok{max}\NormalTok{(}\BuiltInTok{max}\NormalTok{(jahresgang\_speicher\_jahr1), }\BuiltInTok{max}\NormalTok{(jahresgang\_speicher\_jahr2)) }\OperatorTok{*} \FloatTok{1.1}\NormalTok{))}

\CommentTok{\#\# plot restlast}
\NormalTok{ax1.plot(restlast, label }\OperatorTok{=} \StringTok{"Restlast"}\NormalTok{)}
\NormalTok{ax1.grid()}
\NormalTok{ax1.set\_ylabel(}\StringTok{\textquotesingle{}MWh\textquotesingle{}}\NormalTok{)}
\NormalTok{ax1.legend()}

\CommentTok{\#\# plot jahresgang\_speicher\_jahr1}
\NormalTok{ax2.plot(jahresgang\_speicher\_jahr1, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}{-}\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Stromspeicher Jahr 1\textquotesingle{}}\NormalTok{)}
\NormalTok{ax2.grid()}
\NormalTok{ax2.set\_ylabel(}\StringTok{\textquotesingle{}MWh\textquotesingle{}}\NormalTok{)}
\NormalTok{ax2.legend()}

\CommentTok{\#\# plot jahresgang\_speicher\_jahr2}
\NormalTok{ax3.plot(jahresgang\_speicher\_jahr2, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}{-}\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Stromspeicher Jahr 2\textquotesingle{}}\NormalTok{)}
\NormalTok{ax3.tick\_params(axis }\OperatorTok{=} \StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{, rotation }\OperatorTok{=} \DecValTok{45}\NormalTok{)}
\NormalTok{ax3.set\_ylabel(}\StringTok{\textquotesingle{}MWh\textquotesingle{}}\NormalTok{)}
\NormalTok{ax3.grid()}
\NormalTok{ax3.legend()}

\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

Die benötigte Kapazität des Speichers ergibt sich aus den ereuerbaren
Erzeugungsüberschüssen während der Weihnachtsfeiertage. Diese
Kapazitäten werden im übrigen Jahr kaum genutzt, der Speicher ist die
meiste Zeit des Jahres leer. Der Jahresgang für das erste und das zweite
Jahr ist optisch identisch. Dies kann mit
\texttt{pd.Series1.equals(pd.Series2)} leicht überprüft werden. Werden
Ein- und Ausspeicherwirkungsgrade berücksichtigt, reduzieren sich die
ein- und ausgespeicherte Energie und somit die erforderliche
Speichergröße.

\subsubsection{Zyklenzahl berechnen}\label{zyklenzahl-berechnen}

Anhand der Speichergröße und des Jahresgangs des Speichers kann die
Zyklenzahl im ersten und in allen Folgejahren berechnet werden. Ein
Zyklus entspricht der vollständigen Ladung und Entladung des Speichers
bzw. einer entsprechenden Anzahl von Teilladezyklen. Die Zyklenzahl
ergibt sich somit aus der Summe der im Jahresgang des Speichers ein-
bzw. ausgespeicherten Energie, die durch die Speichergröße und durch 2
geteilt wird.

\begin{itemize}
\item
  Eingabe: Der Funktion kann ein Tupel bestehend aus einer Speichergröße
  an Position 0 und Speicherjahresgängen für Jahr 1 und Jahr 2 an den
  Positionen 1 und 2 übergeben werden. Andernfalls werden diese durch
  Aufruf der Funktion \texttt{jahresgang\_speicher\_berechnen} ermittelt
  (ohne bzw. mit Ein- und Ausspeicherwirkungsgrad).
\item
  Verarbeitung: Um die ein- und ausgespeicherte Energie zu bestimmen,
  wird für die Speicherjahresgänge mit der Methode
  \texttt{pd.Series.diff()} elementweise die Differenz jedes Werts zu
  seinem Vorgänger gebildet (gleitende Differenz). Beispielsweise ist
  für die Zahlenreihe \texttt{1,\ 4,\ -6,\ 2} die elementweise Differenz
  \texttt{NaN,\ 3,\ -10,\ 8}. Da der erste Wert keinen Vorgänger hat,
  ist die Differenz NaN. Deshalb wird für die gleitende
  Differenzberechnung dem Jahresgang in Jahr 1 eine Null vorangestellt
  (weil der Speicher leer ans Netz geht), dem Jahresgang in Jahr 2 der
  letzte Wert aus Jahr 1 (weil der Speicher mit diesem Ladestand ins
  zweite Jahr geht). Die Zahlreihe für Jahr 2 sähe beispielsweise so
  aus: \texttt{2,\ 1,\ 4,\ -6,\ 2}. Die elementweise Differenz wäre:
  \texttt{NaN,\ -1,\ 3,\ -10,\ 8}. Anschließend werden die Werte absolut
  gesetzt und summiert. Die Anweisung lautet somit:
  \texttt{pd.Series.diff().abs().sum()}. Zur Ermittlung der Zyklenzahl
  wird die Summe der ein- und ausgespeicherten Energie durch die
  Speichergröße und durch 2 geteilt.
\item
  Ausgabe: Die Funktion gibt, wenn \texttt{output\ =\ False} ist, ein
  Tupel der Zyklenzahl für Jahr 1 und Jahr 2 zurück. Ist
  \texttt{output\ =\ True}, erfolgt die Ausgabe mit \texttt{print()}
\end{itemize}

\section{ohne Wirkungsgrad}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Zyklenzahl berechnen}
\CommentTok{\#\# Eingabe: data = pd.Series(data, dtype = \textquotesingle{}float\textquotesingle{}), output = False}
\CommentTok{\#\# Eingabe: Wenn die Eingabe ein Tupel \{\textquotesingle{}Speichergröße\textquotesingle{}: float, \textquotesingle{}jahresgang\_speicher\_jahr1\textquotesingle{}: pd.Series, \textquotesingle{}jahresgang\_speicher\_jahr2\textquotesingle{}: pd.Series\} ist, wird die Zyklenzahl direkt berechnet.}
\CommentTok{\#\# Eingabe: Wenn die Eingabe data = pd.Series(data, dtype = \textquotesingle{}float\textquotesingle{}) ist, wird jahresgang\_speicher\_berechnen(data, speichergröße = {-}1, output = False) aufgerufen}
\CommentTok{\#\# Verarbeitung: Elementweise wird für Jahr 1 und Jahr 2 die Differenz aufeinanderfolgender Werte gebildet, absolut gesetzt und aufsummiert}
\CommentTok{\#\# Verarbeitung: Für die gleitende Differenzberechnung muss dem Jahresgang in Jahr 1 eine Null vorangestellt werden, dem Jahresgang in Jahr 2 der letzte Wert aus Jahr 1}
\CommentTok{\#\# Verarbeitung: Die Summe der Speicherladungen und {-}entladungen wird durch die Speichergröße und durch 2 geteilt.}
\CommentTok{\#\# Ausgabe: Zyklenzahl für Jahr 1 und Jahr 2 {-} wenn output = False als Rückgabewert (Tupel), wenn output = True mit print()}

\KeywordTok{def}\NormalTok{ zyklenzahl\_berechnen(data, output }\OperatorTok{=} \VariableTok{False}\NormalTok{):}
  
  \ControlFlowTok{if} \BuiltInTok{type}\NormalTok{(data) }\KeywordTok{is} \BuiltInTok{tuple}\NormalTok{: }\CommentTok{\# Speichergröße und Jahresgänge wurden übergeben}
\NormalTok{    speichergröße }\OperatorTok{=}\NormalTok{ data[}\DecValTok{0}\NormalTok{]}
\NormalTok{    jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ data[}\DecValTok{1}\NormalTok{]}
\NormalTok{    jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ data[}\DecValTok{2}\NormalTok{]}
  
  \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# Restlast wurde übergeben}
\NormalTok{    ergebnis }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_berechnen(data, speichergröße }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{1}\NormalTok{, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\NormalTok{    speichergröße }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{0}\NormalTok{]}
\NormalTok{    jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{1}\NormalTok{]}
\NormalTok{    jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{2}\NormalTok{]}
  
  \CommentTok{\# Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1}
\NormalTok{  jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ pd.concat([pd.Series(}\DecValTok{0}\NormalTok{), jahresgang\_speicher\_jahr1])}
\NormalTok{  jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ pd.concat([jahresgang\_speicher\_jahr1[ }\OperatorTok{{-}} \DecValTok{1}\NormalTok{: ], jahresgang\_speicher\_jahr2])}

  \CommentTok{\# Zyklenzahl berechnen}
\NormalTok{  zyklenzahl\_jahr1 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr1.diff().}\BuiltInTok{abs}\NormalTok{().}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ (speichergröße }\OperatorTok{*} \DecValTok{2}\NormalTok{) }\CommentTok{\# ein Zyklus = vollständiges Be{-} und Entladen {-}{-}\textgreater{} durch 2 teilen}
\NormalTok{  zyklenzahl\_jahr2 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr2.diff().}\BuiltInTok{abs}\NormalTok{().}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ (speichergröße }\OperatorTok{*} \DecValTok{2}\NormalTok{) }\CommentTok{\# ein Zyklus = vollständiges Be{-} und Entladen {-}{-}\textgreater{} durch 2 teilen}
  
  \ControlFlowTok{if}\NormalTok{ output:}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Zyklenzahl Jahr 1: }\SpecialCharTok{\{}\NormalTok{zyklenzahl\_jahr1}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
          \SpecialStringTok{f"Zyklenzahl Jahr 2: }\SpecialCharTok{\{}\NormalTok{zyklenzahl\_jahr2}\SpecialCharTok{:,.2f\}}\SpecialStringTok{"}\NormalTok{)}
  
  \ControlFlowTok{else}\NormalTok{:}
    \ControlFlowTok{return}\NormalTok{ zyklenzahl\_jahr1, zyklenzahl\_jahr2}
  
\NormalTok{zyklenzahl\_berechnen(speicher\_2023, output }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Zyklenzahl Jahr 1: 8.38
Zyklenzahl Jahr 2: 8.38
\end{verbatim}

\section{mit Wirkungsgrad}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Zyklenzahl berechnen mit Wirkungsgrad}
\CommentTok{\#\# Eingabe: data = pd.Series(data, dtype = \textquotesingle{}float\textquotesingle{}), einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, output = False}
\CommentTok{\#\# Eingabe: Wenn die Eingabe ein Tupel \{\textquotesingle{}Speichergröße\textquotesingle{}: float, \textquotesingle{}jahresgang\_speicher\_jahr1\textquotesingle{}: pd.Series, \textquotesingle{}jahresgang\_speicher\_jahr2\textquotesingle{}: pd.Series\} ist, wird die Zyklenzahl direkt berechnet.}
\CommentTok{\#\# Eingabe: Wenn die Eingabe data = pd.Series(data, dtype = \textquotesingle{}float\textquotesingle{}) ist, wird jahresgang\_speicher\_berechnen(data, speichergröße = {-}1, einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, output = False) aufgerufen}
\CommentTok{\#\# Verarbeitung: Elementweise wird für Jahr 1 und Jahr 2 die Differenz aufeinanderfolgender Werte gebildet, absolut gesetzt und aufsummiert}
\CommentTok{\#\# Verarbeitung: Für die gleitende Differenzberechnung muss dem Jahresgang in Jahr 1 eine Null vorangestellt werden, dem Jahresgang in Jahr 2 der letzte Wert aus Jahr 1}
\CommentTok{\#\# Verarbeitung: Die Summe der Speicherladungen und {-}entladungen wird durch die Speichergröße und durch 2 geteilt.}
\CommentTok{\#\# Ausgabe: Zyklenzahl für Jahr 1 und Jahr 2 {-} wenn output = False als Rückgabewert (Tupel), wenn output = True mit print()}

\KeywordTok{def}\NormalTok{ zyklenzahl\_berechnen(data, einspeicherwirkungsgrad }\OperatorTok{=} \DecValTok{1}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \DecValTok{1}\NormalTok{, output }\OperatorTok{=} \VariableTok{False}\NormalTok{):}
  
  \ControlFlowTok{if} \BuiltInTok{type}\NormalTok{(data) }\KeywordTok{is} \BuiltInTok{tuple}\NormalTok{: }\CommentTok{\# Speichergröße und Jahresgänge wurden übergeben}
\NormalTok{    speichergröße }\OperatorTok{=}\NormalTok{ data[}\DecValTok{0}\NormalTok{]}
\NormalTok{    jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ data[}\DecValTok{1}\NormalTok{]}
\NormalTok{    jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ data[}\DecValTok{2}\NormalTok{]}
  
  \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# Restlast wurde übergeben}
\NormalTok{    ergebnis }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_berechnen(data, speichergröße }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{1}\NormalTok{, einspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ einspeicherwirkungsgrad, ausspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ ausspeicherwirkungsgrad, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\NormalTok{    speichergröße }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{0}\NormalTok{]}
\NormalTok{    jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{1}\NormalTok{]}
\NormalTok{    jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{2}\NormalTok{]}
  
  \CommentTok{\# Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1}
\NormalTok{  jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ pd.concat([pd.Series(}\DecValTok{0}\NormalTok{), jahresgang\_speicher\_jahr1])}
\NormalTok{  jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ pd.concat([jahresgang\_speicher\_jahr1[ }\OperatorTok{{-}} \DecValTok{1}\NormalTok{: ], jahresgang\_speicher\_jahr2])}

  \CommentTok{\# Zyklenzahl berechnen  }
\NormalTok{  zyklenzahl\_jahr1 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr1.diff().}\BuiltInTok{abs}\NormalTok{().}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ (speichergröße }\OperatorTok{*} \DecValTok{2}\NormalTok{) }\CommentTok{\# ein Zyklus = vollständiges Be{-} und Entladen {-}{-}\textgreater{} durch 2 teilen}
\NormalTok{  zyklenzahl\_jahr2 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr2.diff().}\BuiltInTok{abs}\NormalTok{().}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ (speichergröße }\OperatorTok{*} \DecValTok{2}\NormalTok{) }\CommentTok{\# ein Zyklus = vollständiges Be{-} und Entladen {-}{-}\textgreater{} durch 2 teilen}
  
  \ControlFlowTok{if}\NormalTok{ output:}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Zyklenzahl Jahr 1: }\SpecialCharTok{\{}\NormalTok{zyklenzahl\_jahr1}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
          \SpecialStringTok{f"Zyklenzahl Jahr 2: }\SpecialCharTok{\{}\NormalTok{zyklenzahl\_jahr2}\SpecialCharTok{:,.2f\}}\SpecialStringTok{"}\NormalTok{)}
  
  \ControlFlowTok{else}\NormalTok{:}
    \ControlFlowTok{return}\NormalTok{ zyklenzahl\_jahr1, zyklenzahl\_jahr2}
  
\NormalTok{zyklenzahl\_berechnen(restlast, einspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, output }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Zyklenzahl Jahr 1: 8.79
Zyklenzahl Jahr 2: 8.79
\end{verbatim}

Aufgrund der geringen erneuerbaren Erzeugungsschüsse im Jahr 2023 ist
die Zyklenzahl in Jahr 1 und Jahr 2 identisch. Wenn der Wirkungsgrad
berücksichtigt wird, steigt die Zyklenzahl, weil der Speicher kleiner
dimensioniert ist.

\subsection{Kappung}\label{kappung}

\begin{figure}

\begin{minipage}{0.50\linewidth}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-70-output-1.png}}

\end{minipage}%
%
\begin{minipage}{0.50\linewidth}

\begin{description}
\tightlist
\item[Kappung von Erzeugungsspitzen]
Die Kappung von Erzeugungsspitzen ist eine Möglichkeit, die benötigte
Speichergröße zu reduzieren. Die Kappung der Einspeicherung führt zu
einer besseren Auslastung der Speicherkapazität und einer höheren
Zyklenzahl.

Im oberen Beispiel wird die Speichergröße entsprechend der maximalen
erneuerbaren Überschussproduktion ausgelegt. Der Speicher erreicht damit
1,5 Zyklen.

Im unteren Beispiel wird der Speicher kleiner dimensioniert. Der
Speicher erreicht 2 Zyklen.
\end{description}

\end{minipage}%

\end{figure}%

\subsubsection{Berechnung}\label{berechnung-2}

Auf Grundlage des Jahresgangs des Speichers kann der Effekt der Kappung
von Erzeugungsspitzen auf die eingespeicherte Strommenge und die
erreichte Zyklenzahl des Stromspeichers berechnet werden. Dafür werden
der Jahresgang des Speichers für verschiedene reduzierte Speichergrößen,
die so erreichte Zyklenzahl und die Menge nicht eingespeicherten Stroms
berechnet.

\begin{itemize}
\item
  Eingabe: Der Funktion ist eine Restlastdatenreihe als pd.Series und
  optional eine Liste reduzierter Speichergrößen, ausgedrückt als
  relative Bruchteile von 1, zu übergeben. Wird keine Liste übergeben,
  erfolgt die Berechnung für die relativen Speichergrößen {[}0.9, 0.8,
  0.7, 0.6, 0.5{]}.
\item
  Verarbeitung: Für die Restlast werden durch Aufruf der Funktion
  \texttt{jahresgang\_speicher\_berechnen} die ungekappte Speichergröße
  und Jahresgänge in Jahr 1 und in Jahr 2 berechnet. Anschließend wird
  durch Aufruf der Funktion \texttt{zyklenzahl\_berechnen} die erreichte
  Zyklenzahl bestimmt. Anhand der Jahresgänge wird die eingespeicherte
  Strommenge berechnet. Dazu wird mit der Methode
  \texttt{pd.Series.diff()} elementweise die Differenz jedes Werts zu
  seinem Vorgänger gebildet (gleitende Differenz). Wie auch bei der
  Berechnung der Zyklenzahl wird dazu dem Jahresgang in Jahr 1 eine Null
  vorangestellt, dem Jahresgang in Jahr 2 der letzte Wert aus Jahr 1.
  Die eingespeicherte Strommenge ist die Summe aller positiven Werte
  dieser Reihe. Negative Werte bedeuten eine Reduzierung des Ladestands
  zwischen zwei Zeitpunkten, zeigen also Phasen der Ausspeicherung an.
  Deshalb werden negative Werte mit der Methode \texttt{.clip} Null
  gesetzt. Die Anweisung lautet:
  \texttt{pd.Series.diff().clip(lower\ =\ 0).sum()}.\\
  Diese Schritte werden für alle übergebenen Elemente in der Variablen
  \texttt{neue\_speichergrößen} wiederholt. Dazu wird die Speichergröße
  ohne Kappung mit jeweils einer der relativen Speichergrößen
  multipliziert und die erreichte Zyklenzahl sowie die eingespeicherte
  Strommenge berechnet. Aus der Differenz der eingespeicherten
  Strommenge für jede neue Speichergröße zum Basisjahr wird die gekappte
  Strommenge bestimmt.
\item
  Ausgabe: Wenn \texttt{output\ =\ False}, wird ein DataFrame mit drei
  Spalten zurückgegeben. Die Spalte mit Index 0 enthält die relative
  Speichergröße, Die Spalten 1 und 2 die gekappten Strommengen in Jahr 1
  und Jahr 2. Wenn' output = True' wird dieser DataFrame mit
  \texttt{print()} ausgegeben. Zusätzlich wird ein fünfspaltiger
  DataFrame mit den Zwischenergebnissen (inklusive Basisjahr in Zeile 0)
  mit \texttt{print()} ausgegeben. Dieser enthält in der Spalte mit
  Index 0 die absolute Speichergröße sowie in den folgenden Spalten die
  eingespeicherte Strommenge in Jahr 1 (Spalte mit Index 1), die
  Zyklenzahl in Jahr 1 (Spalte mit Index 2), die eingespeicherte
  Strommenge in Jahr 2 (Spalte mit Index 3), die Zyklenzahl in Jahr 2
  (Spalte mit Index 4).
\end{itemize}

\section{ohne Wirkungsgrad}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Kappung berechnen: Wie viel EE wird verworfen, wenn die Speichergröße begrenzt wird?}
\CommentTok{\#\# Eingabe: Restlastkurve data = pd.Series(data, dtype = \textquotesingle{}float\textquotesingle{}, neue\_speichergrößen = [0.9, 0.8, 0.7, 0.6, 0.5], output = False)}
\CommentTok{\#\# Verarbeitung: Für data werden mit der Funktion jahresgang\_speicher\_berechnen() die Speichergröße und die Jahresgänge Jahr 1 und Jahr 2 ohne zusätzliche Kappung bestimmt}
\CommentTok{\#\# Verarbeitung: Für data wird mit der Funktion zyklenzahl\_berechnen() die Zyklenzahl in Jahr 1 und Jahr 2 ohne zusätzliche Kappung bestimmt}
\CommentTok{\#\# Verarbeitung: Anhand der Jahresgänge wird die eingespeicherte Strommenge ohne zusätzliche Kappung bestimmt}
\CommentTok{\#\# Verarbeitung: Die Verarbeitungsschritte werden für alle übergebenen Elemente in der Variablen neue\_speichergrößen wiederholt}
\CommentTok{\#\# Verarbeitung: Die Speichergröße der Basisrestlastkurve data wird dafür mit den in neue\_speichergrößen übergebenen Werten multipliziert}
\CommentTok{\#\# Verarbeitung: Aus der Differenz der eingespeicherten Strommengen für jede neue Speichergröße zum Basisjahr wird die gekappte Strommenge bestimmt}
\CommentTok{\#\# Ausgabe: Wenn output = False wird ein DataFrame mit drei Spalten zurückgegeben. Die Spalte mit Index 0 enthält die relative Speichergröße, Die Spalten 1 und 2 die gekappten Strommengen in Jahr 1 und Jahr 2.}
\CommentTok{\#\# Ausgabe: Wenn output = True wird der dreispaltige DataFrame mit print() ausgegeben.}
\CommentTok{\#\# Ausgabe: Zusätzlich wird ein fünfspaltiger DataFrame mit den Zwischenergebnissen (inklusive Basisjahr) mit print() ausgegeben.}
\CommentTok{\#\# Ausgabe: (Indexangaben): 0 = absolute Speichergröße, 1 = eingespeicherte Strommenge Jahr 1, 2 = Zyklenzahl Jahr 1, 3 = eingespeicherte Strommenge Jahr 2, 4 = Zyklenzahl Jahr 2}

\KeywordTok{def}\NormalTok{ effekt\_kappung\_berechnen(data, neue\_speichergrößen }\OperatorTok{=}\NormalTok{ [}\FloatTok{0.9}\NormalTok{, }\FloatTok{0.8}\NormalTok{, }\FloatTok{0.7}\NormalTok{, }\FloatTok{0.6}\NormalTok{, }\FloatTok{0.5}\NormalTok{], output }\OperatorTok{=} \VariableTok{False}\NormalTok{):}

  \CommentTok{\# Speichergröße im Basisjahr bestimmen}
\NormalTok{  ergebnis }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_berechnen(data, speichergröße }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{1}\NormalTok{, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\NormalTok{  speichergröße0 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{0}\NormalTok{]}
\NormalTok{  jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{1}\NormalTok{]}
\NormalTok{  jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{2}\NormalTok{]}

  \CommentTok{\# Zyklenzahl im Basisjahr bestimmen, Tupel übergeben}
\NormalTok{  zyklen }\OperatorTok{=}\NormalTok{ zyklenzahl\_berechnen(ergebnis, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\NormalTok{  zyklen\_jahr1 }\OperatorTok{=}\NormalTok{ zyklen[}\DecValTok{0}\NormalTok{]}
\NormalTok{  zyklen\_jahr2 }\OperatorTok{=}\NormalTok{ zyklen[}\DecValTok{1}\NormalTok{]}
  
  \CommentTok{\# Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1}
\NormalTok{  jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ pd.concat([pd.Series([}\DecValTok{0}\NormalTok{]), jahresgang\_speicher\_jahr1])}
\NormalTok{  jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ pd.concat([jahresgang\_speicher\_jahr1[ }\OperatorTok{{-}} \DecValTok{1}\NormalTok{: ], jahresgang\_speicher\_jahr2])}

  \CommentTok{\# eingespeicherte Strommenge im Basisjahr bestimmen}
\NormalTok{  einspeicherung\_jahr1 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr1.diff().clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{()}
\NormalTok{  einspeicherung\_jahr2 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr2.diff().clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{()}

  \CommentTok{\# Ergebnisse in DataFrame speichern}
\NormalTok{  dataframe }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}Speichergröße\textquotesingle{}}\NormalTok{: [speichergröße0], }\StringTok{\textquotesingle{}Einspeicherung Jahr1\textquotesingle{}}\NormalTok{: [einspeicherung\_jahr1], }\StringTok{\textquotesingle{}Zyklen Jahr1\textquotesingle{}}\NormalTok{: zyklen\_jahr1, }\StringTok{\textquotesingle{}Einspeicherung Jahr2\textquotesingle{}}\NormalTok{: [einspeicherung\_jahr2], }\StringTok{\textquotesingle{}Zyklen Jahr2\textquotesingle{}}\NormalTok{: zyklen\_jahr2\})}
  
  \CommentTok{\# eingespeicherte Strommenge bei alternativen Speichergrößen bestimmen}
\NormalTok{  count }\OperatorTok{=} \DecValTok{1}

  \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(neue\_speichergrößen)):}

\NormalTok{    speichergröße\_neu }\OperatorTok{=}\NormalTok{ speichergröße0 }\OperatorTok{*}\NormalTok{ neue\_speichergrößen[i]}
    
\NormalTok{    ergebnis }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_berechnen(data, speichergröße }\OperatorTok{=}\NormalTok{ speichergröße\_neu, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\NormalTok{    jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{1}\NormalTok{]}
\NormalTok{    jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{2}\NormalTok{]}

    \CommentTok{\# Zyklenzahl im Basisjahr bestimmen, Tupel übergeben}
\NormalTok{    zyklen }\OperatorTok{=}\NormalTok{ zyklenzahl\_berechnen(ergebnis, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\NormalTok{    zyklen\_jahr1 }\OperatorTok{=}\NormalTok{ zyklen[}\DecValTok{0}\NormalTok{]}
\NormalTok{    zyklen\_jahr2 }\OperatorTok{=}\NormalTok{ zyklen[}\DecValTok{1}\NormalTok{]}

    \CommentTok{\# Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1}
\NormalTok{    jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ pd.concat([pd.Series([}\DecValTok{0}\NormalTok{]), jahresgang\_speicher\_jahr1])}
\NormalTok{    jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ pd.concat([jahresgang\_speicher\_jahr1[ }\OperatorTok{{-}} \DecValTok{1}\NormalTok{: ], jahresgang\_speicher\_jahr2])}

    \CommentTok{\# eingespeicherte Strommenge mit neuer Speichergröße bestimmen}
\NormalTok{    einspeicherung\_jahr1 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr1.diff().clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{()}
\NormalTok{    einspeicherung\_jahr2 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr2.diff().clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{()}

\NormalTok{    neue\_Zeile }\OperatorTok{=}\NormalTok{ [speichergröße\_neu, einspeicherung\_jahr1, zyklen\_jahr1, einspeicherung\_jahr2, zyklen\_jahr2]}
\NormalTok{    dataframe.loc[count] }\OperatorTok{=}\NormalTok{ neue\_Zeile}
  
\NormalTok{    count }\OperatorTok{+=} \DecValTok{1}
  
  \CommentTok{\# gekappte Menge berechnen data.sub(data[0]).drop(0)}
\NormalTok{  gekappte\_einspeicherung\_jahr1 }\OperatorTok{=}\NormalTok{ dataframe[}\StringTok{\textquotesingle{}Einspeicherung Jahr1\textquotesingle{}}\NormalTok{].sub(dataframe[}\StringTok{\textquotesingle{}Einspeicherung Jahr1\textquotesingle{}}\NormalTok{][}\DecValTok{0}\NormalTok{]).}\BuiltInTok{abs}\NormalTok{().drop(}\DecValTok{0}\NormalTok{).reset\_index(drop }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{  gekappte\_einspeicherung\_jahr2 }\OperatorTok{=}\NormalTok{ dataframe[}\StringTok{\textquotesingle{}Einspeicherung Jahr2\textquotesingle{}}\NormalTok{].sub(dataframe[}\StringTok{\textquotesingle{}Einspeicherung Jahr2\textquotesingle{}}\NormalTok{][}\DecValTok{0}\NormalTok{]).}\BuiltInTok{abs}\NormalTok{().drop(}\DecValTok{0}\NormalTok{).reset\_index(drop }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{  dataset }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}relative Speichergröße\textquotesingle{}}\NormalTok{: pd.Series(neue\_speichergrößen), }\StringTok{\textquotesingle{}gekappte Einspeicherung Jahr1\textquotesingle{}}\NormalTok{: gekappte\_einspeicherung\_jahr1, }\StringTok{\textquotesingle{}gekappte Einspeicherung Jahr2\textquotesingle{}}\NormalTok{: gekappte\_einspeicherung\_jahr2\})}
  
  \ControlFlowTok{if}\NormalTok{ output:}

    \BuiltInTok{print}\NormalTok{(dataframe)}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(dataset)}

  \ControlFlowTok{else}\NormalTok{:}
    \ControlFlowTok{return}\NormalTok{ dataset}

\NormalTok{effekt\_kappung\_berechnen(restlast, output }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   Speichergröße  Einspeicherung Jahr1  Zyklen Jahr1  Einspeicherung Jahr2  \
0       119667.0              1.00e+06          8.38              1.00e+06   
1       107700.3              9.91e+05          9.20              9.91e+05   
2        95733.6              9.79e+05         10.23              9.79e+05   
3        83766.9              9.63e+05         11.49              9.63e+05   
4        71800.2              9.39e+05         13.07              9.39e+05   
5        59833.5              8.99e+05         15.03              8.99e+05   

   Zyklen Jahr2  
0          8.38  
1          9.20  
2         10.23  
3         11.49  
4         13.07  
5         15.03  


   relative Speichergröße  gekappte Einspeicherung Jahr1  \
0                     0.9                        11966.7   
1                     0.8                        23933.4   
2                     0.7                        40443.7   
3                     0.6                        64377.1   
4                     0.5                       103619.5   

   gekappte Einspeicherung Jahr2  
0                        11966.7  
1                        23933.4  
2                        40443.7  
3                        64377.1  
4                       103619.5  
\end{verbatim}

\section{mit Wirkungsgrad}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Kappung berechnen: Wie viel EE wird verworfen, wenn die Speichergröße begrenzt wird?}
\CommentTok{\#\# Eingabe: Restlastkurve data = pd.Series(data, dtype = \textquotesingle{}float\textquotesingle{}, einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, neue\_speichergrößen = [0.9, 0.8, 0.7, 0.6, 0.5], output = False)}
\CommentTok{\#\# Verarbeitung: Für data werden mit der Funktion jahresgang\_speicher\_berechnen() die Speichergröße und die Jahresgänge Jahr 1 und Jahr 2 ohne zusätzliche Kappung bestimmt}
\CommentTok{\#\# Verarbeitung: Für data wird mit der Funktion zyklenzahl\_berechnen() die Zyklenzahl in Jahr 1 und Jahr 2 ohne zusätzliche Kappung bestimmt}
\CommentTok{\#\# Verarbeitung: Anhand der Jahresgänge wird die eingespeicherte Strommenge ohne zusätzliche Kappung bestimmt}
\CommentTok{\#\# Verarbeitung: Die Verarbeitungsschritte werden für alle übergebenen Elemente in der Variablen neue\_speichergrößen wiederholt}
\CommentTok{\#\# Verarbeitung: Die Speichergröße der Basisrestlastkurve data wird dafür mit den in neue\_speichergrößen übergebenen Werten multipliziert}
\CommentTok{\#\# Verarbeitung: Aus der Differenz der eingespeicherten Strommengen für jede neue Speichergröße zum Basisjahr wird die gekappte Strommenge bestimmt}
\CommentTok{\#\# Ausgabe: Wenn output = False wird ein DataFrame mit drei Spalten zurückgegeben. Die Spalte mit Index 0 enthält die relative Speichergröße, Die Spalten 1 und 2 die gekappten Strommengen in Jahr 1 und Jahr 2.}
\CommentTok{\#\# Ausgabe: Wenn output = True wird der dreispaltige DataFrame mit print() ausgegeben.}
\CommentTok{\#\# Ausgabe: Zusätzlich wird ein fünfspaltiger DataFrame mit den Zwischenergebnissen (inklusive Basisjahr) mit print() ausgegeben.}
\CommentTok{\#\# Ausgabe: (Indexangaben): 0 = absolute Speichergröße, 1 = eingespeicherte Strommenge Jahr 1, 2 = Zyklenzahl Jahr 1, 3 = eingespeicherte Strommenge Jahr 2, 4 = Zyklenzahl Jahr 2}

\KeywordTok{def}\NormalTok{ effekt\_kappung\_berechnen(data, einspeicherwirkungsgrad }\OperatorTok{=} \DecValTok{1}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \DecValTok{1}\NormalTok{, neue\_speichergrößen }\OperatorTok{=}\NormalTok{ [}\FloatTok{0.9}\NormalTok{, }\FloatTok{0.8}\NormalTok{, }\FloatTok{0.7}\NormalTok{, }\FloatTok{0.6}\NormalTok{, }\FloatTok{0.5}\NormalTok{], output }\OperatorTok{=} \VariableTok{False}\NormalTok{):}

  \CommentTok{\# Speichergröße im Basisjahr bestimmen}
\NormalTok{  ergebnis }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_berechnen(data, speichergröße }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{1}\NormalTok{, einspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ einspeicherwirkungsgrad, ausspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ ausspeicherwirkungsgrad, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\NormalTok{  speichergröße0 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{0}\NormalTok{]}
\NormalTok{  jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{1}\NormalTok{]}
\NormalTok{  jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{2}\NormalTok{]}

  \CommentTok{\# Zyklenzahl im Basisjahr bestimmen, Tupel übergeben}
\NormalTok{  zyklen }\OperatorTok{=}\NormalTok{ zyklenzahl\_berechnen(ergebnis, einspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ einspeicherwirkungsgrad, ausspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ ausspeicherwirkungsgrad, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\NormalTok{  zyklen\_jahr1 }\OperatorTok{=}\NormalTok{ zyklen[}\DecValTok{0}\NormalTok{]}
\NormalTok{  zyklen\_jahr2 }\OperatorTok{=}\NormalTok{ zyklen[}\DecValTok{1}\NormalTok{]}
  
  \CommentTok{\# Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1}
\NormalTok{  jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ pd.concat([pd.Series([}\DecValTok{0}\NormalTok{]), jahresgang\_speicher\_jahr1])}
\NormalTok{  jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ pd.concat([jahresgang\_speicher\_jahr1[ }\OperatorTok{{-}} \DecValTok{1}\NormalTok{: ], jahresgang\_speicher\_jahr2])}

  \CommentTok{\# eingespeicherte Strommenge im Basisjahr bestimmen}
\NormalTok{  einspeicherung\_jahr1 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr1.diff().clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{()}
\NormalTok{  einspeicherung\_jahr2 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr2.diff().clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{()}

  \CommentTok{\# Ergebnisse in DataFrame speichern}
\NormalTok{  dataframe }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}Speichergröße\textquotesingle{}}\NormalTok{: [speichergröße0], }\StringTok{\textquotesingle{}Einspeicherung Jahr1\textquotesingle{}}\NormalTok{: [einspeicherung\_jahr1], }\StringTok{\textquotesingle{}Zyklen Jahr1\textquotesingle{}}\NormalTok{: zyklen\_jahr1, }\StringTok{\textquotesingle{}Einspeicherung Jahr2\textquotesingle{}}\NormalTok{: [einspeicherung\_jahr2], }\StringTok{\textquotesingle{}Zyklen Jahr2\textquotesingle{}}\NormalTok{: zyklen\_jahr2\})}
  
  \CommentTok{\# eingespeicherte Strommenge bei alternativen Speichergrößen bestimmen}
\NormalTok{  count }\OperatorTok{=} \DecValTok{1}

  \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(neue\_speichergrößen)):}

\NormalTok{    speichergröße\_neu }\OperatorTok{=}\NormalTok{ speichergröße0 }\OperatorTok{*}\NormalTok{ neue\_speichergrößen[i]}
    
\NormalTok{    ergebnis }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_berechnen(data, speichergröße }\OperatorTok{=}\NormalTok{ speichergröße\_neu, einspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ einspeicherwirkungsgrad, ausspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ ausspeicherwirkungsgrad, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\NormalTok{    jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{1}\NormalTok{]}
\NormalTok{    jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{2}\NormalTok{]}

    \CommentTok{\# Zyklenzahl im Basisjahr bestimmen, Tupel übergeben}
\NormalTok{    zyklen }\OperatorTok{=}\NormalTok{ zyklenzahl\_berechnen(ergebnis, einspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ einspeicherwirkungsgrad, ausspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ ausspeicherwirkungsgrad, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\NormalTok{    zyklen\_jahr1 }\OperatorTok{=}\NormalTok{ zyklen[}\DecValTok{0}\NormalTok{]}
\NormalTok{    zyklen\_jahr2 }\OperatorTok{=}\NormalTok{ zyklen[}\DecValTok{1}\NormalTok{]}

    \CommentTok{\# Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1}
\NormalTok{    jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ pd.concat([pd.Series([}\DecValTok{0}\NormalTok{]), jahresgang\_speicher\_jahr1])}
\NormalTok{    jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ pd.concat([jahresgang\_speicher\_jahr1[ }\OperatorTok{{-}} \DecValTok{1}\NormalTok{: ], jahresgang\_speicher\_jahr2])}

    \CommentTok{\# eingespeicherte Strommenge mit neuer Speichergröße bestimmen}
\NormalTok{    einspeicherung\_jahr1 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr1.diff().clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{()}
\NormalTok{    einspeicherung\_jahr2 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr2.diff().clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{()}

\NormalTok{    neue\_Zeile }\OperatorTok{=}\NormalTok{ [speichergröße\_neu, einspeicherung\_jahr1, zyklen\_jahr1, einspeicherung\_jahr2, zyklen\_jahr2]}
\NormalTok{    dataframe.loc[count] }\OperatorTok{=}\NormalTok{ neue\_Zeile}
  
\NormalTok{    count }\OperatorTok{+=} \DecValTok{1}
  
  \CommentTok{\# gekappte Menge berechnen data.sub(data[0]).drop(0)}
\NormalTok{  gekappte\_einspeicherung\_jahr1 }\OperatorTok{=}\NormalTok{ dataframe[}\StringTok{\textquotesingle{}Einspeicherung Jahr1\textquotesingle{}}\NormalTok{].sub(dataframe[}\StringTok{\textquotesingle{}Einspeicherung Jahr1\textquotesingle{}}\NormalTok{][}\DecValTok{0}\NormalTok{]).}\BuiltInTok{abs}\NormalTok{().drop(}\DecValTok{0}\NormalTok{).reset\_index(drop }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{  gekappte\_einspeicherung\_jahr2 }\OperatorTok{=}\NormalTok{ dataframe[}\StringTok{\textquotesingle{}Einspeicherung Jahr2\textquotesingle{}}\NormalTok{].sub(dataframe[}\StringTok{\textquotesingle{}Einspeicherung Jahr2\textquotesingle{}}\NormalTok{][}\DecValTok{0}\NormalTok{]).}\BuiltInTok{abs}\NormalTok{().drop(}\DecValTok{0}\NormalTok{).reset\_index(drop }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{  dataset }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}relative Speichergröße\textquotesingle{}}\NormalTok{: pd.Series(neue\_speichergrößen), }\StringTok{\textquotesingle{}gekappte Einspeicherung Jahr1\textquotesingle{}}\NormalTok{: gekappte\_einspeicherung\_jahr1, }\StringTok{\textquotesingle{}gekappte Einspeicherung Jahr2\textquotesingle{}}\NormalTok{: gekappte\_einspeicherung\_jahr2\})}
  
  \ControlFlowTok{if}\NormalTok{ output:}

    \BuiltInTok{print}\NormalTok{(dataframe)}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(dataset)}

  \ControlFlowTok{else}\NormalTok{:}
    \ControlFlowTok{return}\NormalTok{ dataset}

\NormalTok{effekt\_kappung\_berechnen(restlast, einspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, output }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
   Speichergröße  Einspeicherung Jahr1  Zyklen Jahr1  Einspeicherung Jahr2  \
0      102674.54             902678.40          8.79             902678.40   
1       92407.08             892410.95          9.66             892410.95   
2       82139.63             882143.49         10.74             882143.49   
3       71872.18             864601.21         12.03             864601.21   
4       61604.72             844066.30         13.70             844066.30   
5       51337.27             799701.77         15.58             799701.77   

   Zyklen Jahr2  
0          8.79  
1          9.66  
2         10.74  
3         12.03  
4         13.70  
5         15.58  


   relative Speichergröße  gekappte Einspeicherung Jahr1  \
0                     0.9                       10267.45   
1                     0.8                       20534.91   
2                     0.7                       38077.19   
3                     0.6                       58612.10   
4                     0.5                      102976.63   

   gekappte Einspeicherung Jahr2  
0                       10267.45  
1                       20534.91  
2                       38077.19  
3                       58612.10  
4                      102976.63  
\end{verbatim}

\section{Anteil erneuerbarer Stromerzeugung
bestimmen}\label{anteil-erneuerbarer-stromerzeugung-bestimmen}

Durch die Integration eines Stromspeichers in das Stromsystem kann
erneuerbare Überschussproduktion in Phasen mit einer positiven Restlast
verschoben werden, die andernfalls durch Lastfolgekraftwerke zu decken
wäre. Dadurch sinkt der Anteil konventioneller Stromerzeugung und steigt
der Anteil erneuerbarer Stromerzeugung.

\begin{figure}

\begin{minipage}{0.50\linewidth}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-73-output-1.png}}

\end{minipage}%
%
\begin{minipage}{0.50\linewidth}

\begin{description}
\tightlist
\item[Anteil erneuerbarer Stromproduktion bestimmen]
Die Ausspeicherung von Strom vermindert die positive Restlast

Wird der ausgespeicherte Strom von der positiven Restlast abgezogen (in
Summe oder im Jahresgang), entspricht der Anteil konventionell zu
deckender Last dem Quotienten aus der summierten positiven Restlast und
der summierten Netzlast bzw. aus der summierten positiven Restlast und
der summierten Stromerzeugung.

Der Anteil erneuerbarer Stromproduktion entspricht 1 - Anteil
konventionell zu deckender Last.
\end{description}

\end{minipage}%

\end{figure}%

Der Anteil erneuerbarer Stromproduktion kann deshalb wie folgt berechnet
werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{restlast.clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ verbrauch[}\StringTok{\textquotesingle{}Gesamt (Netzlast) [MWh]\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{()}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Summe positive Restlast [MWh]: }\SpecialCharTok{\{}\NormalTok{restlast}\SpecialCharTok{.}\NormalTok{clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Summe Netzlast: }\SpecialCharTok{\{}\NormalTok{verbrauch[}\StringTok{\textquotesingle{}Gesamt (Netzlast) [MWh]\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Quotient positive Restlast / Netzlast: }\SpecialCharTok{\{}\NormalTok{restlast}\SpecialCharTok{.}\NormalTok{clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ verbrauch[}\StringTok{\textquotesingle{}Gesamt (Netzlast) [MWh]\textquotesingle{}}\NormalTok{]}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Anteil erneuerbarer Erzeugung: }\SpecialCharTok{\{}\NormalTok{ ( anteil\_ee }\OperatorTok{:=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ (restlast.clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ verbrauch[}\StringTok{\textquotesingle{}Gesamt (Netzlast) [MWh]\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{()) ) }\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n\textbackslash{}n}\SpecialStringTok{"}

      \SpecialStringTok{f"Summe Erzeugung: }\SpecialCharTok{\{}\NormalTok{erzeugung}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{(numeric\_only }\OperatorTok{=} \VariableTok{True}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Quotient positive Restlast / Erzeugung: }\SpecialCharTok{\{}\NormalTok{restlast}\SpecialCharTok{.}\NormalTok{clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ erzeugung}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{(numeric\_only }\OperatorTok{=} \VariableTok{True}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Anteil erneuerbarer Erzeugung: }\SpecialCharTok{\{}\DecValTok{1} \OperatorTok{{-}}\NormalTok{ (restlast.clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ erzeugung.}\BuiltInTok{sum}\NormalTok{(numeric\_only }\OperatorTok{=} \VariableTok{True}\NormalTok{).}\BuiltInTok{sum}\NormalTok{())}\SpecialCharTok{:,.2f\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Summe positive Restlast [MWh]: 207842228.25
Summe Netzlast: 458271100.75
Quotient positive Restlast / Netzlast: 0.45
Anteil erneuerbarer Erzeugung: 0.55

Summe Erzeugung: 448650448.25
Quotient positive Restlast / Erzeugung: 0.46
Anteil erneuerbarer Erzeugung: 0.54
\end{verbatim}

Die Netzlast aus dem Datensatz \texttt{verbrauch} weicht mit 458 TWh
geringfügig von der summierten Stromerzeugung aus dem Datensatz
erzeugung in Höhe von 448 TWh ab. Dadurch unterscheiden sich die
berechneten Anteile leicht.

\subsubsection{Berechnung}\label{berechnung-3}

Grundlage für die Berechnung des Anteils erneuerbarer Stromerzeugung
nach Ausspeicherung erneuerbarer Überschussproduktion ist der Jahresgang
des Speichers. Die Ausspeicherung von Strom bedeutet eine Verminderung
des Ladestands zwischen zwei Zeitpunkten. Der ausgespeicherte Strom
vermindert die positive Restlast zu diesem Zeitpunkt. Dadurch nimmt der
Quotient aus der positiven Restlast und der Netzlast ab und der Anteil
erneuerbarer Stromerzeugung steigt. Dies ist in der folgenden Funktion
umgesetzt.

\begin{itemize}
\item
  Eingabe: Der Funktion wird eine Restlastdatenreihe übergeben. Optional
  kann zusätzlich eine Netzlastdatenreihe übergeben werden. Ebenso kann
  optional eine Liste reduzierter Speichergrößen, ausgedrückt als
  relative Bruchteile von 1, übergeben werden. Wird keine Liste
  übergeben, erfolgt die Berechnung für die relativen Speichergrößen
  {[}0.9, 0.8, 0.7, 0.6, 0.5{]}.
\item
  Verarbeitung: Durch Aufruf der Funktion
  \texttt{jahresgang\_speicher\_berechnen()} werden für die
  Restlastdatenreihe die Jahresgänge des Stromspeichers mit relativer
  Größe 1 berechnet. Mit den Jahresgängen wird die ausgespeicherte
  Strommenge im Jahresgang mit der Methode
  \texttt{pd.Series.diff().clip(upper\ =\ 0)} bestimmt. Auch für diese
  gleitende Differenzberechnung wird dem Jahresgang in Jahr 1 eine Null
  vorangestellt, dem Jahresgang in Jahr 2 der letzte Wert aus Jahr 1.
  Der erste Wert im Jahresgang der ausgespeicherten Strommenge ist NaN,
  weshalb dieser Wert entfällt und der Index zurückgesetzt wird. Der
  vollständige Befehl lautet:
  \texttt{pd.Series.diff().clip(upper\ =\ 0){[}1:\ {]}.reset\_index(drop\ =\ True)}.
  Die Jahresgang der ausgespeicherten Strommenge wird von der
  Restlastkurve abgezogen und so die Restlastkurve nach Ausspeicherung
  bestimmt. Da die Ausspeicherung im Jahresgang durch negative Werte
  angezeigt wird, erfolgt die Differenzbildung durch Addition.\\
  Wenn eine Netzlastdatenreihe übergeben wurde, wird auf der Grundlage
  der Restlastkurve nach Ausspeicherung der realisierte Anteil
  erneuerbarer Erzeugung berechnet: 1 - (Summe positive Restlast / Summe
  Netzlast). Die Berechnungen werden für kleiner dimensionerte Speicher
  wiederholt.
\item
  Ausgabe: Wenn \texttt{output\ =\ False}, werden die Restlastkurven
  nach Ausspeicherung als DataFrame zurückgeben. Der DataFrame besteht
  aus je einer Spalte für die relative Speichergröße 1 sowie für alle
  übergebenen relativ reduzierten Speichergrößen. Die Restlastkurven in
  Jahr 1 und Jahr 2 sind in Zeile 0 bzw. 1 gespeichert. Wenn
  \texttt{output\ =\ True}, werden die summierte Netzlast, die summierte
  positive \& negative Restlast, der Anteil erneuerbarer Erzeugung ohne
  Speicher sowie der realisierter Anteil erneuerbarer Erzeugung mit der
  Speichergröße im Basisjahr und für alle übergebenen Speichergrößen
  jeweils für Jahr 1 und Jahr 2 mittels \texttt{print()} ausgegeben.
\end{itemize}

\section{ohne Wirkungsgrad}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Anteil EE berechnen}
\CommentTok{\#\# Eingabe: data = pd.Series(data, dtype = \textquotesingle{}float\textquotesingle{}), netzlast = {-}1, neue\_speichergrößen = [0.9, 0.8, 0.7, 0.6, 0.5], output = False}
\CommentTok{\#\# Verarbeitung: Aufruf der Funktion jahresgang\_speicher\_berechnen(data) zur Bestimmung von Speichergröße und Jahrsgang des Speichers in Jahr 1 und Jahr 2}
\CommentTok{\#\# Verarbeitung: Im Jahresgang des Stromspeichers wird die ausgespeicherte Strommenge bestimmt, diese wird von der Restlast abgezogen {-}{-}\textgreater{} neue Restlastkurve nach Ausspeicherung}
\CommentTok{\#\# Verarbeitung: Wenn netzlast = pd.Series(netzlast, dtype = \textquotesingle{}float\textquotesingle{}) übergeben wurde, wird anhand der Restlastkurve nach Ausspeicherung der Anteil erneuerbarer Energie bestimmt}
\CommentTok{\#\# Verarbeitung: Die Berechnungen werden für kleiner dimensionerte Speicher wiederholt, default = [0.9, 0.8, 0.7, 0.6, 0.5]}
\CommentTok{\#\# Ausgabe: output = False: DataFrame der Restlastkurve(n) nach Ausspeichern wird zurückgeben. In Spalte 0 ist Speichergröße = 1, in den folgenden Spalten die neuen Speichergrößen gespeichert. Zeile 0 enthält die Restlastkurve in Jahr 1, Zeile 1 die Restlastkurve in Jahr 2}
\CommentTok{\#\# Ausgabe: output = True, Ausgabe Summe Netzlast, positive / negative Restlast, Anteil EE ohne Speicher sowie realisierter Anteil EE für Speichergröße Basisjahr und neue\_speichergrößen jeweils für Jahr 1 und Jahr2 mittels print()}

\KeywordTok{def}\NormalTok{ anteil\_ee\_berechnen(data, netzlast }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{1}\NormalTok{, neue\_speichergrößen }\OperatorTok{=}\NormalTok{ [}\FloatTok{0.9}\NormalTok{, }\FloatTok{0.8}\NormalTok{, }\FloatTok{0.7}\NormalTok{, }\FloatTok{0.6}\NormalTok{, }\FloatTok{0.5}\NormalTok{], output }\OperatorTok{=} \VariableTok{False}\NormalTok{):}

  \CommentTok{\# Jahresgang im Basisjahr bestimmen}
\NormalTok{  ergebnis }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_berechnen(data, speichergröße }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{1}\NormalTok{, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\NormalTok{  speichergröße0 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{0}\NormalTok{]}
\NormalTok{  jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{1}\NormalTok{]}
\NormalTok{  jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{2}\NormalTok{]}
  
  \CommentTok{\# Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1}
\NormalTok{  jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ pd.concat([pd.Series([}\DecValTok{0}\NormalTok{]), jahresgang\_speicher\_jahr1])}
\NormalTok{  jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ pd.concat([jahresgang\_speicher\_jahr1[ }\OperatorTok{{-}} \DecValTok{1}\NormalTok{: ], jahresgang\_speicher\_jahr2])}

  \CommentTok{\# Jahresgang der ausgespeicherten Strommenge, erster Wert ist NaN und entfällt}
\NormalTok{  ausspeicherung\_jahr1 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr1.diff().clip(upper }\OperatorTok{=} \DecValTok{0}\NormalTok{)[}\DecValTok{1}\NormalTok{: ].reset\_index(drop }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{  ausspeicherung\_jahr2 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr2.diff().clip(upper }\OperatorTok{=} \DecValTok{0}\NormalTok{)[}\DecValTok{1}\NormalTok{: ].reset\_index(drop }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

  \CommentTok{\# Restlast nach Ausspeicherung berechnen, Werte in ausspeicherung\_jahr1 und ausspeicherung\_jahr2 sind negativ}
\NormalTok{  restlast\_jahr1 }\OperatorTok{=}\NormalTok{ data }\OperatorTok{+}\NormalTok{ ausspeicherung\_jahr1}
\NormalTok{  restlast\_jahr2 }\OperatorTok{=}\NormalTok{ data }\OperatorTok{+}\NormalTok{ ausspeicherung\_jahr2}

  \CommentTok{\# Restlast in DataFrame speichern}
\NormalTok{  restlast\_nach\_ausspeichern }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}Speichergröße 1\textquotesingle{}}\NormalTok{: [ }\BuiltInTok{list}\NormalTok{(restlast\_jahr1), }\BuiltInTok{list}\NormalTok{(restlast\_jahr2) ]\})}

  \ControlFlowTok{if} \BuiltInTok{type}\NormalTok{(netzlast) }\KeywordTok{is} \BuiltInTok{int}\NormalTok{: }\CommentTok{\# Anteil EE kann nicht ermittelt werden}
    \ControlFlowTok{if}\NormalTok{ output:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{"Netzlast wurde nicht übergeben. Anteil erneuerbarer Energien kann nicht ermittelt werden."}\NormalTok{)}

\NormalTok{    output }\OperatorTok{=} \VariableTok{False}
  
  \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# Anteil EE berechnen}
  
    \CommentTok{\# Anteil Anteil EE berechnen = 1 {-} Summe positive Restlast / Summe Netzlast }
    \CommentTok{\#\# Jahr1}
\NormalTok{    anteil\_ee\_jahr1 }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ (restlast\_jahr1.clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ netzlast.}\BuiltInTok{sum}\NormalTok{() )}

    \CommentTok{\#\# Jahr2}
\NormalTok{    anteil\_ee\_jahr2 }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ (restlast\_jahr2.clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ netzlast.}\BuiltInTok{sum}\NormalTok{() )}

    \CommentTok{\# Anteil EE in DataFrame speichern}
\NormalTok{    dataframe\_anteil\_ee }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}relative Speichergröße\textquotesingle{}}\NormalTok{: pd.concat([ pd.Series([}\DecValTok{1}\NormalTok{]), pd.Series(neue\_speichergrößen) ], ignore\_index }\OperatorTok{=} \VariableTok{True}\NormalTok{), }\StringTok{\textquotesingle{}Anteil EE Jahr1\textquotesingle{}}\NormalTok{: pd.Series([ anteil\_ee\_jahr1 ] ), }\StringTok{\textquotesingle{}Anteil EE Jahr2\textquotesingle{}}\NormalTok{: pd.Series([ anteil\_ee\_jahr2 ])\})}

  \CommentTok{\# Jahresgang der ausgespeicherten Strommenge und Anteil EE bei alternativen Speichergrößen berechnen}
\NormalTok{  count }\OperatorTok{=} \DecValTok{1}

  \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(neue\_speichergrößen)):}

\NormalTok{    speichergröße\_neu }\OperatorTok{=}\NormalTok{ speichergröße0 }\OperatorTok{*}\NormalTok{ neue\_speichergrößen[i]}
    
\NormalTok{    ergebnis }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_berechnen(data, speichergröße }\OperatorTok{=}\NormalTok{ speichergröße\_neu, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\NormalTok{    jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{1}\NormalTok{]}
\NormalTok{    jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{2}\NormalTok{]}

    \CommentTok{\# Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1}
\NormalTok{    jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ pd.concat([pd.Series([}\DecValTok{0}\NormalTok{]), jahresgang\_speicher\_jahr1])}
\NormalTok{    jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ pd.concat([jahresgang\_speicher\_jahr1[ }\OperatorTok{{-}} \DecValTok{1}\NormalTok{: ], jahresgang\_speicher\_jahr2])}

    \CommentTok{\# Jahresgang der ausgespeicherten Strommenge, erster Wert ist NaN und entfällt}
\NormalTok{    ausspeicherung\_jahr1 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr1.diff().clip(upper }\OperatorTok{=} \DecValTok{0}\NormalTok{)[}\DecValTok{1}\NormalTok{: ].reset\_index(drop }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{    ausspeicherung\_jahr2 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr2.diff().clip(upper }\OperatorTok{=} \DecValTok{0}\NormalTok{)[}\DecValTok{1}\NormalTok{: ].reset\_index(drop }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

    \CommentTok{\# Restlast nach Ausspeicherung berechnen, Werte in ausspeicherung\_jahr1 und ausspeicherung\_jahr2 sind negativ}
\NormalTok{    restlast\_jahr1 }\OperatorTok{=}\NormalTok{ data }\OperatorTok{+}\NormalTok{ ausspeicherung\_jahr1}
\NormalTok{    restlast\_jahr2 }\OperatorTok{=}\NormalTok{ data }\OperatorTok{+}\NormalTok{ ausspeicherung\_jahr2}

    \CommentTok{\# Spalte in DataFrame restlast\_nach\_ausspeichern einfügen}
\NormalTok{    restlast\_nach\_ausspeichern[}\StringTok{\textquotesingle{}Speichergröße \textquotesingle{}} \OperatorTok{+} \BuiltInTok{str}\NormalTok{(speichergröße\_neu)] }\OperatorTok{=}\NormalTok{ [ }\BuiltInTok{list}\NormalTok{(restlast\_jahr1), }\BuiltInTok{list}\NormalTok{(restlast\_jahr2) ]}

    \CommentTok{\# Anteil EE berechnen = 1 {-} Summe positive Restlast / Summe Netzlast }
    \ControlFlowTok{if} \BuiltInTok{type}\NormalTok{(netzlast) }\KeywordTok{is} \KeywordTok{not} \BuiltInTok{int}\NormalTok{:}
    
       \CommentTok{\#\# Jahr1}
\NormalTok{      anteil\_ee\_jahr1 }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ (restlast\_jahr1.clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ netzlast.}\BuiltInTok{sum}\NormalTok{() )}

      \CommentTok{\#\# Jahr2}
\NormalTok{      anteil\_ee\_jahr2 }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ (restlast\_jahr2.clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ netzlast.}\BuiltInTok{sum}\NormalTok{() )}

      \CommentTok{\# Anteil EE in DataFrame speichern, value assignment: df.loc[row\_indexer, "col"] = values}
\NormalTok{      dataframe\_anteil\_ee.loc[count, }\StringTok{\textquotesingle{}Anteil EE Jahr1\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ anteil\_ee\_jahr1}
\NormalTok{      dataframe\_anteil\_ee.loc[count, }\StringTok{\textquotesingle{}Anteil EE Jahr2\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ anteil\_ee\_jahr2}
    
\NormalTok{    count }\OperatorTok{+=} \DecValTok{1}
                          
  \ControlFlowTok{if}\NormalTok{ output: }\CommentTok{\# Anteil EE ausgeben}

    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Summe Netzlast: }\SpecialCharTok{\{}\NormalTok{netzlast}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{Summe positive Restlast: }\SpecialCharTok{\{}\NormalTok{data}\SpecialCharTok{.}\NormalTok{clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}t}\SpecialStringTok{Summe negative Restlast: }\SpecialCharTok{\{}\NormalTok{data}\SpecialCharTok{.}\NormalTok{clip(upper }\OperatorTok{=} \DecValTok{0}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{Speichergröße 1: }\SpecialCharTok{\{}\NormalTok{speichergr}\SpecialCharTok{öß}\NormalTok{e0}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}t}\SpecialStringTok{Anteil EE ohne Speicher: }\SpecialCharTok{\{}\DecValTok{1} \OperatorTok{{-}}\NormalTok{ ( data.clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ netzlast.}\BuiltInTok{sum}\NormalTok{() ) }\ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(netzlast) }\OperatorTok{\textgreater{}} \DecValTok{1} \ControlFlowTok{else} \StringTok{\textquotesingle{}{-}{-}\textquotesingle{}}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(dataframe\_anteil\_ee)}
    
  \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# Restlastkurven zurückgeben}
    \ControlFlowTok{return}\NormalTok{ restlast\_nach\_ausspeichern}

\NormalTok{anteil\_ee\_berechnen(restlast, netzlast }\OperatorTok{=}\NormalTok{ verbrauch[}\StringTok{\textquotesingle{}Gesamt (Netzlast) [MWh]\textquotesingle{}}\NormalTok{], neue\_speichergrößen }\OperatorTok{=}\NormalTok{ [}\FloatTok{0.9}\NormalTok{, }\FloatTok{0.8}\NormalTok{, }\FloatTok{0.7}\NormalTok{, }\FloatTok{0.6}\NormalTok{, }\FloatTok{0.5}\NormalTok{], output }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Summe Netzlast: 458,271,100.75
Summe positive Restlast: 207,842,228.25 Summe negative Restlast: -1,002,976.00
Speichergröße 1: 119,667.00 Anteil EE ohne Speicher: 0.55

   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                     1.0             0.55             0.55
1                     0.9             0.55             0.55
2                     0.8             0.55             0.55
3                     0.7             0.55             0.55
4                     0.6             0.55             0.55
5                     0.5             0.55             0.55
\end{verbatim}

\section{mit Wirkungsgrad}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Anteil EE berechnen}
\CommentTok{\#\# Eingabe: data = pd.Series(data, dtype = \textquotesingle{}float\textquotesingle{}), netzlast = {-}1, einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, neue\_speichergrößen = [0.9, 0.8, 0.7, 0.6, 0.5], output = False}
\CommentTok{\#\# Verarbeitung: Aufruf der Funktion jahresgang\_speicher\_berechnen(data) zur Bestimmung von Speichergröße und Jahrsgang des Speichers in Jahr 1 und Jahr 2}
\CommentTok{\#\# Verarbeitung: Im Jahresgang des Stromspeichers wird die ausgespeicherte Strommenge bestimmt, diese wird von der Restlast abgezogen {-}{-}\textgreater{} neue Restlastkurve nach Ausspeicherung}
\CommentTok{\#\# Verarbeitung: Wenn netzlast = pd.Series(netzlast, dtype = \textquotesingle{}float\textquotesingle{}) übergeben wurde, wird anhand der Restlastkurve nach Ausspeicherung der Anteil erneuerbarer Energie bestimmt}
\CommentTok{\#\# Verarbeitung: Die Berechnungen werden für kleiner dimensionerte Speicher wiederholt, default = [0.9, 0.8, 0.7, 0.6, 0.5]}
\CommentTok{\#\# Ausgabe: output = False: DataFrame der Restlastkurve(n) nach Ausspeichern wird zurückgeben. In Spalte 0 ist Speichergröße = 1, in den folgenden Spalten die neuen Speichergrößen gespeichert. Zeile 0 enthält die Restlastkurve in Jahr 1, Zeile 1 die Restlastkurve in Jahr 2}
\CommentTok{\#\# Ausgabe: output = True, Ausgabe Summe Netzlast, positive / negative Restlast, Anteil EE ohne Speicher sowie realisierter Anteil EE für Speichergröße Basisjahr und neue\_speichergrößen jeweils für Jahr 1 und Jahr2 mittels print()}

\KeywordTok{def}\NormalTok{ anteil\_ee\_berechnen(data, netzlast }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{1}\NormalTok{, einspeicherwirkungsgrad }\OperatorTok{=} \DecValTok{1}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \DecValTok{1}\NormalTok{, neue\_speichergrößen }\OperatorTok{=}\NormalTok{ [}\FloatTok{0.9}\NormalTok{, }\FloatTok{0.8}\NormalTok{, }\FloatTok{0.7}\NormalTok{, }\FloatTok{0.6}\NormalTok{, }\FloatTok{0.5}\NormalTok{], output }\OperatorTok{=} \VariableTok{False}\NormalTok{):}

  \CommentTok{\# Jahresgang im Basisjahr bestimmen}
\NormalTok{  ergebnis }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_berechnen(data, speichergröße }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{1}\NormalTok{, einspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ einspeicherwirkungsgrad, ausspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ ausspeicherwirkungsgrad, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\NormalTok{  speichergröße0 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{0}\NormalTok{]}
\NormalTok{  jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{1}\NormalTok{]}
\NormalTok{  jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{2}\NormalTok{]}
  
  \CommentTok{\# Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1}
\NormalTok{  jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ pd.concat([pd.Series([}\DecValTok{0}\NormalTok{]), jahresgang\_speicher\_jahr1])}
\NormalTok{  jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ pd.concat([jahresgang\_speicher\_jahr1[ }\OperatorTok{{-}} \DecValTok{1}\NormalTok{: ], jahresgang\_speicher\_jahr2])}

  \CommentTok{\# Jahresgang der ausgespeicherten Strommenge, erster Wert ist NaN und entfällt}
\NormalTok{  ausspeicherung\_jahr1 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr1.diff().clip(upper }\OperatorTok{=} \DecValTok{0}\NormalTok{)[}\DecValTok{1}\NormalTok{: ].reset\_index(drop }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{  ausspeicherung\_jahr2 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr2.diff().clip(upper }\OperatorTok{=} \DecValTok{0}\NormalTok{)[}\DecValTok{1}\NormalTok{: ].reset\_index(drop }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

  \CommentTok{\# Restlast nach Ausspeicherung berechnen, Werte in ausspeicherung\_jahr1 und ausspeicherung\_jahr2 sind negativ}
\NormalTok{  restlast\_jahr1 }\OperatorTok{=}\NormalTok{ data }\OperatorTok{+}\NormalTok{ ausspeicherung\_jahr1}
\NormalTok{  restlast\_jahr2 }\OperatorTok{=}\NormalTok{ data }\OperatorTok{+}\NormalTok{ ausspeicherung\_jahr2}

  \CommentTok{\# Restlast in DataFrame speichern}
\NormalTok{  restlast\_nach\_ausspeichern }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}Speichergröße 1\textquotesingle{}}\NormalTok{: [ }\BuiltInTok{list}\NormalTok{(restlast\_jahr1), }\BuiltInTok{list}\NormalTok{(restlast\_jahr2) ]\})}

  \ControlFlowTok{if} \BuiltInTok{type}\NormalTok{(netzlast) }\KeywordTok{is} \BuiltInTok{int}\NormalTok{: }\CommentTok{\# Anteil EE kann nicht ermittelt werden}
    \ControlFlowTok{if}\NormalTok{ output:}
      \BuiltInTok{print}\NormalTok{(}\StringTok{"Netzlast wurde nicht übergeben. Anteil erneuerbarer Energien kann nicht ermittelt werden."}\NormalTok{)}

\NormalTok{    output }\OperatorTok{=} \VariableTok{False}
  
  \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# Anteil EE berechnen}
  
    \CommentTok{\# Anteil Anteil EE berechnen = 1 {-} Summe positive Restlast / Summe Netzlast }
    \CommentTok{\#\# Jahr1}
\NormalTok{    anteil\_ee\_jahr1 }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ (restlast\_jahr1.clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ netzlast.}\BuiltInTok{sum}\NormalTok{() )}

    \CommentTok{\#\# Jahr2}
\NormalTok{    anteil\_ee\_jahr2 }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ (restlast\_jahr2.clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ netzlast.}\BuiltInTok{sum}\NormalTok{() )}

    \CommentTok{\# Anteil EE in DataFrame speichern}
\NormalTok{    dataframe\_anteil\_ee }\OperatorTok{=}\NormalTok{ pd.DataFrame(\{}\StringTok{\textquotesingle{}relative Speichergröße\textquotesingle{}}\NormalTok{: pd.concat([ pd.Series([}\DecValTok{1}\NormalTok{]), pd.Series(neue\_speichergrößen) ], ignore\_index }\OperatorTok{=} \VariableTok{True}\NormalTok{), }\StringTok{\textquotesingle{}Anteil EE Jahr1\textquotesingle{}}\NormalTok{: pd.Series([ anteil\_ee\_jahr1 ] ), }\StringTok{\textquotesingle{}Anteil EE Jahr2\textquotesingle{}}\NormalTok{: pd.Series([ anteil\_ee\_jahr2 ])\})}

  \CommentTok{\# Jahresgang der ausgespeicherten Strommenge und Anteil EE bei alternativen Speichergrößen berechnen}
\NormalTok{  count }\OperatorTok{=} \DecValTok{1}

  \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(neue\_speichergrößen)):}

\NormalTok{    speichergröße\_neu }\OperatorTok{=}\NormalTok{ speichergröße0 }\OperatorTok{*}\NormalTok{ neue\_speichergrößen[i]}
    
\NormalTok{    ergebnis }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_berechnen(data, speichergröße }\OperatorTok{=}\NormalTok{ speichergröße\_neu, einspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ einspeicherwirkungsgrad, ausspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ ausspeicherwirkungsgrad, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\NormalTok{    jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{1}\NormalTok{]}
\NormalTok{    jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ ergebnis[}\DecValTok{2}\NormalTok{]}

    \CommentTok{\# Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1}
\NormalTok{    jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ pd.concat([pd.Series([}\DecValTok{0}\NormalTok{]), jahresgang\_speicher\_jahr1])}
\NormalTok{    jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ pd.concat([jahresgang\_speicher\_jahr1[ }\OperatorTok{{-}} \DecValTok{1}\NormalTok{: ], jahresgang\_speicher\_jahr2])}

    \CommentTok{\# Jahresgang der ausgespeicherten Strommenge, erster Wert ist NaN und entfällt}
\NormalTok{    ausspeicherung\_jahr1 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr1.diff().clip(upper }\OperatorTok{=} \DecValTok{0}\NormalTok{)[}\DecValTok{1}\NormalTok{: ].reset\_index(drop }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\NormalTok{    ausspeicherung\_jahr2 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_jahr2.diff().clip(upper }\OperatorTok{=} \DecValTok{0}\NormalTok{)[}\DecValTok{1}\NormalTok{: ].reset\_index(drop }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

    \CommentTok{\# Restlast nach Ausspeicherung berechnen, Werte in ausspeicherung\_jahr1 und ausspeicherung\_jahr2 sind negativ}
\NormalTok{    restlast\_jahr1 }\OperatorTok{=}\NormalTok{ data }\OperatorTok{+}\NormalTok{ ausspeicherung\_jahr1}
\NormalTok{    restlast\_jahr2 }\OperatorTok{=}\NormalTok{ data }\OperatorTok{+}\NormalTok{ ausspeicherung\_jahr2}

    \CommentTok{\# Spalte in DataFrame restlast\_nach\_ausspeichern einfügen}
\NormalTok{    restlast\_nach\_ausspeichern[}\StringTok{\textquotesingle{}Speichergröße \textquotesingle{}} \OperatorTok{+} \BuiltInTok{str}\NormalTok{(speichergröße\_neu)] }\OperatorTok{=}\NormalTok{ [ }\BuiltInTok{list}\NormalTok{(restlast\_jahr1), }\BuiltInTok{list}\NormalTok{(restlast\_jahr2) ]}

    \CommentTok{\# Anteil EE berechnen = 1 {-} Summe positive Restlast / Summe Netzlast }
    \ControlFlowTok{if} \BuiltInTok{type}\NormalTok{(netzlast) }\KeywordTok{is} \KeywordTok{not} \BuiltInTok{int}\NormalTok{:}
    
       \CommentTok{\#\# Jahr1}
\NormalTok{      anteil\_ee\_jahr1 }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ (restlast\_jahr1.clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ netzlast.}\BuiltInTok{sum}\NormalTok{() )}

      \CommentTok{\#\# Jahr2}
\NormalTok{      anteil\_ee\_jahr2 }\OperatorTok{=} \DecValTok{1} \OperatorTok{{-}}\NormalTok{ (restlast\_jahr2.clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ netzlast.}\BuiltInTok{sum}\NormalTok{() )}

      \CommentTok{\# Anteil EE in DataFrame speichern, value assignment: df.loc[row\_indexer, "col"] = values}
\NormalTok{      dataframe\_anteil\_ee.loc[count, }\StringTok{\textquotesingle{}Anteil EE Jahr1\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ anteil\_ee\_jahr1}
\NormalTok{      dataframe\_anteil\_ee.loc[count, }\StringTok{\textquotesingle{}Anteil EE Jahr2\textquotesingle{}}\NormalTok{] }\OperatorTok{=}\NormalTok{ anteil\_ee\_jahr2}
    
\NormalTok{    count }\OperatorTok{+=} \DecValTok{1}
                          
  \ControlFlowTok{if}\NormalTok{ output: }\CommentTok{\# Anteil EE ausgeben}

    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Summe Netzlast: }\SpecialCharTok{\{}\NormalTok{netzlast}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{Summe positive Restlast: }\SpecialCharTok{\{}\NormalTok{data}\SpecialCharTok{.}\NormalTok{clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}t}\SpecialStringTok{Summe negative Restlast: }\SpecialCharTok{\{}\NormalTok{data}\SpecialCharTok{.}\NormalTok{clip(upper }\OperatorTok{=} \DecValTok{0}\NormalTok{)}\SpecialCharTok{.}\BuiltInTok{sum}\NormalTok{()}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{Speichergröße 1: }\SpecialCharTok{\{}\NormalTok{speichergr}\SpecialCharTok{öß}\NormalTok{e0}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}t}\SpecialStringTok{Anteil EE ohne Speicher: }\SpecialCharTok{\{}\DecValTok{1} \OperatorTok{{-}}\NormalTok{ ( data.clip(lower }\OperatorTok{=} \DecValTok{0}\NormalTok{).}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/}\NormalTok{ netzlast.}\BuiltInTok{sum}\NormalTok{() ) }\ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(netzlast) }\OperatorTok{\textgreater{}} \DecValTok{1} \ControlFlowTok{else} \StringTok{\textquotesingle{}{-}{-}\textquotesingle{}}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
    \BuiltInTok{print}\NormalTok{(dataframe\_anteil\_ee)}
    
  \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# Restlastkurven zurückgeben}
    \ControlFlowTok{return}\NormalTok{ restlast\_nach\_ausspeichern}

\NormalTok{anteil\_ee\_berechnen(restlast, netzlast }\OperatorTok{=}\NormalTok{ verbrauch[}\StringTok{\textquotesingle{}Gesamt (Netzlast) [MWh]\textquotesingle{}}\NormalTok{], einspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, neue\_speichergrößen }\OperatorTok{=}\NormalTok{ [}\FloatTok{0.9}\NormalTok{, }\FloatTok{0.8}\NormalTok{, }\FloatTok{0.7}\NormalTok{, }\FloatTok{0.6}\NormalTok{, }\FloatTok{0.5}\NormalTok{], output }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Summe Netzlast: 458,271,100.75
Summe positive Restlast: 207,842,228.25 Summe negative Restlast: -1,002,976.00
Speichergröße 1: 102,674.54 Anteil EE ohne Speicher: 0.55

   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                     1.0             0.55             0.55
1                     0.9             0.55             0.55
2                     0.8             0.55             0.55
3                     0.7             0.55             0.55
4                     0.6             0.55             0.55
5                     0.5             0.55             0.55
\end{verbatim}

Für das Jahr 2023 ergäbe sich durch die Netzintegration eines
Stromspeichers zur (teilweisen) Deckung der Restlast aus erneuerbarer
Überschussproduktion eine nur unmerkliche Erhöhung des Anteils
erneuerbarer Energien am Strommix. Das liegt daran, dass die
einzuspeichernden erneuerbaren Überschüsse mit 1.002.976 MWh, also rund
1 TWh, erheblich kleiner als die zu deckende positive Restlast mit
207.842.228 MWh, also rund 208 TWh, sind. Die durch den Stromspeicher
verschiebbare erneuerbare Überschussproduktion entspricht weniger als
einem halben Prozent der zu deckenden Restlast.

Mit steigendem Anteil erneuerbarer Erzeugung wird die Speicherung
überschüssiger Stromerzeugung jedoch immer relevanter werden. Die
Dimension der erforderlichen Stromspeicher können mit den entwickelten
Funktionen für den Ausbaupfad erneuerbarer Energien abgeschätzt werden.

\section{Aufgabe schließende
Datenanalyse}\label{aufgabe-schlieuxdfende-datenanalyse}

\textbf{Berechnen Sie entsprechend des von der Bundesregierung
vorgegebenen Ausbaupfads den Anteil erneuerbarer Stromerzeugung für das
Jahr 2030 und für das Jahr 2035 (siehe
Listing~\ref{lst-zubaufaktoren}).}

\begin{itemize}
\item
  Wie groß ist der maximal benötigte Speicher?
\item
  Welcher Anteil erneuerbarer Stromerzeugung wird erreicht, wenn der
  Speicher halb so groß, ein Zehntel so groß oder ein Hundertstel so
  groß dimensioniert wird?
\item
  Als Netzlast verwenden Sie die Projektionen des Stromverbrauchs für
  das Jahr 2030 und 2035 (siehe untenstehender Hinweis).
\item
  Für den Wirkungsgrad können die bestehenden Pumpspeicherkraftwerke als
  Orientierung dienen. Der Gesamtwirkungsgrad wurde mit 79.10 Prozent
  berechnet. Diesem Wirkungsgrad entspricht näherungsweise eine
  Aufteilung von Einspeicherwirkungsgrad = 0.9, Ausspeicherwirkungsgrad
  = 0.88.
\end{itemize}

\begin{tcolorbox}[enhanced jigsaw, toprule=.15mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, rightrule=.15mm, arc=.35mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\vspace{-3mm}\textbf{Projektionen des Stromverbrauchs}\vspace{3mm}

Der künftige Stromverbrauch wird wahrscheinlich nicht dem des Jahres
2023 entsprechen. Projektionen lassen einen Stromverbrauch von 658 TWh
(Kemmler, Wünsch, und Burret 2021, S. 4) für das Jahr 2030 und von 670,4
TWh im Jahr 2035 (Szenario B nach Nahmmacher et al.~2021, S. 54)
erwarten. Die Steigerung des Stromverbrauchs gegenüber 2023 kann leicht
berechnet werden:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lastfaktor\_2030\_MWh }\OperatorTok{=}\NormalTok{ (}\DecValTok{658} \OperatorTok{*} \DecValTok{1000} \OperatorTok{*} \DecValTok{1000}\NormalTok{) }\OperatorTok{/}\NormalTok{ verbrauch[}\StringTok{"Gesamt (Netzlast) [MWh]"}\NormalTok{].}\BuiltInTok{sum}\NormalTok{()}
\NormalTok{lastfaktor\_2035\_MWh }\OperatorTok{=}\NormalTok{ (}\FloatTok{670.4} \OperatorTok{*} \DecValTok{1000} \OperatorTok{*} \DecValTok{1000}\NormalTok{) }\OperatorTok{/}\NormalTok{ verbrauch[}\StringTok{"Gesamt (Netzlast) [MWh]"}\NormalTok{].}\BuiltInTok{sum}\NormalTok{()}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Steigerung des Stromverbrauchs 2030 gegenüber 2023 Faktor: }\SpecialCharTok{\{}\NormalTok{lastfaktor\_2030\_MWh}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Steigerung des Stromverbrauchs 2035 gegenüber 2023 Faktor: }\SpecialCharTok{\{}\NormalTok{lastfaktor\_2035\_MWh}\SpecialCharTok{:,.2f\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Steigerung des Stromverbrauchs 2030 gegenüber 2023 Faktor: 1.44
Steigerung des Stromverbrauchs 2035 gegenüber 2023 Faktor: 1.46
\end{verbatim}

Kemmler, Andreas, Aurel Wünsch, und Heiko Burret. 2021. ``Entwicklung
des Bruttostromverbrauchs bis 2030. Kurzstudie.''
\url{https://www.bmwk.de/Redaktion/DE/Downloads/E/prognos-bruttostromverbrauch-2018-2030.pdf?__blob=publicationFile&v=2}

Nahmmacher, Paul, Christian Paris, Martin Ruge, Sebastian Spieker,
Thomas Anderski, Sebastian Bohlen, Robin Kaiser, Caroline Podewski,
Jürgen Apfelbeck, Timo Kahl, Fabian Lukas, Sven Schäfer, Paul-Steven
Ganer, Max Muller und Daniel Stützle. 2021. ``Szenariorahmen zum
Netzentwicklungsplan Strom 2035, Version 2021. Entwurf der
Übertragungsnetzbetreiber.''
\url{https://www.netzausbau.de/SharedDocs/Downloads/DE/Bedarfsermittlung/2035/SR/Szenariorahmen_2035_Entwurf.pdf?__blob=publicationFile}

\end{minipage}%
\end{tcolorbox}

~

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-aufgabe-schließende-datenanalyse}: Musterlösung Aufgabe schließende Datenanalyse}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-aufgabe-schließende-datenanalyse} 

\section{vollständige Musterlösung}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}

\CommentTok{\# Deklarieren der Anzahl der Nachkommastellen}
\NormalTok{pd.set\_option(}\StringTok{"display.precision"}\NormalTok{, }\DecValTok{2}\NormalTok{)}

\CommentTok{\# Datensätze werden eingelesen}
\CommentTok{\# !}
\CommentTok{\# Für die eigene Anwendung muss der Dateipfad an den korrekten Speicherort der runtergeladenen .csv Datei angepasst werden. }
\CommentTok{\# !}

\NormalTok{installierte\_leistung\_ms }\OperatorTok{=}\NormalTok{ pd.read\_csv(}\StringTok{"01{-}daten/Installierte\_Erzeugungsleistung\_202301010000\_202401010000\_Jahr.csv"}\NormalTok{, }\OperatorTok{\textbackslash{}}
\NormalTok{sep }\OperatorTok{=} \StringTok{";"}\NormalTok{, thousands }\OperatorTok{=} \StringTok{"."}\NormalTok{, decimal }\OperatorTok{=} \StringTok{","}\NormalTok{, parse\_dates }\OperatorTok{=}\NormalTok{  [}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{], date\_format }\OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y"}\NormalTok{)}

\NormalTok{erzeugung\_ms }\OperatorTok{=}\NormalTok{ pd.read\_csv(}\StringTok{"01{-}daten/Realisierte\_Erzeugung\_202301010000\_202401010000\_Viertelstunde.csv"}\NormalTok{, }\OperatorTok{\textbackslash{}}
\NormalTok{sep }\OperatorTok{=} \StringTok{";"}\NormalTok{, thousands }\OperatorTok{=} \StringTok{"."}\NormalTok{, decimal }\OperatorTok{=} \StringTok{","}\NormalTok{, parse\_dates }\OperatorTok{=}\NormalTok{  [}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{], date\_format }\OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y \%H:\%M"}\NormalTok{)}

\NormalTok{verbrauch\_ms }\OperatorTok{=}\NormalTok{ pd.read\_csv(}\StringTok{"01{-}daten/Realisierter\_Stromverbrauch\_202301010000\_202401010000\_Viertelstunde.csv"}\NormalTok{, }\OperatorTok{\textbackslash{}}
\NormalTok{sep }\OperatorTok{=} \StringTok{";"}\NormalTok{, thousands }\OperatorTok{=} \StringTok{"."}\NormalTok{, decimal }\OperatorTok{=} \StringTok{","}\NormalTok{, parse\_dates }\OperatorTok{=}\NormalTok{  [}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{], date\_format }\OperatorTok{=} \StringTok{"}\SpecialCharTok{\%d}\StringTok{.\%m.\%Y \%H:\%M"}\NormalTok{)}

\CommentTok{\# Zeichenkette " Originalauflösungen" entfernen}
\NormalTok{erzeugung\_ms.columns }\OperatorTok{=}\NormalTok{ erzeugung\_ms.columns.}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{" Originalauflösungen"}\NormalTok{, repl }\OperatorTok{=} \StringTok{""}\NormalTok{)}
\NormalTok{installierte\_leistung\_ms.columns }\OperatorTok{=}\NormalTok{ installierte\_leistung\_ms.columns.}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{" Originalauflösungen"}\NormalTok{, repl }\OperatorTok{=} \StringTok{""}\NormalTok{)}
\NormalTok{verbrauch\_ms.columns }\OperatorTok{=}\NormalTok{ verbrauch\_ms.columns.}\BuiltInTok{str}\NormalTok{.replace(pat }\OperatorTok{=} \StringTok{" Originalauflösungen"}\NormalTok{, repl }\OperatorTok{=} \StringTok{""}\NormalTok{)}

\CommentTok{\# Zusammenfassen der erneuerbaren Erzeugung in einer Liste}
\NormalTok{erneuerbare\_ms }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Biomasse [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wasserkraft [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Offshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Onshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Photovoltaik [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Sonstige Erneuerbare [MWh]\textquotesingle{}}\NormalTok{]}

\NormalTok{pumpspeicherkapazität\_MWh\_ms }\OperatorTok{=} \FloatTok{37.4} \OperatorTok{*} \DecValTok{1000}

\CommentTok{\# Projizierte Erzeugung und Stromverbrauch 2030 \& 2035:}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Wind an Land 2030:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{( zubaufaktor\_windonshore\_2030\_ms }\OperatorTok{:=} \DecValTok{115} \OperatorTok{/}\NormalTok{ (installierte\_leistung\_ms[}\StringTok{\textquotesingle{}Wind Onshore [MW]\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/} \DecValTok{1000}\NormalTok{) )}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Wind auf See 2030:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{( zubaufaktor\_windoffshore\_2030\_ms }\OperatorTok{:=} \DecValTok{30} \OperatorTok{/}\NormalTok{ (installierte\_leistung\_ms[}\StringTok{\textquotesingle{}Wind Offshore [MW]\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/} \DecValTok{1000}\NormalTok{) )}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Solar 2030:}\CharTok{\textbackslash{}t\textbackslash{}t\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{( zubaufaktor\_solar\_2030\_ms }\OperatorTok{:=} \DecValTok{215} \OperatorTok{/}\NormalTok{ (installierte\_leistung\_ms[}\StringTok{\textquotesingle{}Photovoltaik [MW]\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/} \DecValTok{1000}\NormalTok{) )}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Biomasse 2030:}\CharTok{\textbackslash{}t\textbackslash{}t}\SpecialCharTok{\{}\FloatTok{8.4} \OperatorTok{/}\NormalTok{ (installierte\_leistung\_ms[}\StringTok{\textquotesingle{}Biomasse [MW]\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/} \DecValTok{1000}\NormalTok{)}\SpecialCharTok{:,.2f\}}\SpecialStringTok{"}\NormalTok{)}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n\textbackslash{}n}\SpecialStringTok{Wind an Land 2035:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{( zubaufaktor\_windonshore\_2035\_ms }\OperatorTok{:=} \DecValTok{157} \OperatorTok{/}\NormalTok{ (installierte\_leistung\_ms[}\StringTok{\textquotesingle{}Wind Onshore [MW]\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/} \DecValTok{1000}\NormalTok{) )}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Wind auf See 2035:}\CharTok{\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{( zubaufaktor\_windoffshore\_2035\_ms }\OperatorTok{:=} \DecValTok{40} \OperatorTok{/}\NormalTok{ (installierte\_leistung\_ms[}\StringTok{\textquotesingle{}Wind Offshore [MW]\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/} \DecValTok{1000}\NormalTok{) )}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Solar 2035:}\CharTok{\textbackslash{}t\textbackslash{}t\textbackslash{}t}\SpecialCharTok{\{}\NormalTok{( zubaufaktor\_solar\_2035\_ms }\OperatorTok{:=} \DecValTok{309} \OperatorTok{/}\NormalTok{ (installierte\_leistung\_ms[}\StringTok{\textquotesingle{}Photovoltaik [MW]\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/} \DecValTok{1000}\NormalTok{) )}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Biomasse 2035:}\CharTok{\textbackslash{}t\textbackslash{}t}\SpecialCharTok{\{}\FloatTok{8.4} \OperatorTok{/}\NormalTok{ (installierte\_leistung\_ms[}\StringTok{\textquotesingle{}Biomasse [MW]\textquotesingle{}}\NormalTok{].}\BuiltInTok{sum}\NormalTok{() }\OperatorTok{/} \DecValTok{1000}\NormalTok{)}\SpecialCharTok{:,.2f\}}\SpecialStringTok{"}\NormalTok{)}

\NormalTok{lastfaktor\_2030\_MWh\_ms }\OperatorTok{=}\NormalTok{ (}\DecValTok{658} \OperatorTok{*} \DecValTok{1000} \OperatorTok{*} \DecValTok{1000}\NormalTok{) }\OperatorTok{/}\NormalTok{ verbrauch\_ms[}\StringTok{"Gesamt (Netzlast) [MWh]"}\NormalTok{].}\BuiltInTok{sum}\NormalTok{()}
\NormalTok{lastfaktor\_2035\_MWh\_ms }\OperatorTok{=}\NormalTok{ (}\FloatTok{670.4} \OperatorTok{*} \DecValTok{1000} \OperatorTok{*} \DecValTok{1000}\NormalTok{) }\OperatorTok{/}\NormalTok{ verbrauch\_ms[}\StringTok{"Gesamt (Netzlast) [MWh]"}\NormalTok{].}\BuiltInTok{sum}\NormalTok{()}

\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Steigerung des Stromverbrauchs 2030 gegenüber 2023 Faktor: }\SpecialCharTok{\{}\NormalTok{lastfaktor\_2030\_MWh\_ms}\SpecialCharTok{:,.2f\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Steigerung des Stromverbrauchs 2035 gegenüber 2023 Faktor: }\SpecialCharTok{\{}\NormalTok{lastfaktor\_2035\_MWh\_ms}\SpecialCharTok{:,.2f\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# Definieren der Restlast}
\NormalTok{restlast\_ms }\OperatorTok{=}\NormalTok{ pd.DataFrame()}
\NormalTok{restlast\_ms[}\StringTok{"Netzlast [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ verbrauch\_ms[}\StringTok{"Gesamt (Netzlast) [MWh]"}\NormalTok{].copy() }
\NormalTok{restlast\_ms[}\StringTok{"Erneuerbare [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung\_ms[erneuerbare\_ms].}\BuiltInTok{sum}\NormalTok{(axis }\OperatorTok{=} \StringTok{"columns"}\NormalTok{).copy()}
\NormalTok{restlast\_ms[}\StringTok{"Restlast [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ restlast\_ms[}\StringTok{"Netzlast [MWh]"}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ restlast\_ms[}\StringTok{"Erneuerbare [MWh]"}\NormalTok{]}
\NormalTok{restlast\_ms }\OperatorTok{=}\NormalTok{ restlast\_ms[}\StringTok{"Restlast [MWh]"}\NormalTok{]}


\NormalTok{erzeugung\_2030\_ms }\OperatorTok{=}\NormalTok{ erzeugung\_ms.copy()}
\NormalTok{erzeugung\_2035\_ms }\OperatorTok{=}\NormalTok{ erzeugung\_ms.copy()}

\NormalTok{erzeugung\_2030\_ms[}\StringTok{"Wind Onshore [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung\_2030\_ms[}\StringTok{"Wind Onshore [MWh]"}\NormalTok{] }\OperatorTok{*}\NormalTok{ zubaufaktor\_windonshore\_2030\_ms}
\NormalTok{erzeugung\_2030\_ms[}\StringTok{"Wind Offshore [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung\_2030\_ms[}\StringTok{"Wind Offshore [MWh]"}\NormalTok{] }\OperatorTok{*}\NormalTok{ zubaufaktor\_windoffshore\_2030\_ms}
\NormalTok{erzeugung\_2030\_ms[}\StringTok{"Photovoltaik [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung\_2030\_ms[}\StringTok{"Photovoltaik [MWh]"}\NormalTok{]}\OperatorTok{*}\NormalTok{ zubaufaktor\_solar\_2030\_ms}
\CommentTok{\# der Wert für Biomasse muss hier nicht geändert werden, da der Faktor 0,99 (also näherungsweise 1) beträgt}
\NormalTok{erzeugung\_2035\_ms[}\StringTok{"Wind Onshore [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung\_2035\_ms[}\StringTok{"Wind Onshore [MWh]"}\NormalTok{] }\OperatorTok{*}\NormalTok{ zubaufaktor\_windonshore\_2035\_ms}
\NormalTok{erzeugung\_2035\_ms[}\StringTok{"Wind Offshore [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung\_2035\_ms[}\StringTok{"Wind Offshore [MWh]"}\NormalTok{] }\OperatorTok{*}\NormalTok{ zubaufaktor\_windoffshore\_2035\_ms}
\NormalTok{erzeugung\_2035\_ms[}\StringTok{"Photovoltaik [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung\_2035\_ms[}\StringTok{"Photovoltaik [MWh]"}\NormalTok{]}\OperatorTok{*}\NormalTok{ zubaufaktor\_solar\_2035\_ms}

\NormalTok{verbrauch\_2030\_ms }\OperatorTok{=}\NormalTok{ verbrauch\_ms.copy()}
\NormalTok{verbrauch\_2030\_ms[}\StringTok{"Gesamt (Netzlast) [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ verbrauch\_2030\_ms[}\StringTok{"Gesamt (Netzlast) [MWh]"}\NormalTok{]}\OperatorTok{*}\NormalTok{lastfaktor\_2030\_MWh\_ms}
\NormalTok{verbrauch\_2035\_ms }\OperatorTok{=}\NormalTok{ verbrauch\_ms.copy()}
\NormalTok{verbrauch\_2035\_ms[}\StringTok{"Gesamt (Netzlast) [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ verbrauch\_2035\_ms[}\StringTok{"Gesamt (Netzlast) [MWh]"}\NormalTok{]}\OperatorTok{*}\NormalTok{lastfaktor\_2035\_MWh\_ms}

\NormalTok{restlast\_2030\_ms }\OperatorTok{=}\NormalTok{ pd.DataFrame()}
\NormalTok{restlast\_2030\_ms[}\StringTok{"Netzlast [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ verbrauch\_2030\_ms[}\StringTok{"Gesamt (Netzlast) [MWh]"}\NormalTok{].copy() }
\NormalTok{restlast\_2030\_ms[}\StringTok{"Erneuerbare [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung\_2030\_ms[erneuerbare\_ms].}\BuiltInTok{sum}\NormalTok{(axis }\OperatorTok{=} \StringTok{"columns"}\NormalTok{).copy()}
\NormalTok{restlast\_2030\_ms[}\StringTok{"Restlast [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ restlast\_2030\_ms[}\StringTok{"Netzlast [MWh]"}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ restlast\_2030\_ms[}\StringTok{"Erneuerbare [MWh]"}\NormalTok{]}
\NormalTok{restlast\_2030\_ms }\OperatorTok{=}\NormalTok{ restlast\_2030\_ms[}\StringTok{"Restlast [MWh]"}\NormalTok{]}

\NormalTok{restlast\_2035\_ms }\OperatorTok{=}\NormalTok{ pd.DataFrame()}
\NormalTok{restlast\_2035\_ms[}\StringTok{"Netzlast [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ verbrauch\_2035\_ms[}\StringTok{"Gesamt (Netzlast) [MWh]"}\NormalTok{].copy() }
\NormalTok{restlast\_2035\_ms[}\StringTok{"Erneuerbare [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ erzeugung\_2035\_ms[erneuerbare\_ms].}\BuiltInTok{sum}\NormalTok{(axis }\OperatorTok{=} \StringTok{"columns"}\NormalTok{).copy()}
\NormalTok{restlast\_2035\_ms[}\StringTok{"Restlast [MWh]"}\NormalTok{] }\OperatorTok{=}\NormalTok{ restlast\_2035\_ms[}\StringTok{"Netzlast [MWh]"}\NormalTok{] }\OperatorTok{{-}}\NormalTok{ restlast\_2035\_ms[}\StringTok{"Erneuerbare [MWh]"}\NormalTok{]}
\NormalTok{restlast\_2035\_ms }\OperatorTok{=}\NormalTok{ restlast\_2035\_ms[}\StringTok{"Restlast [MWh]"}\NormalTok{]}

\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{2030}\CharTok{\textbackslash{}n}\StringTok{======================}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{speicher\_2030\_ms }\OperatorTok{=}\NormalTok{ berechne\_speichergröße(restlast\_2030\_ms, einspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.88}\NormalTok{, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"erforderliche Speichergröße in 2030: }\SpecialCharTok{\{}\NormalTok{speicher\_2030\_ms}\SpecialCharTok{:,.1f\}}\SpecialStringTok{ MWh"}\NormalTok{)}

\NormalTok{anteil\_EE\_2030\_ms }\OperatorTok{=}\NormalTok{ anteil\_ee\_berechnen(restlast\_2030\_ms, netzlast }\OperatorTok{=}\NormalTok{ verbrauch\_2030\_ms[}\StringTok{\textquotesingle{}Gesamt (Netzlast) [MWh]\textquotesingle{}}\NormalTok{],}
\NormalTok{                                     einspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.88}\NormalTok{, neue\_speichergrößen }\OperatorTok{=}\NormalTok{ [}\FloatTok{0.5}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.01}\NormalTok{], output }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

\CommentTok{\# das ganze nochmal für 2035:}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{2035}\CharTok{\textbackslash{}n}\StringTok{======================}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{speicher\_2035\_ms }\OperatorTok{=}\NormalTok{ berechne\_speichergröße(restlast\_2035\_ms, einspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.88}\NormalTok{, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"erforderliche Speichergröße in 2035: }\SpecialCharTok{\{}\NormalTok{speicher\_2035\_ms}\SpecialCharTok{:,.1f\}}\SpecialStringTok{ MWh"}\NormalTok{)}

\NormalTok{anteil\_EE\_2035\_ms }\OperatorTok{=}\NormalTok{ anteil\_ee\_berechnen(restlast\_2035\_ms, netzlast }\OperatorTok{=}\NormalTok{ verbrauch\_2035\_ms[}\StringTok{\textquotesingle{}Gesamt (Netzlast) [MWh]\textquotesingle{}}\NormalTok{],}
\NormalTok{                                     einspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.88}\NormalTok{, neue\_speichergrößen }\OperatorTok{=}\NormalTok{ [}\FloatTok{0.5}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.01}\NormalTok{], output }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Wind an Land 2030:  2.00
Wind auf See 2030:  3.69
Solar 2030:         3.41
Biomasse 2030:      0.99


Wind an Land 2035:  2.73
Wind auf See 2035:  4.92
Solar 2035:         4.90
Biomasse 2035:      0.99

Steigerung des Stromverbrauchs 2030 gegenüber 2023 Faktor: 1.44
Steigerung des Stromverbrauchs 2035 gegenüber 2023 Faktor: 1.46

2030
======================

erforderliche Speichergröße in 2030: 6,170,038.0 MWh
Summe Netzlast: 658,000,000.00
Summe positive Restlast: 175,897,072.30 Summe negative Restlast: -85,250,478.82
Speichergröße 1: 6,170,038.04   Anteil EE ohne Speicher: 0.73

   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                    1.00             0.83             0.84
1                    0.50             0.83             0.83
2                    0.10             0.81             0.81
3                    0.01             0.75             0.75

2035
======================

erforderliche Speichergröße in 2035: 23,829,823.9 MWh
Summe Netzlast: 670,400,000.00
Summe positive Restlast: 125,949,558.61 Summe negative Restlast: -221,510,407.41
Speichergröße 1: 23,829,823.85  Anteil EE ohne Speicher: 0.81

   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                    1.00             0.98             1.00
1                    0.50             0.97             0.97
2                    0.10             0.94             0.94
3                    0.01             0.87             0.87
\end{verbatim}

Musterlösung von Marc Sönnecken. Für die Kompatibilität mit diesem
Skript wurden der Dateipfad und die Objektbezeichnungen angepasst. Die
Definition der verwendeten Funktionen wurde ausgeschnitten (identisch zu
den im Skript gezeigten). Der Code wurde so ergänzt, dass in der Ausgabe
einige zusätzliche Leerzeilen und Markierungen für das Jahr 2030 und das
Jahr 2035 erscheinen.

\section{Referenz 2030}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{meine\_speichergrößen }\OperatorTok{=}\NormalTok{ [}\FloatTok{0.9}\NormalTok{, }\FloatTok{0.8}\NormalTok{, }\FloatTok{0.7}\NormalTok{, }\FloatTok{0.6}\NormalTok{, }\FloatTok{0.5}\NormalTok{, }\FloatTok{0.4}\NormalTok{, }\FloatTok{0.3}\NormalTok{, }\FloatTok{0.2}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.08}\NormalTok{, }\FloatTok{0.06}\NormalTok{, }\FloatTok{0.04}\NormalTok{, }\FloatTok{0.02}\NormalTok{, }\FloatTok{0.01}\NormalTok{]}
\NormalTok{mein\_einspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}
\NormalTok{mein\_ausspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.88}

\CommentTok{\# Datensatz 2030 erzeugen}
\CommentTok{\#\# zubaufaktor\_windonshore\_2030}
\CommentTok{\#\# zubaufaktor\_windoffshore\_2030}
\CommentTok{\#\# zubaufaktor\_solar\_2030}

\NormalTok{erzeugung\_2030 }\OperatorTok{=}\NormalTok{ erzeugung.copy()}
\NormalTok{erzeugung\_2030[}\StringTok{\textquotesingle{}Wind Onshore [MWh]\textquotesingle{}}\NormalTok{] }\OperatorTok{*=}\NormalTok{ zubaufaktor\_windonshore\_2030}
\NormalTok{erzeugung\_2030[}\StringTok{\textquotesingle{}Wind Offshore [MWh]\textquotesingle{}}\NormalTok{] }\OperatorTok{*=}\NormalTok{ zubaufaktor\_windoffshore\_2030}
\NormalTok{erzeugung\_2030[}\StringTok{\textquotesingle{}Photovoltaik [MWh]\textquotesingle{}}\NormalTok{] }\OperatorTok{*=}\NormalTok{ zubaufaktor\_solar\_2030}

\NormalTok{erneuerbare\_2030 }\OperatorTok{=}\NormalTok{ pd.Series()}
\NormalTok{erneuerbare }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Biomasse [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wasserkraft [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Offshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Onshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Photovoltaik [MWh]\textquotesingle{}}\NormalTok{,}
\StringTok{\textquotesingle{}Sonstige Erneuerbare [MWh]\textquotesingle{}}\NormalTok{]}
\NormalTok{erneuerbare\_2030 }\OperatorTok{=}\NormalTok{ erzeugung\_2030[erneuerbare].}\BuiltInTok{sum}\NormalTok{(axis }\OperatorTok{=} \StringTok{"columns"}\NormalTok{).copy()}

\NormalTok{netzlast\_2023 }\OperatorTok{=}\NormalTok{ pd.Series()}
\NormalTok{netzlast\_2023 }\OperatorTok{=}\NormalTok{ verbrauch[}\StringTok{"Gesamt (Netzlast) [MWh]"}\NormalTok{].copy()}
\NormalTok{netzlast\_2030 }\OperatorTok{=}\NormalTok{ netzlast\_2023 }\OperatorTok{*}\NormalTok{ lastfaktor\_2030\_MWh}

\NormalTok{restlast\_2030 }\OperatorTok{=}\NormalTok{ pd.Series()}
\NormalTok{restlast\_2030 }\OperatorTok{=}\NormalTok{ netzlast\_2030 }\OperatorTok{{-}}\NormalTok{ erneuerbare\_2030}

\CommentTok{\# Ausgabe}
\NormalTok{speicher\_2030 }\OperatorTok{=}\NormalTok{ berechne\_speichergröße(restlast\_2030, einspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ mein\_einspeicherwirkungsgrad, ausspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ mein\_ausspeicherwirkungsgrad, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"maximal erforderliche Speichergröße 2030: }\SpecialCharTok{\{}\NormalTok{speicher\_2030}\SpecialCharTok{:,.1f\}}\SpecialStringTok{ MWh}\CharTok{\textbackslash{}n}\SpecialStringTok{Dies entspricht }\SpecialCharTok{\{}\NormalTok{speicher\_2030 }\OperatorTok{/}\NormalTok{ pumpspeicherkapazit}\SpecialCharTok{ä}\NormalTok{t\_MWh}\SpecialCharTok{:,.1f\}}\SpecialStringTok{ Pumpspeicheräquivalenten."}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{effekt\_kappung\_berechnen(restlast\_2030, einspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ mein\_einspeicherwirkungsgrad, ausspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ mein\_ausspeicherwirkungsgrad, neue\_speichergrößen }\OperatorTok{=}\NormalTok{ meine\_speichergrößen, output }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{anteil\_ee\_berechnen(restlast\_2030, netzlast }\OperatorTok{=}\NormalTok{ netzlast\_2030, einspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ mein\_einspeicherwirkungsgrad, ausspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ mein\_ausspeicherwirkungsgrad, neue\_speichergrößen }\OperatorTok{=}\NormalTok{ meine\_speichergrößen, output }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
maximal erforderliche Speichergröße 2030: 6,170,038.0 MWh
Dies entspricht 165.0 Pumpspeicheräquivalenten.


    Speichergröße  Einspeicherung Jahr1  Zyklen Jahr1  Einspeicherung Jahr2  \
0        6.17e+06              7.67e+07         11.99              7.67e+07   
1        5.55e+06              7.67e+07         13.32              7.61e+07   
2        4.94e+06              7.61e+07         14.92              7.55e+07   
3        4.32e+06              7.55e+07         16.98              7.49e+07   
4        3.70e+06              7.49e+07         19.73              7.43e+07   
5        3.09e+06              7.43e+07         23.58              7.36e+07   
6        2.47e+06              7.35e+07         29.29              7.29e+07   
7        1.85e+06              7.17e+07         38.23              7.12e+07   
8        1.23e+06              6.79e+07         54.56              6.76e+07   
9        6.17e+05              5.90e+07         95.05              5.86e+07   
10       4.94e+05              5.59e+07        112.65              5.55e+07   
11       3.70e+05              5.13e+07        137.99              5.09e+07   
12       2.47e+05              4.28e+07        172.79              4.25e+07   
13       1.23e+05              2.66e+07        215.36              2.65e+07   
14       6.17e+04              1.51e+07        243.93              1.50e+07   

    Zyklen Jahr2  
0          12.44  
1          13.71  
2          15.29  
3          17.34  
4          20.06  
5          23.87  
6          29.53  
7          38.45  
8          54.76  
9          94.96  
10        112.41  
11        137.51  
12        172.29  
13        214.86  
14        243.43  


    relative Speichergröße  gekappte Einspeicherung Jahr1  \
0                     0.90                       1.49e-08   
1                     0.80                       5.95e+05   
2                     0.70                       1.21e+06   
3                     0.60                       1.83e+06   
4                     0.50                       2.45e+06   
5                     0.40                       3.21e+06   
6                     0.30                       5.04e+06   
7                     0.20                       8.78e+06   
8                     0.10                       1.78e+07   
9                     0.08                       2.09e+07   
10                    0.06                       2.55e+07   
11                    0.04                       3.40e+07   
12                    0.02                       5.01e+07   
13                    0.01                       6.16e+07   

    gekappte Einspeicherung Jahr2  
0                        6.17e+05  
1                        1.23e+06  
2                        1.85e+06  
3                        2.47e+06  
4                        3.09e+06  
5                        3.85e+06  
6                        5.55e+06  
7                        9.15e+06  
8                        1.81e+07  
9                        2.12e+07  
10                       2.58e+07  
11                       3.42e+07  
12                       5.02e+07  
13                       6.17e+07  


Summe Netzlast: 658,000,000.00
Summe positive Restlast: 175,897,072.30 Summe negative Restlast: -85,250,478.82
Speichergröße 1: 6,170,038.04   Anteil EE ohne Speicher: 0.73

    relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                     1.00             0.83             0.84
1                     0.90             0.83             0.83
2                     0.80             0.83             0.83
3                     0.70             0.83             0.83
4                     0.60             0.83             0.83
5                     0.50             0.83             0.83
6                     0.40             0.83             0.83
7                     0.30             0.83             0.83
8                     0.20             0.82             0.82
9                     0.10             0.81             0.81
10                    0.08             0.81             0.81
11                    0.06             0.80             0.80
12                    0.04             0.79             0.79
13                    0.02             0.77             0.77
14                    0.01             0.75             0.75
\end{verbatim}

\section{Referenz 2035}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Datensatz 2035 erzeugen}
\CommentTok{\# \#\# zubaufaktor\_windonshore\_2035}
\CommentTok{\# \#\# zubaufaktor\_windonshore\_2035}
\CommentTok{\# \#\# zubaufaktor\_solar\_2035}

\NormalTok{erzeugung\_2035 }\OperatorTok{=}\NormalTok{ erzeugung.copy()}
\NormalTok{erzeugung\_2035[}\StringTok{\textquotesingle{}Wind Onshore [MWh]\textquotesingle{}}\NormalTok{] }\OperatorTok{*=}\NormalTok{ zubaufaktor\_windonshore\_2035}
\NormalTok{erzeugung\_2035[}\StringTok{\textquotesingle{}Wind Offshore [MWh]\textquotesingle{}}\NormalTok{] }\OperatorTok{*=}\NormalTok{ zubaufaktor\_windoffshore\_2035}
\NormalTok{erzeugung\_2035[}\StringTok{\textquotesingle{}Photovoltaik [MWh]\textquotesingle{}}\NormalTok{] }\OperatorTok{*=}\NormalTok{ zubaufaktor\_solar\_2035}

\NormalTok{erneuerbare\_2035 }\OperatorTok{=}\NormalTok{ pd.Series()}
\NormalTok{erneuerbare }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Biomasse [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wasserkraft [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Offshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Onshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Photovoltaik [MWh]\textquotesingle{}}\NormalTok{,}
\StringTok{\textquotesingle{}Sonstige Erneuerbare [MWh]\textquotesingle{}}\NormalTok{]}
\NormalTok{erneuerbare\_2035 }\OperatorTok{=}\NormalTok{ erzeugung\_2035[erneuerbare].}\BuiltInTok{sum}\NormalTok{(axis }\OperatorTok{=} \StringTok{"columns"}\NormalTok{).copy()}

\NormalTok{netzlast\_2023 }\OperatorTok{=}\NormalTok{ pd.Series()}
\NormalTok{netzlast\_2023 }\OperatorTok{=}\NormalTok{ verbrauch[}\StringTok{"Gesamt (Netzlast) [MWh]"}\NormalTok{].copy()}
\NormalTok{netzlast\_2035 }\OperatorTok{=}\NormalTok{ netzlast\_2023 }\OperatorTok{*}\NormalTok{ lastfaktor\_2035\_MWh}

\NormalTok{restlast\_2035 }\OperatorTok{=}\NormalTok{ pd.Series()}
\NormalTok{restlast\_2035 }\OperatorTok{=}\NormalTok{ netzlast\_2035 }\OperatorTok{{-}}\NormalTok{ erneuerbare\_2035}

\CommentTok{\# Ausgabe}
\NormalTok{speicher\_2035 }\OperatorTok{=}\NormalTok{ berechne\_speichergröße(restlast\_2035, einspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ mein\_einspeicherwirkungsgrad, ausspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ mein\_ausspeicherwirkungsgrad, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"maximal erforderliche Speichergröße 2035: }\SpecialCharTok{\{}\NormalTok{speicher\_2035}\SpecialCharTok{:,.1f\}}\SpecialStringTok{ MWh}\CharTok{\textbackslash{}n}\SpecialStringTok{Dies entspricht }\SpecialCharTok{\{}\NormalTok{speicher\_2035 }\OperatorTok{/}\NormalTok{ pumpspeicherkapazit}\SpecialCharTok{ä}\NormalTok{t\_MWh}\SpecialCharTok{:,.1f\}}\SpecialStringTok{ Pumpspeicheräquivalenten."}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{effekt\_kappung\_berechnen(restlast\_2035, einspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ mein\_einspeicherwirkungsgrad, ausspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ mein\_ausspeicherwirkungsgrad, neue\_speichergrößen }\OperatorTok{=}\NormalTok{ meine\_speichergrößen, output }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}

\NormalTok{anteil\_ee\_berechnen(restlast\_2035, netzlast }\OperatorTok{=}\NormalTok{ netzlast\_2035, einspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ mein\_einspeicherwirkungsgrad, ausspeicherwirkungsgrad }\OperatorTok{=}\NormalTok{ mein\_ausspeicherwirkungsgrad, neue\_speichergrößen }\OperatorTok{=}\NormalTok{ meine\_speichergrößen, output }\OperatorTok{=} \VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
maximal erforderliche Speichergröße 2035: 23,829,823.9 MWh
Dies entspricht 637.2 Pumpspeicheräquivalenten.


    Speichergröße  Einspeicherung Jahr1  Zyklen Jahr1  Einspeicherung Jahr2  \
0        2.38e+07              1.49e+08          5.84              1.43e+08   
1        2.14e+07              1.47e+08          6.44              1.41e+08   
2        1.91e+07              1.44e+08          7.17              1.38e+08   
3        1.67e+07              1.42e+08          8.05              1.33e+08   
4        1.43e+07              1.39e+08          9.19              1.29e+08   
5        1.19e+07              1.34e+08         10.73              1.24e+08   
6        9.53e+06              1.29e+08         12.99              1.19e+08   
7        7.15e+06              1.21e+08         16.49              1.14e+08   
8        4.77e+06              1.13e+08         23.15              1.08e+08   
9        2.38e+06              1.01e+08         41.76              9.83e+07   
10       1.91e+06              9.72e+07         50.47              9.53e+07   
11       1.43e+06              9.18e+07         63.73              9.04e+07   
12       9.53e+05              8.23e+07         85.86              8.14e+07   
13       4.77e+05              6.58e+07        137.54              6.53e+07   
14       2.38e+05              4.29e+07        179.40              4.26e+07   

    Zyklen Jahr2  
0           6.01  
1           6.56  
2           7.24  
3           7.99  
4           8.99  
5          10.39  
6          12.49  
7          15.99  
8          22.65  
9          41.26  
10         49.97  
11         63.23  
12         85.36  
13        137.04  
14        178.90  


    relative Speichergröße  gekappte Einspeicherung Jahr1  \
0                     0.90                       2.38e+06   
1                     0.80                       4.77e+06   
2                     0.70                       7.15e+06   
3                     0.60                       1.07e+07   
4                     0.50                       1.55e+07   
5                     0.40                       2.07e+07   
6                     0.30                       2.78e+07   
7                     0.20                       3.65e+07   
8                     0.10                       4.86e+07   
9                     0.08                       5.21e+07   
10                    0.06                       5.74e+07   
11                    0.04                       6.69e+07   
12                    0.02                       8.35e+07   
13                    0.01                       1.06e+08   

    gekappte Einspeicherung Jahr2  
0                        2.38e+06  
1                        5.01e+06  
2                        9.77e+06  
3                        1.45e+07  
4                        1.93e+07  
5                        2.41e+07  
6                        2.88e+07  
7                        3.52e+07  
8                        4.48e+07  
9                        4.79e+07  
10                       5.27e+07  
11                       6.18e+07  
12                       7.78e+07  
13                       1.00e+08  


Summe Netzlast: 670,400,000.00
Summe positive Restlast: 125,949,558.61 Summe negative Restlast: -221,510,407.41
Speichergröße 1: 23,829,823.85  Anteil EE ohne Speicher: 0.81

    relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                     1.00             0.98             1.00
1                     0.90             0.98             1.00
2                     0.80             0.98             0.99
3                     0.70             0.98             0.99
4                     0.60             0.98             0.98
5                     0.50             0.97             0.97
6                     0.40             0.97             0.97
7                     0.30             0.96             0.96
8                     0.20             0.95             0.95
9                     0.10             0.94             0.94
10                    0.08             0.94             0.94
11                    0.06             0.93             0.93
12                    0.04             0.92             0.92
13                    0.02             0.90             0.90
14                    0.01             0.87             0.87
\end{verbatim}

\end{tcolorbox}

\subsection{Grafische Darstellung ausgewählter
Speicherauslegungen}\label{grafische-darstellung-ausgewuxe4hlter-speicherauslegungen}

Eine grafische Darstellung des Jahresgangs des Speichers kann für
verschiedene Auslegungen relativ zur maximal benötigten Speichergröße
(C\(_{max}\)) mit Hilfe der Funktion
\texttt{jahresgang\_speicher\_berechnen(output\ =\ False)} erzeugt
werden. Dazu wird zunächst aus der prognostizierten Netzlast und dem
geplanten erneuerbaren Zubau eine Restlastkurve für das Jahr 2030 und
das Jahr 2035 berechnet.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Restlast 2030 berechnen}
\CommentTok{\#\# zubaufaktor\_windonshore\_2030}
\CommentTok{\#\# zubaufaktor\_windoffshore\_2030}
\CommentTok{\#\# zubaufaktor\_solar\_2030}

\NormalTok{erzeugung\_2030 }\OperatorTok{=}\NormalTok{ erzeugung.copy()}
\NormalTok{erzeugung\_2030[}\StringTok{\textquotesingle{}Wind Onshore [MWh]\textquotesingle{}}\NormalTok{] }\OperatorTok{*=}\NormalTok{ zubaufaktor\_windonshore\_2030}
\NormalTok{erzeugung\_2030[}\StringTok{\textquotesingle{}Wind Offshore [MWh]\textquotesingle{}}\NormalTok{] }\OperatorTok{*=}\NormalTok{ zubaufaktor\_windoffshore\_2030}
\NormalTok{erzeugung\_2030[}\StringTok{\textquotesingle{}Photovoltaik [MWh]\textquotesingle{}}\NormalTok{] }\OperatorTok{*=}\NormalTok{ zubaufaktor\_solar\_2030}

\NormalTok{erneuerbare\_2030 }\OperatorTok{=}\NormalTok{ pd.Series()}
\NormalTok{erneuerbare }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Biomasse [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wasserkraft [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Offshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Onshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Photovoltaik [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Sonstige Erneuerbare [MWh]\textquotesingle{}}\NormalTok{]}
\NormalTok{erneuerbare\_2030 }\OperatorTok{=}\NormalTok{ erzeugung\_2030[erneuerbare].}\BuiltInTok{sum}\NormalTok{(axis }\OperatorTok{=} \StringTok{"columns"}\NormalTok{).copy()}

\NormalTok{netzlast\_2023 }\OperatorTok{=}\NormalTok{ pd.Series()}
\NormalTok{netzlast\_2023 }\OperatorTok{=}\NormalTok{ verbrauch[}\StringTok{"Gesamt (Netzlast) [MWh]"}\NormalTok{].copy()}
\NormalTok{netzlast\_2030 }\OperatorTok{=}\NormalTok{ netzlast\_2023 }\OperatorTok{*}\NormalTok{ lastfaktor\_2030\_MWh}

\NormalTok{restlast\_2030 }\OperatorTok{=}\NormalTok{ pd.Series()}
\NormalTok{restlast\_2030 }\OperatorTok{=}\NormalTok{ netzlast\_2030 }\OperatorTok{{-}}\NormalTok{ erneuerbare\_2030}

\CommentTok{\# Restlast 2035 berechnen}
\CommentTok{\#\# zubaufaktor\_windonshore\_2035}
\CommentTok{\#\# zubaufaktor\_windonshore\_2035}
\CommentTok{\#\# zubaufaktor\_solar\_2035}

\NormalTok{erzeugung\_2035 }\OperatorTok{=}\NormalTok{ erzeugung.copy()}
\NormalTok{erzeugung\_2035[}\StringTok{\textquotesingle{}Wind Onshore [MWh]\textquotesingle{}}\NormalTok{] }\OperatorTok{*=}\NormalTok{ zubaufaktor\_windonshore\_2035}
\NormalTok{erzeugung\_2035[}\StringTok{\textquotesingle{}Wind Offshore [MWh]\textquotesingle{}}\NormalTok{] }\OperatorTok{*=}\NormalTok{ zubaufaktor\_windoffshore\_2035}
\NormalTok{erzeugung\_2035[}\StringTok{\textquotesingle{}Photovoltaik [MWh]\textquotesingle{}}\NormalTok{] }\OperatorTok{*=}\NormalTok{ zubaufaktor\_solar\_2035}

\NormalTok{erneuerbare\_2035 }\OperatorTok{=}\NormalTok{ pd.Series()}
\NormalTok{erneuerbare }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}Biomasse [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wasserkraft [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Offshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Wind Onshore [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Photovoltaik [MWh]\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}Sonstige Erneuerbare [MWh]\textquotesingle{}}\NormalTok{]}
\NormalTok{erneuerbare\_2035 }\OperatorTok{=}\NormalTok{ erzeugung\_2035[erneuerbare].}\BuiltInTok{sum}\NormalTok{(axis }\OperatorTok{=} \StringTok{"columns"}\NormalTok{).copy()}

\NormalTok{netzlast\_2023 }\OperatorTok{=}\NormalTok{ pd.Series()}
\NormalTok{netzlast\_2023 }\OperatorTok{=}\NormalTok{ verbrauch[}\StringTok{"Gesamt (Netzlast) [MWh]"}\NormalTok{].copy()}
\NormalTok{netzlast\_2035 }\OperatorTok{=}\NormalTok{ netzlast\_2023 }\OperatorTok{*}\NormalTok{ lastfaktor\_2035\_MWh}

\NormalTok{restlast\_2035 }\OperatorTok{=}\NormalTok{ pd.Series()}
\NormalTok{restlast\_2035 }\OperatorTok{=}\NormalTok{ netzlast\_2035 }\OperatorTok{{-}}\NormalTok{ erneuerbare\_2035}
\end{Highlighting}
\end{Shaded}

~

Auf der Grundlage der berechneten Restlastkurven werden eine
80-prozentige, eine 20-prozentige und eine 4-prozentige Auslegung der
maximal benötigten Speicherkapazität berechnet und dargestellt.

\section{80 \% 2030}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-82-output-1.png}}

\begin{verbatim}
Zyklenzahl Jahr 1: 14.92
Zyklenzahl Jahr 2: 15.29
Summe Netzlast: 658,000,000.00
Summe positive Restlast: 175,897,072.30 Summe negative Restlast: -85,250,478.82
Speichergröße 1: 6,170,038.04   Anteil EE ohne Speicher: 0.73

   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                     1.0             0.83             0.84
1                     0.8             0.83             0.83

Die Speichergröße beträgt 4,936,030.4 MWh
Dies entspricht 132.0 Pumpspeicheräquivalenten.
\end{verbatim}

\section{80 \% 2035}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-83-output-1.png}}

\begin{verbatim}
Zyklenzahl Jahr 1: 7.17
Zyklenzahl Jahr 2: 7.24
Summe Netzlast: 670,400,000.00
Summe positive Restlast: 125,949,558.61 Summe negative Restlast: -221,510,407.41
Speichergröße 1: 23,829,823.85  Anteil EE ohne Speicher: 0.81

   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                     1.0             0.98             1.00
1                     0.8             0.98             0.99

Die Speichergröße beträgt 19,063,859.1 MWh
Dies entspricht 509.7 Pumpspeicheräquivalenten.
\end{verbatim}

\section{20 \% 2030}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-84-output-1.png}}

\begin{verbatim}
Zyklenzahl Jahr 1: 54.56
Zyklenzahl Jahr 2: 54.76
Summe Netzlast: 658,000,000.00
Summe positive Restlast: 175,897,072.30 Summe negative Restlast: -85,250,478.82
Speichergröße 1: 6,170,038.04   Anteil EE ohne Speicher: 0.73

   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                     1.0             0.83             0.84
1                     0.2             0.82             0.82

Die Speichergröße beträgt 1,234,007.6 MWh
Dies entspricht 33.0 Pumpspeicheräquivalenten.
\end{verbatim}

\section{20 \% 2035}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-85-output-1.png}}

\begin{verbatim}
Zyklenzahl Jahr 1: 23.15
Zyklenzahl Jahr 2: 22.65
Summe Netzlast: 670,400,000.00
Summe positive Restlast: 125,949,558.61 Summe negative Restlast: -221,510,407.41
Speichergröße 1: 23,829,823.85  Anteil EE ohne Speicher: 0.81

   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                     1.0             0.98             1.00
1                     0.2             0.95             0.95

Die Speichergröße beträgt 4,765,964.8 MWh
Dies entspricht 127.4 Pumpspeicheräquivalenten.
\end{verbatim}

\section{4 \% 2030}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-86-output-1.png}}

\begin{verbatim}
Zyklenzahl Jahr 1: 172.79
Zyklenzahl Jahr 2: 172.29
Summe Netzlast: 658,000,000.00
Summe positive Restlast: 175,897,072.30 Summe negative Restlast: -85,250,478.82
Speichergröße 1: 6,170,038.04   Anteil EE ohne Speicher: 0.73

   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                    1.00             0.83             0.84
1                    0.04             0.79             0.79

Die Speichergröße beträgt 246,801.5 MWh
Dies entspricht 6.6 Pumpspeicheräquivalenten.
\end{verbatim}

\section{4 \% 2035}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-energiedatenanalyse/skript/energiedatenanalyse_files/figure-pdf/cell-87-output-1.png}}

\begin{verbatim}
Zyklenzahl Jahr 1: 85.86
Zyklenzahl Jahr 2: 85.36
Summe Netzlast: 670,400,000.00
Summe positive Restlast: 125,949,558.61 Summe negative Restlast: -221,510,407.41
Speichergröße 1: 23,829,823.85  Anteil EE ohne Speicher: 0.81

   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                    1.00             0.98             1.00
1                    0.04             0.92             0.92

Die Speichergröße beträgt 953,193.0 MWh
Dies entspricht 25.5 Pumpspeicheräquivalenten.
\end{verbatim}

\section{Code-Beispiel}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Daten generieren}
\CommentTok{\#\# Speichergröße bestimmen und 80 Prozent berechnen}
\NormalTok{speichergröße\_2030\_80 }\OperatorTok{=}\NormalTok{ berechne\_speichergröße(restlast\_2030, einspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.88}\NormalTok{, output }\OperatorTok{=} \VariableTok{False}\NormalTok{) }\OperatorTok{*} \FloatTok{0.8}

\CommentTok{\#\# Jahresgang des Speichers bestimmen}
\NormalTok{speicher\_2030\_80\_wirkungsgrad\_90\_88 }\OperatorTok{=}\NormalTok{ jahresgang\_speicher\_berechnen(restlast\_2030, speichergröße }\OperatorTok{=}\NormalTok{ speichergröße\_2030\_80, einspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.88}\NormalTok{, output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}

\NormalTok{jahresgang\_speicher\_jahr1 }\OperatorTok{=}\NormalTok{ speicher\_2030\_80\_wirkungsgrad\_90\_88[}\DecValTok{1}\NormalTok{]}
\NormalTok{jahresgang\_speicher\_jahr2 }\OperatorTok{=}\NormalTok{ speicher\_2030\_80\_wirkungsgrad\_90\_88[}\DecValTok{2}\NormalTok{]}

\CommentTok{\# xticks erzeugen}
\NormalTok{monate\_index }\OperatorTok{=}\NormalTok{ erzeugung[}\OperatorTok{\textasciitilde{}}\NormalTok{erzeugung[}\StringTok{"Datum von"}\NormalTok{].dt.month.duplicated()].index}
\NormalTok{monatsnamen }\OperatorTok{=}\NormalTok{ erzeugung[}\StringTok{"Datum von"}\NormalTok{].iloc[monate\_index].dt.strftime(}\StringTok{"\%B"}\NormalTok{) }

\CommentTok{\# Grafik mit drei subplots erzeugen}
\NormalTok{fig, (ax1, ax2, ax3) }\OperatorTok{=}\NormalTok{ plt.subplots(}\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, figsize }\OperatorTok{=}\NormalTok{ (}\FloatTok{7.5}\NormalTok{, }\DecValTok{6}\NormalTok{), height\_ratios }\OperatorTok{=}\NormalTok{ [}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{], sharex }\OperatorTok{=} \VariableTok{True}\NormalTok{, layout }\OperatorTok{=} \StringTok{\textquotesingle{}tight\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.suptitle(}\StringTok{\textquotesingle{}Restlast 2030 und Jahresgang eines Speichers mit}\CharTok{\textbackslash{}n}\StringTok{ C$\_}\SpecialCharTok{\{max\}}\StringTok{$ = 0.8, η$\_}\SpecialCharTok{\{ein\}}\StringTok{$ = 0.9 und η$\_}\SpecialCharTok{\{aus\}}\StringTok{$ = 0.88\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xticks(monate\_index, monatsnamen, rotation }\OperatorTok{=} \DecValTok{45}\NormalTok{)}\OperatorTok{;}
\NormalTok{plt.minorticks\_off()}
\NormalTok{plt.setp([ax1, ax2, ax3], xlim }\OperatorTok{=}\NormalTok{ (restlast.index.}\BuiltInTok{min}\NormalTok{() }\OperatorTok{{-}} \BuiltInTok{len}\NormalTok{(restlast.index) }\OperatorTok{/} \DecValTok{100}\NormalTok{, restlast.index.}\BuiltInTok{max}\NormalTok{() }\OperatorTok{*} \FloatTok{1.01}\NormalTok{))}
\NormalTok{plt.setp([ax2, ax3], ylim }\OperatorTok{=}\NormalTok{ (}\DecValTok{0}\NormalTok{, }\BuiltInTok{max}\NormalTok{(}\BuiltInTok{max}\NormalTok{(jahresgang\_speicher\_jahr1), }\BuiltInTok{max}\NormalTok{(jahresgang\_speicher\_jahr2)) }\OperatorTok{*} \FloatTok{1.2}\NormalTok{))}

\CommentTok{\#\# plot restlast}
\NormalTok{ax1.plot(restlast\_2030, label }\OperatorTok{=} \StringTok{"Restlast"}\NormalTok{)}
\NormalTok{ax1.grid()}
\NormalTok{ax1.set\_ylabel(}\StringTok{\textquotesingle{}MWh\textquotesingle{}}\NormalTok{)}
\NormalTok{ax1.legend()}

\CommentTok{\#\# plot jahresgang\_speicher\_jahr1}
\NormalTok{ax2.plot(jahresgang\_speicher\_jahr1, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}{-}\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Stromspeicher Jahr 1\textquotesingle{}}\NormalTok{)}
\NormalTok{ax2.grid()}
\NormalTok{ax2.set\_ylabel(}\StringTok{\textquotesingle{}MWh\textquotesingle{}}\NormalTok{)}
\NormalTok{ax2.legend()}

\CommentTok{\#\# plot jahresgang\_speicher\_jahr2}
\NormalTok{ax3.plot(jahresgang\_speicher\_jahr2, color }\OperatorTok{=} \StringTok{\textquotesingle{}black\textquotesingle{}}\NormalTok{, linestyle }\OperatorTok{=} \StringTok{\textquotesingle{}{-}\textquotesingle{}}\NormalTok{, label }\OperatorTok{=} \StringTok{\textquotesingle{}Stromspeicher Jahr 2\textquotesingle{}}\NormalTok{)}
\NormalTok{ax3.tick\_params(axis }\OperatorTok{=} \StringTok{\textquotesingle{}x\textquotesingle{}}\NormalTok{, rotation }\OperatorTok{=} \DecValTok{45}\NormalTok{)}
\NormalTok{ax3.set\_ylabel(}\StringTok{\textquotesingle{}MWh\textquotesingle{}}\NormalTok{)}
\NormalTok{ax3.grid()}
\NormalTok{ax3.legend()}

\NormalTok{plt.show()}

\CommentTok{\# Zyklenzahl berechnen, Übergabe von Tupel = Wirkungsgrade werden nicht benötigt}
\NormalTok{zyklenzahl\_berechnen(speicher\_2030\_80\_wirkungsgrad\_90\_88, output }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

\CommentTok{\# Anteil EE berechnen}
\NormalTok{anteil\_ee\_berechnen(restlast\_2030, netzlast }\OperatorTok{=}\NormalTok{ netzlast\_2030, einspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.88}\NormalTok{, neue\_speichergrößen }\OperatorTok{=}\NormalTok{ [}\FloatTok{0.8}\NormalTok{], output }\OperatorTok{=} \VariableTok{True}\NormalTok{)}

\CommentTok{\# Speichergröße ausgeben}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Die Speichergröße beträgt }\SpecialCharTok{\{}\NormalTok{speicher\_2030\_80\_wirkungsgrad\_90\_88[}\DecValTok{0}\NormalTok{]}\SpecialCharTok{:,.1f\}}\SpecialStringTok{ MWh}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Dies entspricht }\SpecialCharTok{\{}\NormalTok{speicher\_2030\_80\_wirkungsgrad\_90\_88[}\DecValTok{0}\NormalTok{] }\OperatorTok{/}\NormalTok{ pumpspeicherkapazit}\SpecialCharTok{ä}\NormalTok{t\_MWh}\SpecialCharTok{:,.1f\}}\SpecialStringTok{ Pumpspeicheräquivalenten."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Mit einer 80-prozentigen Auslegung der Speichergröße wirkt der Speicher
überdimensioniert. Im Jahr 2030 kann der Speicher seine Kapazität über
das Jahr kaum ausschöpfen. Der Speicher erreicht nur selten Ladestände
im Bereich von 50 Prozent. Lediglich über den Jahreswechsel wird die
maximale Kapazität in Anspruch genommen. Umgekehrt ist der Speicher im
Jahr 2035 überwiegend voll geladen und es findet eine nur geringe Ein-
und Ausspeicherung statt. Der Speicher erreicht insbesondere im Jahr
2035 nur wenige Vollyzklen.

Die 2030 erforderliche Speicherkapazität von 4.936 GWh enspricht dem
132-Fachen der bestehenden Pumpspeicherkraftwerke oder 99
Jahresproduktionen der Tesla Gigafactory Berlin-Brandenburg in der
ersten Ausbaustufe mit 50 GWh/a
(\href{https://de.wikipedia.org/wiki/Liste_von_Batteriezellfabriken_in_Deutschland}{Wikipedia}).
Die im Jahr 2035 erforderliche Speicherkapazität von 19.064 GWh
entspricht dem 510-Fachen der bestehenden Pumpspeicherkraftwerke oder
381 Jahresproduktionen der Tesla Gigafactory Berlin-Brandenburg.\\
\textbf{Hinweis:} Die Referenz auf die Tesla Gigafactory
Berlin-Brandenburg dient lediglich zur Einordnung. Die Fabrik in
Grünheide produziert aktuell keine Batteriezellen. Planungen für weitere
Batteriefabriken in Deutschland wurden jüngst eingestellt.

Mit einer 20-prozentigen Auslegung werden mehr Vollzyklen und
umfangreichere Teilzyklen erreicht. Dennoch sind im Jahr 2035 von April
bis Ende August konstant hohe Ladestände zu beobachten. 2030 würden
1.234 GWh Speicherkapazität benötigt, 2035 4.766 GWh. Dies entspricht
dem 33- bzw. 127-Fachen der bestehenden Pumpspeicherkapazität oder 25
bzw. 95 Jahresproduktionen der Tesla Gigafactory Berlin-Brandenburg in
der ersten Ausbaustufe.

Die 4-Prozentige Auslegung zeigt ein ständiges Auf und Ab. In dieser
Dimension könnte ein Stromspeicher wirtschaftlich zu betreiben sein.
Dafür würden 2030 247 GWh und 2035 953 GWh Speicherkapazität benötigt.
247 GWh entsprechen dem 6,6-Fachen der bestehenden Pumpspeicherkapazität
oder 5 Jahresproduktionen der Tesla Gigafactory Berlin-Brandenburg in
der ersten Ausbaustufe. 953 GWh entsprechen 25,5
Pumpspeicheräquivalenten und 19 Jahresproduktionen der Tesla Gigafactory
Berlin-Brandenburg.

In allen Szenarien ist auffällig, dass die Zyklenzahl in Jahr 1 und Jahr
2 fast identisch ist. Der Unterschied von einem halben Zyklus ergibt
sich dadurch, dass der Speicher im ersten Jahr leer ans Netz geht. Je
nach Szenario wird der Speicher dann im Jahresverlauf (Speichergröße 80
\%), innerhalb weniger Wochen (Speichergröße 20 \%) oder nahezu sofort
(Speichergröße 4 \%) erstmalig voll geladen.

Erkennbar gilt bei der Speicherauslegung die 80-20-Regel
(\href{https://de.wikipedia.org/wiki/Paretoprinzip}{Paretoprinzip}): Mit
20 Prozent des Aufwands werden 80 Prozent des Weges erreicht. Beträgt
2035 der Anteil erneuerbarer Energien ohne Speicher 81 Prozent, so sind
19 Prozent durch Speicher (oder anderweitig) zu decken. Für eine
100-prozentige Bedarfsdeckung aus Stromspeichern würden 23,8 TWh
Speicherkapzität benötigt. Ein 20 Prozent so großer Speicher erreicht
einen Gesamtanteil erneuerbarer Energien von 95 Prozent. Ein wiederum
nur 20 Prozent so großer Speicher erreicht einen Gesamtanteil von 92
Prozent.

\section{Bonus: Benötigte Spitzenleistung der Reservekraftwerke
abschätzen}\label{bonus-benuxf6tigte-spitzenleistung-der-reservekraftwerke-abschuxe4tzen}

Aus der Berechnung verschiedener Speichergrößen wurde erkennbar, dass
auch verhältnismäßig kleine Speichergrößen zu einem hohen Anteil
erneuerbarer Energien im Strommix führen. Dennoch bedeuten kleiner
dimensionierte Speicher, dass punktuell Netzlast durch in Reserve
stehende Lastfolgekraftwerke bedient werden muss. In diesem Abschnitt
wird die benötigte Erzeugungsleistung der Reservekraftwerke abgeschätzt.
Dazu wird das Maximum der positiven Restlast nach Ausspeicherung mal
vier multipliziert, da der Datensatz auf Viertelstundenbasis vorliegt.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{spitzenleistung\_2030 }\OperatorTok{=}\NormalTok{ anteil\_ee\_berechnen(restlast\_2030, netzlast }\OperatorTok{=}\NormalTok{ netzlast\_2030, einspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.88}\NormalTok{, neue\_speichergrößen }\OperatorTok{=}\NormalTok{ [}\FloatTok{0.2}\NormalTok{, }\FloatTok{0.04}\NormalTok{], output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}
\NormalTok{spitzenleistung\_2035 }\OperatorTok{=}\NormalTok{ anteil\_ee\_berechnen(restlast\_2035, netzlast }\OperatorTok{=}\NormalTok{ netzlast\_2035, einspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.9}\NormalTok{, ausspeicherwirkungsgrad }\OperatorTok{=} \FloatTok{0.88}\NormalTok{, neue\_speichergrößen }\OperatorTok{=}\NormalTok{ [}\FloatTok{0.2}\NormalTok{, }\FloatTok{0.04}\NormalTok{], output }\OperatorTok{=} \VariableTok{False}\NormalTok{)}

\CommentTok{\#\# Datenstruktur angucken}
\CommentTok{\#\# In Spalte 0 ist Speichergröße = 1, in den folgenden Spalten die neuen Speichergrößen gespeichert. Zeile 0 enthält die Restlastkurve in Jahr 1, Zeile 1 die Restlastkurve in Jahr 2}
\CommentTok{\# print(spitzenleistung\_2030.shape)}
\CommentTok{\# print(spitzenleistung\_2030.head())}

\CommentTok{\# Zeile 1 enthält den Jahresgang in Jahr 2}
\CommentTok{\# Spalte 0 enthält das Basisszenario Speichergröße = 1}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"}\CharTok{\textbackslash{}n}\SpecialStringTok{Spitzenleistung 2030 für Cmax = 0.20: }\SpecialCharTok{\{}\BuiltInTok{max}\NormalTok{(spitzenleistung\_2030.iloc[}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{]) }\OperatorTok{*} \DecValTok{4} \OperatorTok{/} \DecValTok{1000}\SpecialCharTok{:.2f\}}\SpecialStringTok{ GW}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Spitzenleistung 2030 für Cmax = 0.04: }\SpecialCharTok{\{}\BuiltInTok{max}\NormalTok{(spitzenleistung\_2030.iloc[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{]) }\OperatorTok{*} \DecValTok{4} \OperatorTok{/} \DecValTok{1000}\SpecialCharTok{:.2f\}}\SpecialStringTok{ GW}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Spitzenleistung 2035 für Cmax = 0.20: }\SpecialCharTok{\{}\BuiltInTok{max}\NormalTok{(spitzenleistung\_2035.iloc[}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{]) }\OperatorTok{*} \DecValTok{4} \OperatorTok{/} \DecValTok{1000}\SpecialCharTok{:.2f\}}\SpecialStringTok{ GW}\CharTok{\textbackslash{}n}\SpecialStringTok{"}
      \SpecialStringTok{f"Spitzenleistung 2035 für Cmax = 0.04: }\SpecialCharTok{\{}\BuiltInTok{max}\NormalTok{(spitzenleistung\_2035.iloc[}\DecValTok{1}\NormalTok{ , }\DecValTok{2}\NormalTok{]) }\OperatorTok{*} \DecValTok{4} \OperatorTok{/} \DecValTok{1000}\SpecialCharTok{:.2f\}}\SpecialStringTok{ GW"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}

Spitzenleistung 2030 für Cmax = 0.20: 87.64 GW
Spitzenleistung 2030 für Cmax = 0.04: 87.64 GW
Spitzenleistung 2035 für Cmax = 0.20: 87.53 GW
Spitzenleistung 2035 für Cmax = 0.04: 87.53 GW
\end{verbatim}

\chapter{Das Wichtigste}\label{das-wichtigste-4}

Bei der vergleichenden Analyse der Erzeugungs- und Verbrauchsdaten für
Deutschland und Österreich wurde deutlich, dass vergleichbare Datensätze
unterschiedlich aufgebaut sein können. Die Intention hinter der
Zusammenstellung eines Datensatzes muss nicht notwendigerweise mit den
Zielen Ihrer Analyse übereinstimmen, was beispielsweise eine Trennung
von Kraftwerken und Stromspeichern rechtfertigen kann. In diesem
Baustein haben Sie zwei allgemeine Vorgehensweisen zur Analyse von
Datensätzen kennengelernt, die auf andere Anwendungsfelder und andere
Datensätze übertragen werden können. Dies ist zum einen das Einlesen,
Organisieren, Kontrollieren und Plausiblisieren von Daten. Zum anderen
das Beschreiben, Erkunden und Auswerten von Daten mit Hilfe von
Kennzahlen und Methoden der Datenvisualisierung.

Kennzahlenbasierte und visuelle Methoden der Datenanalyse ergänzen
einander und helfen, einen Datensatz zu verstehen. Beispielsweise könnte
mit einer rein kennzahlbasierten Vorgehensweise die Abschaltung der
deutschen Kernkraftwerke leicht übersehen werden, während diese in der
grafischen Darstellung des Jahresgangs deutlich erkennbar ist.
Demgegenüber könnten bei der reinen Visualisierung des Erzeugungsanteils
verschiedener Kraftwerkstypen in Österreich die Ein- und Ausspeicherung
unbedacht aufsummiert werden.

\chapter{Lernzielkontrolle}\label{lernzielkontrolle-5}

\section{Kompetenzquiz}\label{kompetenzquiz-2}

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\setcounter{enumi}{3}
\tightlist
\item
  Wie lautet der vollständige Befehl, um mit dem Python Modul Pandas
  folgenden String in ein Objekt vom Typ datetime umzuwandeln?
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]

\NormalTok{datum = ‘2008{-}Oct{-}29’}
\NormalTok{datum\_pd = pd.to\_datetime(datum, format = " ... ")}
\end{Highlighting}
\end{Shaded}

~

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\setcounter{enumi}{4}
\item
  Mit welcher Methode können die Datenreihen a, b und c verkettet
  werden?

  \begin{enumerate}
  \def\labelenumii{\alph{enumii})}
  \item
    pandas.concat(a, b, c)
  \item
    pandas.append(a, b, ,c)
  \item
    pandas.concatenate{[}a, b, c{]}
  \item
    pandas.concat({[}a , b , c{]})
  \end{enumerate}
\end{enumerate}

~

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\setcounter{enumi}{5}
\item
  Was ist der Zweck der beschreibenden Datenanalyse?

  \begin{enumerate}
  \def\labelenumii{\alph{enumii})}
  \item
    Fehler im Datensatz identifizieren
  \item
    Benötigte Module laden
  \item
    Vorbereitung der explorativen und schließenden Datenanalyse
  \item
    Überblick über den Datensatz gewinnen
  \end{enumerate}
\end{enumerate}

~

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\setcounter{enumi}{6}
\item
  Welche Aussagen sind wahr?

  \begin{enumerate}
  \def\labelenumii{\alph{enumii})}
  \item
    Explorative Datenanalyse ist ein iterativer Prozess, um einen
    Datensatz zu erkunden und mit den gewonnenen Erkenntnissen neue
    Fragen an den Datensatz zu stellen.
  \item
    Die Methoden der explorativen Datenanalyse sind fest vorgegeben.
  \item
    Die explorative Datenanalyse erfolgt rein kennzahlenbasiert.
  \item
    Die explorative Datenanalyse bereitet die schließende Datenanalyse
    vor.
  \end{enumerate}
\end{enumerate}

~

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\setcounter{enumi}{7}
\item
  Die Auslegung der Größe eines Stromspeichers ist abhängig von:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii})}
  \item
    Der Zyklik der Einspeicherung
  \item
    Dem Verhältnis der einspeicherbaren, überschüssigen Stromerzeugung
    und der durch den Speicher zu bedienenden Last
  \item
    Der Kappung von Erzeugungsspitzen
  \item
    Dem Wirkungsgrad des Speichers
  \end{enumerate}
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Tip \ref*{tip-Kompetenzquiz}: Lösungen}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

\quartocallouttip{tip-Kompetenzquiz} 

Lösung 1: datum\_pd = pd.to\_datetime(datum, format = ``\%Y-\%b-\%d'')

Lösung 2: pandas.concat({[}a , b , c{]})

Lösung 3: a, c, d

Lösung 4: a, d

Lösung 5: a, b, c, d

\end{tcolorbox}

\section{Übungen}\label{uxfcbungen-2}

Im Rahmen der schließenden Datenanalyse wurde festgestellt, dass durch
die Kappung von Erzeugungsspitzen in einem von erneuerbarer
Überschussproduktion geprägtem Stromsystem der erforderliche
Stromspeicher um Größenordnungen kleiner dimensioniert werden kann.
Allerdings verbleiben dann wenige Prozent der Jahresstromnachfrage, die
nicht erneuerbar aus der laufenden Produktion oder durch Ausspeicherung
gedeckt werden können. Eine Option bestünde darin, die
Biomassekraftwerke in Lastfolge zu betreiben.

Berechnen Sie die erforderliche Speichergröße (Einspeicherwirkungsgrad =
0.9, Ausspeicherwirkungsgrad = 0.88), wenn der Anteil erneuerbarer
Energien 2035 100 Prozent betragen soll und Biomassekraftwerke in
Lastfolge betrieben werden. Dabei wird angenommen, dass
Biomassekraftwerke in Zeiten mit einer vollständigen Deckung des
Stromverbrauchs durch die übrigen erneuerbaren Energien ihre
Gasproduktion einspeichern und dann verstromen, wenn eine positive
Restlast besteht. Die Produktion der Biogasanlagen entspreche der
Erzeugungskurve des Jahres 2023.

\begin{itemize}
\item
  Wie groß müsste der Gasspeicher (in MWh elektrischer Energie) sein?
\item
  Wie hoch ist die maximal benötigte Stromerzeugungsleistung der
  Biomassekraftwerke absolut und relativ zur 2023 installierten
  Leistung?
\item
  Wie groß muss der erforderliche Stromspeicher sein, wenn
  Biomassekraftwerke in Lastfolge betrieben werden?
\end{itemize}

\part{a-auswertung-fds-daten}

\chapter*{Preamble}\label{preamble-4}
\addcontentsline{toc}{chapter}{Preamble}

\markboth{Preamble}{Preamble}

\phantomsection\label{Lizenz}
\begin{figure}

\begin{minipage}{0.20\linewidth}
\pandocbounded{\includegraphics[keepaspectratio]{index_files/mediabag/by.png}}\end{minipage}%
%
\begin{minipage}{0.80\linewidth}
Bausteine Computergestützter Datenanalyse von Lukas Arnold, Simone
Arnold, Florian Bagemihl, Matthias Baitsch, Marc Fehr, Franca Hollmann,
Maik Poetzsch und Sebastian Seipel. ``Anwendungsbaustein Auswertung von
fds-Daten'' von Marc Fehr ist lizensiert unter
\href{https://creativecommons.org/licenses/by/4.0/deed.de}{CC BY 4.0}.
Das Werk ist abrufbar unter
\url{https://github.com/bausteine-der-datenanalyse/a-auswertung_fds_daten}.
Ausgenommen von der Lizenz sind alle Logos und anders gekennzeichneten
Inhalte. 2025\end{minipage}%

\end{figure}%

Zitiervorschlag

Arnold, Lukas, Simone Arnold, Matthias Baitsch, Marc Fehr, Franca
Hollmann, Maik Poetzsch, und Sebastian Seipel. 2025. „Bausteine
Computergestützter Datenanalyse. Anwendungsbaustein Auswertung von
fds-Daten``.
\url{https://github.com/bausteine-der-datenanalyse/a-auswertung-fds-daten}.

BibTeX-Vorlage

\begin{verbatim}
@misc{BCD-fds-daten-2025,
 title={Bausteine Computergestützter Datenanalyse. Anwendungsbaustein Auswertung von fds-Daten},
 author={Arnold, Lukas and Arnold, Simone and Baitsch, Matthias and Fehr, Marc and Hollmann, Franca and Poetzsch, Maik and Seipel, Sebastian},
 year={2025},
 url={https://github.com/bausteine-der-datenanalyse/a-auswertung-fds-daten}} 
\end{verbatim}

\chapter*{Intro}\label{intro-4}
\addcontentsline{toc}{chapter}{Intro}

\markboth{Intro}{Intro}

\section*{Voraussetzungen}\label{voraussetzungen-12}
\addcontentsline{toc}{section}{Voraussetzungen}

\markright{Voraussetzungen}

\begin{itemize}
\tightlist
\item
  Grundlagen Python
\item
  Einbinden von zusätzlichen Paketen
\item
  Arbeiten mit NumPy
\item
  Arbeiten mit Pandas
\item
  Plotten mit Matplotlib
\item
  Grundkentnisse im Simulieren von Bränden
\end{itemize}

\section*{Verwendete Pakete und
Datensätze}\label{verwendete-pakete-und-datensuxe4tze-4}
\addcontentsline{toc}{section}{Verwendete Pakete und Datensätze}

\markright{Verwendete Pakete und Datensätze}

\begin{itemize}
\tightlist
\item
  NumPy
\item
  pandas
\item
  matplotlib
\item
  fdsreader
\end{itemize}

\section*{Bearbeitungszeit}\label{bearbeitungszeit-4}
\addcontentsline{toc}{section}{Bearbeitungszeit}

\markright{Bearbeitungszeit}

Geschätzte Bearbeitungszeit: 4h

\section*{Lernziele}\label{lernziele-12}
\addcontentsline{toc}{section}{Lernziele}

\markright{Lernziele}

\begin{itemize}
\tightlist
\item
  Einlesen von fds Daten mit dem fdsreader
\item
  Analyse der Daten in Bezug auf ASET
\end{itemize}

\chapter{Einführung in ASET}\label{einfuxfchrung-in-aset}

ASET (Available Safe Egress Time, auf Deutsch: Verfügbare Sichere
Räumungszeit) ist ein zentrales Konzept im Brandschutzingenieurwesen. Es
beschreibt die Zeitspanne, die den Gebäudenutzern zur Verfügung steht,
um ein Gebäude sicher zu verlassen, bevor die Bedingungen durch Feuer,
Rauch oder Hitze lebensbedrohlich werden. Die ASET wird anhand
verschiedener Faktoren berechnet, darunter die Brandentwicklung, die
Zeit bis zur Branderkennung sowie die baulichen Gegebenheiten des
Gebäudes, wie Notausgänge und Löschanlagen.

Es ist entscheidend, dass die ASET größer ist als die erforderliche
sichere Räumungszeit (RSET -- Required Safe Egress Time), um effektive
Evakuierungspläne zu erstellen und die Sicherheit der Personen im
Gebäude im Notfall zu gewährleisten.

\section{Datenerhebung}\label{datenerhebung}

Die Daten, die wir hier betrachten, wurden mithilfe des Fire Dynamics
Simulator (FDS) erzeugt. Der FDS (Fire Dynamics Simulator) ist ein
Modell der numerischen Strömungsmechanik, das zur Simulation von
feuergetriebenen Strömungen verwendet wird. Es ermöglicht die Analyse
und Vorhersage des Brandverhaltens sowie dessen Auswirkungen auf Gebäude
und Umgebungen.

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-warning-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-warning-color-frame, coltitle=black, title=\textcolor{quarto-callout-warning-color}{\faExclamationTriangle}\hspace{0.5em}{Warning}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Dieses Lernmodul geht nicht weiter auf Simulationen oder den FDS ein.
Die hier verwendeten Simulationsdaten werden als Download
bereitgestellt.

\end{tcolorbox}

\chapter{Verfügbare sichere Evakuierungszeit
(ASET)}\label{verfuxfcgbare-sichere-evakuierungszeit-aset}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ fdsreader}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\end{Highlighting}
\end{Shaded}

Dieses Beispiel demonstriert eine Analyse von Slice-Daten, um die Karte
der \textbf{verfügbaren sicheren Evakuierungszeit (ASET)} sowie die
zeitliche Entwicklung der Rauchsichtbarkeitsschicht zu bestimmen. Das
verwendete Szenario ist eine Mehrraumwohnung.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pfad\_zur\_simulation }\OperatorTok{=} \StringTok{\textquotesingle{}../skript/01{-}data/apartment\_01\textquotesingle{}}

\NormalTok{sim }\OperatorTok{=}\NormalTok{ fdsreader.Simulation(pfad\_zur\_simulation)}
\BuiltInTok{print}\NormalTok{(sim)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Simulation(chid=Appartment,
           meshes=8,
           obstructions=23,
           slices=20,
           data_3d=5,
           smoke_3d=3)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Rußdichte{-}Slice laden, senkrecht zur z{-}Achse in 1,5 m Höhe}
\NormalTok{slc }\OperatorTok{=}\NormalTok{ sim.slices.get\_by\_id(}\StringTok{\textquotesingle{}SootDensityZ\_1.5m\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Da die Simulation auf mehreren Gittern basiert, wird eine globale Datenstruktur erstellt;}
\CommentTok{\# Wände werden als ungültige Datenpunkte (NaN) dargestellt}
\NormalTok{slc\_data }\OperatorTok{=}\NormalTok{ slc.to\_global(masked}\OperatorTok{=}\VariableTok{True}\NormalTok{, fill}\OperatorTok{=}\NormalTok{np.nan)}
\end{Highlighting}
\end{Shaded}

Zuerst wird eine Visualisierung der Daten zu einem ausgewählten
Zeitpunkt mit der Funktion \texttt{imshow} durchgeführt.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Zeitindex ermitteln}
\NormalTok{it }\OperatorTok{=}\NormalTok{ slc.get\_nearest\_timestep(}\DecValTok{50}\NormalTok{)}

\CommentTok{\# Daten visualisieren}
\NormalTok{plt.imshow(slc\_data[it,:,:].T, origin}\OperatorTok{=}\StringTok{\textquotesingle{}lower\textquotesingle{}}\NormalTok{, extent}\OperatorTok{=}\NormalTok{slc.extent.as\_list())}

\CommentTok{\# Achsenbeschriftung und Farbleiste}
\NormalTok{plt.title(}\SpecialStringTok{f\textquotesingle{}Rußdichte bei t=}\SpecialCharTok{\{}\NormalTok{slc}\SpecialCharTok{.}\NormalTok{times[it]}\SpecialCharTok{:.2f\}}\SpecialStringTok{s\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Position / m\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Position / m\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.colorbar(orientation}\OperatorTok{=}\StringTok{\textquotesingle{}horizontal\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\SpecialStringTok{f\textquotesingle{}}\SpecialCharTok{\{}\NormalTok{slc}\SpecialCharTok{.}\NormalTok{quantity}\SpecialCharTok{.}\NormalTok{name}\SpecialCharTok{\}}\SpecialStringTok{ / }\SpecialCharTok{\{}\NormalTok{slc}\SpecialCharTok{.}\NormalTok{quantity}\SpecialCharTok{.}\NormalTok{unit}\SpecialCharTok{\}}\SpecialStringTok{\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-auswertung-fds-daten/skript/aset_files/figure-pdf/cell-5-output-1.png}}

Nun werden die lokalen ASET-Werte berechnet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Über alle räumlichen Elemente der Slice-Daten iterieren\\
\item
  Alle Zeitpunkte bestimmen, an denen der Begehbarkeits-Grenzwert
  überschritten wird\\
\item
  Falls dies der Fall ist, den ersten Zeitpunkt als lokalen ASET-Wert
  setzen
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beliebiger Grenzwert für die Begehbarkeit}
\NormalTok{grenzwert\_rußdichte }\OperatorTok{=} \FloatTok{1e{-}4}

\CommentTok{\# Karte mit maximaler ASET als Standardwert erstellen}
\NormalTok{aset\_karte }\OperatorTok{=}\NormalTok{ np.full\_like(slc\_data[}\DecValTok{0}\NormalTok{], slc.times[}\OperatorTok{{-}}\DecValTok{1}\NormalTok{])}

\CommentTok{\# Wände auf NaN setzen}
\NormalTok{aset\_karte[np.isnan(slc\_data[}\DecValTok{0}\NormalTok{,:,:])] }\OperatorTok{=}\NormalTok{ np.nan}

\CommentTok{\# 1D{-}Schleife über alle Array{-}Indizes, ix ist ein zweidimensionaler Index}
\ControlFlowTok{for}\NormalTok{ ix }\KeywordTok{in}\NormalTok{ np.ndindex(aset\_karte.shape):}
    \CommentTok{\# Lokale Werte, die den Grenzwert überschreiten, ermitteln}
\NormalTok{    lokaler\_aset }\OperatorTok{=}\NormalTok{ np.where(slc\_data[:, ix[}\DecValTok{0}\NormalTok{], ix[}\DecValTok{1}\NormalTok{]] }\OperatorTok{\textgreater{}}\NormalTok{ grenzwert\_rußdichte)[}\DecValTok{0}\NormalTok{]}
    
    \CommentTok{\# Falls vorhanden, ersten Zeitpunkt als ASET{-}Wert verwenden}
    \ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(lokaler\_aset) }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{:}
\NormalTok{        aset\_karte[ix] }\OperatorTok{=}\NormalTok{ slc.times[lokaler\_aset[}\DecValTok{0}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

Mit der berechneten Karte kann nun eine grafische Darstellung erzeugt
werden, ähnlich wie bei anderen Größen -- hier mit diskreter Farbskala.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Diskrete (12 Werte) Farbskala erstellen}
\NormalTok{cmap }\OperatorTok{=}\NormalTok{ plt.cm.get\_cmap(}\StringTok{\textquotesingle{}jet\_r\textquotesingle{}}\NormalTok{, }\DecValTok{12}\NormalTok{)}

\CommentTok{\# Visualisierung der ASET{-}Karte}
\NormalTok{plt.imshow(aset\_karte.T, origin}\OperatorTok{=}\StringTok{\textquotesingle{}lower\textquotesingle{}}\NormalTok{, extent}\OperatorTok{=}\NormalTok{slc.extent.as\_list(), cmap}\OperatorTok{=}\NormalTok{cmap)}
\NormalTok{plt.title(}\SpecialStringTok{f\textquotesingle{}ASET{-}Karte mit Grenzwert der Rußdichte }\SpecialCharTok{\{}\NormalTok{grenzwert\_ru}\SpecialCharTok{ß}\NormalTok{dichte}\SpecialCharTok{:.1e\}}\SpecialStringTok{\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}x{-}Position / m\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}y{-}Position / m\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.colorbar(orientation}\OperatorTok{=}\StringTok{\textquotesingle{}horizontal\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Zeit / s\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Ausgabe in Datei speichern (optional)}
\CommentTok{\# plt.savefig(\textquotesingle{}figs/appartment\_aset\_map.svg\textquotesingle{}, bbox\_inches=\textquotesingle{}tight\textquotesingle{})}
\CommentTok{\# plt.close()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_81178/2604837150.py:2: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.
  cmap = plt.cm.get_cmap('jet_r', 12)
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-auswertung-fds-daten/skript/aset_files/figure-pdf/cell-7-output-2.png}}

\section{Rauchsichtbarkeitsschicht}\label{rauchsichtbarkeitsschicht}

In diesem Beispiel wird die Höhe der Rauchsichtbarkeitsschicht
analysiert. Die Unterscheidung erfolgt hier anhand eines einfachen
Temperatur-Grenzwerts: Die lokale Schichthöhe ergibt sich aus dem
niedrigsten Punkt, an dem eine bestimmte Temperatur überschritten wird.
Die Auswertung erfolgt auf einem Slice entlang des Brenners (normal zur
x-Achse).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Slice finden}
\NormalTok{slc }\OperatorTok{=}\NormalTok{ sim.slices.get\_by\_id(}\StringTok{\textquotesingle{}BurnerTempX\textquotesingle{}}\NormalTok{)}

\CommentTok{\# In globale Datenstruktur umwandeln und Koordinaten extrahieren}
\NormalTok{slc\_data, slc\_coords }\OperatorTok{=}\NormalTok{ slc.to\_global(masked}\OperatorTok{=}\VariableTok{True}\NormalTok{, fill}\OperatorTok{=}\NormalTok{np.nan, return\_coordinates}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Zunächst erfolgt eine Visualisierung der Daten zu einem beliebigen
Zeitpunkt. Weiße Bereiche stellen Hindernisse dar.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Zeitpunkt wählen}
\NormalTok{it }\OperatorTok{=}\NormalTok{ slc.get\_nearest\_timestep(}\DecValTok{150}\NormalTok{)}

\CommentTok{\# Daten visualisieren}
\NormalTok{plt.imshow(slc\_data[it,:,:].T, origin}\OperatorTok{=}\StringTok{\textquotesingle{}lower\textquotesingle{}}\NormalTok{, vmax}\OperatorTok{=}\DecValTok{200}\NormalTok{, extent}\OperatorTok{=}\NormalTok{slc.extent.as\_list())}
\NormalTok{plt.title(}\SpecialStringTok{f\textquotesingle{}Temperatur bei t=}\SpecialCharTok{\{}\NormalTok{slc}\SpecialCharTok{.}\NormalTok{times[it]}\SpecialCharTok{:.2f\}}\SpecialStringTok{s\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}y{-}Position / m\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}z{-}Position / m\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.colorbar(orientation}\OperatorTok{=}\StringTok{\textquotesingle{}horizontal\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\SpecialStringTok{f\textquotesingle{}}\SpecialCharTok{\{}\NormalTok{slc}\SpecialCharTok{.}\NormalTok{quantity}\SpecialCharTok{.}\NormalTok{name}\SpecialCharTok{\}}\SpecialStringTok{ / }\SpecialCharTok{\{}\NormalTok{slc}\SpecialCharTok{.}\NormalTok{quantity}\SpecialCharTok{.}\NormalTok{unit}\SpecialCharTok{\}}\SpecialStringTok{\textquotesingle{}}\NormalTok{)}

\CommentTok{\# plt.savefig(\textquotesingle{}figs/appartment\_temp\_slice.svg\textquotesingle{}, bbox\_inches=\textquotesingle{}tight\textquotesingle{})}
\CommentTok{\# plt.close()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-auswertung-fds-daten/skript/aset_files/figure-pdf/cell-9-output-1.png}}

Nun wird für jede y-Position der z-Index gesucht, an dem die Temperatur
den Grenzwert überschreitet. Der niedrigste dieser Punkte ist die lokale
Höhe der Rauchsichtbarkeitsschicht.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Grenzwert für Temperatur}
\NormalTok{temperatur\_grenzwert }\OperatorTok{=} \DecValTok{75}

\CommentTok{\# Array zur Speicherung der lokalen Höhenwerte; Standard ist maximale z{-}Koordinate}
\NormalTok{schicht\_hoehe }\OperatorTok{=}\NormalTok{ np.full(slc\_data.shape[}\DecValTok{1}\NormalTok{], slc\_coords[}\StringTok{\textquotesingle{}z\textquotesingle{}}\NormalTok{][}\OperatorTok{{-}}\DecValTok{1}\NormalTok{])}

\CommentTok{\# Schleife über y{-}Indizes}
\ControlFlowTok{for}\NormalTok{ ix }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(schicht\_hoehe)):}
    \CommentTok{\# Indizes finden die den Grenzwert überschreiten}
\NormalTok{    lt }\OperatorTok{=}\NormalTok{ np.where(slc\_data[it, ix, :] }\OperatorTok{\textgreater{}}\NormalTok{ temperatur\_grenzwert)[}\DecValTok{0}\NormalTok{]}
    \CommentTok{\# Wenn welche existieren, wähle den niedrigsten von ihnen}
    \ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(lt) }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{:}
\NormalTok{        schicht\_hoehe[ix] }\OperatorTok{=}\NormalTok{ slc\_coords[}\StringTok{\textquotesingle{}z\textquotesingle{}}\NormalTok{][lt[}\DecValTok{0}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

Die resultierenden Werte können nun über dem Slice dargestellt werden,
um die Plausibilität zu überprüfen.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Slice Daten}
\NormalTok{plt.imshow(slc\_data[it,:,:].T, origin}\OperatorTok{=}\StringTok{\textquotesingle{}lower\textquotesingle{}}\NormalTok{, vmax}\OperatorTok{=}\DecValTok{200}\NormalTok{, extent}\OperatorTok{=}\NormalTok{slc.extent.as\_list())}
\NormalTok{plt.title(}\SpecialStringTok{f\textquotesingle{}Temperatur bei t=}\SpecialCharTok{\{}\NormalTok{slc}\SpecialCharTok{.}\NormalTok{times[it]}\SpecialCharTok{:.2f\}}\SpecialStringTok{s\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}y{-}Position / m\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}z{-}Position / m\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.colorbar(orientation}\OperatorTok{=}\StringTok{\textquotesingle{}horizontal\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\SpecialStringTok{f\textquotesingle{}}\SpecialCharTok{\{}\NormalTok{slc}\SpecialCharTok{.}\NormalTok{quantity}\SpecialCharTok{.}\NormalTok{name}\SpecialCharTok{\}}\SpecialStringTok{ / }\SpecialCharTok{\{}\NormalTok{slc}\SpecialCharTok{.}\NormalTok{quantity}\SpecialCharTok{.}\NormalTok{unit}\SpecialCharTok{\}}\SpecialStringTok{\textquotesingle{}}\NormalTok{)}
\CommentTok{\# Rauchsichtbarkeitsschichthöhe}
\NormalTok{plt.plot(slc\_coords[}\StringTok{\textquotesingle{}y\textquotesingle{}}\NormalTok{], schicht\_hoehe, }\StringTok{\textquotesingle{}.{-}\textquotesingle{}}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{)}

\CommentTok{\# plt.savefig(\textquotesingle{}figs/appartment\_temp\_slice\_height.svg\textquotesingle{}, bbox\_inches=\textquotesingle{}tight\textquotesingle{})}
\CommentTok{\# plt.close()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-auswertung-fds-daten/skript/aset_files/figure-pdf/cell-11-output-1.png}}

Die obige Methode kann auch über alle Zeitpunkte angewendet werden, um
z.\,B. Mittelwert und Standardabweichung der Schichthöhe zu berechnen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mittelwert }\OperatorTok{=}\NormalTok{ np.zeros\_like(slc.times)}
\NormalTok{standardabweichung }\OperatorTok{=}\NormalTok{ np.zeros\_like(slc.times)}
\NormalTok{res }\OperatorTok{=}\NormalTok{ np.zeros(slc\_data.shape[}\DecValTok{1}\NormalTok{])}

\ControlFlowTok{for}\NormalTok{ it }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(slc.times)):}
\NormalTok{    res[:] }\OperatorTok{=}\NormalTok{ slc\_coords[}\StringTok{\textquotesingle{}z\textquotesingle{}}\NormalTok{][}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
    \ControlFlowTok{for}\NormalTok{ ix }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(res)):}
\NormalTok{        lt }\OperatorTok{=}\NormalTok{ np.where(slc\_data[it, ix, :] }\OperatorTok{\textgreater{}}\NormalTok{ temperatur\_grenzwert)[}\DecValTok{0}\NormalTok{]}
        \ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(lt) }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{:}
\NormalTok{            res[ix] }\OperatorTok{=}\NormalTok{ slc\_coords[}\StringTok{\textquotesingle{}z\textquotesingle{}}\NormalTok{][lt[}\DecValTok{0}\NormalTok{]]}
\NormalTok{    mittelwert[it] }\OperatorTok{=}\NormalTok{ np.mean(res)}
\NormalTok{    standardabweichung[it] }\OperatorTok{=}\NormalTok{ np.std(res)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Darstellung des Mittelwerts und der Standartabweichung als Funktion der Zeit}
\NormalTok{plt.plot(slc.times, mittelwert, label}\OperatorTok{=}\StringTok{\textquotesingle{}Mittlere Schichthöhe\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(slc.times, standardabweichung, label}\OperatorTok{=}\StringTok{\textquotesingle{}Standardabweichung\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.legend()}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Zeit / s\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Höhe / m\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Ergebnisse in Datei abspeichern}
\CommentTok{\# plt.savefig(\textquotesingle{}figs/appartment\_layer\_mean\_stddev.svg\textquotesingle{}, bbox\_inches=\textquotesingle{}tight\textquotesingle{})}
\CommentTok{\# plt.close()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Text(0, 0.5, 'Höhe / m')
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-auswertung-fds-daten/skript/aset_files/figure-pdf/cell-13-output-2.png}}

Beide Werte können kombiniert visualisiert werden. Die
Standardabweichung ergibt ein Band um den Mittelwert.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Mittelwert darstellen}
\NormalTok{plt.plot(slc.times, mittelwert, label}\OperatorTok{=}\StringTok{\textquotesingle{}Mittlere Schichthöhe\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Band um den Mittelwert darstellen mit Hilfe der Standartabweichung}
\NormalTok{plt.fill\_between(slc.times, mittelwert}\OperatorTok{{-}}\NormalTok{standardabweichung, mittelwert}\OperatorTok{+}\NormalTok{standardabweichung, color}\OperatorTok{=}\StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.3}\NormalTok{)}

\CommentTok{\# Boden als Referenz zeigen}
\NormalTok{plt.ylim(bottom}\OperatorTok{=}\DecValTok{0}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.legend()}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Zeit / s\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Höhe / m\textquotesingle{}}\NormalTok{)}

\CommentTok{\# plt.savefig(\textquotesingle{}figs/appartment\_layer\_mean\_band.svg\textquotesingle{}, bbox\_inches=\textquotesingle{}tight\textquotesingle{})}
\CommentTok{\# plt.close()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Text(0, 0.5, 'Höhe / m')
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-auswertung-fds-daten/skript/aset_files/figure-pdf/cell-14-output-2.png}}

Wenn bestimmte Bereiche ausgeschlossen werden sollen, kann eine
koordinatenabhängige Maske verwendet werden.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Finde Indizes bei denen die y{-}Koordinate zwischen den angegebenen Werten liegt}
\NormalTok{ymin }\OperatorTok{=} \DecValTok{1}
\NormalTok{ymax }\OperatorTok{=} \DecValTok{4}
\NormalTok{koordinaten\_maske }\OperatorTok{=}\NormalTok{ np.where((slc\_coords[}\StringTok{\textquotesingle{}y\textquotesingle{}}\NormalTok{] }\OperatorTok{\textgreater{}}\NormalTok{ ymin) }\OperatorTok{\&}\NormalTok{ (slc\_coords[}\StringTok{\textquotesingle{}y\textquotesingle{}}\NormalTok{] }\OperatorTok{\textless{}}\NormalTok{ ymax))}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Slice Daten}
\NormalTok{plt.imshow(slc\_data[it,:,:].T, origin}\OperatorTok{=}\StringTok{\textquotesingle{}lower\textquotesingle{}}\NormalTok{, vmax}\OperatorTok{=}\DecValTok{200}\NormalTok{, extent}\OperatorTok{=}\NormalTok{slc.extent.as\_list())}
\NormalTok{plt.title(}\SpecialStringTok{f\textquotesingle{}Temperatur bei t=}\SpecialCharTok{\{}\NormalTok{slc}\SpecialCharTok{.}\NormalTok{times[it]}\SpecialCharTok{:.2f\}}\SpecialStringTok{s\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}y{-}Position / m\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}z{-}Position / m\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.colorbar(orientation}\OperatorTok{=}\StringTok{\textquotesingle{}horizontal\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\SpecialStringTok{f\textquotesingle{}}\SpecialCharTok{\{}\NormalTok{slc}\SpecialCharTok{.}\NormalTok{quantity}\SpecialCharTok{.}\NormalTok{name}\SpecialCharTok{\}}\SpecialStringTok{ / }\SpecialCharTok{\{}\NormalTok{slc}\SpecialCharTok{.}\NormalTok{quantity}\SpecialCharTok{.}\NormalTok{unit}\SpecialCharTok{\}}\SpecialStringTok{\textquotesingle{}}\NormalTok{)}
\CommentTok{\# Rauchsichtbarkeitsschichthöhe}
\NormalTok{plt.plot(slc\_coords[}\StringTok{\textquotesingle{}y\textquotesingle{}}\NormalTok{][koordinaten\_maske], schicht\_hoehe[koordinaten\_maske], }\StringTok{\textquotesingle{}.{-}\textquotesingle{}}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}red\textquotesingle{}}\NormalTok{)}

\CommentTok{\# plt.savefig(\textquotesingle{}figs/appartment\_temp\_slice\_height\_mask.svg\textquotesingle{}, bbox\_inches=\textquotesingle{}tight\textquotesingle{})}
\CommentTok{\# plt.close()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-auswertung-fds-daten/skript/aset_files/figure-pdf/cell-16-output-1.png}}

Das gleiche Verfahren kann erneut verwendet werden, wobei Mittelwert und
Standardabweichung nur auf die maskierten Werte berechnet werden.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ it }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(slc.times)):}
\NormalTok{    res[:] }\OperatorTok{=}\NormalTok{ slc\_coords[}\StringTok{\textquotesingle{}z\textquotesingle{}}\NormalTok{][}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
    \ControlFlowTok{for}\NormalTok{ ix }\KeywordTok{in}\NormalTok{ np.ndindex(res.shape):}
\NormalTok{        lt }\OperatorTok{=}\NormalTok{ np.where(slc\_data[it, ix, :] }\OperatorTok{\textgreater{}}\NormalTok{ temperatur\_grenzwert)[}\DecValTok{1}\NormalTok{]}
        \ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(lt) }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{:}
\NormalTok{            res[ix] }\OperatorTok{=}\NormalTok{ slc\_coords[}\StringTok{\textquotesingle{}z\textquotesingle{}}\NormalTok{][lt[}\DecValTok{0}\NormalTok{]]}
    \CommentTok{\# Berechnungen werden nun mit den Werten aus der Maske durchgeführt}
\NormalTok{    mittelwert[it] }\OperatorTok{=}\NormalTok{ np.mean(res[koordinaten\_maske])}
\NormalTok{    standardabweichung[it] }\OperatorTok{=}\NormalTok{ np.std(res[koordinaten\_maske])}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Selbe Darstellung wie zuvor}
\NormalTok{plt.plot(slc.times, mittelwert, label}\OperatorTok{=}\StringTok{\textquotesingle{}Mittlere Schichthöhe\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.fill\_between(slc.times, mittelwert}\OperatorTok{{-}}\NormalTok{standardabweichung, mittelwert}\OperatorTok{+}\NormalTok{standardabweichung, color}\OperatorTok{=}\StringTok{\textquotesingle{}C0\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.3}\NormalTok{)}
\NormalTok{plt.ylim(bottom}\OperatorTok{=}\DecValTok{0}\NormalTok{)}
\NormalTok{plt.grid()}
\NormalTok{plt.legend()}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Zeit / s\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Höhe / m\textquotesingle{}}\NormalTok{)}

\CommentTok{\# plt.savefig(\textquotesingle{}figs/appartment\_layer\_mean\_band\_mask.svg\textquotesingle{}, bbox\_inches=\textquotesingle{}tight\textquotesingle{})}
\CommentTok{\# plt.close()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Text(0, 0.5, 'Höhe / m')
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-auswertung-fds-daten/skript/aset_files/figure-pdf/cell-18-output-2.png}}

\chapter{Fdsreader}\label{fdsreader}

Um Simulationsdaten, die mit FDS berechnet wurden, mit Python
auszuwerten, hat die Arbeitsgruppe von Prof.~Lukas Arnold das
Python-Modul \texttt{fdsreader} entwickelt. Ziel ist es, die meisten von
FDS erzeugten Ausgabeformate auszulesen und in Python-Datenstrukturen
abzubilden.

Das Modul ist frei verfügbar und Open Source. Der Quellcode ist auf
GitHub gehostet:
\href{https://github.com/FireDynamics/fdsreader}{FireDynamics/fdsreader},
eine
\href{https://firedynamics.github.io/fdsreader/index.html}{API-Dokumentation}
ist ebenfalls verfügbar.

\section{Installation und Import des
Pakets}\label{installation-und-import-des-pakets}

Das \texttt{fdsreader}-Modul kann über pip installiert werden (siehe
auch das GitHub-Repository):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pip install fdsreader}
\end{Highlighting}
\end{Shaded}

Zur Einführung in die grundlegende Verwendung von \texttt{fdsreader}
betrachten wir ein einfaches FDS-Szenario. Zunächst importieren wir das
Modul:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ fdsreader}
\end{Highlighting}
\end{Shaded}

Da wir die Daten auch visualisieren möchten, importieren wir zusätzlich
\texttt{matplotlib}:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}
\end{Highlighting}
\end{Shaded}

\section{Auswahl des richtigen
Ordners}\label{auswahl-des-richtigen-ordners}

Als Nächstes muss der Reader auf das Verzeichnis zeigen, das die
Simulationsdaten enthält, insbesondere die Smokeview-Datei:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Pfad zu den Daten definieren}
\NormalTok{path\_to\_data }\OperatorTok{=} \StringTok{\textquotesingle{}../skript/01{-}data/first\_example\textquotesingle{}}

\NormalTok{sim }\OperatorTok{=}\NormalTok{ fdsreader.Simulation(path\_to\_data)}
\end{Highlighting}
\end{Shaded}

Das \texttt{Simulation}-Objekt \texttt{sim} enthält nun alle
Informationen und Daten des Simulationsausgangs:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sim}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Simulation(chid=StecklerExample,
           meshes=1,
           obstructions=7,
           slices=5,
           data_3d=5,
           smoke_3d=3,
           devices=4)
\end{verbatim}

Die Variable \texttt{sim} enthält Informationen über das Gitter
(\texttt{MESH}), vier Schnittdaten (\texttt{SLCF}) und vier
Punktmessungen (\texttt{DEVC}). Das zusätzliche Messgerät -- in der
FDS-Eingabedatei wurden nur drei definiert -- ist die Zeitspalte.

\section{Messgeräte-Daten}\label{messgeruxe4te-daten}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Messgeräte in FDS}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Messgeräte fungieren als virtuelle Sensoren, mit denen Daten wie
Temperatur, Wärmestrom, Gaskonzentration, Geschwindigkeit usw. an
bestimmten Punkten im Simulationsbereich aufgezeichnet werden können.
Diese Daten sind entscheidend für das Verständnis des Verhaltens von
Feuer und Rauch unter verschiedenen Bedingungen.

Ein Messgerät kann mit einem Label (\texttt{ID}) versehen werden, was
die Identifizierung in der durch FDS erzeugten CSV-Datei vereinfacht. Es
benötigt eine Position und eine zu messende Größe.

Positionen können auf verschiedene Arten angegeben werden. Wir
fokussieren uns hier auf einen Punkt über \texttt{XYZ}. Linien, Flächen
und Volumen sind jedoch ebenso möglich.

Der Parameter \texttt{QUANTITY} erwartet eine Zeichenkette, die angibt,
welche Größe aufgezeichnet werden soll, z.\,B. \texttt{TEMPERATURE} für
die Gastemperatur.

\end{tcolorbox}

Die einfachste Datenstruktur ist die Ausgabe der
\texttt{DEVC}-Direktiven. Die verfügbaren Daten und Metainformationen
können direkt ausgegeben werden:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Kurzreferenz für Bequemlichkeit – \textasciigrave{}devc\textasciigrave{} enthält alle Messgeräte}
\NormalTok{devc }\OperatorTok{=}\NormalTok{ sim.devices}
\BuiltInTok{print}\NormalTok{(devc)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[Device(id='Time', xyz=(0.0, 0.0, 0.0), quantity=Quantity('TIME')),
Device(id='Temp_Door_Low', xyz=(1.45, 0.05, 0.1), quantity=Quantity('TEMPERATURE')),
Device(id='Temp_Door_Mid', xyz=(1.45, 0.05, 1.0), quantity=Quantity('TEMPERATURE')),
Device(id='Temp_Door_High', xyz=(1.45, 0.05, 1.65), quantity=Quantity('TEMPERATURE'))]
\end{verbatim}

Die \texttt{Device}-Klasse enthält alle relevanten Informationen (siehe
\href{https://firedynamics.github.io/fdsreader/devc.html}{Geräte-Dokumentation}):

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ devc:}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"ID: }\SpecialCharTok{\{}\NormalTok{i}\SpecialCharTok{.}\BuiltInTok{id}\SpecialCharTok{\}}\SpecialStringTok{,}\CharTok{\textbackslash{}t}\SpecialStringTok{ Messgröße: }\SpecialCharTok{\{}\NormalTok{i}\SpecialCharTok{.}\NormalTok{quantity\_name}\SpecialCharTok{\}}\SpecialStringTok{, }\CharTok{\textbackslash{}t}\SpecialStringTok{ Position: }\SpecialCharTok{\{}\NormalTok{i}\SpecialCharTok{.}\NormalTok{position}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ID: Time,    Messgröße: TIME,    Position: (0.0, 0.0, 0.0)
ID: Temp_Door_Low,   Messgröße: TEMPERATURE,     Position: (1.45, 0.05, 0.1)
ID: Temp_Door_Mid,   Messgröße: TEMPERATURE,     Position: (1.45, 0.05, 1.0)
ID: Temp_Door_High,  Messgröße: TEMPERATURE,     Position: (1.45, 0.05, 1.65)
\end{verbatim}

Einzelne Messgeräte, einschließlich der Zeitspalte, sind über
Dictionary-Einträge mit ihrer ID als Schlüssel zugänglich. Die Daten
eines einzelnen Messgeräts (\texttt{Device.data}) sind als NumPy-Array
gespeichert:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{type}\NormalTok{(devc[}\StringTok{\textquotesingle{}Temp\_Door\_Mid\textquotesingle{}}\NormalTok{].data)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
numpy.ndarray
\end{verbatim}

Die Länge entspricht dem erwarteten Wert, also 1801, da die Simulation
1800\,s dauerte und die Messgeräte jede Sekunde beschrieben wurden,
einschließlich \texttt{t\ =\ 0\,s}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{len}\NormalTok{(devc[}\StringTok{\textquotesingle{}Time\textquotesingle{}}\NormalTok{].data)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1801
\end{verbatim}

Ein erster Blick auf die Rohdaten (\texttt{Device.data}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{devc[}\StringTok{\textquotesingle{}Temp\_Door\_Mid\textquotesingle{}}\NormalTok{].data}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
array([ 20.      ,  20.002083,  20.034418, ..., 105.32822 , 114.82179 ,
       115.01705 ], shape=(1801,), dtype=float32)
\end{verbatim}

Die Messgerät-Daten können auch mit Matplotlib visualisiert werden:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Plot erstellen}
\NormalTok{plt.plot(devc[}\StringTok{\textquotesingle{}Time\textquotesingle{}}\NormalTok{].data, devc[}\StringTok{\textquotesingle{}Temp\_Door\_High\textquotesingle{}}\NormalTok{].data)}

\CommentTok{\# Achsen beschriften}
\NormalTok{plt.xlabel(}\StringTok{"Zeit / s"}\NormalTok{)}
\NormalTok{devc\_id }\OperatorTok{=}\NormalTok{ devc[}\StringTok{\textquotesingle{}Temp\_Door\_High\textquotesingle{}}\NormalTok{].}\BuiltInTok{id}
\NormalTok{devc\_q }\OperatorTok{=}\NormalTok{ devc[}\StringTok{\textquotesingle{}Temp\_Door\_High\textquotesingle{}}\NormalTok{].quantity\_name}
\NormalTok{devc\_u }\OperatorTok{=}\NormalTok{ devc[}\StringTok{\textquotesingle{}Temp\_Door\_High\textquotesingle{}}\NormalTok{].unit}
\NormalTok{plt.ylabel(}\SpecialStringTok{f"}\SpecialCharTok{\{}\NormalTok{devc\_q}\SpecialCharTok{\}}\SpecialStringTok{ (}\SpecialCharTok{\{}\NormalTok{devc\_id}\SpecialCharTok{\}}\SpecialStringTok{) / }\SpecialCharTok{\{}\NormalTok{devc\_u}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}

\CommentTok{\# Raster hinzufügen}
\NormalTok{plt.grid()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-auswertung-fds-daten/skript/fdsreader_files/figure-pdf/cell-11-output-1.png}}

In gleicher Weise können mehrere Messgeräte gleichzeitig geplottet
werden, z.\,B. alle, deren Namen mit \texttt{Temp\_} beginnen:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Alle Messgeräte durchlaufen}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ devc:}
    
    \CommentTok{\# Nur Messgeräte mit ID, die mit \textquotesingle{}Temp\_\textquotesingle{} beginnt}
    \ControlFlowTok{if} \KeywordTok{not}\NormalTok{ i.}\BuiltInTok{id}\NormalTok{.startswith(}\StringTok{\textquotesingle{}Temp\_\textquotesingle{}}\NormalTok{): }
        \ControlFlowTok{continue}
    
\NormalTok{    plt.plot(devc[}\StringTok{"Time"}\NormalTok{].data, i.data, label}\OperatorTok{=}\NormalTok{i.}\BuiltInTok{id}\NormalTok{)}
    
\NormalTok{plt.legend()}
\NormalTok{plt.xlabel(}\StringTok{"Zeit / s"}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Temperatur / $\^{}}\ErrorTok{\textbackslash{}}\StringTok{circ$C\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.grid()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
<>:12: SyntaxWarning: invalid escape sequence '\c'
<>:12: SyntaxWarning: invalid escape sequence '\c'
/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_81191/1963712746.py:12: SyntaxWarning: invalid escape sequence '\c'
  plt.ylabel('Temperatur / $^\circ$C')
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-auswertung-fds-daten/skript/fdsreader_files/figure-pdf/cell-12-output-2.png}}

\section{HRR-Daten}\label{hrr-daten}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Heat Release Rate (HRR)}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Ein zentraler Parameter in der Brandmodellierung. Er beschreibt die
Freisetzungsrate thermischer Energie und wird in Kilowatt (kW) oder
Megawatt (MW) angegeben.

\end{tcolorbox}

Wie bei den \texttt{DEVC}-Daten kann auch auf die im \texttt{HRR}-File
gespeicherten Daten direkt zugegriffen werden. Diese befinden sich im
Attribut \texttt{hrr} des \texttt{Simulation}-Objekts und nicht bei den
Messgeräten:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plt.plot(sim.hrr[}\StringTok{\textquotesingle{}Time\textquotesingle{}}\NormalTok{], sim.hrr[}\StringTok{\textquotesingle{}HRR\textquotesingle{}}\NormalTok{], label}\OperatorTok{=}\StringTok{\textquotesingle{}Freisetzung durch Brand\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.plot(sim.hrr[}\StringTok{\textquotesingle{}Time\textquotesingle{}}\NormalTok{], sim.hrr[}\StringTok{\textquotesingle{}Q\_RADI\textquotesingle{}}\NormalTok{], label}\OperatorTok{=}\StringTok{\textquotesingle{}Strahlung\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(sim.hrr[}\StringTok{\textquotesingle{}Time\textquotesingle{}}\NormalTok{], sim.hrr[}\StringTok{\textquotesingle{}Q\_COND\textquotesingle{}}\NormalTok{], label}\OperatorTok{=}\StringTok{\textquotesingle{}Leitung\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.plot(sim.hrr[}\StringTok{\textquotesingle{}Time\textquotesingle{}}\NormalTok{], sim.hrr[}\StringTok{\textquotesingle{}Q\_CONV\textquotesingle{}}\NormalTok{], label}\OperatorTok{=}\StringTok{\textquotesingle{}Konvektion\textquotesingle{}}\NormalTok{)}

\NormalTok{plt.plot(sim.hrr[}\StringTok{\textquotesingle{}Time\textquotesingle{}}\NormalTok{], }
\NormalTok{         sim.hrr[}\StringTok{\textquotesingle{}HRR\textquotesingle{}}\NormalTok{] }\OperatorTok{+}\NormalTok{ sim.hrr[}\StringTok{\textquotesingle{}Q\_RADI\textquotesingle{}}\NormalTok{] }\OperatorTok{+}\NormalTok{ sim.hrr[}\StringTok{\textquotesingle{}Q\_COND\textquotesingle{}}\NormalTok{] }\OperatorTok{+}\NormalTok{ sim.hrr[}\StringTok{\textquotesingle{}Q\_CONV\textquotesingle{}}\NormalTok{], }
\NormalTok{         color}\OperatorTok{=}\StringTok{\textquotesingle{}grey\textquotesingle{}}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Summe\textquotesingle{}}\NormalTok{, zorder}\OperatorTok{=}\DecValTok{0}\NormalTok{)}

\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Zeit / s\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}Wärmefreisetzung / kW\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.legend()}
\NormalTok{plt.grid()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-auswertung-fds-daten/skript/fdsreader_files/figure-pdf/cell-13-output-1.png}}

\section{Slice-Daten}\label{slice-daten}

\begin{tcolorbox}[enhanced jigsaw, titlerule=0mm, opacityback=0, left=2mm, breakable, bottomrule=.15mm, colback=white, arc=.35mm, colbacktitle=quarto-callout-tip-color!10!white, opacitybacktitle=0.6, toprule=.15mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, coltitle=black, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Slices}, rightrule=.15mm, bottomtitle=1mm, toptitle=1mm]

Slices sind eine Art der Ausgabe, bei der bestimmte physikalische Größen
(z.\,B. Temperatur, Geschwindigkeit, Rauchkonzentration) innerhalb einer
Ebene des Simulationsraums visualisiert werden können. Diese Schnitte
geben einen Einblick, wie sich Größen über einen Bereich verteilen.

\end{tcolorbox}

Die durch \texttt{SLCF} erzeugten Daten erstrecken sich über zwei oder
drei räumliche Dimensionen sowie über die Zeit. Zusätzlich können sie
auf mehrere Meshes verteilt sein.

Die Slice-Daten werden pro Mesh gespeichert. In diesem Beispiel gibt es
nur ein Mesh, doch der Zugriff erfolgt trotzdem formell mit Index.

Die Datenstruktur sieht wie folgt aus:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sim.slices[sliceid][meshid].data[zeitindex, richtung1, richtung2]}
\end{Highlighting}
\end{Shaded}

Dabei ist \texttt{sliceid} der Index des Slices, \texttt{meshid} der
Mesh-Index (hier: 0), und der Zugriff erfolgt über den Zeitindex sowie
zwei Raumrichtungen (für 2D-Slices).

Es gibt mehrere Slice-Objekte:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Verfügbare Slices ausgeben}
\ControlFlowTok{for} \BuiltInTok{slice} \KeywordTok{in}\NormalTok{ sim.slices:}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Slicetyp [2D/3D]: }\SpecialCharTok{\{}\BuiltInTok{slice}\SpecialCharTok{.}\BuiltInTok{type}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{  Größe: }\SpecialCharTok{\{}\BuiltInTok{slice}\SpecialCharTok{.}\NormalTok{quantity}\SpecialCharTok{.}\NormalTok{name}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{, }
          \SpecialStringTok{f" Ausdehnung: }\SpecialCharTok{\{}\BuiltInTok{slice}\SpecialCharTok{.}\NormalTok{extent}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{  Orientierung [1/2/3]: }\SpecialCharTok{\{}\BuiltInTok{slice}\SpecialCharTok{.}\NormalTok{orientation}\SpecialCharTok{\}}\CharTok{\textbackslash{}n}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Slicetyp [2D/3D]: 2D
  Größe: TEMPERATURE
  Ausdehnung: Extent([0.00, 0.00] x [-1.40, 1.40] x [0.00, 2.20])
  Orientierung [1/2/3]: 1

Slicetyp [2D/3D]: 2D
  Größe: TEMPERATURE
  Ausdehnung: Extent([-1.40, 2.60] x [0.00, 0.00] x [0.00, 2.20])
  Orientierung [1/2/3]: 2

Slicetyp [2D/3D]: 2D
  Größe: W-VELOCITY
  Ausdehnung: Extent([0.00, 0.00] x [-1.40, 1.40] x [0.00, 2.20])
  Orientierung [1/2/3]: 1

Slicetyp [2D/3D]: 2D
  Größe: U-VELOCITY
  Ausdehnung: Extent([-1.40, 2.60] x [0.00, 0.00] x [0.00, 2.20])
  Orientierung [1/2/3]: 2

Slicetyp [2D/3D]: 2D
  Größe: W-VELOCITY
  Ausdehnung: Extent([-1.40, 2.60] x [-1.40, 1.40] x [1.80, 1.80])
  Orientierung [1/2/3]: 3
\end{verbatim}

Es gibt viele Wege einen bestimmten Slice unter den anderen zu finden.
Eine Möglichkeit, den gewünschten Slice zu finden, ist das Filtern nach
Quantity über \texttt{filter\_by\_quantity}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Slice(s) mit W{-}Geschwindigkeit bekommen}
\NormalTok{w\_slice }\OperatorTok{=}\NormalTok{ sim.slices.filter\_by\_quantity(}\StringTok{"W{-}VELOCITY"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(w\_slice)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
SliceCollection([Slice([2D] quantity=Quantity('W-VELOCITY'), cell_centered=False, extent=Extent([0.00, 0.00] x [-1.40, 1.40] x [0.00, 2.20]), extent_dirs=('y', 'z'), orientation=1),
Slice([2D] quantity=Quantity('W-VELOCITY'), cell_centered=False, extent=Extent([-1.40, 2.60] x [-1.40, 1.40] x [1.80, 1.80]), extent_dirs=('x', 'y'), orientation=3)])
\end{verbatim}

Oder die Auswahl über die Nähe zu einem Punkt:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Auswahl basierend auf der Nähe zu einem Punkt}
\NormalTok{slc }\OperatorTok{=}\NormalTok{ w\_slice.get\_nearest(x}\OperatorTok{=}\DecValTok{1}\NormalTok{, z}\OperatorTok{=}\DecValTok{2}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(slc)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Slice([2D] quantity=Quantity('W-VELOCITY'), cell_centered=False, extent=Extent([-1.40, 2.60] x [-1.40, 1.40] x [1.80, 1.80]), extent_dirs=('x', 'y'), orientation=3)
\end{verbatim}

Der Zugriff auf Slice-Daten benötigt die Auswahl von einem bestimmten
Mesh und Zeitindex. Die Funktion \texttt{get\_nearest\_timestep} hilft
dabei:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Zeitindex nahe t=25 s auswählen}
\NormalTok{it }\OperatorTok{=}\NormalTok{ slc.get\_nearest\_timestep(}\DecValTok{25}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Zeitschritt: }\SpecialCharTok{\{}\NormalTok{it}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Simulationszeit: }\SpecialCharTok{\{}\NormalTok{slc}\SpecialCharTok{.}\NormalTok{times[it]}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Zeitschritt: 25
Simulationszeit: 25.021108627319336
\end{verbatim}

Das folgende Beispiel zeigt eine Darstellung der Daten und die
benötigten Schritte um diese anzupassen. Die Anpassungen finden anhand
der Datenausrichtung aus der Function \texttt{imshow} statt.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Temperaturslice in y{-}Richtung auswählen}
\NormalTok{slc }\OperatorTok{=}\NormalTok{ sim.slices.filter\_by\_quantity(}\StringTok{\textquotesingle{}TEMPERATURE\textquotesingle{}}\NormalTok{).get\_nearest(x}\OperatorTok{=}\DecValTok{3}\NormalTok{, y}\OperatorTok{=}\DecValTok{0}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(slc)}
\CommentTok{\# Nur ein Mesh}
\NormalTok{slc\_data }\OperatorTok{=}\NormalTok{ slc[}\DecValTok{0}\NormalTok{].data}
\BuiltInTok{print}\NormalTok{(slc\_data)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Slice([2D] quantity=Quantity('TEMPERATURE'), cell_centered=False, extent=Extent([-1.40, 2.60] x [0.00, 0.00] x [0.00, 2.20]), extent_dirs=('x', 'z'), orientation=2)
[[[ 20.        20.        20.       ...  20.        20.        20.      ]
  [ 20.        20.        20.       ...  20.        20.        20.      ]
  [ 20.        20.        20.       ...  20.        20.        20.      ]
  ...
  [ 20.        20.        20.       ...  20.        20.        20.      ]
  [ 20.        20.        20.       ...  20.        20.        20.      ]
  [ 20.        20.        20.       ...  20.        20.        20.      ]]

 [[ 20.030926  20.031328  20.032204 ...  20.001385  20.001268  20.00117 ]
  [ 20.030703  20.031597  20.033634 ...  20.001493  20.001345  20.001238]
  [ 20.031723  20.033785  20.038801 ...  20.001757  20.001535  20.001389]
  ...
  [ 20.006077  20.004908  20.002953 ...  20.001383  20.001154  20.00104 ]
  [ 20.005085  20.004053  20.00236  ...  20.00129   20.001116  20.001026]
  [ 20.004608  20.003656  20.0021   ...  20.00125   20.001104  20.001026]]

 [[ 20.12404   20.126698  20.133305 ...  20.026028  20.02525   20.025595]
  [ 20.116137  20.11882   20.12633  ...  20.02626   20.025606  20.02608 ]
  [ 20.114033  20.117645  20.128752 ...  20.02802   20.027351  20.027908]
  ...
  [ 20.018784  20.016739  20.013128 ...  20.00563   20.004776  20.004353]
  [ 20.015898  20.014067  20.010876 ...  20.005054  20.004427  20.004118]
  [ 20.01441   20.012737  20.00983  ...  20.004791  20.004278  20.00403 ]]

 ...

 [[ 44.00391   43.917053  43.920734 ... 143.89009  142.69537  142.16621 ]
  [ 44.004223  43.863914  43.708996 ... 143.29715  142.09953  141.6622  ]
  [ 43.81018   43.64982   43.4085   ... 142.64955  141.90448  141.75969 ]
  ...
  [ 20.284891  20.19156   20.076902 ...  90.631195  78.81051   72.00585 ]
  [ 20.218634  20.140545  20.047134 ...  56.04536   43.176456  39.645744]
  [ 20.151264  20.09307   20.028439 ...  34.67456   27.534237  27.970665]]

 [[ 45.228874  45.115242  44.938766 ... 150.18481  150.12732  149.83371 ]
  [ 44.492287  44.350613  44.180614 ... 149.79759  150.0778   149.77635 ]
  [ 43.646873  43.590538  43.562504 ... 147.7298   148.82109  149.29768 ]
  ...
  [ 20.281096  20.186028  20.071451 ... 106.69953   93.09295   83.79199 ]
  [ 20.205025  20.13359   20.046276 ...  80.62758   71.11945   62.30358 ]
  [ 20.16152   20.102564  20.033293 ...  65.56552   56.724525  46.839134]]

 [[ 42.762764  42.892406  42.67096  ... 146.0912   145.20709  144.58104 ]
  [ 43.14627   43.263447  43.141045 ... 145.02187  144.6713   143.69063 ]
  [ 43.753468  43.769325  43.798447 ... 141.0417   142.32797  141.77148 ]
  ...
  [ 20.268656  20.194078  20.08938  ...  72.89162   70.64532   65.348694]
  [ 20.206676  20.136755  20.052374 ...  59.554634  49.809177  42.573883]
  [ 20.180956  20.111738  20.035168 ...  48.16472   36.145966  31.134487]]]
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Erste Visualisierung bei t=50 s}
\NormalTok{it }\OperatorTok{=}\NormalTok{ slc.get\_nearest\_timestep(}\DecValTok{50}\NormalTok{)}
\NormalTok{plt.imshow(slc\_data[it])}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-auswertung-fds-daten/skript/fdsreader_files/figure-pdf/cell-20-output-1.png}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Auf transponierte Darstellung mithilfe von ndarray.T zugreifen und anpassung des Ursprungs}
\NormalTok{plt.imshow(slc\_data[it].T, origin}\OperatorTok{=}\StringTok{\textquotesingle{}lower\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-auswertung-fds-daten/skript/fdsreader_files/figure-pdf/cell-21-output-1.png}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Erste Visualisierung bei t=50 s}
\CommentTok{\# Angabe der Ausdehnung um von Indexen in den physikalischen Raum zu wechseln}
\CommentTok{\# Festsetzen eines Maximalwerts mit Hilfe von vmax}

\NormalTok{plt.imshow(slc\_data[it].T, }
\NormalTok{           origin}\OperatorTok{=}\StringTok{\textquotesingle{}lower\textquotesingle{}}\NormalTok{,}
\NormalTok{           vmax}\OperatorTok{=}\DecValTok{200}\NormalTok{,}
\NormalTok{           extent}\OperatorTok{=}\NormalTok{slc.extent.as\_list())}
\NormalTok{plt.colorbar(label}\OperatorTok{=}\StringTok{\textquotesingle{}Temperatur / °C\textquotesingle{}}\NormalTok{, orientation}\OperatorTok{=}\StringTok{\textquotesingle{}horizontal\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}x{-}Koordinate / m\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.ylabel(}\StringTok{\textquotesingle{}z{-}Koordinate / m\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Text(0, 0.5, 'z-Koordinate / m')
\end{verbatim}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-auswertung-fds-daten/skript/fdsreader_files/figure-pdf/cell-22-output-2.png}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Beispiel für Mehrfach{-}Plot}
\NormalTok{list\_t }\OperatorTok{=}\NormalTok{ [}\DecValTok{0}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{200}\NormalTok{, }\DecValTok{300}\NormalTok{, }\DecValTok{400}\NormalTok{]}
\NormalTok{fig, axs }\OperatorTok{=}\NormalTok{ plt.subplots(}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{, sharex}\OperatorTok{=}\VariableTok{True}\NormalTok{, sharey}\OperatorTok{=}\VariableTok{True}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(list\_t)):}
\NormalTok{    it }\OperatorTok{=}\NormalTok{ slc.get\_nearest\_timestep(list\_t[i])}
\NormalTok{    axs.flat[i].imshow(slc\_data[it].T,}
\NormalTok{                       vmin}\OperatorTok{=}\DecValTok{20}\NormalTok{,}
\NormalTok{                       vmax}\OperatorTok{=}\DecValTok{400}\NormalTok{,}
\NormalTok{                       origin}\OperatorTok{=}\StringTok{\textquotesingle{}lower\textquotesingle{}}\NormalTok{, }
\NormalTok{                       extent}\OperatorTok{=}\NormalTok{slc.extent.as\_list())}
\NormalTok{    axs.flat[i].set\_title(}\SpecialStringTok{f"t=}\SpecialCharTok{\{}\NormalTok{slc}\SpecialCharTok{.}\NormalTok{times[it]}\SpecialCharTok{:.1f\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{books/a-auswertung-fds-daten/skript/fdsreader_files/figure-pdf/cell-23-output-1.png}}

\chapter{}\label{section-6}

\chapter{}\label{section-7}




\end{document}
